# Lilipup Core Module

## 1. Введение
`core` — базовый модуль Lilipup Framework, который отвечает за контейнер компонентов, внедрение зависимостей, событийную шину и базовые абстракции запуска приложения.

Зачем нужен:
- стандартизирует инициализацию приложения;
- управляет жизнью компонентов через контейнер `LilipupContext`;
- предоставляет единый API для модулей `configuration`, `validation`, `security`, `scheduler`, `kafka`, `monitoring`.

## 2. Подключение модуля
### Maven
```xml
<dependency>
  <groupId>io.lilipup</groupId>
  <artifactId>lilipup-core</artifactId>
  <version>1.2.0</version>
</dependency>
```

### Gradle
```groovy
implementation 'io.lilipup:lilipup-core:1.2.0'
```

### Минимальный bootstrap
```java
import io.lilipup.core.LilipupApplication;
import io.lilipup.core.annotation.LilipupApp;

@LilipupApp(scan = "com.example.app")
public class App {
    public static void main(String[] args) {
        LilipupApplication.run(App.class, args);
    }
}
```

## 3. Использование в коде
### Компоненты и внедрение зависимостей
```java
import io.lilipup.core.annotation.Component;
import io.lilipup.core.annotation.Inject;

@Component
public class InvoiceService {

    private final TaxService taxService;

    // Конструкторное внедрение предпочтительнее: гарантирует неизменяемость зависимостей.
    @Inject
    public InvoiceService(TaxService taxService) {
        this.taxService = taxService;
    }

    public long calculateTotal(long baseAmount) {
        return baseAmount + taxService.taxFor(baseAmount);
    }
}

@Component
class TaxService {
    public long taxFor(long amount) {
        return Math.round(amount * 0.2);
    }
}
```

### Событийная шина
```java
import io.lilipup.core.event.EventPublisher;
import io.lilipup.core.event.annotation.OnEvent;
import io.lilipup.core.annotation.Component;

@Component
public class OrderFlow {
    private final EventPublisher publisher;

    public OrderFlow(EventPublisher publisher) {
        this.publisher = publisher;
    }

    public void placeOrder(String orderId) {
        publisher.publish(new OrderCreatedEvent(orderId));
    }

    @OnEvent
    public void onOrderCreated(OrderCreatedEvent event) {
        // Локальная реакция: запись метрики, подготовка к отправке в Kafka и т.д.
        System.out.println("Order accepted: " + event.orderId());
    }
}

record OrderCreatedEvent(String orderId) {}
```

## 4. Конфигурация
```yaml
lilipup:
  app:
    name: billing-service
    profile: prod
  core:
    scan-packages:
      - com.example.app
      - com.example.shared
    lazy-init: false
    fail-fast: true
    event-bus:
      async: true
      workers: 8
```

Ключевые параметры:
- `lilipup.core.lazy-init`: откладывает создание бинов до первого запроса;
- `lilipup.core.fail-fast`: завершает запуск при ошибках графа зависимостей;
- `lilipup.core.event-bus.async`: включает асинхронную доставку событий.

## 5. Обязательные проверки
- Всегда проверяйте, что `scan-packages` включает все модули с компонентами, иначе часть бинов не будет создана.
- Всегда включайте `fail-fast=true` для production, чтобы не запускаться с полубитым контейнером.
- Перед публикацией доменных событий проверяйте валидность payload (не `null`, корректные идентификаторы).
- Не создавайте циклические зависимости между компонентами (`A -> B -> A`).
- Проверяйте, что асинхронный `event-bus` имеет достаточное число `workers` под нагрузкой.

## 6. Ошибки и их обработка
### Типичные ошибки
- `BeanResolutionException`: контейнер не может найти/создать зависимость.
- `CircularDependencyException`: цикл в графе DI.
- `EventDispatchTimeoutException`: обработчик события не уложился в таймаут.

### Пример обработки ошибок запуска
```java
import io.lilipup.core.LilipupApplication;
import io.lilipup.core.exception.BootstrapException;

public class SafeMain {
    public static void main(String[] args) {
        try {
            LilipupApplication.run(App.class, args);
        } catch (BootstrapException ex) {
            // В реальном проекте: структурированный лог + аварийное уведомление.
            System.err.println("Startup failed: " + ex.getMessage());
            System.exit(1);
        }
    }
}
```

## 7. Best Practices
- Используйте конструкторное внедрение как default.
- Разделяйте `@Component` и инфраструктурные бины (`@Factory`) по пакетам.
- Ограничивайте область сканирования (`scan-packages`) для ускорения старта.
- Доменные события делайте immutable (`record` / финальные поля).
- Не размещайте тяжелую I/O-логику в синхронных обработчиках событий.
