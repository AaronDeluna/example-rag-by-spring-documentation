
# Рекурсивные советники

## Что такое рекурсивный советник?

image:advisors-recursive.png[Advisors Recursive, width=230, float="right", align="center", alt="Advisors Recursive"]
Рекурсивные советники — это особый тип советника, который может многократно проходить по цепочке советников вниз. 
Этот паттерн полезен, когда необходимо повторно вызывать LLM до тех пор, пока не будет выполнено определенное условие, например:

- Выполнение вызовов инструментов в цикле до тех пор, пока не останется больше инструментов для вызова
- Проверка структурированного вывода и повторная попытка в случае неудачи проверки
- Реализация логики оценки с изменениями в запросе
- Реализация логики повторных попыток с изменениями в запросе

Метод `CallAdvisorChain.copy(CallAdvisor after)` является ключевым инструментом, который позволяет использовать рекурсивные паттерны советников. 
Он создает новую цепочку советников, которая содержит только тех советников, которые идут после указанного советника в оригинальной цепочке,
и позволяет рекурсивному советнику вызывать эту подцепочку по мере необходимости.
Этот подход гарантирует, что:

- Рекурсивный советник может проходить по оставшимся советникам в цепочке
- Другие советники в цепочке могут наблюдать и перехватывать каждую итерацию
- Цепочка советников сохраняет правильный порядок и наблюдаемость
- Рекурсивный советник не повторно выполняет советников, которые были до него

## Встроенные рекурсивные советники

Spring AI предоставляет два встроенных рекурсивных советника, которые демонстрируют этот паттерн:

### ToolCallAdvisor

`ToolCallAdvisor` реализует цикл вызова инструментов как часть цепочки советников, а не полагается на внутреннее выполнение инструментов моделью. Это позволяет другим советникам в цепочке перехватывать и наблюдать процесс вызова инструментов.

Ключевые особенности:

- Отключает внутреннее выполнение инструментов моделью, устанавливая `setInternalToolExecutionEnabled(false)`
- Проходит по цепочке советников до тех пор, пока не останется больше вызовов инструментов
- Поддерживает функциональность "возврат напрямую" - когда выполнение инструмента имеет `returnDirect=true`, оно прерывает цикл вызова инструментов и возвращает результат выполнения инструмента непосредственно в клиентское приложение, а не отправляет его обратно в LLM
- Использует `callAdvisorChain.copy(this)` для создания подцепочки для рекурсивных вызовов
- Включает проверки на нулевые значения для обработки случаев, когда ответ чата может быть нулевым
- Поддерживает настраиваемое управление историей беседы через `conversationHistoryEnabled`

Пример использования:

```java
var toolCallAdvisor = ToolCallAdvisor.builder()
    .toolCallingManager(toolCallingManager)
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 300)
    .build();

var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(toolCallAdvisor)
    .build();
```

#### Управление историей беседы

`ToolCallAdvisor` включает параметр конфигурации `conversationHistoryEnabled`, который управляет тем, как история беседы обрабатывается во время итераций вызова инструментов.

По умолчанию (`conversationHistoryEnabled=true`), советник поддерживает полную историю беседы внутри во время итераций вызова инструментов. Это означает, что каждый последующий вызов LLM в цикле вызова инструментов включает все предыдущие сообщения (сообщение пользователя, ответы помощника, ответы инструментов).

Используйте метод `.disableMemory()`, чтобы отключить внутреннее управление историей беседы. Когда отключено, только последнее сообщение ответа инструмента передается в следующую итерацию. Это полезно, когда:

- У вас есть зарегистрированный советник Chat Memory, который уже управляет историей беседы
- Вы хотите сократить использование токенов, не дублируя управление историей
- Вы интегрируетесь с внешними системами памяти беседы

Пример с отключенной историей беседы:

```java
var toolCallAdvisor = ToolCallAdvisor.builder()
    .toolCallingManager(toolCallingManager)
    .disableMemory()  // Отключить внутреннюю историю - позволить ChatMemory управлять ею
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 300)
    .build();

var chatMemoryAdvisor = MessageChatMemoryAdvisor.builder(chatMemory)
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 200)  // Размещен перед ToolCallAdvisor
    .build();

var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(chatMemoryAdvisor, toolCallAdvisor)
    .build();
```

#### Функциональность возврата напрямую

Функция "возврат напрямую" позволяет инструментам обойти LLM и вернуть свои результаты непосредственно в клиентское приложение. Это полезно, когда:

- Выход инструмента является окончательным ответом и не требует обработки LLM
- Вы хотите сократить задержку, избегая дополнительного вызова LLM
- Результат инструмента должен быть возвращен без интерпретации

Когда выполнение инструмента имеет `returnDirect=true`, `ToolCallAdvisor` будет:

1. Выполнять вызов инструмента как обычно
2. Обнаруживать флаг `returnDirect` в `ToolExecutionResult`
3. Прерывать цикл вызова инструментов
4. Возвращать результат выполнения инструмента непосредственно в клиентское приложение как `ChatResponse` с выводом инструмента в качестве содержимого генерации

### StructuredOutputValidationAdvisor

`StructuredOutputValidationAdvisor` проверяет структурированный JSON-вывод на соответствие сгенерированной JSON-схеме и повторяет вызов, если проверка не удалась, до указанного количества попыток.

Ключевые особенности:

- Автоматически генерирует JSON-схему из ожидаемого типа вывода
- Проверяет ответ LLM на соответствие схеме
- Повторяет вызов, если проверка не удалась, до настраиваемого количества попыток
- Дополняет запрос сообщениями об ошибках проверки при повторных попытках, чтобы помочь LLM исправить свой вывод
- Использует `callAdvisorChain.copy(this)` для создания подцепочки для рекурсивных вызовов
- Опционально поддерживает настраиваемый `ObjectMapper` для обработки JSON

Пример использования:

```java
var validationAdvisor = StructuredOutputValidationAdvisor.builder()
    .outputType(MyResponseType.class)
    .maxRepeatAttempts(3)
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 1000)
    .build();

var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(validationAdvisor)
    .build();
```
