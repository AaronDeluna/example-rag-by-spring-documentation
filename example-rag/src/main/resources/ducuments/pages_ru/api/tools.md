# Вызов инструментов

_Вызов инструментов_ (также известный как _вызов функций_) — это распространенный шаблон в приложениях ИИ, позволяющий модели взаимодействовать с набором API или _инструментов_, расширяя ее возможности.

Инструменты в основном используются для:

- **Извлечения информации**. Инструменты в этой категории могут использоваться для извлечения информации из внешних источников, таких как база данных, веб-сервис, файловая система или веб-поисковая система. Цель состоит в том, чтобы дополнить знания модели, позволяя ей отвечать на вопросы, на которые она иначе не смогла бы ответить. Таким образом, их можно использовать в сценариях, связанных с извлечением информации для генерации (RAG). Например, инструмент может быть использован для получения текущей погоды для заданного местоположения, для извлечения последних новостных статей или для запроса базы данных на наличие конкретной записи.
- **Выполнения действий**. Инструменты в этой категории могут использоваться для выполнения действий в программной системе, таких как отправка электронной почты, создание новой записи в базе данных, отправка формы или запуск рабочего процесса. Цель состоит в том, чтобы автоматизировать задачи, которые в противном случае потребовали бы человеческого вмешательства или явного программирования. Например, инструмент может быть использован для бронирования рейса для клиента, взаимодействующего с чат-ботом, для заполнения формы на веб-странице или для реализации класса Java на основе автоматизированного теста (TDD) в сценарии генерации кода.

Хотя мы обычно относим _вызов инструментов_ к возможностям модели, на самом деле именно клиентское приложение отвечает за предоставление логики вызова инструментов. Модель может только запрашивать вызов инструмента и предоставлять входные аргументы, в то время как приложение отвечает за выполнение вызова инструмента на основе входных аргументов и возврат результата. Модель никогда не получает доступ к каким-либо API, предоставляемым в качестве инструментов, что является критическим аспектом безопасности.

Spring AI предоставляет удобные API для определения инструментов, разрешения запросов на вызов инструментов от модели и выполнения вызовов инструментов. В следующих разделах представлено общее описание возможностей вызова инструментов в Spring AI.

> **Примечание:** Проверьте xref:api/chat/comparison.adoc[Сравнения моделей ИИ], чтобы увидеть, какие модели ИИ поддерживают вызов инструментов.

> **Совет:** Следуйте руководству, чтобы перейти с устаревшего xref:api/tools-migration.adoc[API FunctionCallback на API ToolCallback].

## Быстрый старт

Давайте посмотрим, как начать использовать вызов инструментов в Spring AI. Мы реализуем два простых инструмента: один для извлечения информации и один для выполнения действий. Инструмент извлечения информации будет использоваться для получения текущей даты и времени в часовом поясе пользователя. Инструмент действий будет использоваться для установки будильника на указанное время.

### Извлечение информацииAI модели не имеют доступа к информации в реальном времени. Любой вопрос, который предполагает осведомленность о такой информации, как текущая дата или прогноз погоды, не может быть отвечен моделью. Однако мы можем предоставить инструмент, который сможет извлекать эту информацию, и позволить модели вызывать этот инструмент, когда потребуется доступ к информации в реальном времени.

Давайте реализуем инструмент для получения текущей даты и времени в часовом поясе пользователя в классе `DateTimeTools`. Инструмент не будет принимать аргументов. `LocaleContextHolder` из Spring Framework может предоставить часовой пояс пользователя. Инструмент будет определен как метод, аннотированный `@Tool`. Чтобы помочь модели понять, когда и как вызывать этот инструмент, мы предоставим подробное описание того, что делает инструмент.

```java
import java.time.LocalDateTime;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = "Получить текущую дату и время в часовом поясе пользователя")
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

Далее, давайте сделаем инструмент доступным для модели. В этом примере мы будем использовать `ChatClient` для взаимодействия с моделью. Мы предоставим инструмент модели, передав экземпляр `DateTimeTools` через метод `tools()`. Когда модели потребуется узнать текущую дату и время, она запросит вызов инструмента. Внутри `ChatClient` будет вызван инструмент, и результат будет возвращен модели, которая затем использует результат вызова инструмента для генерации окончательного ответа на исходный вопрос.

```java
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt("Какой день завтра?")
        .tools(new DateTimeTools())
        .call()
        .content();

System.out.println(response);
```

Вывод будет чем-то вроде:

[source]
```
Завтра 2015-10-21.
```

Вы можете снова попробовать задать тот же вопрос. На этот раз не предоставляйте инструмент модели. Вывод будет чем-то вроде:

[source]
```
Я — ИИ и не имею доступа к информации в реальном времени. Пожалуйста, укажите текущую дату, чтобы я мог точно определить, какой день будет завтра.
```

Без инструмента модель не знает, как ответить на вопрос, потому что у нее нет возможности определить текущую дату и время.

### Выполнение действийAI модели могут использоваться для генерации планов по достижению определенных целей. Например, модель может сгенерировать план по бронированию поездки в Данию. Однако модель не имеет возможности выполнить план. Здесь на помощь приходят инструменты: они могут быть использованы для выполнения плана, который генерирует модель.

В предыдущем примере мы использовали инструмент для определения текущей даты и времени. В этом примере мы определим второй инструмент для установки будильника на определенное время. Цель состоит в том, чтобы установить будильник на 10 минут вперед, поэтому нам нужно предоставить обе инструменты модели для выполнения этой задачи.

Мы добавим новый инструмент в тот же класс `DateTimeTools`, что и раньше. Новый инструмент будет принимать один параметр, который представляет собой время в формате ISO-8601. Затем инструмент выведет сообщение в консоль, указывающее, что будильник установлен на указанное время. Как и прежде, инструмент определяется как метод, аннотированный `@Tool`, который мы также используем для предоставления подробного описания, чтобы помочь модели понять, когда и как использовать инструмент.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = "Получить текущую дату и время в часовом поясе пользователя")
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

    @Tool(description = "Установить будильник для пользователя на указанное время, предоставленное в формате ISO-8601")
    void setAlarm(String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Будильник установлен на " + alarmTime);
    }

}
```

Далее, давайте сделаем оба инструмента доступными для модели. Мы будем использовать `ChatClient` для взаимодействия с моделью. Мы предоставим инструменты модели, передав экземпляр `DateTimeTools` через метод `tools()`. Когда мы попросим установить будильник на 10 минут вперед, модели сначала нужно будет узнать текущую дату и время. Затем она использует текущую дату и время для расчета времени будильника. Наконец, она использует инструмент будильника для его установки. Внутри `ChatClient` будет обрабатывать любой запрос на вызов инструмента от модели и отправлять обратно результат выполнения вызова инструмента, чтобы модель могла сгенерировать окончательный ответ.

```java
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt("Можешь установить будильник на 10 минут вперед?")
        .tools(new DateTimeTools())
        .call()
        .content();

System.out.println(response);
```

В журналах приложения вы можете проверить, что будильник установлен на правильное время.

## ОбзорSpring AI поддерживает вызов инструментов через набор гибких абстракций, которые позволяют вам определять, разрешать и выполнять инструменты последовательным образом. Этот раздел предоставляет обзор основных концепций и компонентов вызова инструментов в Spring AI.

![Основная последовательность действий для вызова инструментов, width=700, align="center"](tools/tool-calling-01.jpg)

1. Когда мы хотим сделать инструмент доступным для модели, мы включаем его определение в запрос чата. Каждое определение инструмента состоит из имени, описания и схемы входных параметров.
2. Когда модель решает вызвать инструмент, она отправляет ответ с именем инструмента и входными параметрами, смоделированными по определенной схеме.
3. Приложение отвечает за использование имени инструмента для идентификации и выполнения инструмента с предоставленными входными параметрами.
4. Результат вызова инструмента обрабатывается приложением.
5. Приложение отправляет результат вызова инструмента обратно в модель.
6. Модель генерирует окончательный ответ, используя результат вызова инструмента в качестве дополнительного контекста.

Инструменты являются строительными блоками вызова инструментов и моделируются с помощью интерфейса `ToolCallback`. Spring AI предоставляет встроенную поддержку для указания `ToolCallback`(ов) из методов и функций, но вы всегда можете определить свои собственные реализации `ToolCallback`, чтобы поддерживать больше случаев использования.

Реализации `ChatModel` прозрачно направляют запросы на вызов инструментов к соответствующим реализациям `ToolCallback` и отправляют результаты вызова инструментов обратно в модель, которая в конечном итоге генерирует окончательный ответ. Они делают это с помощью интерфейса `ToolCallingManager`, который отвечает за управление жизненным циклом выполнения инструмента.

Как `ChatClient`, так и `ChatModel` принимают список объектов `ToolCallback`, чтобы сделать инструменты доступными для модели и `ToolCallingManager`, который в конечном итоге их выполнит.

Кроме передачи объектов `ToolCallback` напрямую, вы также можете передать список имен инструментов, которые будут разрешены динамически с использованием интерфейса `ToolCallbackResolver`.

Следующие разделы подробно рассмотрят все эти концепции и API, включая то, как настраивать и расширять их для поддержки большего количества случаев использования.

## Методы как инструменты

Spring AI предоставляет встроенную поддержку для указания инструментов (т.е. `ToolCallback`(ов)) из методов двумя способами:

- декларативно, с использованием аннотации `@Tool`
- программно, с использованием низкоуровневой реализации `MethodToolCallback`.

### Декларативная спецификация: `@Tool`Вы можете превратить метод в инструмент, аннотировав его с помощью `@Tool`.

```java
class DateTimeTools {

    @Tool(description = "Получить текущую дату и время в часовом поясе пользователя")
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

Аннотация `@Tool` позволяет предоставить ключевую информацию об инструменте:

- `name`: Название инструмента. Если не указано, будет использовано имя метода. Модели ИИ используют это имя для идентификации инструмента при его вызове. Поэтому не допускается наличие двух инструментов с одинаковым именем в одном классе. Имя должно быть уникальным среди всех доступных инструментов для конкретного запроса чата.
- `description`: Описание инструмента, которое может быть использовано моделью для понимания, когда и как вызывать инструмент. Если не указано, будет использовано имя метода в качестве описания инструмента. Однако настоятельно рекомендуется предоставить подробное описание, так как это имеет первостепенное значение для понимания моделью назначения инструмента и его использования. Непредоставление хорошего описания может привести к тому, что модель не будет использовать инструмент, когда это необходимо, или будет использовать его неправильно.
- `returnDirect`: Должен ли результат инструмента возвращаться непосредственно клиенту или передаваться обратно модели. См. xref:_return_direct[] для получения дополнительных сведений.
- `resultConverter`: Реализация `ToolCallResultConverter`, которая будет использоваться для преобразования результата вызова инструмента в `String object`, чтобы отправить обратно модели ИИ. См. xref:_result_conversion[] для получения дополнительных сведений.

Метод может быть как статическим, так и экземплярным, и он может иметь любую видимость (public, protected, package-private или private). Класс, содержащий метод, может быть как верхнеуровневым, так и вложенным, и он также может иметь любую видимость (при условии, что он доступен там, где вы планируете его инстанцировать).

> **Примечание:** Spring AI предоставляет встроенную поддержку AOT-компиляции методов, аннотированных `@Tool`, при условии, что класс, содержащий методы, является Spring-бином (например, `@Component`). В противном случае вам нужно будет предоставить необходимую конфигурацию для компилятора GraalVM. Например, аннотировав класс с помощью `@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)`.

Вы можете определить любое количество аргументов для метода (включая отсутствие аргументов) с большинством типов (примитивы, POJO, перечисления, списки, массивы, карты и так далее). Аналогично, метод может возвращать большинство типов, включая `void`. Если метод возвращает значение, тип возвращаемого значения должен быть сериализуемым, так как результат будет сериализован и отправлен обратно модели.

> **Примечание:** Некоторые типы не поддерживаются. См. xref:_method_tool_limitations[] для получения дополнительных сведений.

Spring AI автоматически сгенерирует JSON-схему для входных параметров метода, аннотированного `@Tool`. Схема используется моделью для понимания того, как вызывать инструмент и подготовить запрос к инструменту. Аннотацию `@ToolParam` можно использовать для предоставления дополнительной информации о входных параметрах, такой как описание или то, является ли параметр обязательным или необязательным. По умолчанию все входные параметры считаются обязательными.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;

class DateTimeTools {

    @Tool(description = "Установить будильник для указанного времени")
    void setAlarm(@ToolParam(description = "Время в формате ISO-8601") String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Будильник установлен на " + alarmTime);
    }

}
```

Аннотация `@ToolParam` позволяет предоставить ключевую информацию о параметре инструмента:

- `description`: Описание параметра, которое может быть использовано моделью для лучшего понимания того, как его использовать. Например, в каком формате должен быть параметр, какие значения допустимы и так далее.
- `required`: Является ли параметр обязательным или необязательным. По умолчанию все параметры считаются обязательными.

Если параметр аннотирован как `@Nullable`, он будет считаться необязательным, если не будет явно помечен как обязательный с помощью аннотации `@ToolParam`.

Кроме аннотации `@ToolParam`, вы также можете использовать аннотацию `@Schema` из Swagger или `@JsonProperty` из Jackson. См. xref:_json_schema[] для получения дополнительных сведений.#### Добавление инструментов в `ChatClient`

При использовании подхода декларативной спецификации вы можете передать экземпляр класса инструмента в метод `tools()` при вызове `ChatClient`. Такие инструменты будут доступны только для конкретного запроса чата, к которому они добавлены.

```java
ChatClient.create(chatModel)
    .prompt("Какой день завтра?")
    .tools(new DateTimeTools())
    .call()
    .content();
```

Внутри `ChatClient` будет сгенерирован `ToolCallback` из каждого метода, аннотированного `@Tool`, в экземпляре класса инструмента, и передан в модель. Если вы предпочитаете генерировать `ToolCallback`(и) самостоятельно, вы можете использовать утилитный класс `ToolCallbacks`.

```java
ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools());
```

#### Добавление стандартных инструментов в `ChatClient`

При использовании подхода декларативной спецификации вы можете добавить стандартные инструменты в `ChatClient.Builder`, передав экземпляр класса инструмента в метод `defaultTools()`. Если предоставлены как стандартные, так и временные инструменты, временные инструменты полностью заменят стандартные.

> **Внимание:** Стандартные инструменты разделяются между всеми запросами чата, выполняемыми всеми экземплярами `ChatClient`, созданными из одного и того же `ChatClient.Builder`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, рискуя сделать их доступными, когда это не следует.

```java
ChatModel chatModel = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultTools(new DateTimeTools())
    .build();
```

#### Добавление инструментов в `ChatModel`

При использовании подхода декларативной спецификации вы можете передать экземпляр класса инструмента в метод `toolCallbacks()` объекта `ToolCallingChatOptions`, который вы используете для вызова `ChatModel`. Такие инструменты будут доступны только для конкретного запроса чата, к которому они добавлены.

```java
ChatModel chatModel = ...
ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools());
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(dateTimeTools)
    .build();
Prompt prompt = new Prompt("Какой день завтра?", chatOptions);
chatModel.call(prompt);
```

#### Добавление стандартных инструментов в `ChatModel`

При использовании подхода декларативной спецификации вы можете добавить стандартные инструменты в `ChatModel` во время его создания, передав экземпляр класса инструмента в метод `toolCallbacks()` объекта `ToolCallingChatOptions`, используемого для создания `ChatModel`. Если предоставлены как стандартные, так и временные инструменты, временные инструменты полностью заменят стандартные.

> **Внимание:** Стандартные инструменты разделяются между всеми запросами чата, выполняемыми этим экземпляром `ChatModel`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, рискуя сделать их доступными, когда это не следует.

```java
ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools());
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolCallbacks(dateTimeTools)
            .build())
    .build();
```

### Программная спецификация: `MethodToolCallback`Вы можете превратить метод в инструмент, создав `MethodToolCallback` программно.

```java
class DateTimeTools {

    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

`MethodToolCallback.Builder` позволяет вам создать экземпляр `MethodToolCallback` и предоставить ключевую информацию об инструменте:

- `toolDefinition`: Экземпляр `ToolDefinition`, который определяет имя инструмента, описание и схему ввода. Вы можете создать его с помощью класса `ToolDefinition.Builder`. Обязательно.
- `toolMetadata`: Экземпляр `ToolMetadata`, который определяет дополнительные настройки, такие как необходимость возвращать результат непосредственно клиенту и конвертер результата, который следует использовать. Вы можете создать его с помощью класса `ToolMetadata.Builder`.
- `toolMethod`: Экземпляр `Method`, который представляет метод инструмента. Обязательно.
- `toolObject`: Экземпляр объекта, который содержит метод инструмента. Если метод статический, вы можете опустить этот параметр.
- `toolCallResultConverter`: Экземпляр `ToolCallResultConverter`, который следует использовать для преобразования результата вызова инструмента в объект `String`, который будет отправлен обратно в модель ИИ. Если не предоставлен, будет использован конвертер по умолчанию (`DefaultToolCallResultConverter`).

`ToolDefinition.Builder` позволяет вам создать экземпляр `ToolDefinition` и определить имя инструмента, описание и схему ввода:

- `name`: Имя инструмента. Если не указано, будет использовано имя метода. Модели ИИ используют это имя для идентификации инструмента при его вызове. Поэтому не допускается наличие двух инструментов с одинаковым именем в одном классе. Имя должно быть уникальным для всех инструментов, доступных модели для конкретного запроса чата.
- `description`: Описание инструмента, которое может быть использовано моделью для понимания, когда и как вызывать инструмент. Если не указано, будет использовано имя метода в качестве описания инструмента. Тем не менее, настоятельно рекомендуется предоставить подробное описание, так как это имеет первостепенное значение для понимания моделью назначения инструмента и его использования. Непредоставление хорошего описания может привести к тому, что модель не будет использовать инструмент, когда это необходимо, или будет использовать его неправильно.
- `inputSchema`: JSON-схема для входных параметров инструмента. Если не указано, схема будет сгенерирована автоматически на основе параметров метода. Вы можете использовать аннотацию `@ToolParam`, чтобы предоставить дополнительную информацию о входных параметрах, такую как описание или необходимость параметра. По умолчанию все входные параметры считаются обязательными. См. xref:_json_schema[] для получения дополнительных сведений.

`ToolMetadata.Builder` позволяет вам создать экземпляр `ToolMetadata` и определить дополнительные настройки для инструмента:

- `returnDirect`: Должен ли результат инструмента возвращаться непосредственно клиенту или передаваться обратно в модель. См. xref:_return_direct[] для получения дополнительных сведений.

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolCallback toolCallback = MethodToolCallback.builder()
    .toolDefinition(ToolDefinitions.builder(method)
            .description("Получить текущую дату и время в часовом поясе пользователя")
            .build())
    .toolMethod(method)
    .toolObject(new DateTimeTools())
    .build();
```

Метод может быть как статическим, так и экземплярным, и он может иметь любую видимость (public, protected, package-private или private). Класс, содержащий метод, может быть как верхнего уровня, так и вложенным, и он также может иметь любую видимость (при условии, что он доступен там, где вы планируете его инстанцировать).

> **Примечание:** Spring AI предоставляет встроенную поддержку AOT-компиляции методов инструмента, если класс, содержащий методы, является Spring-бином (например, `@Component`). В противном случае вам нужно будет предоставить необходимую конфигурацию для компилятора GraalVM. Например, аннотировав класс с помощью `@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)`.

Вы можете определить любое количество аргументов для метода (включая отсутствие аргументов) с большинством типов (примитивы, POJO, перечисления, списки, массивы, карты и т. д.). Аналогично, метод может возвращать большинство типов, включая `void`. Если метод возвращает значение, тип возвращаемого значения должен быть сериализуемым, так как результат будет сериализован и отправлен обратно в модель.

> **Примечание:** Некоторые типы не поддерживаются. См. xref:_method_tool_limitations[] для получения дополнительных сведений.

Если метод статический, вы можете опустить метод `toolObject()`, так как он не нужен.

```java
class DateTimeTools {

    static String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolCallback toolCallback = MethodToolCallback.builder()
    .toolDefinition(ToolDefinitions.builder(method)
            .description("Получить текущую дату и время в часовом поясе пользователя")
            .build())
    .toolMethod(method)
    .build();
```

Spring AI автоматически сгенерирует JSON-схему для входных параметров метода. Схема используется моделью для понимания того, как вызывать инструмент и подготавливать запрос инструмента. Аннотацию `@ToolParam` можно использовать для предоставления дополнительной информации о входных параметрах, такой как описание или необходимость параметра. По умолчанию все входные параметры считаются обязательными.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.ToolParam;

class DateTimeTools {

    void setAlarm(@ToolParam(description = "Время в формате ISO-8601") String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Будильник установлен на " + alarmTime);
    }

}
```

Аннотация `@ToolParam` позволяет вам предоставить ключевую информацию о параметре инструмента:

- `description`: Описание параметра, которое может быть использовано моделью для лучшего понимания, как его использовать. Например, в каком формате должен быть параметр, какие значения допустимы и так далее.
- `required`: Является ли параметр обязательным или необязательным. По умолчанию все параметры считаются обязательными.

Если параметр аннотирован как `@Nullable`, он будет считаться необязательным, если не будет явно помечен как обязательный с помощью аннотации `@ToolParam`.

Кроме аннотации `@ToolParam`, вы также можете использовать аннотацию `@Schema` из Swagger или `@JsonProperty` из Jackson. См. xref:_json_schema[] для получения дополнительных сведений.#### Добавление инструментов в `ChatClient` и `ChatModel`

При использовании подхода программной спецификации вы можете передать экземпляр `MethodToolCallback` в метод `toolCallbacks()` класса `ChatClient`. Инструмент будет доступен только для конкретного запроса чата, к которому он добавлен.

```java
ToolCallback toolCallback = ...
ChatClient.create(chatModel)
    .prompt("Какой день завтра?")
    .toolCallbacks(toolCallback)
    .call()
    .content();
```

#### Добавление стандартных инструментов в `ChatClient`

При использовании подхода программной спецификации вы можете добавить стандартные инструменты в `ChatClient.Builder`, передав экземпляр `MethodToolCallback` в метод `defaultToolCallbacks()`. Если предоставлены как стандартные, так и временные инструменты, временные инструменты полностью заменят стандартные.

> **Внимание:** Стандартные инструменты общие для всех запросов чата, выполняемых всеми экземплярами `ChatClient`, созданными из одного и того же `ChatClient.Builder`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, так как это может сделать их доступными, когда это не должно быть.

```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultToolCallbacks(toolCallback)
    .build();
```

#### Добавление инструментов в `ChatModel`

При использовании подхода программной спецификации вы можете передать экземпляр `MethodToolCallback` в метод `toolCallbacks()` класса `ToolCallingChatOptions`, который вы используете для вызова `ChatModel`. Инструмент будет доступен только для конкретного запроса чата, к которому он добавлен.

```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(toolCallback)
    .build();
Prompt prompt = new Prompt("Какой день завтра?", chatOptions);
chatModel.call(prompt);
```

#### Добавление стандартных инструментов в `ChatModel`

При использовании подхода программной спецификации вы можете добавить стандартные инструменты в `ChatModel` во время его создания, передав экземпляр `MethodToolCallback` в метод `toolCallbacks()` экземпляра `ToolCallingChatOptions`, используемого для создания `ChatModel`. Если предоставлены как стандартные, так и временные инструменты, временные инструменты полностью заменят стандартные.

> **Внимание:** Стандартные инструменты общие для всех запросов чата, выполняемых этим экземпляром `ChatModel`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, так как это может сделать их доступными, когда это не должно быть.

```java
ToolCallback toolCallback = ...
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolCallbacks(toolCallback)
            .build())
    .build();
```

### Ограничения инструментов методов

Следующие типы в настоящее время не поддерживаются в качестве параметров или возвращаемых типов для методов, используемых в качестве инструментов:

- `Optional`
- Асинхронные типы (например, `CompletableFuture`, `Future`)
- Реактивные типы (например, `Flow`, `Mono`, `Flux`)
- Функциональные типы (например, `Function`, `Supplier`, `Consumer`).

Функциональные типы поддерживаются с использованием подхода спецификации инструментов на основе функций. См. xref:_functions_as_tools[] для получения дополнительной информации.

## Функции как инструменты

Spring AI предоставляет встроенную поддержку для спецификации инструментов из функций, либо программно с использованием низкоуровневой реализации `FunctionToolCallback`, либо динамически как `@Bean`(ы), разрешаемые во время выполнения.

### Программная спецификация: `FunctionToolCallback`Вы можете превратить функциональный тип (`Function`, `Supplier`, `Consumer` или `BiFunction`) в инструмент, создавая `FunctionToolCallback` программно.

```java
public class WeatherService implements Function<WeatherRequest, WeatherResponse> {
    public WeatherResponse apply(WeatherRequest request) {
        return new WeatherResponse(30.0, Unit.C);
    }
}

public enum Unit { C, F }
public record WeatherRequest(String location, Unit unit) {}
public record WeatherResponse(double temp, Unit unit) {}
```

`FunctionToolCallback.Builder` позволяет вам создать экземпляр `FunctionToolCallback` и предоставить ключевую информацию об инструменте:

- `name`: Название инструмента. Модели ИИ используют это имя для идентификации инструмента при его вызове. Поэтому не допускается наличие двух инструментов с одинаковым именем в одном контексте. Имя должно быть уникальным среди всех инструментов, доступных модели для конкретного запроса чата. Обязательно.
- `toolFunction`: Функциональный объект, представляющий метод инструмента (`Function`, `Supplier`, `Consumer` или `BiFunction`). Обязательно.
- `description`: Описание инструмента, которое может быть использовано моделью для понимания, когда и как вызывать инструмент. Если не предоставлено, будет использовано имя метода в качестве описания инструмента. Тем не менее, настоятельно рекомендуется предоставить подробное описание, так как это имеет первостепенное значение для понимания моделью назначения инструмента и его использования. Непредоставление хорошего описания может привести к тому, что модель не будет использовать инструмент, когда это необходимо, или будет использовать его неправильно.
- `inputType`: Тип входных данных функции. Обязательно.
- `inputSchema`: JSON-схема для входных параметров инструмента. Если не предоставлена, схема будет сгенерирована автоматически на основе `inputType`. Вы можете использовать аннотацию `@ToolParam`, чтобы предоставить дополнительную информацию о входных параметрах, такую как описание или то, является ли параметр обязательным или необязательным. По умолчанию все входные параметры считаются обязательными. См. xref:_json_schema[] для получения дополнительной информации.
- `toolMetadata`: Экземпляр `ToolMetadata`, который определяет дополнительные настройки, такие как необходимость возвращать результат непосредственно клиенту и конвертер результата, который следует использовать. Вы можете создать его с помощью класса `ToolMetadata.Builder`.
- `toolCallResultConverter`: Экземпляр `ToolCallResultConverter`, который следует использовать для преобразования результата вызова инструмента в объект `String`, который будет отправлен обратно модели ИИ. Если не предоставлен, будет использован конвертер по умолчанию (`DefaultToolCallResultConverter`).

`ToolMetadata.Builder` позволяет вам создать экземпляр `ToolMetadata` и определить дополнительные настройки для инструмента:

- `returnDirect`: Должен ли результат инструмента возвращаться непосредственно клиенту или передаваться обратно модели. См. xref:_return_direct[] для получения дополнительной информации.

```java
ToolCallback toolCallback = FunctionToolCallback
    .builder("currentWeather", new WeatherService())
    .description("Получить погоду в местоположении")
    .inputType(WeatherRequest.class)
    .build();
```

Входные и выходные данные функции могут быть либо `Void`, либо POJO. Входные и выходные POJO должны быть сериализуемыми, так как результат будет сериализован и отправлен обратно модели. Функция, а также входные и выходные типы должны быть публичными.

> **Примечание:** Некоторые типы не поддерживаются. См. xref:_function_tool_limitations[] для получения дополнительной информации.

#### Добавление инструментов в `ChatClient`

При использовании подхода программной спецификации вы можете передать экземпляр `FunctionToolCallback` в метод `toolCallbacks()` класса `ChatClient`. Инструмент будет доступен только для конкретного запроса чата, к которому он добавлен.

```java
ToolCallback toolCallback = ...
ChatClient.create(chatModel)
    .prompt("Какова погода в Копенгагене?")
    .toolCallbacks(toolCallback)
    .call()
    .content();
```

#### Добавление стандартных инструментов в `ChatClient`Когда вы используете подход программной спецификации, вы можете добавить инструменты по умолчанию в `ChatClient.Builder`, передав экземпляр `FunctionToolCallback` в метод `defaultToolCallbacks()`. Если предоставлены как инструменты по умолчанию, так и инструменты времени выполнения, инструменты времени выполнения полностью заменят инструменты по умолчанию.

> **Внимание:** Инструменты по умолчанию разделяются между всеми запросами чата, выполняемыми всеми экземплярами `ChatClient`, созданными из одного и того же `ChatClient.Builder`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, рискуя сделать их доступными, когда это не следует.

```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultToolCallbacks(toolCallback)
    .build();
```

#### Добавление инструментов в `ChatModel`

При использовании подхода программной спецификации вы можете передать экземпляр `FunctionToolCallback` в метод `toolCallbacks()` класса `ToolCallingChatOptions`. Инструмент будет доступен только для конкретного запроса чата, к которому он добавлен.

```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(toolCallback)
    .build();
Prompt prompt = new Prompt("Какова погода в Копенгагене?", chatOptions);
chatModel.call(prompt);
```

#### Добавление инструментов по умолчанию в `ChatModel`

При использовании подхода программной спецификации вы можете добавить инструменты по умолчанию в `ChatModel` во время его создания, передав экземпляр `FunctionToolCallback` в метод `toolCallbacks()` экземпляра `ToolCallingChatOptions`, используемого для создания `ChatModel`. Если предоставлены как инструменты по умолчанию, так и инструменты времени выполнения, инструменты времени выполнения полностью заменят инструменты по умолчанию.

> **Внимание:** Инструменты по умолчанию разделяются между всеми запросами чата, выполняемыми этим экземпляром `ChatModel`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, рискуя сделать их доступными, когда это не следует.

```java
ToolCallback toolCallback = ...
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolCallbacks(toolCallback)
            .build())
    .build();
```

### Динамическая спецификация: `@Bean`Вместо того чтобы указывать инструменты программно, вы можете определить инструменты как Spring бины и позволить Spring AI разрешать их динамически во время выполнения с помощью интерфейса `ToolCallbackResolver` (через реализацию `SpringBeanToolCallbackResolver`). Этот вариант дает вам возможность использовать любой бин типа `Function`, `Supplier`, `Consumer` или `BiFunction` в качестве инструмента. Имя бина будет использоваться как имя инструмента, а аннотация `@Description` из Spring Framework может быть использована для предоставления описания инструмента, которое будет использоваться моделью для понимания, когда и как вызывать инструмент. Если вы не предоставите описание, будет использовано имя метода в качестве описания инструмента. Тем не менее, настоятельно рекомендуется предоставить подробное описание, так как это имеет первостепенное значение для понимания моделью назначения инструмента и его использования. Непредоставление хорошего описания может привести к тому, что модель не будет использовать инструмент, когда это необходимо, или будет использовать его неправильно.

```java
@Configuration(proxyBeanMethods = false)
class WeatherTools {

    WeatherService weatherService = new WeatherService();

	@Bean
	@Description("Получить погоду в указанном месте")
	Function<WeatherRequest, WeatherResponse> currentWeather() {
		return weatherService;
	}

}
```

> **Примечание:** Некоторые типы не поддерживаются. См. xref:_function_tool_limitations[] для получения дополнительной информации.

JSON-схема для входных параметров инструмента будет сгенерирована автоматически. Вы можете использовать аннотацию `@ToolParam`, чтобы предоставить дополнительную информацию о входных параметрах, такую как описание или то, является ли параметр обязательным или необязательным. По умолчанию все входные параметры считаются обязательными. См. xref:_json_schema[] для получения дополнительной информации.

```java
record WeatherRequest(@ToolParam(description = "Название города или страны") String location, Unit unit) {}
```

Этот подход к спецификации инструмента имеет недостаток в том, что не гарантирует безопасность типов, так как разрешение инструмента происходит во время выполнения. Чтобы смягчить это, вы можете явно указать имя инструмента с помощью аннотации `@Bean` и сохранить значение в константе, чтобы использовать его в запросе чата вместо жесткого кодирования имени инструмента.

```java
@Configuration(proxyBeanMethods = false)
class WeatherTools {

    public static final String CURRENT_WEATHER_TOOL = "currentWeather";

	@Bean(CURRENT_WEATHER_TOOL)
	@Description("Получить погоду в указанном месте")
	Function<WeatherRequest, WeatherResponse> currentWeather() {
		...
	}

}
```

#### Добавление инструментов в `ChatClient`

При использовании подхода динамической спецификации вы можете передать имя инструмента (т.е. имя бина функции) в метод `toolNames()` класса `ChatClient`. Инструмент будет доступен только для конкретного запроса чата, к которому он добавлен.

```java
ChatClient.create(chatModel)
    .prompt("Какова погода в Копенгагене?")
    .toolNames("currentWeather")
    .call()
    .content();
```

#### Добавление стандартных инструментов в `ChatClient`

При использовании подхода динамической спецификации вы можете добавить стандартные инструменты в `ChatClient.Builder`, передав имя инструмента в метод `defaultToolNames()`. Если предоставлены как стандартные, так и динамические инструменты, динамические инструменты полностью заменят стандартные.

> **Внимание:** Стандартные инструменты общие для всех запросов чата, выполняемых всеми экземплярами `ChatClient`, созданными из одного и того же `ChatClient.Builder`. Они полезны для инструментов, которые часто используются в различных запросах чата, но могут быть опасны, если не использовать их осторожно, рискуя сделать их доступными, когда это не следует.

```java
ChatModel chatModel = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultToolNames("currentWeather")
    .build();
```

#### Добавление инструментов в `ChatModel`Когда вы используете подход динамической спецификации, вы можете передать имя инструмента в метод `toolNames()` экземпляра `ToolCallingChatOptions`, который вы используете для вызова `ChatModel`. Инструмент будет доступен только для конкретного запроса чата, к которому он добавлен.

```java
ChatModel chatModel = ...
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolNames("currentWeather")
    .build();
Prompt prompt = new Prompt("Какова погода в Копенгагене?", chatOptions);
chatModel.call(prompt);
```

#### Добавление стандартных инструментов в `ChatModel`

При использовании подхода динамической спецификации вы можете добавить стандартные инструменты в `ChatModel` во время его создания, передав имя инструмента в метод `toolNames()` экземпляра `ToolCallingChatOptions`, используемого для создания `ChatModel`. Если предоставлены как стандартные, так и временные инструменты, временные инструменты полностью заменят стандартные.

> **Внимание:** Стандартные инструменты общие для всех запросов чата, выполняемых этим экземпляром `ChatModel`. Они полезны для инструментов, которые часто используются в различных запросах чата, но их использование может быть опасным, если не проявлять осторожность, так как это может сделать их доступными, когда это не должно быть.

```java
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolNames("currentWeather")
            .build())
    .build();
```

### Ограничения инструментов функций

Следующие типы в настоящее время не поддерживаются в качестве входных или выходных типов для функций, используемых в качестве инструментов:

- Примитивные типы
- `Optional`
- Коллекции (например, `List`, `Map`, `Array`, `Set`)
- Асинхронные типы (например, `CompletableFuture`, `Future`)
- Реактивные типы (например, `Flow`, `Mono`, `Flux`).

Примитивные типы и коллекции поддерживаются с использованием подхода спецификации инструментов на основе методов. См. xref:_methods_as_tools[] для получения дополнительной информации.

## Спецификация инструмента

В Spring AI инструменты моделируются через интерфейс `ToolCallback`. В предыдущих разделах мы видели, как определять инструменты из методов и функций с использованием встроенной поддержки, предоставляемой Spring AI (см. xref:_methods_as_tools[] и xref:_functions_as_tools[]). Этот раздел углубится в спецификацию инструмента и то, как ее настроить и расширить для поддержки большего количества случаев использования.

### Обратный вызов инструмента

Интерфейс `ToolCallback` предоставляет способ определения инструмента, который может быть вызван AI-моделью, включая как логику определения, так и выполнения. Это основной интерфейс, который нужно реализовать, когда вы хотите определить инструмент с нуля. Например, вы можете определить `ToolCallback` из MCP Client (используя Протокол Контекста Модели) или `ChatClient` (для создания модульного агентного приложения).

Интерфейс предоставляет следующие методы:

```java
public interface ToolCallback {

	/**
	 * Определение, используемое AI-моделью для определения, когда и как вызывать инструмент.
	 */
	ToolDefinition getToolDefinition();

	/**
	 * Метаданные, предоставляющие дополнительную информацию о том, как обрабатывать инструмент.
	 */
	ToolMetadata getToolMetadata();

    /**
	 * Выполнить инструмент с заданным входом и вернуть результат для отправки обратно в AI-модель.
	 */
	String call(String toolInput);

    /**
	 * Выполнить инструмент с заданным входом и контекстом и вернуть результат для отправки обратно в AI-модель.
	 */
	String call(String toolInput, ToolContext tooContext);

}
```

Spring AI предоставляет встроенные реализации для методов инструментов (`MethodToolCallback`) и функций инструментов (`FunctionToolCallback`).

### Определение инструмента```markdown
Интерфейс `ToolDefinition` предоставляет необходимую информацию для AI-модели о доступности инструмента, включая название инструмента, описание и схему ввода. Каждая реализация `ToolCallback` должна предоставить экземпляр `ToolDefinition`, чтобы определить инструмент.

Интерфейс предоставляет следующие методы:

```java
public interface ToolDefinition {

	/**
	 * Название инструмента. Уникально в наборе инструментов, предоставленных модели.
	 */
	String name();

	/**
	 * Описание инструмента, используемое AI-моделью для определения его функциональности.
	 */
	String description();

	/**
	 * Схема параметров, используемых для вызова инструмента.
	 */
	String inputSchema();

}
```

> **Примечание:** См. xref:_json_schema[] для получения дополнительной информации о схеме ввода.

`ToolDefinition.Builder` позволяет вам создать экземпляр `ToolDefinition`, используя стандартную реализацию (`DefaultToolDefinition`).

```java
ToolDefinition toolDefinition = ToolDefinition.builder()
    .name("currentWeather")
    .description("Получить погоду в указанном месте")
    .inputSchema("""
        {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string"
                },
                "unit": {
                    "type": "string",
                    "enum": ["C", "F"]
                }
            },
            "required": ["location", "unit"]
        }
    """)
    .build();
```

#### Определение метода инструмента

При создании инструментов из метода `ToolDefinition` автоматически генерируется для вас. Если вы предпочитаете сгенерировать `ToolDefinition` самостоятельно, вы можете использовать этот удобный билдер.

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolDefinition toolDefinition = ToolDefinitions.from(method);
```

Сгенерированный из метода `ToolDefinition` включает имя метода в качестве названия инструмента, имя метода в качестве описания инструмента и JSON-схему входных параметров метода. Если метод аннотирован с помощью `@Tool`, название и описание инструмента будут взяты из аннотации, если они заданы.

> **Примечание:** См. xref:_methods_as_tools[] для получения дополнительной информации.

Если вы хотите явно указать некоторые или все атрибуты, вы можете использовать `ToolDefinition.Builder`, чтобы создать пользовательский экземпляр `ToolDefinition`.

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolDefinition toolDefinition = ToolDefinitions.builder(method)
    .name("currentDateTime")
    .description("Получить текущую дату и время в часовом поясе пользователя")
    .inputSchema(JsonSchemaGenerator.generateForMethodInput(method))
    .build();
```

#### Определение функции инструмента

При создании инструментов из функции `ToolDefinition` автоматически генерируется для вас. Когда вы используете `FunctionToolCallback.Builder` для создания экземпляра `FunctionToolCallback`, вы можете предоставить название инструмента, описание и схему ввода, которые будут использованы для генерации `ToolDefinition`. См. xref:_functions_as_tools[] для получения дополнительной информации.

### JSON-схема
```Когда вы предоставляете инструмент модели ИИ, модели необходимо знать схему типа входных данных для вызова инструмента. Схема используется для понимания того, как вызвать инструмент и подготовить запрос к инструменту. Spring AI предоставляет встроенную поддержку для генерации JSON-схемы входного типа для инструмента с помощью класса `JsonSchemaGenerator`. Схема предоставляется как часть `ToolDefinition`.

> **Примечание:** См. xref:_tool_definition[] для получения дополнительной информации о `ToolDefinition` и о том, как передать входную схему в него.

Класс `JsonSchemaGenerator` используется в фоновом режиме для генерации JSON-схемы для входных параметров метода или функции, используя любую из стратегий, описанных в xref:_methods_as_tools[] и xref:_functions_as_tools[]. Логика генерации JSON-схемы поддерживает ряд аннотаций, которые вы можете использовать на входных параметрах для методов и функций, чтобы настроить результирующую схему.

В этом разделе описаны две основные опции, которые вы можете настроить при генерации JSON-схемы для входных параметров инструмента: описание и статус обязательности.

#### Описание

Помимо предоставления описания для самого инструмента, вы также можете предоставить описание для входных параметров инструмента. Описание может использоваться для предоставления ключевой информации о входных параметрах, такой как формат, в котором должен быть параметр, какие значения допустимы и так далее. Это полезно для того, чтобы помочь модели понять входную схему и как ее использовать. Spring AI предоставляет встроенную поддержку для генерации описания для входного параметра с помощью одной из следующих аннотаций:

- `@ToolParam(description = "...")` от Spring AI
- `@JsonClassDescription(description = "...")` от Jackson
- `@JsonPropertyDescription(description = "...")` от Jackson
- `@Schema(description = "...")` от Swagger.

Этот подход работает как для методов, так и для функций, и вы можете использовать его рекурсивно для вложенных типов.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = "Установить будильник для заданного времени")
    void setAlarm(@ToolParam(description = "Время в формате ISO-8601") String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Будильник установлен на " + alarmTime);
    }

}
```

#### Обязательный/Необязательный

По умолчанию каждый входной параметр считается обязательным, что заставляет модель ИИ предоставлять значение для него при вызове инструмента. Однако вы можете сделать входной параметр необязательным, используя одну из следующих аннотаций, в этом порядке приоритета:

- `@ToolParam(required = false)` от Spring AI
- `@JsonProperty(required = false)` от Jackson
- `@Schema(required = false)` от Swagger
- `@Nullable` от Spring Framework.

Этот подход работает как для методов, так и для функций, и вы можете использовать его рекурсивно для вложенных типов.

```java
class CustomerTools {

    @Tool(description = "Обновить информацию о клиенте")
    void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) {
        System.out.println("Обновлена информация для клиента с id: " + id);
    }

}
```

> **Внимание:** Определение правильного статуса обязательности для входного параметра имеет решающее значение для снижения риска галлюцинаций и обеспечения того, чтобы модель предоставляла правильный ввод при вызове инструмента. В предыдущем примере параметр `email` является необязательным, что означает, что модель может вызвать инструмент, не предоставляя значение для него. Если бы параметр был обязательным, модели пришлось бы предоставить значение для него при вызове инструмента. А если значения не существовало, модель, вероятно, придумала бы его, что привело бы к галлюцинациям.

### Конвертация результатаРезультат вызова инструмента сериализуется с помощью `ToolCallResultConverter` и затем отправляется обратно в модель ИИ. Интерфейс `ToolCallResultConverter` предоставляет способ преобразования результата вызова инструмента в объект `String`.

Интерфейс предоставляет следующий метод:

```java
@FunctionalInterface
public interface ToolCallResultConverter {

	/**
	 * Учитывая объект, возвращаемый инструментом, преобразует его в строку, совместимую с
	 * данным типом класса.
	 */
	String convert(@Nullable Object result, @Nullable Type returnType);

}
```

Результат должен быть сериализуемым типом. По умолчанию результат сериализуется в JSON с использованием Jackson (`DefaultToolCallResultConverter`), но вы можете настроить процесс сериализации, предоставив свою собственную реализацию `ToolCallResultConverter`.

Spring AI полагается на `ToolCallResultConverter` как в методах, так и в функциональных инструментах.

#### Преобразование результата вызова метода инструмента

При создании инструментов из метода с декларативным подходом вы можете предоставить пользовательский `ToolCallResultConverter`, который будет использоваться для инструмента, установив атрибут `resultConverter()` аннотации `@Tool`.

```java
class CustomerTools {

    @Tool(description = "Получить информацию о клиенте", resultConverter = CustomToolCallResultConverter.class)
    Customer getCustomerInfo(Long id) {
        return customerRepository.findById(id);
    }

}
```

Если вы используете программный подход, вы можете предоставить пользовательский `ToolCallResultConverter`, который будет использоваться для инструмента, установив атрибут `resultConverter()` в `MethodToolCallback.Builder`.

Смотрите xref:_methods_as_tools[] для получения дополнительных сведений.

#### Преобразование результата вызова функционального инструмента

При создании инструментов из функции с использованием программного подхода вы можете предоставить пользовательский `ToolCallResultConverter`, который будет использоваться для инструмента, установив атрибут `resultConverter()` в `FunctionToolCallback.Builder`.

Смотрите xref:_functions_as_tools[] для получения дополнительных сведений.

### Контекст инструмента

Spring AI поддерживает передачу дополнительной контекстной информации инструментам через API `ToolContext`. Эта функция позволяет вам предоставлять дополнительные данные, предоставленные пользователем, которые могут быть использованы в процессе выполнения инструмента вместе с аргументами инструмента, переданными моделью ИИ.

![Предоставление дополнительной контекстной информации инструментам, ширина=700, выравнивание="центр"](tools/tool-context.jpg)

```java
class CustomerTools {

    @Tool(description = "Получить информацию о клиенте")
    Customer getCustomerInfo(Long id, ToolContext toolContext) {
        return customerRepository.findById(id, toolContext.getContext().get("tenantId"));
    }

}
```

`ToolContext` заполняется данными, предоставленными пользователем при вызове `ChatClient`.

```java
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt("Расскажите больше о клиенте с ID 42")
        .tools(new CustomerTools())
        .toolContext(Map.of("tenantId", "acme"))
        .call()
        .content();

System.out.println(response);
```

> **Примечание:** Ни одно из данных, предоставленных в `ToolContext`, не отправляется в модель ИИ.

Аналогично, вы можете определить данные контекста инструмента при прямом вызове `ChatModel`.

```java
ChatModel chatModel = ...
ToolCallback[] customerTools = ToolCallbacks.from(new CustomerTools());
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(customerTools)
    .toolContext(Map.of("tenantId", "acme"))
    .build();
Prompt prompt = new Prompt("Расскажите больше о клиенте с ID 42", chatOptions);
chatModel.call(prompt);
```

Если опция `toolContext` установлена как в параметрах по умолчанию, так и в параметрах времени выполнения, результирующий `ToolContext` будет объединением двух, где параметры времени выполнения имеют приоритет над параметрами по умолчанию.

### Возврат напрямуюПо умолчанию результат вызова инструмента отправляется обратно в модель в качестве ответа. Затем модель может использовать результат для продолжения разговора.

Существуют случаи, когда вы предпочли бы вернуть результат непосредственно вызывающему, а не отправлять его обратно в модель. Например, если вы создаете агента, который полагается на инструмент RAG, вы можете захотеть вернуть результат непосредственно вызывающему, а не отправлять его обратно в модель для ненужной постобработки. Или, возможно, у вас есть определенные инструменты, которые должны завершить цикл рассуждений агента.

Каждая реализация `ToolCallback` может определить, должен ли результат вызова инструмента возвращаться непосредственно вызывающему или отправляться обратно в модель. По умолчанию результат отправляется обратно в модель. Но вы можете изменить это поведение для каждого инструмента.

`ToolCallingManager`, отвечающий за управление жизненным циклом выполнения инструмента, отвечает за обработку атрибута `returnDirect`, связанного с инструментом. Если атрибут установлен в `true`, результат вызова инструмента возвращается непосредственно вызывающему. В противном случае результат отправляется обратно в модель.

> **Примечание:** Если несколько вызовов инструмента запрашиваются одновременно, атрибут `returnDirect` должен быть установлен в `true` для всех инструментов, чтобы вернуть результаты непосредственно вызывающему. В противном случае результаты будут отправлены обратно в модель.

![Возврат результатов вызова инструмента непосредственно вызывающему, width=700, align="center"](tools/return-direct.jpg)

1. Когда мы хотим сделать инструмент доступным для модели, мы включаем его определение в запрос чата. Если мы хотим, чтобы результат выполнения инструмента возвращался непосредственно вызывающему, мы устанавливаем атрибут `returnDirect` в `true`.
2. Когда модель решает вызвать инструмент, она отправляет ответ с именем инструмента и входными параметрами, смоделированными по определенной схеме.
3. Приложение отвечает за использование имени инструмента для идентификации и выполнения инструмента с предоставленными входными параметрами.
4. Результат вызова инструмента обрабатывается приложением.
5. Приложение отправляет результат вызова инструмента непосредственно вызывающему, вместо того чтобы отправлять его обратно в модель.

#### Метод Возврат Напрямую

При создании инструментов из метода с декларативным подходом вы можете пометить инструмент для возврата результата непосредственно вызывающему, установив атрибут `returnDirect` аннотации `@Tool` в `true`.

```java
class CustomerTools {

    @Tool(description = "Получить информацию о клиенте", returnDirect = true)
    Customer getCustomerInfo(Long id) {
        return customerRepository.findById(id);
    }

}
```

Если использовать программный подход, вы можете установить атрибут `returnDirect` через интерфейс `ToolMetadata` и передать его в `MethodToolCallback.Builder`.

```java
ToolMetadata toolMetadata = ToolMetadata.builder()
    .returnDirect(true)
    .build();
```

Смотрите xref:_methods_as_tools[] для получения дополнительных сведений.

#### Функция Возврат Напрямую

При создании инструментов из функции с программным подходом вы можете установить атрибут `returnDirect` через интерфейс `ToolMetadata` и передать его в `FunctionToolCallback.Builder`.

```java
ToolMetadata toolMetadata = ToolMetadata.builder()
    .returnDirect(true)
    .build();
```

Смотрите xref:_functions_as_tools[] для получения дополнительных сведений.

## Выполнение ИнструментаИсполнение инструмента — это процесс вызова инструмента с предоставленными входными аргументами и возвратом результата. Исполнение инструмента обрабатывается интерфейсом `ToolCallingManager`, который отвечает за управление жизненным циклом исполнения инструмента.

```java
public interface ToolCallingManager {

	/**
	 * Разрешить определения инструмента из параметров вызова инструмента модели.
	 */
	List<ToolDefinition> resolveToolDefinitions(ToolCallingChatOptions chatOptions);

	/**
	 * Выполнить вызовы инструмента, запрошенные моделью.
	 */
	ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse);

}
```

Если вы используете любой из Spring AI Spring Boot Starters, `DefaultToolCallingManager` является автоматически сконфигурированной реализацией интерфейса `ToolCallingManager`. Вы можете настроить поведение исполнения инструмента, предоставив свой собственный бин `ToolCallingManager`.

```java
@Bean
ToolCallingManager toolCallingManager() {
    return ToolCallingManager.builder().build();
}
```

По умолчанию Spring AI управляет жизненным циклом исполнения инструмента прозрачно для вас из каждой реализации `ChatModel`. Но у вас есть возможность отказаться от этого поведения и контролировать исполнение инструмента самостоятельно. Этот раздел описывает эти два сценария.

### Исполнение инструмента под контролем фреймворка

При использовании поведения по умолчанию Spring AI автоматически перехватывает любой запрос на вызов инструмента от модели, вызывает инструмент и возвращает результат модели. Все это делается прозрачно для вас каждой реализацией `ChatModel`, использующей `ToolCallingManager`.

![Жизненный цикл исполнения инструмента под контролем фреймворка, ширина=700, выравнивание="центр"](tools/framework-manager.jpg)

1. Когда мы хотим сделать инструмент доступным для модели, мы включаем его определение в запрос чата (`Prompt`) и вызываем API `ChatModel`, который отправляет запрос в AI модель.
2. Когда модель решает вызвать инструмент, она отправляет ответ (`ChatResponse`) с именем инструмента и входными параметрами, смоделированными по определенной схеме.
3. `ChatModel` отправляет запрос на вызов инструмента в API `ToolCallingManager`.
4. `ToolCallingManager` отвечает за идентификацию инструмента для вызова и его исполнение с предоставленными входными параметрами.
5. Результат вызова инструмента возвращается в `ToolCallingManager`.
6. `ToolCallingManager` возвращает результат исполнения инструмента обратно в `ChatModel`.
7. `ChatModel` отправляет результат исполнения инструмента обратно в AI модель (`ToolResponseMessage`).
8. AI модель генерирует финальный ответ, используя результат вызова инструмента в качестве дополнительного контекста, и отправляет его обратно вызывающему (`ChatResponse`) через `ChatClient`.

> **Внимание:** В настоящее время внутренние сообщения, обмениваемые с моделью относительно исполнения инструмента, не доступны пользователю. Если вам нужно получить доступ к этим сообщениям, вы должны использовать подход исполнения инструмента под контролем пользователя.

Логика, определяющая, является ли вызов инструмента подходящим для исполнения, обрабатывается интерфейсом `ToolExecutionEligibilityPredicate`. По умолчанию пригодность исполнения инструмента определяется проверкой, установлено ли значение атрибута `internalToolExecutionEnabled` в `ToolCallingChatOptions` на `true` (значение по умолчанию), и содержит ли `ChatResponse` какие-либо вызовы инструмента.

```java
public class DefaultToolExecutionEligibilityPredicate implements ToolExecutionEligibilityPredicate {

	@Override
	public boolean test(ChatOptions promptOptions, ChatResponse chatResponse) {
		return ToolCallingChatOptions.isInternalToolExecutionEnabled(promptOptions) && chatResponse != null
				&& chatResponse.hasToolCalls();
	}

}
```

Вы можете предоставить свою собственную реализацию `ToolExecutionEligibilityPredicate` при создании бина `ChatModel`.

### Исполнение инструмента под контролем советника с ToolCallAdvisorВ качестве альтернативы инструментам, управляемым фреймворком, вы можете использовать `ToolCallAdvisor` для реализации вызова инструментов как части цепочки xref:api/chatclient.adoc#_advisors[советников]. Этот подход предоставляет несколько преимуществ:

- **Наблюдаемость**: Другие советники в цепочке могут перехватывать и наблюдать за каждой итерацией вызова инструмента
- **Интеграция с памятью чата**: Работает без проблем с советниками памяти чата для управления историей разговоров
- **Расширяемость**: Советник можно расширить для настройки поведения вызова инструмента

`ToolCallAdvisor` реализует цикл вызова инструмента и отключает внутреннее выполнение инструмента моделью. Когда модель запрашивает вызов инструмента, советник выполняет инструмент и отправляет результат обратно модели, продолжая до тех пор, пока не потребуется больше вызовов инструментов.

```java
var toolCallAdvisor = ToolCallAdvisor.builder()
    .toolCallingManager(toolCallingManager)
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 300)
    .build();

var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(toolCallAdvisor)
    .build();

String response = chatClient.prompt("Какой день завтра?")
    .tools(new DateTimeTools())
    .call()
    .content();
```

#### Опции конфигурации

`ToolCallAdvisor.Builder` поддерживает следующие параметры конфигурации:

- `toolCallingManager`: Экземпляр `ToolCallingManager`, который будет использоваться для выполнения вызовов инструментов. Если не предоставлен, используется экземпляр по умолчанию.
- `advisorOrder`: Порядок, в котором советник применяется в цепочке. Должен быть между `BaseAdvisor.HIGHEST_PRECEDENCE` и `BaseAdvisor.LOWEST_PRECEDENCE`.
- `conversationHistoryEnabled`: Управляет тем, будет ли советник поддерживать историю разговоров внутри во время итераций вызова инструментов. По умолчанию `true`.

#### Управление историей разговоров

По умолчанию (`conversationHistoryEnabled=true`) `ToolCallAdvisor` поддерживает полную историю разговоров внутри во время итераций вызова инструментов. Каждый последующий вызов LLM включает все предыдущие сообщения.

Используйте метод `.disableMemory()`, чтобы отключить внутреннее управление историей разговоров. Когда это отключено, только последнее сообщение ответа инструмента передается в следующую итерацию. Это полезно при интеграции с советником памяти чата, который уже управляет историей разговоров:

```java
var toolCallAdvisor = ToolCallAdvisor.builder()
    .toolCallingManager(toolCallingManager)
    .disableMemory()  // Позволить ChatMemory управлять историей
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 300)
    .build();

var chatMemoryAdvisor = MessageChatMemoryAdvisor.builder(chatMemory)
    .advisorOrder(BaseAdvisor.HIGHEST_PRECEDENCE + 200)  // Перед ToolCallAdvisor
    .build();

var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(chatMemoryAdvisor, toolCallAdvisor)
    .build();
```

#### Прямой возврат

`ToolCallAdvisor` поддерживает функцию "прямого возврата", позволяя инструментам обходить LLM и возвращать результаты напрямую клиенту. Когда выполнение инструмента имеет `returnDirect=true`, советник выходит из цикла вызова инструмента и возвращает результат инструмента напрямую.

Для получения дополнительной информации о `ToolCallAdvisor` смотрите xref:api/advisors-recursive.adoc#_toolcalladvisor[Рекурсивные советники - ToolCallAdvisor].

### Управляемое пользователем выполнение инструментовЕсть случаи, когда вы предпочли бы самостоятельно контролировать жизненный цикл выполнения инструмента. Вы можете сделать это, установив атрибут `internalToolExecutionEnabled` в `ToolCallingChatOptions` в значение `false`.

Когда вы вызываете `ChatModel` с этой опцией, выполнение инструмента будет делегировано вызывающему, что даст вам полный контроль над жизненным циклом выполнения инструмента. Ваша ответственность — проверять вызовы инструмента в `ChatResponse` и выполнять их с помощью `ToolCallingManager`.

Следующий пример демонстрирует минимальную реализацию подхода с управляемым пользователем выполнением инструмента:

```java
ChatModel chatModel = ...
ToolCallingManager toolCallingManager = ToolCallingManager.builder().build();

ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(new CustomerTools())
    .internalToolExecutionEnabled(false)
    .build();
Prompt prompt = new Prompt("Расскажите больше о клиенте с ID 42", chatOptions);

ChatResponse chatResponse = chatModel.call(prompt);

while (chatResponse.hasToolCalls()) {
    ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, chatResponse);

    prompt = new Prompt(toolExecutionResult.conversationHistory(), chatOptions);

    chatResponse = chatModel.call(prompt);
}

System.out.println(chatResponse.getResult().getOutput().getText());
```

> **Примечание:** При выборе подхода с управляемым пользователем выполнением инструмента мы рекомендуем использовать `ToolCallingManager` для управления операциями вызова инструмента. Таким образом, вы сможете воспользоваться встроенной поддержкой, предоставляемой Spring AI для выполнения инструмента. Однако ничто не мешает вам реализовать собственную логику выполнения инструмента.

Следующий пример демонстрирует минимальную реализацию подхода с управляемым пользователем выполнением инструмента в сочетании с использованием API `ChatMemory`:

```java
ToolCallingManager toolCallingManager = DefaultToolCallingManager.builder().build();
ChatMemory chatMemory = MessageWindowChatMemory.builder().build();
String conversationId = UUID.randomUUID().toString();

ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(ToolCallbacks.from(new MathTools()))
    .internalToolExecutionEnabled(false)
    .build();
Prompt prompt = new Prompt(
        List.of(new SystemMessage("Вы полезный помощник."), new UserMessage("Сколько будет 6 * 8?")),
        chatOptions);
chatMemory.add(conversationId, prompt.getInstructions());

Prompt promptWithMemory = new Prompt(chatMemory.get(conversationId), chatOptions);
ChatResponse chatResponse = chatModel.call(promptWithMemory);
chatMemory.add(conversationId, chatResponse.getResult().getOutput());

while (chatResponse.hasToolCalls()) {
    ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(promptWithMemory,
            chatResponse);
    chatMemory.add(conversationId, toolExecutionResult.conversationHistory()
        .get(toolExecutionResult.conversationHistory().size() - 1));
    promptWithMemory = new Prompt(chatMemory.get(conversationId), chatOptions);
    chatResponse = chatModel.call(promptWithMemory);
    chatMemory.add(conversationId, chatResponse.getResult().getOutput());
}

UserMessage newUserMessage = new UserMessage("Что я спрашивал вас ранее?");
chatMemory.add(conversationId, newUserMessage);

ChatResponse newResponse = chatModel.call(new Prompt(chatMemory.get(conversationId)));
```

### Обработка ИсключенийКогда вызов инструмента завершается неудачей, исключение передается как `ToolExecutionException`, которое можно перехватить для обработки ошибки. 
`ToolExecutionExceptionProcessor` можно использовать для обработки `ToolExecutionException` с двумя результатами: либо создание сообщения об ошибке, которое будет отправлено обратно в модель ИИ, либо выбрасывание исключения для обработки вызывающей стороной.

```java
@FunctionalInterface
public interface ToolExecutionExceptionProcessor {

	/**
	 * Преобразовать исключение, выброшенное инструментом, в строку, которая может быть отправлена обратно в ИИ
	 * модель, или выбросить исключение для обработки вызывающей стороной.
	 */
	String process(ToolExecutionException exception);

}
```

Если вы используете любой из Spring AI Spring Boot Starters, `DefaultToolExecutionExceptionProcessor` является автоматически настроенной реализацией интерфейса `ToolExecutionExceptionProcessor`. По умолчанию сообщение об ошибке `RuntimeException` отправляется обратно в модель, в то время как проверяемые исключения и ошибки (например, `IOException`, `OutOfMemoryError`) всегда выбрасываются. Конструктор `DefaultToolExecutionExceptionProcessor` позволяет установить атрибут `alwaysThrow` в `true` или `false`. Если `true`, исключение будет выброшено вместо отправки сообщения об ошибке обратно в модель.

Вы можете использовать свойство ``spring.ai.tools.throw-exception-on-error` для управления поведением бина `DefaultToolExecutionExceptionProcessor`:

| Свойство | Описание | По умолчанию |
| --- | --- | --- |

| `spring.ai.tools.throw-exception-on-error` | Если `true`, ошибки вызова инструмента выбрасываются как исключения для обработки вызывающей стороной. Если `false`, ошибки преобразуются в сообщения и отправляются обратно в модель ИИ, позволяя ей обрабатывать и реагировать на ошибку. | `false` |
| --- | --- | --- |


```java
@Bean
ToolExecutionExceptionProcessor toolExecutionExceptionProcessor() {
    return new DefaultToolExecutionExceptionProcessor(true);
}
```

> **Примечание:** Если вы определили свою собственную реализацию `ToolCallback`, убедитесь, что вы выбрасываете `ToolExecutionException`, когда происходит ошибка в рамках логики выполнения инструмента в методе `call()`.

`ToolExecutionExceptionProcessor` используется внутренне по умолчанию `ToolCallingManager` (`DefaultToolCallingManager`) для обработки исключений во время выполнения инструмента. См. xref:_tool_execution[] для получения дополнительной информации о жизненном цикле выполнения инструмента.

## Разрешение инструментаОсновной подход к передаче инструментов модели заключается в предоставлении `ToolCallback`(ов) при вызове `ChatClient` или `ChatModel`, используя одну из стратегий, описанных в xref:_methods_as_tools[] и xref:_functions_as_tools[].

Однако Spring AI также поддерживает динамическое разрешение инструментов во время выполнения с использованием интерфейса `ToolCallbackResolver`.

```java
public interface ToolCallbackResolver {

	/**
	 * Разрешить {@link ToolCallback} для данного имени инструмента.
	 */
	@Nullable
	ToolCallback resolve(String toolName);

}
```

При использовании этого подхода:

- На стороне клиента вы предоставляете имена инструментов `ChatClient` или `ChatModel` вместо `ToolCallback`(ов).
- На стороне сервера реализация `ToolCallbackResolver` отвечает за разрешение имен инструментов в соответствующие экземпляры `ToolCallback`.

По умолчанию Spring AI полагается на `DelegatingToolCallbackResolver`, который делегирует разрешение инструментов списку экземпляров `ToolCallbackResolver`:

- `SpringBeanToolCallbackResolver` разрешает инструменты из Spring-бинов типа `Function`, `Supplier`, `Consumer` или `BiFunction`. См. xref:_dynamic_specification_bean[] для получения дополнительных сведений.
- `StaticToolCallbackResolver` разрешает инструменты из статического списка экземпляров `ToolCallback`. При использовании автоконфигурации Spring Boot этот резолвер автоматически настраивается со всеми бинами типа `ToolCallback`, определенными в контексте приложения.

Если вы полагаетесь на автоконфигурацию Spring Boot, вы можете настроить логику разрешения, предоставив пользовательский бин `ToolCallbackResolver`.

```java
@Bean
ToolCallbackResolver toolCallbackResolver(List<FunctionCallback> toolCallbacks) {
    StaticToolCallbackResolver staticToolCallbackResolver = new StaticToolCallbackResolver(toolCallbacks);
    return new DelegatingToolCallbackResolver(List.of(staticToolCallbackResolver));
}
```

`ToolCallbackResolver` используется внутренне `ToolCallingManager` для динамического разрешения инструментов во время выполнения, поддерживая как xref:_framework_controlled_tool_execution[], так и xref:_user_controlled_tool_execution[].

## Увеличение аргументов инструмента

Spring AI предоставляет утилиту для **динамического увеличения схем ввода инструментов** с дополнительными аргументами. Это позволяет захватывать дополнительную информацию от модели — такую как рассуждения или метаданные — без изменения основной реализации инструмента.

Распространенные случаи использования включают:

- **Внутренние размышления/рассуждения**: Захват пошаговых рассуждений модели перед выполнением инструмента
- **Улучшение памяти**: Извлечение инсайтов для хранения в долгосрочной памяти
- **Аналитика и отслеживание**: Сбор метаданных, намерений пользователя или паттернов использования
- **Координация многопользовательских агентов**: Передача идентификаторов агентов или сигналов координации

### Быстрый старт

**Определите увеличенные аргументы** как Java Record:

```java
public record AgentThinking(
    @ToolParam(description = "Ваши рассуждения о вызове этого инструмента", required = true)
    String innerThought,

    @ToolParam(description = "Уровень уверенности (низкий, средний, высокий)", required = false)
    String confidence
) {}
```

**Оберните ваш инструмент** с помощью `AugmentedToolCallbackProvider`:

```java
AugmentedToolCallbackProvider<AgentThinking> provider = AugmentedToolCallbackProvider
    .<AgentThinking>builder()
    .toolObject(new MyTools())  // Ваш класс с аннотацией @Tool
    .argumentType(AgentThinking.class)
    .argumentConsumer(event -> {
        AgentThinking thinking = event.arguments();
        log.info("Инструмент: {} | Рассуждения: {}", event.toolDefinition().name(), thinking.innerThought());
    })
    .removeExtraArgumentsAfterProcessing(true)
    .build();
```

**Используйте с ChatClient**:

```java
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultToolCallbacks(provider)
    .build();
```

LLM видит увеличенную схему с вашими дополнительными полями. Ваш потребитель получает запись `AgentThinking`, в то время как оригинальный инструмент получает только ожидаемые аргументы.

### Основные компоненты- `AugmentedToolCallbackProvider<T>` - Оборачивает объекты инструментов или провайдеров, дополняя все инструменты указанным типом Record
- `AugmentedToolCallback<T>` - Оборачивает отдельные экземпляры `ToolCallback`
- `AugmentedArgumentEvent<T>` - Содержит `toolDefinition()`, `rawInput()` и `arguments()` для потребителей
- `ToolInputSchemaAugmenter` - Утилита низкого уровня для манипуляции схемами

### Конфигурация

Опция `removeExtraArgumentsAfterProcessing` управляет тем, передаются ли дополненные аргументы оригинальному инструменту:

- `true` (по умолчанию) - Удалить дополненные аргументы перед вызовом инструмента
- `false` - Сохранить дополненные аргументы во входных данных (если инструмент может игнорировать дополнительные поля)

## Наблюдаемость

Вызов инструмента включает поддержку наблюдаемости с помощью spring.ai.tool, которая измеряет время выполнения и передает информацию о трассировке. См. xref:observability/index.adoc#_tool_calling[Наблюдаемость вызова инструмента].

При желании Spring AI может экспортировать аргументы вызова инструмента и результаты в качестве атрибутов спана, отключенных по умолчанию по соображениям конфиденциальности. Подробности: xref:observability/index.adoc#_tool_call_arguments_and_result_data[Аргументы вызова инструмента и данные результатов].

### Логирование

Все основные операции функций вызова инструмента регистрируются на уровне `DEBUG`. Вы можете включить логирование, установив уровень логирования на `DEBUG` для пакета `org.springframework.ai`.
