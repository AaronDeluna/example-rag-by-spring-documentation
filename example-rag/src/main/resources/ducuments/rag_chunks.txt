API рекомендаций Spring.
Теперь мы можем изучить, как Spring AOP обрабатывает советы.
Жизненный цикл рекомендаций.
Каждый совет — это компонент Spring.
Экземпляр совета может быть общим для всех рекомендуемых объектов или быть уникальным для каждого рекомендуемого объекта.
Это соответствует классу или консультации по каждому экземпляру.
Жизненный цикл рекомендаций.
Чаще всего используются индивидуальные консультации.
Подходит для общих советов, таких как консультанты по сделкам.
Они не зависят от состояния проксируемого объекта и не добавляют новые. государство.
Они просто действуют в соответствии с методом и аргументами.
Жизненный цикл рекомендаций.
Советы по каждому экземпляру подходят для ознакомления и поддержки миксинов.
В этом случае совет добавляет состояние к проксируемому объекту.
Жизненный цикл рекомендаций.
Вы можете использовать сочетание общих и индивидуальных рекомендаций в одном прокси-сервере AOP.
Типы рекомендаций Spring.
Spring предоставляет несколько типов советов и может быть расширен для поддержки. произвольные типы советов.
В этом разделе описаны основные понятия и стандартные типы советов.
Перехват вокруг советов.
Самый фундаментальный тип совета в Spring — это _перехват вокруг совета_.
Перехват вокруг советов.
Spring совместим с интерфейсом AOP Alliance для рекомендаций, использующих метод. перехват.
Поэтому классы, реализующие рекомендации, должны реализовывать следующий интерфейс MethodInterceptor из пакета org.aopalliance.intercept:
	public interface MethodInterceptor extends Interceptor {
		Object invoke(MethodInvocation invocation) throws Throwable;
Перехват вокруг советов.

Аргумент `MethodInvoke` метода `invoke()` раскрывает используемый метод. вызываемый, целевую точку соединения, прокси-сервер AOP и аргументы метода.
Метод `invoke()` должен возвращать результат вызова: обычно возвращаемое значение точка соединения.
Java
	public class DebugInterceptor implements MethodInterceptor {
		public Object invoke(MethodInvocation invocation) throws Throwable {
			System.out.println("Before: invocation=[" + invocation + "]");
			Object result = invocation.proceed();
			System.out.println("Invocation returned");
			return result;
	class DebugInterceptor : MethodInterceptor {
В следующем примере показана простая реализация MethodInterceptor:.
Обратите внимание на вызов метода proceed() метода MethodInvocacy.
Это происходит вниз по цепочка перехватчиков к точке соединения.
Большинство перехватчиков вызывают этот метод и вернуть его возвращаемое значение.
Однако `MethodInterceptor`, как и любой другой совет, может верните другое значение или создайте исключение, а не вызывайте метод continue.
Однако не стоит этого делать без уважительной причины.
В следующем примере показана простая реализация MethodInterceptor:.
ПРИМЕЧАНИЕ.
Реализации MethodInterceptor обеспечивают совместимость с другими AOP, совместимыми с AOP Alliance. реализации.
Другие типы советов, обсуждаемые в оставшейся части этого раздела. реализовать общие концепции АОП, но специфичным для Spring способом.

Хотя есть преимущество при использовании наиболее конкретного типа совета придерживайтесь `MethodInterceptor` вокруг совета, если вы, вероятно, захотите запустить этот аспект в другой среде АОП.
Обратите внимание, что точечные разрезы в настоящее время несовместимы между собой, и Альянс АОП не в настоящее время определяют интерфейсы pointcut.
Перед советом.
Более простой тип совета — это «перед советом».
Для этого не требуется `MethodInvocacy` объект, поскольку он вызывается только перед входом в метод.
Перед советом.
Основное преимущество совета before заключается в том, что нет необходимости вызывать `proceed()`. метод и, следовательно, отсутствие возможности случайно не пройти вниз по цепочка перехватчиков.
	public interface MethodBeforeAdvice extends BeforeAdvice {
		void before(Method m, Object[] args, Object target) throws Throwable;
В следующем листинге показан интерфейс MethodBeforeAdvice:.
Обратите внимание, что тип возвращаемого значения — void.
Прежде чем совет может вставить пользовательское поведение перед объединением точка запускается, но не может изменить возвращаемое значение.
Если совет перед выдает исключение, оно останавливает дальнейшее выполнение цепочки перехватчиков.
Исключение распространяется обратно по цепочке перехватчиков.
Если флажок снят или в подписи вызванный метод, он передается непосредственно клиенту.
В противном случае это завернутый в непроверенное исключение прокси-сервером AOP.
В следующем листинге показан интерфейс MethodBeforeAdvice:.
В следующем примере показан совет before в Spring, который подсчитывает все вызовы методов:
Java
	public class CountingBeforeAdvice implements MethodBeforeAdvice {

private int count;
		public void before(Method m, Object[] args, Object target) throws Throwable {
			++count;
		public int getCount() {
			return count;
	class CountingBeforeAdvice : MethodBeforeAdvice {
В следующем листинге показан интерфейс MethodBeforeAdvice:.
СОВЕТ: Совет Before можно использовать с любым точечным вырезом.
Бросает совет. _Совет по выбрасыванию_ вызывается после возврата точки соединения, если точка соединения выдала исключение.
Весна предлагает типизированные советы.
Обратите внимание, что это означает, что Интерфейс `org.springframework.aop.ThrowsAdvice` не содержит никаких методов.
Это интерфейс маркера, определяющий, что данный объект реализует один или несколько типизированных бросков методы консультирования.
Они должны быть в следующей форме:
	afterThrowing([Метод, аргументы, цель], subclassOfThrowable)
Бросает совет.
Требуется только последний аргумент.
Сигнатуры метода могут иметь одну или четыре аргументы, в зависимости от того, заинтересован ли в методе совет и аргументы.
В следующих двух листингах показаны классы, являющиеся примерами советов по броскам.
Java
	public class RemoteThrowsAdvice implements ThrowsAdvice {
		public void afterThrowing(RemoteException ex) throws Throwable {
			// Сделайте что-нибудь с удаленным исключением
	class RemoteThrowsAdvice : ThrowsAdvice {
Следующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.

В отличие от предыдущего совета, в следующем примере объявляются четыре аргумента, поэтому он имеет доступ к вызванному методу, аргументам метода и целевому объекту.
Следующий совет вызывается, если выдается `ServletException`:
Java
	public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {
		public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
			// Сделайте что-нибудь со всеми аргументами
	class ServletThrowsAdviceWithArguments : ThrowsAdvice {
Следующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.
Последний пример иллюстрирует, как эти два метода можно использовать в одном классе. который обрабатывает как RemoteException, так и ServletException.
Совет по любому количеству бросков методы могут быть объединены в одном классе.
В следующем листинге показан последний пример:
Java
	public static class CombinedThrowsAdvice implements ThrowsAdvice {
		public void afterThrowing(RemoteException ex) throws Throwable {
			// Сделайте что-нибудь с удаленным исключением
		public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
			// Сделайте что-нибудь со всеми аргументами
	class CombinedThrowsAdvice : ThrowsAdvice {
Следующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.
ПРИМЕЧАНИЕ.
Если метод throws-advice сам генерирует исключение, он переопределяет исходное исключение (то есть оно изменяет исключение, выданное пользователю).
Наиважнейшее значение исключением обычно является RuntimeException, совместимое с любым методом. подпись.

Однако если метод throws-advice выдает проверенное исключение, он должен соответствовать объявленным исключениям целевого метода и, следовательно, в некоторой степени в сочетании с конкретными сигнатурами целевого метода. _Не выбрасывать необъявленную галочку исключение, несовместимое с сигнатурой целевого метода!_
Следующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.
СОВЕТ: Совет по броскам можно использовать с любым ударом.
После возвращения совета. _после возврата совета_ в Spring должен реализовать Интерфейс `org.springframework.aop.AfterReturningAdvice`, который показан в следующем листинге:
	public interface AfterReturningAdvice extends Advice {
		void afterReturning (Объект returnValue, Метод m, Object[] args, Цель объекта)
				throws Throwable;
После возвращения совета.
Совет после возврата имеет доступ к возвращаемому значению (которое он не может изменить). вызванный метод, аргументы метода и цель.
После возвращения совета.
Следующий после возврата совет подсчитывает все успешные вызовы методов, которые не выброшенные исключения:
Java
	public class CountingAfterReturningAdvice implements AfterReturningAdvice {
		private int count;
		public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
				throws Throwable {
			++count;
		public int getCount() {
			return count;
	class CountingAfterReturningAdvice : AfterReturningAdvice {
После возвращения совета.
Этот совет не меняет путь выполнения.
Если он выдает исключение, это выбрасывает цепочку перехватчиков вместо возвращаемого значения.
После возвращения совета.

СОВЕТ: После возврата совет можно использовать с любым pointcut.
Введение Совет.
Spring рассматривает _рекомендации по внедрению_ как особый вид рекомендаций по перехвату.
Введение Совет.
Для введения требуются `IntroductionAdvisor` и `IntroductionInterceptor`, которые реализовать следующий интерфейс:
	public interface IntroductionInterceptor extends MethodInterceptor {
		boolean implementsInterface(Class intf);
Введение Совет.
Метод `invoke()`, унаследованный от интерфейса `MethodInterceptor` Альянса АОП, должен реализовать введение.
То есть, если вызванный метод находится на введенном интерфейс, за обработку вызова метода отвечает перехватчик введения. не может вызвать `proceed()`.
Введение Совет.
Совет по введению не может быть использован ни с каким поинткатом, поскольку он применяется только на занятии. а не метод, уровень.
Вы можете использовать вводный совет только с `IntroductionAdvisor`, который имеет следующие методы:
	public interface IntroductionAdvisor extends Advisor, IntroductionInfo {
		ClassFilter getClassFilter();
		void validateInterfaces() throws IllegalArgumentException;
	public interface IntroductionInfo {
		Class<?>[] getInterfaces();
Введение Совет.
Нет `MethodMatcher` и, следовательно, нет `Pointcut`, связанного с введением. совет.
Логична только фильтрация классов.
Введение Совет.
Метод getInterfaces() возвращает интерфейсы, представленные этим советником.
Введение Совет.
Метод validateInterfaces() используется внутренне, чтобы узнать, действительно ли представленные интерфейсы могут быть реализованы с помощью настроенного `IntroductionInterceptor`.
Введение Совет.

Рассмотрим пример из набора тестов Spring и предположим, что мы хотим введите следующий интерфейс для одного или нескольких объектов:
Java
	public interface Lockable {
		void lock();
		void unlock();
		boolean locked();
Введение Совет.
Это иллюстрирует миксин.
Мы хотим иметь возможность приводить рекомендуемые объекты к «Lockable», независимо от их типа и вызовов методов блокировки и разблокировки.
Если мы вызовем метод lock(), мы хочу, чтобы все методы установки выдавали `LockedException`.
Таким образом, мы можем добавить аспект, который предоставляет возможность делать объекты неизменяемыми, не зная об этом: хороший пример АОП.
Введение Совет.
Во-первых, нам нужен «IntroductionInterceptor», который сделает всю тяжелую работу.
В этом В этом случае мы расширяем `org.springframework.aop.support.DelegatingIntroductionInterceptor` класс удобства.
Мы могли бы реализовать «IntroductionInterceptor» напрямую, но используя `DelegatingIntroductionInterceptor` лучше всего подходит для большинства случаев.
Введение Совет.
DelegatingIntroductionInterceptor предназначен для делегирования введения в фактическая реализация внедренных интерфейсов, скрывающая использование перехвата сделать это.
Вы можете установить делегата для любого объекта, используя аргумент конструктора.
Делегат по умолчанию (когда используется конструктор без аргументов) — `this`.
Таким образом, в следующем примере делегатом является подкласс LockMixin от DelegatingIntroductionInterceptor.

Для делегата (по умолчанию самого себя) создается экземпляр DelegatingIntroductionInterceptor. ищет все интерфейсы, реализованные делегатом (кроме `IntroductionInterceptor`) и поддерживает введение против любого из них.
Подклассы, такие как `LockMixin`, могут вызывать `suppressInterface(Class intf)` метод для подавления интерфейсов, которые не должны быть раскрыты.
Однако, сколько бы интерфейсы, которые готов поддерживать `IntroductionInterceptor`, `IntroductionAdvisor` использовал элементы управления, какие интерфейсы фактически доступны.
Ан введенный интерфейс скрывает любую реализацию того же интерфейса целью.
Введение Совет.
Таким образом, LockMixin расширяет DelegatingIntroductionInterceptor и реализует Lockable. сам.
Суперкласс автоматически определяет, что Lockable может поддерживаться. введение, поэтому нам не нужно это указывать.
Мы можем ввести любое количество интерфейсы таким образом.
Введение Совет.
Обратите внимание на использование переменной экземпляра `locked`.
Это эффективно добавляет дополнительное состояние тому, что содержится в целевом объекте.
Java
	public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {
		private boolean locked;
		public void lock() {
			this.locked = true;
		public void unlock() {
			this.locked = false;
		public boolean locked() {
			return this.locked;
		public Object invoke(MethodInvocation invocation) throws Throwable {
			if (locked() && invocation.getMethod().getName().indexOf("set") == 0) {
				throw new LockedException();

return super.invoke(invocation);
	class LockMixin : DelegatingIntroductionInterceptor(), Lockable {
В следующем примере показан пример класса LockMixin:.
Часто вам не нужно переопределять метод invoke().
Реализация DelegatingIntroductionInterceptor (которая вызывает метод делегата, если метод вводится, в противном случае продолжается к точке соединения) обычно достаточно.
В данном случае нам нужно добавить проверку: ни один метод установки не может быть вызван. если в заблокированном режиме.
В следующем примере показан пример класса LockMixin:.
Требуемое введение должно лишь содержать четкую `LockMixin` и укажите введенные интерфейсы (в данном случае только «Запираемый»).
Более сложный пример может потребовать ссылки на введение. перехватчик (который будет определен как прототип).
В этом случае нет конфигурация, соответствующая LockMixin, поэтому мы создаем ее, используя new.
В следующем примере показан наш класс LockMixinAdvisor:
Java
	public class LockMixinAdvisor extends DefaultIntroductionAdvisor {
		public LockMixinAdvisor() {
			super(new LockMixin(), Lockable.class);
В следующем примере показан пример класса LockMixin:.
Применить этот советник можно очень просто, поскольку он не требует настройки. (Однако это невозможно использовать `IntroductionInterceptor` без `IntroductionAdvisor`.) Как обычно при ознакомлении, советник должен быть для каждого экземпляра, поскольку это состояние.
Нам нужен другой экземпляр LockMixinAdvisor, и, следовательно, `LockMixin`, для каждого рекомендуемого объекта.
Советник включает в себя часть советуемого объекта государство.

В следующем примере показан пример класса LockMixin:.
Мы можем применить этот советник программно, используя метод Advised.addAdvisor() или (рекомендуемый способ) в конфигурации XML, как и любой другой советник.
Все создание прокси варианты, обсуждаемые ниже, в том числе «автоматические создатели прокси», правильно обрабатывают представления. и миксины с сохранением состояния.

Манипулирование рекомендуемыми объектами.
Как бы вы ни создавали прокси-серверы AOP, вы можете манипулировать ими с помощью Интерфейс `org.springframework.aop.framework.Advised`.
К этому можно применить любой прокси-сервер AOP. интерфейс, независимо от того, какие другие интерфейсы он реализует.
Этот интерфейс включает в себя следующие методы:
Java
	Advisor[] getAdvisors();
	void addAdvice(Advice advice) throws AopConfigException;
	void addAdvice(int pos, Advice advice) throws AopConfigException;
	void addAdvisor(Advisor advisor) throws AopConfigException;
	void addAdvisor(int pos, Advisor advisor) throws AopConfigException;
	int indexOf(Advisor advisor);
	boolean removeAdvisor(Advisor advisor) throws AopConfigException;
	void removeAdvisor(int index) throws AopConfigException;
	boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;
	boolean isFrozen();
Манипулирование рекомендуемыми объектами.
Метод getAdvisors() возвращает советника для каждого советника, перехватчика или другой тип совета, добавленный на заводе.
Если вы добавили «Советника», Возвращаемый советник по этому индексу — это добавленный вами объект.
Если вы добавили перехватчик или другой тип совета, Spring завернул его в советник с pointcut, который всегда возвращает true.
Таким образом, если вы добавили «MethodInterceptor», советник для этого индекса возвращается `DefaultPointcutAdvisor`, который возвращает ваш `MethodInterceptor` и pointcut, соответствующий всем классам и методам.
Манипулирование рекомендуемыми объектами.

Методы addAdvisor() можно использовать для добавления любого советника.
Обычно советник, держащий Pointcut и совет — это универсальный `DefaultPointcutAdvisor`, который вы можете использовать с любые советы или замечания (но не для ознакомления).
Манипулирование рекомендуемыми объектами.
По умолчанию можно добавлять или удалять советников или перехватчиков даже после прокси-сервера. был создан.
Единственное ограничение – невозможно добавить или удалить советник по внедрению, так как существующие прокси с завода не показывают интерфейс изменить. (Чтобы избежать этой проблемы, вы можете получить новый прокси-сервер с завода.)
Манипулирование рекомендуемыми объектами.
В следующем примере показано приведение прокси-сервера AOP к интерфейсу Advised, а также проверка и манипулируя его советом:
Java
	Advised advised = (Advised) myObject;
	Advisor[] advisors = advised.getAdvisors();
	int oldAdvisorCount = advisors.length;
	System.out.println(oldAdvisorCount + " advisors");
	// Добавляем совет типа перехватчика без точечного выреза
	// Будет соответствовать всем прокси-методам
	// Можно использовать для перехватчиков до, после возвращения или давать советы.
	advised.addAdvice(new DebugInterceptor());
	// Добавьте выборочный совет с помощью pointcut
	advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));
	assertEquals("Added two advisors", oldAdvisorCount + 2, advised.getAdvisors().length);
	// Добавляем совет типа перехватчика без точечного выреза

// Будет соответствовать всем прокси-методам
	// Можно использовать для перехватчиков до, после возвращения или давать советы.
	advised.addAdvice(DebugInterceptor())
	// Добавьте выборочный совет с помощью pointcut
	advised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice))
	assertEquals("Added two advisors", oldAdvisorCount + 2, advised.advisors.size)
Манипулирование рекомендуемыми объектами.
ПРИМЕЧАНИЕ.
Сомнительно, целесообразно ли (без каламбура) изменять рекомендации по бизнес-объект в производстве, хотя, без сомнения, существуют законные случаи использования.
Однако это может быть очень полезно при разработке (например, при тестировании).
У нас иногда бывает нашел очень полезным иметь возможность добавлять тестовый код в виде перехватчика или другого совет, проникая внутрь вызова метода, который мы хотим протестировать. (Например, совет может войти в транзакцию, созданную для этого метода, возможно, чтобы запустить SQL и проверить это база данных была правильно обновлена, прежде чем пометить транзакцию для отката.)
Манипулирование рекомендуемыми объектами.
В зависимости от того, как вы создали прокси, вы обычно можете установить флаг «заморозки».
В этом В этом случае метод `Advised` `isFrozen()` возвращает `true`, и любые попытки изменить рекомендации по добавлению или удалению приводят к возникновению исключения AopConfigException.
Способность заморозить состояние советуемого объекта полезно в некоторых случаях (например, для предотвратить вызывающий код, удалив перехватчик безопасности).

API советника Spring.
В Spring советник — это аспект, который содержит только один объект совета, связанный с с выражением pointcut.
API советника Spring.
За исключением особого случая знакомств, любой советник может быть использован с любым советом. `org.springframework.aop.support.DefaultPointcutAdvisor` является наиболее часто используемым. класс советника.
Его можно использовать с MethodInterceptor, BeforeAdvice или `ThrowsAdvice`.
API советника Spring.
В Spring можно смешивать типы советников и советов в одном прокси-сервере AOP.
Для Например, вы можете использовать перехват вокруг советов, выбрасываний советов и перед советом в одна конфигурация прокси.
Spring автоматически создает необходимый перехватчик цепь.

Совет контроллера.
Обычно применяются методы `@ExceptionHandler`, `@InitBinder` и `@ModelAttribute`. внутри класса `@Controller` (или иерархии классов), в котором они объявлены.
Если ты хотите, чтобы такие методы применялись более глобально (на всех контроллерах), вы можете объявить их в класс, аннотированный `@ControllerAdvice` или `@RestControllerAdvice`.
Совет контроллера. `@ControllerAdvice` имеет аннотацию `@Component`, что означает, что такие классы могут быть зарегистрировано как bean-компоненты Spring через сканирование компонентов. `@RestControllerAdvice` — это составленная аннотация, которая аннотирована как с `@ControllerAdvice`, так и с `@ResponseBody`, что по сути означает Методы `@ExceptionHandler` отображаются в теле ответа посредством преобразования сообщения. (по сравнению с разрешением просмотра или рендерингом шаблона).
Совет контроллера.
При запуске классы инфраструктуры для `@RequestMapping` и `@ExceptionHandler` методы обнаруживают bean-компоненты Spring, помеченные `@ControllerAdvice`, а затем применяют их методы во время выполнения.
Глобальные методы `@ExceptionHandler` (из `@ControllerAdvice`) применил _after_ локальные (из `@Controller`).
Напротив, глобальный `@ModelAttribute` и методы `@InitBinder` применяются _раньше_ локальных.
Совет контроллера.

По умолчанию методы @ControllerAdvice применяются к каждому запросу (то есть ко всем контроллерам). но вы можете сузить это до подмножества контроллеров, используя атрибуты в аннотация, как показано в следующем примере:
Java
	// Нацеливаемся на все контроллеры, помеченные @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class ExampleAdvice1 {}
	// Нацеливаемся на все контроллеры в определенных пакетах
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}
	// Назначаем все контроллеры, которые можно назначить определенным классам
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class ExampleAdvice3 {}
	// Нацеливаемся на все контроллеры в определенных пакетах
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}
Совет контроллера.
Селекторы в предыдущем примере оцениваются во время выполнения и могут отрицательно повлиять производительность при интенсивном использовании.
См. {spring-framework-api}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`] javadoc для более подробной информации.

Исключения.
Классы `@Controller` и @ControllerAdvice могут иметь Методы `@ExceptionHandler` для обработки исключений из методов контроллера.
Следующие пример включает такой метод-обработчик: См. пример кода в исходном документе.
Исключения.
Исключение может соответствовать распространяемому исключению верхнего уровня (то есть прямому выдается `IOException`) или против непосредственной причины внутри оболочки верхнего уровня. исключение (например, IOException, завернутое в IllegalStateException).
Исключения.
Для сопоставления типов исключений желательно объявить целевое исключение как аргумент метода. как показано в предыдущем примере.
Альтернативно, объявление аннотации может сузить типы исключений для соответствия.
Обычно мы рекомендуем указывать как можно более конкретно подпись аргумента и объявить сопоставления основных корневых исключений на `@ControllerAdvice` имеет приоритет в соответствующем порядке.
Подробности см. в раздел MVC.
Исключения.
ПРИМЕЧАНИЕ.
Метод @ExceptionHandler в WebFlux поддерживает те же аргументы метода и возвращаемые значения как метод @RequestMapping, за исключением тела запроса. и аргументы метода, связанные с `@ModelAttribute`.
Исключения.
Поддержка методов @ExceptionHandler в Spring WebFlux обеспечивается HandlerAdapter для методов @RequestMapping.
См. ссылку:web/webflux/dispatcher-handler.adoc[`DispatcherHandler`] для более подробной информации.
Сопоставление типов носителей.
Помимо типов исключений, методы @ExceptionHandler также могут объявлять производимые типы мультимедиа.

Это позволяет уточнить ответы об ошибках в зависимости от типов мультимедиа, запрашиваемых HTTP-клиентами, обычно в заголовке HTTP-запроса «Принять».
Сопоставление типов носителей.
Приложения могут объявлять типы воспроизводимых носителей непосредственно в аннотациях для одного и того же типа исключения: См. пример кода в исходном документе.
Сопоставление типов носителей.
Здесь методы обрабатывают один и тот же тип исключения, но не будут отклонены как дубликаты.
Вместо этого клиенты API, запрашивающие «application/json», получат ошибку JSON, а браузеры получат представление об ошибке HTML.
Каждая аннотация @ExceptionHandler может объявлять несколько типов воспроизводимых носителей: согласование контента на этапе обработки ошибок решит, какой тип контента будет использоваться.
Аргументы метода.
Методы @ExceptionHandler поддерживают одни и те же параметры. как методы @RequestMapping, за исключением того, что тело запроса могло уже быть использовано.
Возвращаемые значения.
Методы @ExceptionHandler поддерживают одни и те же значения. как методы @RequestMapping.

`DataBinder`.
Классы `@Controller` или `@ControllerAdvice` могут иметь методы `@InitBinder` для инициализировать экземпляры `WebDataBinder`, которые, в свою очередь, могут:
* Привязка параметров запроса к объекту модели.
* Преобразование значений запроса из строковых в типы свойств объекта.
* Свойства объекта модели форматируются как строки при рендеринге HTML-форм.
`DataBinder`.
В @Controller настройки DataBinder применяются локально внутри контроллера. или даже к определенному атрибуту модели, на который ссылается имя в аннотации.
В @ControllerAdvice настройки могут применяться ко всем контроллерам или к их подмножеству.
`DataBinder`.
Вы можете зарегистрировать компоненты PropertyEditor, Converter и Formatter в `DataBinder` для преобразования типов.
Альтернативно, вы можете использовать Компоненты Converter и Formatter в глобальной общей службе FormattingConversionService.
Java
	@Controller
	public class FormController {
		@InitBinder // <1>
		public void initBinder(WebDataBinder binder) {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
`DataBinder`. <1> Использование аннотации `@InitBinder`.
	@Controller
	class FormController {
`DataBinder`. <1> Использование аннотации `@InitBinder`.
`DataBinder`.

Альтернативно, при использовании установки на основе «Форматтера» через общий `FormattingConversionService`, вы можете повторно использовать тот же подход и зарегистрировать экземпляры `Formatter`, специфичные для контроллера, как показано в следующем примере:
Java
	@Controller
	public class FormController {
		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); <1>
`DataBinder`. <1> Добавление специального средства форматирования (в данном случае DateFormatter).
	@Controller
	class FormController {
`DataBinder`. <1> Добавление специального средства форматирования (в данном случае DateFormatter).

Методы обработчика.
Методы-обработчики `@RequestMapping` имеют гибкую сигнатуру и могут выбирать из ряда поддерживаемые аргументы метода контроллера и возвращаемые значения.

* В ссылке:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[аргумент метода]
Вы можете использовать аннотацию @ModelAttribute:. в методах @RequestMapping для создания или доступа к объекту из модели и его привязки. на запрос через `WebDataBinder`.
* В качестве аннотации на уровне метода в классах `@Controller` или `@ControllerAdvice`, помогая
Вы можете использовать аннотацию @ModelAttribute:. для инициализации модели перед вызовом любого метода @RequestMapping.
* В методе @RequestMapping для пометки возвращаемого значения как атрибута модели.
Вы можете использовать аннотацию @ModelAttribute:.
В этом разделе обсуждаются методы @ModelAttribute или второй элемент из предыдущего списка.
Контроллер может иметь любое количество методов @ModelAttribute.
Все подобные методы вызывается перед методами @RequestMapping в том же контроллере. `@ModelAttribute` метод также можно использовать для разных контроллеров через `@ControllerAdvice`.
См. раздел о
Вы можете использовать аннотацию @ModelAttribute:.
Методы `@ModelAttribute` имеют гибкие сигнатуры методов.
Они поддерживают многие из тех же аргументы как методы `@RequestMapping` (за исключением самого `@ModelAttribute` и всего остального относительно тела запроса).
Java
	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountRepository.findAccount(number));
		// добавить еще...
Java
	@ModelAttribute

public Account addAccount(@RequestParam String number) {
		return accountRepository.findAccount(number);
В следующем примере добавляется только один атрибут:.
ПРИМЕЧАНИЕ.
Если имя не указано явно, имя по умолчанию выбирается на основе типа. как описано в javadoc для {spring-framework-api}/core/Conventions.html[`Conventions`].
Вы всегда можете назначить явное имя, используя перегруженный метод addAttribute или через атрибут имени в `@ModelAttribute` (для возвращаемого значения).
В следующем примере добавляется только один атрибут:.
Spring WebFlux, в отличие от Spring MVC, явно поддерживает реактивные типы в модели. (например, Mono<Account> или io.reactivex.Single<Account>).
Такая асинхронная модель атрибуты могут быть прозрачно разрешены (и обновлена модель) до их фактических значений. во время вызова @RequestMapping при условии, что аргумент @ModelAttribute объявлен без оболочки, как показано в следующем примере:
Java
	@ModelAttribute
	public void addAccount(@RequestParam String number) {
		Mono<Account> accountMono = accountRepository.findAccount(number);
		model.addAttribute("account", accountMono);
	@PostMapping("/accounts")
	public String handle(@ModelAttribute Account account, BindingResult errors) {
В следующем примере добавляется только один атрибут:.

Кроме того, любые атрибуты модели, имеющие оболочку реактивного типа, разрешаются в свои фактические значения (и обновленная модель) непосредственно перед рендерингом просмотра.
В следующем примере добавляется только один атрибут:.
Вы также можете использовать @ModelAttribute в качестве аннотации на уровне метода для @RequestMapping. методы, и в этом случае возвращаемое значение метода @RequestMapping интерпретируется как Атрибут модели.
Обычно это не требуется, поскольку это поведение по умолчанию в HTML. контроллеры, если только возвращаемое значение не является строкой, которая в противном случае была бы интерпретирована в качестве имени представления. `@ModelAttribute` также может помочь настроить имя атрибута модели, как показано в следующем примере:
Java
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	public Account handle() {
		return account;

Сопоставление запросов.
В этом разделе обсуждается сопоставление запросов для аннотированных контроллеров.
`@RequestMapping`.
Аннотация `@RequestMapping` используется для сопоставления запросов с методами контроллеров.
Он имеет различные атрибуты для сопоставления по URL-адресу, методу HTTP, параметрам запроса, заголовкам и медиафайлам. типы.
Вы можете использовать его на уровне класса для выражения общих сопоставлений или на уровне метода. чтобы сузить список до конкретного сопоставления конечных точек.
* `@GetMapping`
* `@PostMapping`
* `@PutMapping`
* `@DeleteMapping`
* `@PatchMapping`
Существуют также варианты ярлыков `@RequestMapping`, специфичные для HTTP-метода:.
Предыдущие аннотации — это [Пользовательские аннотации], которые предоставляются. потому что, возможно, большинство методов контроллера должны быть сопоставлены с конкретным методом HTTP, а не с используя @RequestMapping, который по умолчанию соответствует всем методам HTTP.
В то же время, `@RequestMapping` по-прежнему необходим на уровне класса для выражения общих сопоставлений.
Существуют также варианты ярлыков `@RequestMapping`, специфичные для HTTP-метода:.
ПРИМЕЧАНИЕ. `@RequestMapping` нельзя использовать вместе с другими `@RequestMapping`. аннотации, объявленные для одного и того же элемента (класса, интерфейса или метода).
Если в одном и том же элементе обнаружено несколько аннотаций `@RequestMapping`, появится предупреждение. регистрироваться, и будет использоваться только первое сопоставление.

Это касается и составных Аннотации `@RequestMapping`, такие как `@GetMapping`, `@PostMapping` и т. д.
Java
	@RestController
	@RequestMapping("/persons")
	class PersonController {
		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
	@RestController
	@RequestMapping("/persons")
	class PersonController {
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.
Доступ к захваченным переменным URI можно получить с помощью `@PathVariable`, как показано в следующем примере:
Java
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.
Вы можете объявить переменные URI на уровне класса и метода, как показано в следующем примере:
Java
	@Controller
	@RequestMapping("/owners/{ownerId}") // <1>
	public class OwnerController {
		@GetMapping("/pets/{petId}") // <2>
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {

Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:. <1> Сопоставление URI на уровне класса. <2> Сопоставление URI на уровне метода.
	@Controller
	@RequestMapping("/owners/{ownerId}") // <1>
	class OwnerController {
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:. <1> Сопоставление URI на уровне класса. <2> Сопоставление URI на уровне метода.
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.
Переменные URI автоматически преобразуются в соответствующий тип или в исключение TypeMismatchException. поднят.
Простые типы («int», «long», «Date» и т. д.) поддерживаются по умолчанию, и вы можете зарегистрировать поддержку любого другого типа данных.
См.
Преобразование типов и DataBinder.
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.
Переменные URI могут быть названы явно (например, `@PathVariable("customId")`), но вы можете оставьте эту деталь, если имена одинаковы и вы компилируете свой код с параметрами `-parameters` флаг компилятора.
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.
Синтаксис `{*varName}` объявляет переменную URI, которая соответствует нулю или более оставшемуся пути. сегменты.

Например, `/resources/{*path}` соответствует всем файлам в `/resources/`, а Переменная `"path"` фиксирует полный путь в `/resources`.
Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.
Синтаксис `{varName:regex}` объявляет переменную URI с регулярным выражением, имеющим синтаксис: `{varName:regex}`.
Например, учитывая URL-адрес `/spring-web-3.0.5.jar`, следующий метод извлекает имя, версию и расширение файла:
Java
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
- Встроенные заполнители `${...}`, которые разрешаются при запуске через
Шаблоны путей URI также могут иметь:. `PropertySourcesPlaceholderConfigurer` для локального, системного, окружения и другие источники собственности.
Это полезно, например, для параметризации базового URL-адреса на основе внешняя конфигурация.
- Выражения SpEL `#{...}`.
Шаблоны путей URI также могут иметь:.
ПРИМЕЧАНИЕ.

Spring WebFlux использует PathPattern и PathPatternParser для поддержки сопоставления путей URI.
Оба класса расположены в Spring-Web и специально предназначены для использования с URL-адресами HTTP. пути в веб-приложениях, где во время выполнения сопоставляется большое количество шаблонов путей URI.
Шаблоны путей URI также могут иметь:.
Spring WebFlux не поддерживает сопоставление шаблонов суффиксов — в отличие от Spring MVC, где mapping such as `/person` also matches to `/person.{asterisk}`.
Для контента на основе URL согласования, при необходимости мы рекомендуем использовать параметр запроса, который проще и более явный и менее уязвимый для эксплойтов, основанных на URL-путях.
Сравнение шаблонов.
Если URL-адресу соответствует несколько шаблонов, их необходимо сравнить, чтобы найти наилучшее соответствие.
Это сделано с `PathPattern.SPECIFICITY_COMPARATOR`, который ищет более конкретные шаблоны.
Сравнение шаблонов.
Для каждого шаблона вычисляется оценка на основе количества переменных URI и подстановочных знаков. где переменная URI оценивается ниже, чем подстановочный знак.
Шаблон с меньшим общим баллом побеждает.
Если два паттерна имеют одинаковую оценку, выбирается более длинный.
Сравнение шаблонов.
Всеобъемлющие шаблоны (например, `**`, `{*varName}`) исключаются из оценки и всегда вместо этого отсортировано последним.
Если оба шаблона являются универсальными, выбирается более длинный.
Типы расходных материалов.

Вы можете сузить сопоставление запросов на основе «Типа контента» запроса, как показано в следующем примере:
Java
	@PostMapping(path = "/pets", consumes = "application/json")
	public void addPet(@RequestBody Pet pet) {
Типы расходных материалов.
Атрибут Consumers также поддерживает выражения отрицания — например, `!text/plain` означает любое тип контента, отличный от `text/plain`.
Типы расходных материалов.
Вы можете объявить общий атрибут «consumes» на уровне класса.
В отличие от большинства других запросов атрибуты сопоставления, однако при использовании на уровне класса атрибут «consumes» уровня метода переопределяет, а не расширяет объявление уровня класса.
Типы расходных материалов.
СОВЕТ: MediaType предоставляет константы для часто используемых типов мультимедиа, например `APPLICATION_JSON_VALUE` и `APPLICATION_XML_VALUE`.
Типы производимых носителей.
Вы можете сузить сопоставление запросов на основе заголовка запроса Accept и списка типы контента, которые создает метод контроллера, как показано в следующем примере:
Java
	@GetMapping(path = "/pets/{petId}", produces = "application/json")
	@ResponseBody
	public Pet getPet(@PathVariable String petId) {
Типы производимых носителей.
Тип носителя может указывать набор символов.
Поддерживаются отрицательные выражения, например: `!text/plain` означает любой тип контента, кроме `text/plain`.
Типы производимых носителей.

Вы можете объявить общий атрибут Produces на уровне класса.
В отличие от большинства других запросов атрибуты сопоставления, однако при использовании на уровне класса атрибут "производит" на уровне метода переопределяет, а не расширяет объявление уровня класса.
Типы производимых носителей.
СОВЕТ: MediaType предоставляет константы для часто используемых типов мультимедиа, например `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE`.
Параметры и заголовки.
Вы можете сузить сопоставления запросов на основе условий параметров запроса.
Вы можете протестировать наличие параметра запроса (`myParam`), его отсутствие (`!myParam`) или наличие конкретное значение (`myParam=myValue`).
В следующих примерах проверяется параметр со значением:
Java
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") // <1>
	public void findPet(@PathVariable String petId) {
Параметры и заголовки. <1> Убедитесь, что `myParam` равен `myValue`.
Параметры и заголовки.
Вы также можете использовать то же самое с условиями заголовка запроса, как показано в следующем примере:
Java
	@GetMapping(path = "/pets/{petId}", headers = "myHeader=myValue") // <1>
	public void findPet(@PathVariable String petId) {
Параметры и заголовки. <1> Убедитесь, что `myHeader` равен `myValue`.
Версия API.

Не существует стандартного способа указать версию API, поэтому при включении управления версиями API в файле WebFlux Config, который вам нужен чтобы указать, как разрешить версию.
Конфигурация WebFlux создает используется для сопоставления запросов.
Версия API.
После включения управления версиями API вы можете начать сопоставлять запросы с версиями.
Атрибут `@RequestMapping` `version` поддерживает следующее:
- Фиксированная версия ("1.2") — соответствует только данной версии.
- Базовая версия ("1.2+") — соответствует данной версии и выше.
- Нет значения – соответствует любой версии, но заменяется более конкретной версией.
Версия API.
Если несколько методов контроллера имеют версию, меньшую или равную версии запроса, рассматривается самая высокая из них и наиболее близкая к версии запроса, фактически заменяя все остальное.
Java
	@RestController
	@RequestMapping("/account/{id}")
	public class AccountController {
		@GetMapping // <1>
		public Account getAccount() {
		@GetMapping(version = "1.1") // <2>
		public Account getAccount1_1() {
		@GetMapping(version = "1.2+") // <3>
		public Account getAccount1_2() {
		@GetMapping(version = "1.5") // <4>
		public Account getAccount1_5() {

Чтобы проиллюстрировать это, рассмотрим следующие отображения:. <1> соответствует любой версии <2> соответствует версии 1.1 <3> соответствует версии 1.2 и выше <4> соответствует версии 1.5
- (1) соответствует любой версии
- (2) не соответствует
- (3) соответствует версии 1.2 и выше и *выбирается* как максимальное совпадение
- (4) выше и не соответствует
- (1) соответствует любой версии
- (2) не соответствует
- (3) соответствует версии 1.2 и выше
- (4) соответствует и *выбирается* как наибольшее совпадение
Для запроса с версией `"1.5"`:.
Запрос с версией «1.6» не имеет совпадения. (1) и (3) совпадают, но заменено (4), которое допускает только строгое совпадение и, следовательно, не соответствует.
В этом сценарии исключение NotAcceptableApiVersionException приводит к ответу 400.
Для запроса с версией `"1.5"`:.
Методы контроллера без версии предназначены для поддержки клиентов, созданных до была представлена версионная альтернатива.
Поэтому, даже несмотря на то, что неверсионный контроллер метод считается подходящим для любой версии, фактически ему присваивается самый низкий приоритет, и фактически заменяется любым альтернативным методом контроллера с версией.
Для запроса с версией `"1.5"`:.
ПРИМЕЧАНИЕ.

Вышеупомянутое предполагает, что версия запроса является иначе это потерпит неудачу.
Для запроса с версией `"1.5"`:.
См.
Версии API для получения более подробной информации об основных инфраструктура и поддержка управления версиями API.
ЗАГОЛОВОК HTTP, ОПЦИИ. `@GetMapping` и `@RequestMapping(method=HttpMethod.GET)` поддерживают HTTP HEAD transparently for request mapping purposes.
Методы контроллера не должны меняться.
Оболочка ответа, применяемая в серверном адаптере HttpHandler, обеспечивает Content-Length.
В заголовке установлено количество байтов, записанных без фактической записи в ответ.
ЗАГОЛОВОК HTTP, ОПЦИИ.
По умолчанию HTTP OPTIONS обрабатывается путем установки заголовка ответа «Allow» в список HTTP-параметров. методы, перечисленные во всех методах @RequestMapping с соответствующими шаблонами URL.
ЗАГОЛОВОК HTTP, ОПЦИИ.
Для `@RequestMapping` без объявлений метода HTTP заголовок `Allow` имеет значение `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`.
Методы контроллера всегда должны объявлять поддерживаемые методы HTTP (например, с помощью конкретных вариантов метода HTTP — `@GetMapping`, `@PostMapping` и другие).
ЗАГОЛОВОК HTTP, ОПЦИИ.
Вы можете явно сопоставить метод @RequestMapping с HTTP HEAD и HTTP OPTIONS, но это в обычном случае не требуется.
Пользовательские аннотации.
Spring WebFlux поддерживает использование составных аннотаций для сопоставления запросов.

Это аннотации, которые сами по себе метааннотированы с помощью `@RequestMapping` и создан для повторного объявления подмножества (или всего) `@RequestMapping` атрибуты с более узкой и конкретной целью.
Пользовательские аннотации. `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` и `@PatchMapping` примеры составленных аннотаций.
Они предусмотрены, потому что, возможно, большинство методы контроллера должны быть сопоставлены с конкретным методом HTTP, а не с использованием `@RequestMapping`, который по умолчанию соответствует всем методам HTTP.
Если вам нужен пример реализации составленная аннотация, посмотрите, как они объявляются.
Пользовательские аннотации.
ПРИМЕЧАНИЕ. `@RequestMapping` нельзя использовать вместе с другими `@RequestMapping`. аннотации, объявленные для одного и того же элемента (класса, интерфейса или метода).
Если в одном и том же элементе обнаружено несколько аннотаций `@RequestMapping`, появится предупреждение. регистрироваться, и будет использоваться только первое сопоставление.
Это касается и составных Аннотации `@RequestMapping`, такие как `@GetMapping`, `@PostMapping` и т. д.
Пользовательские аннотации.
Spring WebFlux также поддерживает пользовательские атрибуты сопоставления запросов с пользовательским сопоставлением запросов. логика.
Это более продвинутый вариант, требующий создания подклассов.
RequestMappingHandlerMapping и переопределение метода getCustomMethodCondition, где вы можете проверить пользовательский атрибут и вернуть свой собственный RequestCondition.
Явные регистрации.

Вы можете программно зарегистрировать методы Handler, которые можно использовать для динамических регистрации или в сложных случаях, например, разные экземпляры одного и того же обработчика под разными URL-адресами.
В следующем примере показано, как это сделать:
Java
	@Configuration
	public class MyConfig {
		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>
				throws NoSuchMethodException {
			RequestMappingInfo info = RequestMappingInfo
					.paths("/user/{id}").methods(RequestMethod.GET).build(); // <2>
			Method method = UserHandler.class.getMethod("getUser", Long.class); // <3>
			mapping.registerMapping(info, handler, method); // <4>
Явные регистрации. <1> Внедрить целевые обработчики и сопоставление обработчиков для контроллеров. <2> Подготовьте метаданные сопоставления запроса. <3> Получите метод-обработчик. <4> Добавьте регистрацию.
	@Configuration
	class MyConfig {
			mapping.registerMapping(info, handler, method) // <4>
Явные регистрации. <1> Внедрить целевые обработчики и сопоставление обработчиков для контроллеров. <2> Подготовьте метаданные сопоставления запроса. <3> Получите метод-обработчик. <4> Добавьте регистрацию.
`@HttpExchange`.

Хотя основная цель `@HttpExchange` — для HTTP-сервиса. интерфейс службы HTTP, в котором размещаются такие аннотации, не зависит от контракта. для использования клиента и сервера.
Помимо упрощения клиентского кода, есть еще случаи где интерфейс службы HTTP может быть удобным способом для серверов раскрыть свои API для клиентского доступа.
Это приводит к усилению связи между клиентом и сервером и часто не является хорошим выбором, особенно для общедоступных API, но может быть именно целью для внутреннего API.
Этот подход обычно используется в Spring Cloud, и именно поэтому `@HttpExchange` поддерживается как альтернатива `@RequestMapping` для серверной части. обработка в классах контроллера.
Java
	@HttpExchange("/persons")
	interface PersonService {
		@GetExchange("/{id}")
		Person getPerson(@PathVariable Long id);
		@PostExchange
		void add(@RequestBody Person person);
	@RestController
	class PersonController implements PersonService {
		public Person getPerson(@PathVariable Long id) {
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
	@HttpExchange("/persons")
	interface PersonService {
	@RestController
	class PersonController : PersonService {

Например:. `@HttpExchange` и `@RequestMapping` имеют различия. `@RequestMapping` может сопоставляться с любым количеством запросов по шаблонам путей, методам HTTP, и многое другое, в то время как `@HttpExchange` объявляет одну конечную точку с конкретным методом HTTP, путь и типы контента.
Например:.
Для параметров метода и возвращаемых значений, как правило, `@HttpExchange` поддерживает подмножество параметров метода, которое выполняет `@RequestMapping`.
Примечательно, что это исключает любые типы параметров, специфичные для серверной стороны.
Подробности смотрите в списке

Реакции на ошибки.
Общим требованием к службам REST является включение подробностей в текст ошибки. ответы.
Spring Framework поддерживает «Подробности проблем для HTTP API». спецификация, {rfc-site}/rfc9457.html[RFC 9457].
- `ProblemDetail` — представление подробностей проблемы RFC 9457; простой контейнер
Ниже приведены основные абстракции для этой поддержки:. как для стандартных полей, определенных в спецификации, так и для нестандартных.
- `ErrorResponse` — контракт для предоставления подробностей ответа об ошибке HTTP, включая HTTP.
Ниже приведены основные абстракции для этой поддержки:. статус, заголовки ответа и тело в формате RFC 9457; это позволяет исключениям инкапсулировать и раскрывать подробности того, как они сопоставляются с ответом HTTP.
Все Spring WebFlux исключения реализуют это.
- `ErrorResponseException` -- базовая реализация `ErrorResponse`, которую другие
Ниже приведены основные абстракции для этой поддержки:. можно использовать как удобный базовый класс.
- `ResponseEntityExceptionHandler` -- удобный базовый класс для
Ниже приведены основные абстракции для этой поддержки:. и любое `ErrorResponseException` и отображает ответ об ошибке с телом.
Рендеринг.
Вы можете вернуть «ProblemDetail» или «ErrorResponse» из любого «@ExceptionHandler» или из любой метод @RequestMapping для обработки ответа RFC 9457.
Это обрабатывается следующим образом:
- Свойство `status` `ProblemDetail` определяет статус HTTP.

- Свойство `instance` для `ProblemDetail` устанавливается на основе текущего URL-пути, если это не так.
Рендеринг. уже установлен.
- Конвертеры сообщений Jackson JSON и XML используют «application/problem+json» или
Рендеринг. «application/problem+xml» соответственно в качестве типов воспроизводимых носителей для «ProblemDetail». чтобы гарантировать, что им будет отдано предпочтение при обсуждении содержания.
Рендеринг.
Чтобы включить ответы RFC 9457 для исключений Spring WebFlux и для любых `ErrorResponseException`, расширьте `ResponseEntityExceptionHandler` и объявите его как имеет метод @ExceptionHandler, который обрабатывает любое исключение ErrorResponse, которое включает все встроенные веб-исключения.
Вы можете добавить больше методов обработки исключений и используйте защищенный метод для сопоставления любого исключения с «ProblemDetail».
Рендеринг.
Вы можете зарегистрировать перехватчики `ErrorResponse` через любой ответ RFC 9457 и предпримите какие-либо действия.
Нестандартные поля.
Вы можете расширить ответ RFC 9457 нестандартными полями одним из двух способов.
Нестандартные поля.
Во-первых, вставьте в «свойства» «Карту» «ProblemDetail».
При использовании Джексона библиотека, Spring Framework регистрирует `ProblemDetailJacksonMixin`, который обеспечивает это «Свойства» `Карта` разворачивается и отображается как свойства JSON верхнего уровня в ответ, и аналогично любое неизвестное свойство во время десериализации вставляется в эта `Карта`.
Нестандартные поля.
Вы также можете расширить «ProblemDetail», чтобы добавить специальные нестандартные свойства.

Конструктор копирования в «ProblemDetail» позволяет упростить создание подкласса. из существующего «ProblemDetail».
Это можно сделать централизованно, например, из `@ControllerAdvice`, например `ResponseEntityExceptionHandler`, который воссоздает `ProblemDetail` исключения в подкласс с дополнительными нестандартными полями.
Нестандартные поля.
СОВЕТ: В Spring Boot свойство Spring.webflux.problemdetails.enabled настраивается автоматически. `ResponseEntityExceptionHandler`, который обрабатывает встроенные исключения с подробностями проблемы.
В этом случае вы можете предпочесть создать еще один `@ControllerAdvice` вместо расширения `ResponseEntityExceptionHandler`, если вы хотите взять на себя обработку определенного встроенное исключение.
Вам необходимо убедиться, что ваш обработчик заказан раньше, чем тот, который настроенный Spring Boot, порядок которого равен 0.
Кастомизация и i18n.
Общепринятым требованием является настройка и интернационализация сведений об ошибках.
Также рекомендуется настроить детали проблемы для исключений Spring WebFlux. чтобы не раскрывать детали реализации.
В этом разделе описывается поддержка этого.
Кастомизация и i18n. `ErrorResponse` предоставляет коды сообщения для «типа», «заголовка» и «детали», а также Аргументы кода сообщения для поля «подробности». `ResponseEntityExceptionHandler` разрешает это через MessageSource и соответствующим образом обновляет соответствующие поля «ProblemDetail».
`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. `ErrorResponse` может предоставлять более одного кода сообщения, обычно с добавлением суффикса. к коду сообщения по умолчанию.

В таблице ниже перечислены коды сообщений и аргументы для Исключения Spring WebFlux:
`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. [cols="1,1,2", options="header"] |=== | Исключение | Код сообщения | Аргументы кода сообщения
`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `HandlerMethodValidationException` | (по умолчанию) | `+{0}+` выводит список всех ошибок проверки.
Коды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.
`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `MethodNotAllowedException` | (по умолчанию) | `+{0}+` текущий метод HTTP, `+{1}+` список поддерживаемых методов HTTP
`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `MissingRequestValueException` | (по умолчанию) | `+{0}+` метка значения (например, «заголовок запроса», «значение файла cookie»,...), `+{1}+` имя значения

`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `NotAcceptableStatusException` | (по умолчанию) | `+{0}+` список поддерживаемых типов мультимедиа
| `NotAcceptableStatusException` | (по умолчанию) + «.parseError». | `ServerErrorException` | (по умолчанию) | `+{0}+` причина сбоя, указанная конструктору класса
| `NotAcceptableStatusException` | (по умолчанию) + «.parseError». | `UnsupportedMediaTypeStatusException` | (по умолчанию) | `+{0}+` тип носителя, который не поддерживается, `+{1}+` список поддерживаемых типов мультимедиа
| `UnsatisfiedRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра. | `WebExchangeBindException` | (по умолчанию) | `+{0}+` список глобальных ошибок, `+{1}+` список ошибок полей.
Коды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.
| `UnsatisfiedRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра. | `NoResourceFoundException` | (по умолчанию) | `+{0}+` путь запроса (или его часть), используемый для поиска ресурса

| `UnsatisfiedRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра.
ПРИМЕЧАНИЕ.
В отличие от других исключений, аргументы сообщения для `WebExchangeBindException` и `HandlerMethodValidationException` основаны на списке Ошибки MessageSourceResolvable, которые также можно настроить с помощью пакет ресурсов.
См. для более подробной информации.
Обработка клиентов.
Клиентское приложение может перехватить исключение WebClientResponseException при использовании WebClient. или RestClientResponseException при использовании RestTemplate и используйте их `getResponseBodyAs` для декодирования тела ответа об ошибке в любой целевой тип, например `ProblemDetail` или подкласс `ProblemDetail`.

Валидация.
Spring WebFlux имеет встроенный Validation для Методы `@RequestMapping`, включая Проверка Java Bean.
Валидация может применяться на одном из двух уровней:
1. Проверка Java Bean применяется индивидуально к
Валидация. с аннотацией `@jakarta.validation.Valid` или `@Validated` Spring, если это командный объект, а не контейнер, такой как «Карта» или «Коллекция», он не имеют `Errors` или `BindingResult` сразу после сигнатуры метода и не имеют в противном случае потребуется проверка метода (см. далее). `WebExchangeBindException` — это исключение, возникающее при индивидуальной проверке параметра метода.
2. Проверка Java Bean применяется к методу, когда аннотации @Constraint, такие как
Валидация. `@Min`, `@NotBlank` и другие объявляются непосредственно в параметрах метода или в метод для возвращаемого значения, и он заменяет любую проверку, которая будет применяться в противном случае к параметру метода индивидуально, поскольку проверка метода охватывает оба ограничения параметров метода и вложенные ограничения через `@Valid`. `HandlerMethodValidationException` — это исключение, при котором применяется проверка. к методу.
Валидация.
Приложения должны обрабатывать как WebExchangeBindException, так и `HandlerMethodValidationException`, поскольку любое из них может быть вызвано в зависимости от контроллера. подпись метода.
Однако эти два исключения очень похожи и могут быть обрабатывается практически идентичным кодом.

Основное отличие состоит в том, что первый предназначен для одного объект, а последний — для списка параметров метода.
Валидация.
ПРИМЕЧАНИЕ. `@Valid` — это не аннотация ограничения, а скорее для вложенных ограничений внутри Объект.
Следовательно, `@Valid` сам по себе не приводит к проверке метода. `@NotNull` с другой стороны, это ограничение, и добавление его к параметру @Valid приводит к методу проверка.
В частности, для возможности обнуления вы также можете использовать флаг `required` `@RequestBody` или `@ModelAttribute`.
Валидация.
Проверка метода может использоваться в сочетании с методом «Errors» или «BindingResult». параметры.
Однако метод контроллера вызывается только в том случае, если включены все ошибки проверки. параметры метода с `Errors` сразу после них.
Если есть ошибки проверки на любой другой параметр метода, тогда возникает HandlerMethodValidationException.
Валидация.
Вы можете настроить «Валидатор» глобально через с помощью метода @InitBinder в `@Controller` или `@ControllerAdvice`.
Вы также можете использовать несколько валидаторов.
Валидация.
ПРИМЕЧАНИЕ.
Если контроллер имеет уровень класса @Validated, то через прокси-сервер АОП.
Чтобы воспользоваться встроенной поддержкой Spring MVC для проверка метода добавлена в Spring Framework 6.1, вам необходимо удалить уровень класса Аннотация `@Validated` от контроллера.
Валидация.

В разделе «Ответы на ошибки» представлена дополнительная информация. подробности о том, как `WebExchangeBindException` и `HandlerMethodValidationException` обрабатываются, а также то, как их рендеринг можно настроить с помощью MessageSource и пакеты ресурсов, специфичные для локали и языка.
Валидация.
Для дальнейшей обработки ошибок проверки метода вы можете расширить `ResponseEntityExceptionHandler` или используйте метод `@ExceptionHandler` в контроллере. или в `@ControllerAdvice` и напрямую обрабатывать `HandlerMethodValidationException`.
Исключение содержит список ParameterValidationResult, которые группируют ошибки проверки. по параметру метода.
Вы можете либо перебрать их, либо предоставить посетителю обратный вызов. методы по типу параметра метода контроллера:
Java
	HandlerMethodValidationException ex = ... ;
	ex.visitResults(new HandlerMethodValidationException.Visitor() {
		@Override
		public void requestHeader(RequestHeader requestHeader, ParameterValidationResult result) {
		@Override
		public void requestParam(@Nullable RequestParam requestParam, ParameterValidationResult result) {
		@Override
		public void modelAttribute(@Nullable ModelAttribute modelAttribute, ParameterErrors errors) {
		@Override
		public void other(ParameterValidationResult result) {

`@Контроллер`.
Вы можете определить bean-компоненты контроллера, используя стандартное определение bean-компонента Spring.
Стереотип @Controller обеспечивает автоматическое обнаружение и соответствует общей поддержке Spring. для обнаружения классов `@Component` в пути к классам и автоматической регистрации определений компонентов для них.
Он также действует как стереотип для аннотируемого класса, указывая на его роль как веб-компонент.
`@Контроллер`.
Чтобы включить автоматическое обнаружение таких bean-компонентов `@Controller`, вы можете добавить сканирование компонентов в вашей конфигурации Java, как показано в следующем примере:
Java
	@Configuration
	@ComponentScan("org.example.web") // <1>
	public class WebConfiguration {
`@Контроллер`. <1> Сканируйте пакет `org.example.web`.
	@Configuration
	@ComponentScan("org.example.web") // <1>
	class WebConfiguration {
`@Контроллер`. <1> Сканируйте пакет `org.example.web`.
`@Контроллер`. `@RestController` — это составная аннотация, которая мета-аннотации `@Controller` и `@ResponseBody`, обозначающие контроллер, чей каждый метод наследует аннотацию @ResponseBody уровня типа и, следовательно, записывает непосредственно в тело ответа, а не разрешение просмотра и рендеринг с помощью HTML-шаблона.
АОП-прокси.

В некоторых случаях вам может потребоваться дополнить контроллер прокси-сервером AOP во время выполнения.
Одним из примеров является то, что вы решили разместить аннотации @Transactional непосредственно на контроллер.
В этом случае, особенно для контроллеров, мы рекомендуем использование проксирования на основе классов.
Это автоматически происходит с такими аннотациями. непосредственно на контроллере.
АОП-прокси.
Если контроллер реализует интерфейс и нуждается в проксировании AOP, вам может потребоваться явно настроить проксирование на основе классов.
Например, с помощью `@EnableTransactionManagement` вы можете изменить на `@EnableTransactionManagement(proxyTargetClass = true)`, и с помощью `<tx:annotation-driven/>` вы можете изменить на `<tx:annotation-driven proxy-target-class="true"/>`.
АОП-прокси.
ПРИМЕЧАНИЕ.
Имейте в виду, что начиная с версии 6.0 при проксировании интерфейса Spring WebFlux больше не обнаруживает контроллеры, основанные исключительно на аннотации @RequestMapping на уровне типа в интерфейсе.
Пожалуйста, включите проксирование на основе классов, иначе интерфейс также должен иметь Аннотация `@Controller`.

Конфигурация контейнера на основе аннотаций.
Spring обеспечивает комплексную поддержку конфигурации на основе аннотаций, работая на метаданные в самом классе компонента, используя аннотации соответствующего класса, метод или объявление поля.
Как упоминалось в Spring использует BeanPostProcessors в сочетании с аннотациями для создания ядра IOC. контейнер знает о конкретных аннотациях.
Конфигурация контейнера на основе аннотаций.
Например, `@Autowired` аннотация предоставляет те же возможности, что описаны в с более детальным контролем и более широкой применимостью.
Кроме того, Spring предоставляет поддержка аннотаций JSR-250, таких как `@PostConstruct` и `@PreDestroy`, а также поддержка аннотаций JSR-330 (внедрение зависимостей для Java), содержащихся в пакет `jakarta.inject`, например `@Inject` и `@Named`.
Подробности об этих аннотациях можно найти в соответствующий раздел.
Конфигурация контейнера на основе аннотаций. [ПРИМЕЧАНИЕ] = Внедрение аннотаций выполняется до внедрения внешних свойств.
Таким образом, внешние конфигурация (например, свойства bean-компонента, указанные в XML) эффективно переопределяет аннотации для объектов недвижимости при использовании смешанных подходов.
Конфигурация контейнера на основе аннотаций.
Технически вы можете зарегистрировать постпроцессоры как отдельные определения компонентов, но они уже неявно зарегистрированы в AnnotationConfigApplicationContext.
Конфигурация контейнера на основе аннотаций.
В настройке Spring на основе XML вы можете включить следующий тег конфигурации, чтобы включить смешивание и сопоставление с конфигурацией на основе аннотаций:

<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<context:annotation-config/>
	</beans>
* {spring-framework-api}/context/annotation/ConfigurationClassPostProcessor.html[`ConfigurationClassPostProcessor`]
* {spring-framework-api}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`]
* {spring-framework-api}/context/annotation/CommonAnnotationBeanPostProcessor.html[`CommonAnnotationBeanPostProcessor`]
* {spring-framework-api}/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html[`PersistenceAnnotationBeanPostProcessor`]

* {spring-framework-api}/context/event/EventListenerMethodProcessor.html[`EventListenerMethodProcessor`]
Элемент `<context:annotation-config/>` неявно регистрирует следующие постпроцессоры:. [ПРИМЕЧАНИЕ] = `<context:annotation-config/>` ищет только аннотации к bean-компонентам в одном и том же контекст приложения, в котором он определен.
Это означает, что если вы поставите `<context:annotation-config/>` в `WebApplicationContext` для `DispatcherServlet`, он проверяет только bean-компоненты `@Autowired` в ваших контроллерах, а не в ваших службах.
См.

Использование `@Transactional`.
В дополнение к декларативному подходу к конфигурации транзакций на основе XML вы можете используйте подход, основанный на аннотациях.
Объявление семантики транзакции непосредственно в Java исходный код помещает объявления намного ближе к затронутому коду.
Существует не так много опасность ненужной связанности, поскольку код, предназначенный для транзакционного использования, В любом случае почти всегда развертывается таким образом.
Использование `@Transactional`.
ПРИМЕЧАНИЕ.
Стандартная аннотация `jakarta.transaction.Transactional` также поддерживается как замена собственной аннотации Spring.
Пожалуйста, обратитесь к документации JTA. для более подробной информации.
Использование `@Transactional`.
Простота использования, обеспечиваемая использованием аннотации @Transactional, является лучшей. иллюстрируется примером, который поясняется в следующем тексте.
Рассмотрим следующее определение класса:
Java
	// класс обслуживания, который мы хотим сделать транзакционным
	@Transactional
	public class DefaultFooService implements FooService {
		@Override
		public Foo getFoo(String fooName) {
		@Override
		public Foo getFoo(String fooName, String barName) {
		@Override
		public void insertFoo(Foo foo) {
		@Override
		public void updateFoo(Foo foo) {
	// класс обслуживания, который мы хотим сделать транзакционным
	@Transactional
	class DefaultFooService : FooService {
Использование `@Transactional`.
Используемая на уровне класса, как указано выше, аннотация указывает значение по умолчанию для всех методов. объявляющего класса (а также его подклассов).
Альтернативно, каждый метод может быть аннотировано индивидуально.

См. для получения более подробной информации о том, какие методы Spring считает транзакционными.
Обратите внимание, что уровень класса аннотация не применяется к классам-предкам вверх по иерархии классов; в таком сценарии, унаследованные методы необходимо локально переобъявить, чтобы участвовать в аннотация уровня подкласса.
Использование `@Transactional`.
Когда класс POJO, такой как приведенный выше, определяется как компонент в контексте Spring, вы можете сделать экземпляр компонента транзакционным через `@EnableTransactionManagement` аннотация в классе @Configuration.
См. {spring-framework-api}/transaction/annotation/EnableTransactionManagement.html[javadoc] для получения полной информации.
	<!-- from the file 'context.xml' -->
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans

https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<!-- this is the service object that we want to make transactional -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>
		<!-- enable the configuration of transactional behavior based on annotations -->
		<!-- a TransactionManager is still required -->
		<tx:annotation-driven transaction-manager="txManager"/> <1>
		<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<!-- (this dependency is defined somewhere else) -->
			<property name="dataSource" ref="dataSource"/>
		</bean>
		<!-- other <bean/> definitions here -->
	</beans>

В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. <1> Строка, которая делает экземпляр компонента транзакционным.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
СОВЕТ: Вы можете опустить атрибут `transaction-manager` в `<tx:annotation-driven/>`. тег, если имя bean-компонента TransactionManager, к которому вы хотите подключиться, имеет имя `Менеджер транзакций`.
Если bean-компонент TransactionManager, в который вы хотите внедрить зависимость, имеет любое другое имя, вам необходимо использовать атрибут `transaction-manager`, как в предыдущий пример.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
Реактивные транзакционные методы используют реактивные типы возврата в отличие от императивных. порядок программирования, как показано в следующем листинге:
Java
	// класс реактивного обслуживания, который мы хотим сделать транзакционным
	@Transactional
	public class DefaultFooService implements FooService {
		@Override
		public Publisher<Foo> getFoo(String fooName) {
		@Override
		public Mono<Foo> getFoo(String fooName, String barName) {
		@Override
		public Mono<Void> insertFoo(Foo foo) {
		@Override
		public Mono<Void> updateFoo(Foo foo) {
	// класс реактивного обслуживания, который мы хотим сделать транзакционным
	@Transactional
	class DefaultFooService : FooService {

В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
Обратите внимание, что для возвращаемого «Издателя» существуют особые соображения в отношении Сигналы отмены реактивных потоков.
См. раздел «Использование TransactionalOperator» для получения более подробной информации.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. .Видимость метода и `@Transactional` в режиме прокси. [ПРИМЕЧАНИЕ] = Аннотация `@Transactional` обычно используется для методов с `публичной` видимостью.
Начиная с версии 6.0, «защищенные» или видимые для пакета методы также можно сделать транзакционными для прокси на основе классов по умолчанию.
Обратите внимание, что транзакционные методы в интерфейсах прокси всегда должны быть «публичными» и определены в прокси-интерфейсе.
Для обоих видов из прокси перехватываются только вызовы внешних методов, поступающие через прокси.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
Если вы предпочитаете единообразную обработку видимости метода для различных типов прокси (которые использовались по умолчанию до версии 5.3), рассмотрите возможность указания publicMethodsOnly:
	 * Зарегистрируйте пользовательский AnnotationTransactionAttributeSource с помощью
	 * publicMethodsOnly flag set to true to consistently ignore non-public methods.
	 * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()
	@Bean
	TransactionAttributeSource transactionAttributeSource() {
		return new AnnotationTransactionAttributeSource(true);

В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. _Spring TestContext Framework_ поддерживает неприватные методы тестирования `@Transactional`. по умолчанию также.
См. ссылку:testing/testcontext-framework/tx.adoc [Управление транзакциями]. примеры в главе о тестировании.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
Вы можете применить аннотацию @Transactional к определению интерфейса, методу в интерфейсе, определении класса или методе класса.
Однако само присутствие аннотации @Transactional недостаточно для активации транзакционного поведения.
Аннотация `@Transactional` — это просто метаданные, которые могут использоваться соответствующими инфраструктура времени выполнения, которая использует эти метаданные для настройки соответствующих bean-компонентов с помощью транзакционное поведение.
В предыдущем примере элемент `<tx:annotation-driven/>` включает фактическое управление транзакциями во время выполнения.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
СОВЕТ: Команда Spring рекомендует аннотировать методы конкретных классов с помощью Аннотация `@Transactional` вместо того, чтобы полагаться на аннотированные методы в интерфейсах, даже если последний работает для прокси-серверов на основе интерфейса и целевого класса, начиная с версии 5.0.

Поскольку аннотации Java не наследуются от интерфейсов, аннотации, объявленные в интерфейсе по-прежнему не распознаются инфраструктурой плетения при использовании режима AspectJ, поэтому аспект не применяется.
Как следствие, ваши аннотации транзакций могут быть молча игнорируется: может показаться, что ваш код «работает», пока вы не протестируете сценарий отката.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
ПРИМЕЧАНИЕ.
В режиме прокси (который используется по умолчанию) через прокси перехватываются.
Это означает, что самовызов (по сути, метод внутри целевой объект, вызывающий другой метод целевого объекта) не приводит к фактическому транзакция во время выполнения, даже если вызванный метод помечен `@Transactional`.
Кроме того, прокси-сервер должен быть полностью инициализирован, чтобы обеспечить ожидаемое поведение, поэтому вам не следует используйте эту функцию в своем коде инициализации, например, в методе @PostConstruct.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
Рассмотрите возможность использования режима AspectJ (см. атрибут `mode` в следующей таблице), если вы ожидайте, что самовызовы также будут обернуты транзакциями.
В этом случае существует вообще нет прокси.
Вместо этого целевой класс вплетается (то есть его байт-код изменен) для поддержки поведения `@Transactional` во время выполнения для любого метода.

В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. .Настройки транзакций, управляемых аннотациями. |=== | XML-атрибут | Атрибут аннотации | По умолчанию| Описание
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `менеджер транзакций` | Н/Д (см. {spring-framework-api}/transaction/annotation/TransactionManagementConfigurer.html[`TransactionManagementConfigurer`] javadoc) | `транзакционный менеджер` | Имя используемого менеджера транзакций.
Требуется только в том случае, если имя транзакции менеджер не является «transactionManager», как в предыдущем примере.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `режим` | `прокси` | Режим по умолчанию («прокси») обрабатывает аннотированные bean-компоненты для проксирования с использованием Spring AOP. framework (следуя семантике прокси, как обсуждалось ранее, применительно к вызовам методов вход только через прокси).
Альтернативный режим («aspectj») вместо этого вплетает затронутые классы с аспектом транзакции Spring AspectJ, изменяя целевой класс байт-код для применения к любому вызову метода.

Для плетения AspectJ требуется `spring-aspects.jar` в пути к классам, а также включено переплетение во время загрузки (или переплетение во время компиляции). (Подробную информацию см. в конфигурация Spring). о том, как настроить переплетение во время загрузки.)
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `прокси-целевой класс` | `proxyTargetClass` | `ложь` | Применяется только к режиму «прокси».
Контролирует, какой тип транзакционных прокси создается. для классов, помеченных аннотацией @Transactional.
Если `proxy-target-class` атрибуту присвоено значение true, создаются прокси на основе классов.
Если `proxy-target-class` `false` или если атрибут опущен, то стандартные прокси на основе интерфейса JDK создано. (Подробное описание см. в Механизмы проксирования). различных типов прокси.)
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `заказ` | `Упорядочено.LOWEST_PRECEDENCE` | Определяет порядок рекомендаций по транзакции, которые применяются к компонентам, помеченным с помощью `@Transactional`. (Подробнее о правилах заказа АОП совет, см.
Упорядочение советов.) Отсутствие определенного порядка означает, что подсистема АОП определяет порядок рекомендаций. |===

В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
ПРИМЕЧАНИЕ.
Режим рекомендаций по умолчанию для обработки аннотаций `@Transactional` — это `прокси`. что позволяет перехватывать звонки только через прокси.
Местные звонки в пределах тот же класс не может быть перехвачен таким образом.
Для более продвинутого режима перехвата рассмотрите возможность переключения в режим aspectj в сочетании с переплетением во время компиляции или во время загрузки.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
ПРИМЕЧАНИЕ.
Атрибут proxy-target-class определяет тип транзакционных прокси. создан для классов, помеченных аннотацией @Transactional.
Если Для `proxy-target-class` установлено значение `true`, создаются прокси на основе классов.
Если `proxy-target-class` имеет значение `false` или, если атрибут опущен, стандартный JDK. создаются прокси на основе интерфейса. (См.
Механизмы проксирования для обсуждения различных типов прокси.)
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
ПРИМЕЧАНИЕ. `@EnableTransactionManagement` и `<tx:annotation-driven/>` ищут `@Transactional` только для bean-компонентов в том же контексте приложения, в котором они определены.

Это означает, что если вы поместите конфигурацию, управляемую аннотациями, в `WebApplicationContext` для DispatcherServlet он проверяет bean-компоненты @Transactional только в ваших контроллерах. и не в ваших услугах.
Дополнительную информацию см. в MVC.
В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.
Наиболее производное местоположение имеет приоритет при оценке настроек транзакций. для метода.
В следующем примере класс DefaultFooService аннотируется на уровне класса настройками транзакции только для чтения, но Аннотация `@Transactional` для метода `updateFoo(Foo)` в том же классе принимает приоритет над настройками транзакций, определенными на уровне класса.
Java
	@Transactional(readOnly = true)
	public class DefaultFooService implements FooService {
		public Foo getFoo(String fooName) {
		// эти настройки имеют приоритет для этого метода
		@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
		public void updateFoo(Foo foo) {
	@Transactional(readOnly = true)
	class DefaultFooService : FooService {
`@Transactional` Настройки.
Аннотация `@Transactional` — это метаданные, указывающие, что интерфейс, класс, или метод должен иметь транзакционную семантику (например, «запустить новый файл только для чтения»). транзакция при вызове этого метода, приостанавливая любую существующую транзакцию").
Настройки `@Transactional` по умолчанию следующие:
* Параметр распространения — PROPAGATION_REQUIRED.
* Уровень изоляции — `ISOLATION_DEFAULT.`

* Транзакция является чтение-запись.
* Тайм-аут транзакции по умолчанию равен тайм-ауту по умолчанию базовой транзакции.
`@Transactional` Настройки. системе или нет, если таймауты не поддерживаются.
* Любое `RuntimeException` или `Error` вызывает откат, а любое отмеченное `Exception` вызывает откат.
`@Transactional` Настройки. нет.
`@Transactional` Настройки.
Вы можете изменить эти настройки по умолчанию.
В следующей таблице суммированы различные свойства аннотации @Transactional:
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | value | `Строка` | Необязательный квалификатор, указывающий используемый менеджер транзакций.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `транзакционный менеджер` | `Строка` | Псевдоним для `value`.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `этикетка` | Массив меток String для добавления выразительного описания транзакции. | Метки могут оцениваться менеджерами транзакций, чтобы связать поведение, специфичное для реализации, с фактической транзакцией.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | распространение | `enum`: `Распространение` | Дополнительная настройка распространения.

.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `изоляция` | `enum`: `Изоляция` | Дополнительный уровень изоляции.
Применяется только к значениям распространения REQUIRED или REQUIRES_NEW.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `тайм-аут` | `int` (детализация в секундах) | Необязательный тайм-аут транзакции.
Применяется только к значениям распространения REQUIRED или REQUIRES_NEW.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `timeoutString` | `String` (детализация в секундах) | Альтернатива указанию тайм-аута в секундах в виде значения String, например, в качестве заполнителя.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `только для чтения` | `логическое значение` | Транзакция чтения-записи в сравнении с транзакцией только чтения.
Применимо только к значениям REQUIRED или REQUIRES_NEW.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `rollbackFor` | Массив объектов Class, который должен быть производным от Throwable. | Необязательный массив типов исключений, которые должны вызывать откат.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `rollbackForClassName` | Массив шаблонов имен исключений. | Необязательный массив шаблонов имен исключений, которые должны вызывать откат.

.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `noRollbackFor` | Массив объектов Class, который должен быть производным от Throwable. | Необязательный массив типов исключений, которые не должны вызывать откат.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `noRollbackForClassName` | Массив шаблонов имен исключений. | Необязательный массив шаблонов имен исключений, которые не должны вызывать откат. |===
.@Настройки транзакций |=== | Недвижимость| Тип| Описание.
СОВЕТ: См. для получения более подробной информации о семантике, шаблонах и предупреждениях правил отката. относительно возможных непреднамеренных совпадений с правилами отката на основе шаблонов.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание. [ПРИМЕЧАНИЕ] = Начиная с версии 6.2, вы можете глобально изменить поведение отката по умолчанию, например, с помощью `@EnableTransactionManagement(rollbackOn=ALL_EXCEPTIONS)`, приводящий к откату для всех исключений, возникших в транзакции, включая любое проверенное исключение.
Для дальнейшей настройки AnnotationTransactionAttributeSource предоставляет `addDefaultRollbackRule(RollbackRuleAttribute)` для пользовательских правил по умолчанию.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание.
Обратите внимание, что правила отката для конкретных транзакций переопределяют поведение по умолчанию, но сохраните выбранное значение по умолчанию для неуказанных исключений.

Это относится к Spring `@Transactional`, а также `jakarta.transaction.Transactional` JTA аннотация.
.@Настройки транзакций |=== | Недвижимость| Тип| Описание.
В настоящее время вы не можете явно контролировать имя транзакции, где «имя» означает имя транзакции, которое отображается в мониторе транзакций и в выходных данных журнала.
Для декларативных транзакций имя транзакции всегда является полным классом. имя транзакционно рекомендуемого класса + `.` + имя метода.
Например, если Метод handlePayment(..) класса BusinessService запустил транзакцию, имя транзакции будет `com.example.BusinessService.handlePayment`.
Несколько менеджеров транзакций с `@Transactional`.
Большинству приложений Spring нужен только один менеджер транзакций, но может быть и ситуации, когда вам нужно несколько независимых менеджеров транзакций в одном приложение.
Вы можете использовать атрибут `value` или `transactionManager` Аннотация `@Transactional` для опционального указания личности `TransactionManager`, который будет использоваться.
Это может быть имя компонента или значение квалификатора. компонента менеджера транзакций.
Например, используя квалификатор, вы можете объедините следующий код Java со следующими объявлениями компонентов менеджера транзакций в контексте приложения:
Java
	public class TransactionalService {
		@Transactional("order")
		public void setSomething(String name) { ... }
		@Transactional("account")
		public void doSomething() { ... }

@Transactional("reactive-account")
		public Mono<Void> doSomethingReactive() { ... }
	class TransactionalService {
	<tx:annotation-driven/>
		<bean id="transactionManager1" class="org.springframework.jdbc.support.JdbcTransactionManager">
			<qualifier value="order"/>
		</bean>
		<bean id="transactionManager2" class="org.springframework.jdbc.support.JdbcTransactionManager">
			<qualifier value="account"/>
		</bean>
		<bean id="transactionManager3" class="org.springframework.data.r2dbc.connection.R2dbcTransactionManager">
			<qualifier value="reactive-account"/>
		</bean>
В следующем листинге показаны объявления bean-компонентов:.
В этом случае отдельные методы TransactionalService выполняются под отдельными менеджеры транзакций, различающиеся по «заказу», «счету» и «реактивному счету». отборочные.
Имя целевого компонента по умолчанию `<tx:annotation-driven>`, `transactionManager`, по-прежнему используется, если не найден специально определенный bean-компонент TransactionManager.
В следующем листинге показаны объявления bean-компонентов:. [СОВЕТ] = Если все транзакционные методы одного класса имеют один и тот же квалификатор, рассмотрите объявление уровня типа `org.springframework.beans.factory.annotation.Qualifier` вместо этого аннотация.

Если его значение соответствует значению квалификатора (или имени компонента) конкретный менеджер транзакций, для которого будет использоваться этот менеджер транзакций определения транзакций без специального квалификатора в самом `@Transactional`.
В следующем листинге показаны объявления bean-компонентов:.
Такой квалификатор уровня типа может быть объявлен в конкретном классе, применяясь к определения транзакций из базового класса.
Это эффективно переопределяет выбор менеджера транзакций по умолчанию для любых неквалифицированных методов базового класса.
В следующем листинге показаны объявления bean-компонентов:.
И последнее, но не менее важное: такой квалификатор bean-компонента на уровне типа может служить нескольким целям: например, со значением «order» его можно использовать для целей автоматического подключения (идентификации хранилище заказов), а также выбор менеджера транзакций, если целевые bean-компоненты для автоматического подключения, а также связанный с ним менеджер транзакций определения декларируют одно и то же значение квалификатора.
Такое значение квалификатора необходимо только быть уникальным в наборе bean-компонентов, соответствующих типам, и не обязательно служить идентификатором.
Пользовательские аннотации.
Если вы обнаружите, что неоднократно используете одни и те же атрибуты с `@Transactional` в разных методах, позволяет вам определять пользовательские аннотации для ваших конкретных случаев использования.
Например, рассмотрим следующие определения аннотаций:
Java
	@Target({ElementType.METHOD, ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)

@Transactional(transactionManager = "order", label = "causal-consistency")
	public @interface OrderTx {
	@Target({ElementType.METHOD, ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	@Transactional(transactionManager = "account", label = "retryable")
	public @interface AccountTx {
	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@Transactional(transactionManager = "order", label = ["causal-consistency"])
	annotation class OrderTx
	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@Transactional(transactionManager = "account", label = ["retryable"])
	annotation class AccountTx
Java
	public class TransactionalService {
		@OrderTx
		public void setSomething(String name) {
		@AccountTx
		public void doSomething() {
	class TransactionalService {
Предыдущие аннотации позволяют записать пример из предыдущего раздела следующим образом:.
В предыдущем примере мы использовали синтаксис для определения квалификатора менеджера транзакций. и транзакционные метки, но мы могли бы также включить поведение распространения, правила отката, таймауты и другие функции.

Spring AOP API.
В предыдущей главе описывалась поддержка АОП в Spring с помощью @AspectJ и схемы на основе схем. определения аспектов.
В этой главе мы обсуждаем API-интерфейсы Spring AOP нижнего уровня.
Для общего приложениях мы рекомендуем использовать Spring AOP с точками AspectJ, как описано в предыдущая глава.

Аспектно-ориентированное программирование с помощью Spring.
Аспектно-ориентированное программирование (АОП) дополняет объектно-ориентированное программирование (ООП). обеспечивая другой способ мышления о структуре программы.
Ключевой элемент модульности в ООП — это класс, тогда как в АОП единицей модульности является аспект.
Аспекты обеспечить модульность задач (таких как управление транзакциями), которые пересекаются несколько типов и объектов. (Такие проблемы часто называют «сквозными» проблемами. в литературе АОП.)
Аспектно-ориентированное программирование с помощью Spring.
Одним из ключевых компонентов Spring является платформа АОП.
В то время как Spring IoC контейнер не зависит от АОП (это означает, что вам не нужно использовать АОП, если вы не хотите to), АОП дополняет Spring IoC, предоставляя очень эффективное промежуточное программное решение.
Аспектно-ориентированное программирование с помощью Spring. .Spring AOP с точками AspectJ **** Spring предоставляет простые и мощные способы написания пользовательских аспектов с помощью Оба этих стиля предлагают полностью типизированные советы и использование языка pointcut AspectJ. при этом все еще используя Spring AOP для плетения.
Аспектно-ориентированное программирование с помощью Spring.
В этой главе обсуждается поддержка АОП на основе схемы и @AspectJ.
Поддержка АОП нижнего уровня обсуждается в следующая глава. ****
* Предоставлять декларативные корпоративные услуги. Важнейшим из таких сервисов является
* Позвольте пользователям реализовывать собственные аспекты, дополняя использование ООП АОП.
АОП используется в Spring Framework для:.
ПРИМЕЧАНИЕ.

Если вас интересуют только универсальные декларативные службы или другие готовые декларативные службы промежуточного программного обеспечения, такие как пул, вам не нужно работать напрямую с Spring AOP, и можно пропустить большую часть этой главы.

Опережающая оптимизация.
В этой главе рассматриваются оптимизации Spring Ahead of Time (AOT).
Опережающая оптимизация.
Информацию о поддержке AOT, специфичной для интеграционных тестов, см. в документе Опереденная поддержка тестов.
Введение в упреждающую оптимизацию.
Поддержка оптимизации AOT в Spring предназначена для проверки `ApplicationContext` во время сборки и применения решений и логики обнаружения, которые обычно происходят во время выполнения.
Это позволяет создать более простую схему запуска приложения, ориентированную на фиксированный набор функций, основанный главным образом на пути к классам и «Среде».
* Путь к классам фиксирован и полностью определен во время сборки.
* Компоненты, определенные в вашем приложении, не могут изменяться во время выполнения, что означает:
Раннее применение таких оптимизаций подразумевает следующие ограничения:. ** `@Profile`, в частности, конфигурация, специфичная для профиля, должна быть выбрана во время сборки и автоматически включается во время выполнения, когда включен AOT. ** Свойства «Среды», влияющие на наличие компонента («@Conditional»), учитываются только во время сборки.
* Определения компонентов с поставщиками экземпляров (лямбда-выражения или ссылки на методы) не могут быть преобразованы заранее.
* Компоненты, зарегистрированные как синглтоны (с использованием `registerSingleton`, обычно из
Раннее применение таких оптимизаций подразумевает следующие ограничения:. `ConfigurableListableBeanFactory`) также не может быть преобразовано заранее.

* Поскольку мы не можем полагаться на экземпляр, убедитесь, что тип компонента максимально точен.
Раннее применение таких оптимизаций подразумевает следующие ограничения:. возможно.
Раннее применение таких оптимизаций подразумевает следующие ограничения:.
СОВЕТ: См. также раздел.
Раннее применение таких оптимизаций подразумевает следующие ограничения:.
Когда эти ограничения действуют, становится возможным выполнять предварительную обработку во время сборки и генерировать дополнительные ресурсы.
Приложение, обработанное Spring AOT, обычно генерирует:
* Исходный код Java
* Байт-код (обычно для динамических прокси)
* {spring-framework-api}/aot/hint/RuntimeHints.html[`RuntimeHints`] для использования отражения, загрузки ресурсов, сериализации и прокси-серверов JDK.
Раннее применение таких оптимизаций подразумевает следующие ограничения:.
ПРИМЕЧАНИЕ.
На данный момент AOT сосредоточен на том, чтобы разрешить развертывание приложений Spring как собственных образов с использованием GraalVM.
Мы намерены поддерживать больше вариантов использования на основе JVM в будущих поколениях.
Обзор движка AOT.
Точкой входа механизма AOT для обработки ApplicationContext является ApplicationContextAotGenerator.
It takes care of the following steps, based on a `GenericApplicationContext` that represents the application to optimize and a {spring-framework-api}/aot/generate/GenerationContext.html[`GenerationContext`]:
* Обновите `ApplicationContext` для обработки AOT. В отличие от традиционного обновления, эта версия создает только определения компонентов, а не экземпляры компонентов.

* Вызовите доступные реализации BeanFactoryInitializationAotProcessor и примените их вклад к GenerationContext.
Обзор движка AOT.
Например, основная реализация перебирает все определения потенциальных компонентов и генерирует необходимый код для восстановления состояния BeanFactory.
Обзор движка AOT.
После завершения этого процесса GenerationContext будет обновлен сгенерированным кодом, ресурсами и классами, необходимыми для запуска приложения.
Экземпляр RuntimeHints также можно использовать для создания соответствующих файлов конфигурации собственного образа GraalVM.
Обзор движка AOT. `ApplicationContextAotGenerator#processAheadOfTime` returns the class name of the `ApplicationContextInitializer` entry point that allows the context to be started with AOT optimizations.
Обзор движка AOT.
Эти шаги более подробно описаны в разделах ниже.
Обновление для обработки AOT поддерживается во всех реализациях GenericApplicationContext.
Контекст приложения создается с любым количеством точек входа, обычно в форме классов, аннотированных `@Configuration`.
Обновление для обработки AOT.
Давайте посмотрим на базовый пример: См. пример кода в исходном документе.
Обновление для обработки AOT.
Запуск этого приложения в обычной среде выполнения включает в себя ряд шагов, включая сканирование пути к классам, анализ классов конфигурации, создание экземпляров bean-компонентов и обработку обратного вызова жизненного цикла.
Обновление для обработки AOT применяет только часть того, что происходит с regular `refresh`.
Обработку AOT можно запустить следующим образом: См. пример кода в исходном документе.
Обновление для обработки AOT.
В этом режиме реализации BeanFactoryPostProcessor вызываются как обычно.

Сюда входит анализ классов конфигурации, селекторы импорта, сканирование путей к классам и т. д.
Такие шаги гарантируют, что `BeanRegistry` содержит соответствующие определения bean-компонентов для приложения.
Если определения bean-компонентов защищены условиями (такими как `@Profile`), они оцениваются, и определения компонентов, которые не соответствуют их условиям, на этом этапе отбрасываются.
Обновление для обработки AOT.
Если пользовательскому коду необходимо программно зарегистрировать дополнительные компоненты, убедитесь, что пользовательский код регистрационный код использует BeanDefinitionRegistry вместо BeanFactory как единственный компонент определения принимаются во внимание.
Хороший шаблон — реализовать `ImportBeanDefinitionRegistrar` и зарегистрируйте его через `@Import` на одном из ваших классы конфигурации.
Обновление для обработки AOT.
Поскольку этот режим фактически не создает экземпляры bean-компонентов, реализации BeanPostProcessor не вызываются, за исключением определенных вариантов, которые имеют отношение к обработке AOT.
Это:
* MergedBeanDefinitionPostProcessor реализует определения bean-компонентов постобработки для извлечения дополнительных настроек, таких как методы init и destroy.
* Реализации SmartInstantiationAwareBeanPostProcessor при необходимости определяют более точный тип компонента.
Обновление для обработки AOT.
Это гарантирует создание любого прокси, который потребуется во время выполнения.
Обновление для обработки AOT.
После завершения этой части «BeanFactory» будет содержать определения компонентов, необходимые для запуска приложения.
Он не запускает создание экземпляра компонента, но позволяет механизму AOT проверять компоненты, которые будут созданы во время выполнения.
Вклад AOT в инициализацию Bean Factory.

Компоненты, которые хотят участвовать в этом шаге, могут реализовать интерфейс {spring-framework-api}/beans/factory/aot/BeanFactoryInitializationAotProcessor.html[`BeanFactoryInitializationAotProcessor`].
Каждая реализация может возвращать вклад AOT в зависимости от состояния фабрики компонентов.
Вклад AOT в инициализацию Bean Factory.
Вклад AOT — это компонент, который вносит сгенерированный код, воспроизводящий определенное поведение.
Он также может предоставлять RuntimeHints, чтобы указать на необходимость отражения, загрузки ресурсов, сериализации или прокси-серверов JDK.
Вклад AOT в инициализацию Bean Factory.
Реализация BeanFactoryInitializationAotProcessor может быть зарегистрирована в META-INF/spring/aot.factories с ключом, равным полному имени интерфейса.
Вклад AOT в инициализацию Bean Factory.
Интерфейс BeanFactoryInitializationAotProcessor также может быть реализован непосредственно компонентом.
В этом режиме компонент обеспечивает вклад AOT, эквивалентный функции, которую он предоставляет в обычной среде выполнения.
Следовательно, такой компонент автоматически исключается из контекста, оптимизированного для AOT.
Вклад AOT в инициализацию Bean Factory. [ПРИМЕЧАНИЕ] = Если компонент реализует интерфейс BeanFactoryInitializationAotProcessor, компонент и **все** его зависимости будут инициализированы во время обработки AOT.
Обычно мы рекомендуем, чтобы этот интерфейс реализовывался только инфраструктурными компонентами, такими как BeanFactoryPostProcessor, которые имеют ограниченные зависимости и уже инициализируются на ранних стадиях жизненного цикла фабрики компонентов.

Если такой компонент зарегистрирован с использованием фабричного метода @Bean, убедитесь, что метод является статическим, чтобы не нужно было инициализировать включающий его класс @Configuration.
Регистрация компонентов AOT.
Базовая реализация BeanFactoryInitializationAotProcessor отвечает за сбор необходимых вкладов для каждого кандидата BeanDefinition.
Это делается с помощью специального BeanRegistrationAotProcessor.
* Реализовано bean-компонентом BeanPostProcessor для замены его поведения во время выполнения.
Этот интерфейс используется следующим образом:.
Например, `AutowiredAnnotationBeanPostProcessor` реализует этот интерфейс для генерации кода, который внедряет элементы, помеченные `@Autowired`.
* Реализовано типом, зарегистрированным в `META-INF/spring/aot.factories` с ключом, равным полному имени интерфейса.
Этот интерфейс используется следующим образом:.
Обычно используется, когда определение компонента необходимо настроить для конкретных функций базовой платформы.
Этот интерфейс используется следующим образом:. [ПРИМЕЧАНИЕ] = Если компонент реализует интерфейс `BeanRegistrationAotProcessor`, компонент и **все** его зависимости будут инициализированы во время обработки AOT.
Обычно мы рекомендуем, чтобы этот интерфейс реализовывался только инфраструктурными компонентами, такими как BeanFactoryPostProcessor, которые имеют ограниченные зависимости и уже инициализируются на ранних стадиях жизненного цикла фабрики компонентов.
Если такой компонент зарегистрирован с использованием фабричного метода @Bean, убедитесь, что метод является статическим, чтобы не нужно было инициализировать включающий его класс @Configuration.
Этот интерфейс используется следующим образом:.

Если ни один `BeanRegistrationAotProcessor` не обрабатывает конкретный зарегистрированный компонент, его обрабатывает реализация по умолчанию.
Это поведение по умолчанию, поскольку настройка сгенерированного кода для определения компонента должна ограничиваться крайними случаями.
Этот интерфейс используется следующим образом:.
Возьмем наш предыдущий пример и предположим, что `DataSourceConfiguration` выглядит следующим образом:
Java
	@Configuration(proxyBeanMethods = false)
	public class DataSourceConfiguration {
		@Bean
		public SimpleDataSource dataSource() {
			return new SimpleDataSource();
	@Configuration(proxyBeanMethods = false)
	class DataSourceConfiguration {
Этот интерфейс используется следующим образом:.
Поскольку для этого класса нет каких-либо особых условий, dataSourceConfiguration и dataSource идентифицируются как кандидаты.
Механизм AOT преобразует приведенный выше класс конфигурации в код, аналогичный следующему:
Java
	 * Bean definitions for {@link DataSourceConfiguration}
	@Generated
	public class DataSourceConfiguration__BeanDefinitions {
		 * Получите определение bean-компонента для dataSourceConfiguration.
		public static BeanDefinition getDataSourceConfigurationBeanDefinition() {
			Class<?> beanType = DataSourceConfiguration.class;
			RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
			beanDefinition.setInstanceSupplier(DataSourceConfiguration::new);
			return beanDefinition;
		 * Получите поставщика экземпляра компонента для dataSource.
		private static BeanInstanceSupplier<SimpleDataSource> getDataSourceInstanceSupplier() {
			return BeanInstanceSupplier.<SimpleDataSource>forFactoryMethod(DataSourceConfiguration.class, "dataSource")
					.withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(DataSourceConfiguration.class).dataSource());

* Получите определение bean-компонента для dataSource.
		public static BeanDefinition getDataSourceBeanDefinition() {
			Class<?> beanType = SimpleDataSource.class;
			RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
			beanDefinition.setInstanceSupplier(getDataSourceInstanceSupplier());
			return beanDefinition;
Этот интерфейс используется следующим образом:.
ПРИМЕЧАНИЕ.
Точный сгенерированный код может отличаться в зависимости от точного характера определений вашего компонента.
Этот интерфейс используется следующим образом:.
СОВЕТ: Каждый сгенерированный класс помечен с помощью `org.springframework.aot.generate.Generated` для идентифицируйте их, если их необходимо исключить, например, с помощью инструментов статического анализа.
Этот интерфейс используется следующим образом:.
Сгенерированный выше код создает определения bean-компонентов, эквивалентные классу @Configuration, но напрямую и, если возможно, вообще без использования отражения.
Существует определение компонента для `dataSourceConfiguration` и одно для `dataSourceBean`.
Когда требуется экземпляр источника данных, вызывается BeanInstanceSupplier.
Этот поставщик вызывает метод dataSource() в bean-компоненте dataSourceConfiguration.
Работа с оптимизацией AOT.
AOT — обязательный шаг для преобразования приложения Spring в собственный исполняемый файл. автоматически включается при запуске в собственном образе.
Однако также возможно использовать оптимизацию AOT. на JVM, установив для системного свойства Spring.aot.enabled значение true.
Работа с оптимизацией AOT.
ПРИМЕЧАНИЕ.
Когда включена оптимизация AOT, некоторые решения, принятые во время сборки, жестко запрограммированы в настройке приложения.

Например, профили, которые были включены в время сборки также автоматически включается во время выполнения.
Лучшие практики.
Механизм AOT предназначен для обработки как можно большего количества вариантов использования без изменения кода в приложениях.
Однако имейте в виду, что некоторые оптимизации выполняются во время сборки на основе статического определения компонентов.
Лучшие практики.
В этом разделе перечислены рекомендации, которые помогут убедиться, что ваше приложение готово к AOT.
Программная регистрация компонентов.
Механизм AOT заботится о модели @Configuration и любом обратном вызове, который может быть вызывается как часть обработки вашей конфигурации.
Если вам необходимо зарегистрировать доп. beans программно, обязательно используйте BeanDefinitionRegistry для регистрации определения бобов.
Программная регистрация компонентов.
Обычно это можно сделать с помощью BeanDefinitionRegistryPostProcessor.
Обратите внимание, что если это зарегистрирован как компонент, он будет вызываться снова во время выполнения, если вы не сделаете обязательно также реализуйте `BeanFactoryInitializationAotProcessor`.
Более идиоматический способ — реализовать ImportBeanDefinitionRegistrar и зарегистрировать его с помощью @Import на один из ваших классов конфигурации.
Это вызывает ваш собственный код как часть конфигурации. разбор классов.
Программная регистрация компонентов.
Если вы объявляете дополнительные компоненты программно, используя другой обратный вызов, они скорее всего, не будет обрабатываться движком AOT, поэтому никаких подсказок не будет. созданные для них.
В зависимости от среды эти бобы могут не быть зарегистрированы на все.
Например, сканирование пути к классам не работает в собственном образе, поскольку там нет понятие пути к классам.

В подобных случаях крайне важно, чтобы сканирование происходило в время сборки.
Раскройте наиболее точный тип компонента.
Хотя ваше приложение может взаимодействовать с интерфейсом, реализуемым компонентом, все равно очень важно объявить наиболее точный тип.
Механизм AOT выполняет дополнительные проверки типа компонента, например, обнаруживает наличие членов @Autowired или методов обратного вызова жизненного цикла.
Раскройте наиболее точный тип компонента.
Для классов `@Configuration` убедитесь, что тип возвращаемого значения фабричного метода `@Bean` является максимально точным.
Рассмотрим следующий пример:
Java
	@Configuration(proxyBeanMethods = false)
	public class UserConfiguration {
		@Bean
		public MyInterface myInterface() {
			return new MyImplementation();
	@Configuration(proxyBeanMethods = false)
	class UserConfiguration {
Раскройте наиболее точный тип компонента.
В приведенном выше примере объявленным типом bean-компонента myInterface является MyInterface.
Во время обработки AOT ни одна обычная постобработка не будет учитывать MyImplementation.
Например, если в MyImplementation существует аннотированный метод-обработчик, который контекст должен зарегистрировать, он не будет обнаружен во время обработки AOT.
Java
	@Configuration(proxyBeanMethods = false)
	public class UserConfiguration {
		@Bean
		public MyImplementation myInterface() {
			return new MyImplementation();
	@Configuration(proxyBeanMethods = false)
	class UserConfiguration {
Поэтому приведенный выше пример следует переписать следующим образом:.
Если вы регистрируете определения bean-компонентов программным способом, рассмотрите возможность использования RootBeanBefinition, поскольку он позволяет указать ResolvableType, который обрабатывает дженерики.

Избегайте использования нескольких конструкторов.
Контейнер может выбирать наиболее подходящий для использования конструктор на основе нескольких кандидатов.
Однако полагаться на это не рекомендуется, и при необходимости предпочтительнее пометить предпочтительный конструктор с помощью `@Autowired`.
Избегайте использования нескольких конструкторов.
Если вы работаете с базой кода, которую не можете изменить, вы можете установить {spring-framework-api}/beans/factory/support/AbstractBeanDefinition.html#PREFERRED_CONSTRUCTORS_ATTRIBUTE[`preferredConstructors` атрибут] в определении связанного компонента, чтобы указать, какой конструктор следует использовать.
Избегайте сложных структур данных для параметров и свойств конструктора.
При программном создании RootBeanDefinition вы не ограничены в типах, которые можете использовать.
Например, у вас может быть специальная «запись» с несколькими свойствами, которые ваш компонент принимает в качестве аргумента конструктора.
Избегайте сложных структур данных для параметров и свойств конструктора.
Хотя это прекрасно работает в обычной среде выполнения, AOT не знает, как генерировать код вашей пользовательской структуры данных.
Хорошее практическое правило — помнить, что определения компонентов представляют собой абстракцию, лежащую поверх нескольких моделей.
Вместо использования таких структур рекомендуется разложить их на простые типы или обратиться к созданному компоненту как таковому.
Избегайте сложных структур данных для параметров и свойств конструктора.
В крайнем случае, вы можете реализовать свой собственный `org.springframework.aot.generate.ValueCodeGenerator$Delegate`.

Чтобы использовать его, зарегистрируйте его полное имя в `META-INF/spring/aot.factories`, используя `org.springframework.aot.generate.ValueCodeGenerator$Delegate` в качестве ключа.
Избегайте создания компонентов с пользовательскими аргументами.
Spring AOT определяет, что необходимо сделать для создания компонента, и преобразует это в сгенерированный код, который использует поставщика экземпляра.
Контейнер также поддерживает создание bean-компонента с помощью {spring-framework-api}++/beans/factory/BeanFactory.html#getBean(java.lang.String,java.lang.Object...)++[пользовательских аргументов], что может привести к нескольким проблемам с AOT:
Избегайте создания компонентов с пользовательскими аргументами. .
Пользовательские аргументы требуют динамического анализа соответствующего конструктора или фабричного метода.
Эти аргументы не могут быть обнаружены AOT, поэтому необходимые подсказки по отражению придется предоставлять вручную..
Обход поставщика экземпляра означает, что все остальные оптимизации после создания также пропускаются.
Например, автоматическое связывание полей и методов будет пропущено, поскольку они обрабатываются поставщиком экземпляра.
Избегайте создания компонентов с пользовательскими аргументами.
Вместо того, чтобы создавать bean-компоненты с областью прототипа с настраиваемыми аргументами, мы рекомендуем использовать фабричный шаблон вручную, в котором bean-компонент отвечает за создание экземпляра.
Избегайте циклических зависимостей.
Определенные варианты использования могут привести к циклическим зависимостям между одним или несколькими компонентами.

С обычная среда выполнения, возможно, можно будет связать эти циклические зависимости через `@Autowired` по методам или полям установки.
Однако контекст, оптимизированный для AOT, не сможет начаться с явные циклические зависимости.
Избегайте циклических зависимостей.
Поэтому в приложении, оптимизированном для AOT, следует стараться избегать циклического зависимости.
Если это невозможно, вы можете использовать точки внедрения `@Lazy` или `ObjectProvider` для ленивого доступа или получения необходимых взаимодействующих компонентов.
См. для получения дополнительной информации.
ФабрикаБин. «FactoryBean» следует использовать с осторожностью, поскольку он вводит промежуточный уровень с точки зрения разрешения типов компонентов, который может не быть концептуально необходимым.
Как правило, если экземпляр FactoryBean не сохраняет долгосрочное состояние и не требуется на более позднем этапе во время выполнения, его следует заменить обычным фабричным методом @Bean, возможно, с слоем адаптера FactoryBean сверху (в целях декларативной конфигурации).
ФабрикаБин.
Если ваша реализация FactoryBean не разрешает тип объекта (т. е.
T), необходима дополнительная осторожность.
Рассмотрим следующий пример:
Java
	public class ClientFactoryBean<T extends AbstractClient> implements FactoryBean<T> {
	class ClientFactoryBean<T : AbstractClient> : FactoryBean<T> {
ФабрикаБин.
Конкретное объявление клиента должно предоставлять разрешенный универсальный код для клиента, как показано в следующем примере:
Java
	@Configuration(proxyBeanMethods = false)
	public class UserConfiguration {
		@Bean
		public ClientFactoryBean<MyClient> myClient() {

return new ClientFactoryBean<>(...);
	@Configuration(proxyBeanMethods = false)
	class UserConfiguration {
ФабрикаБин.
Если определение bean-компонента FactoryBean зарегистрировано программно, обязательно выполните следующие шаги:
1. Используйте RootBeanDefinition.
2. Установите для beanClass класс FactoryBean, чтобы AOT знал, что это промежуточный уровень.
3. Установите для параметра ResolvableType разрешенный универсальный тип, который гарантирует предоставление наиболее точного типа.
Java
	RootBeanDefinition beanDefinition = new RootBeanDefinition(ClientFactoryBean.class);
	beanDefinition.setTargetType(ResolvableType.forClassWithGenerics(ClientFactoryBean.class, MyClient.class));
	registry.registerBeanDefinition("myClient", beanDefinition);
Следующий пример демонстрирует базовое определение:.
Для применения определенных оптимизаций необходимо заранее знать модуль персистентности JPA.
Рассмотрим следующий базовый пример:
Java
	@Bean
	LocalContainerEntityManagerFactoryBean customDBEntityManagerFactory(DataSource dataSource) {
		LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
		factoryBean.setDataSource(dataSource);
		factoryBean.setPackagesToScan("com.example.app");
		return factoryBean;
Следующий пример демонстрирует базовое определение:.
Чтобы гарантировать, что сканирование объектов происходит заранее, bean-компонент PersistenceManagedTypes должен быть объявлен и использован определение фабричного компонента, как показано в следующем примере:
Java
	@Bean
	PersistenceManagedTypes persistenceManagedTypes(ResourceLoader resourceLoader) {
		return new PersistenceManagedTypesScanner(resourceLoader)
				.scan("com.example.app");
	@Bean
	LocalContainerEntityManagerFactoryBean customDBEntityManagerFactory(DataSource dataSource, PersistenceManagedTypes managedTypes) {

LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
		factoryBean.setDataSource(dataSource);
		factoryBean.setManagedTypes(managedTypes);
		return factoryBean;
Подсказки во время выполнения.
Запуск приложения в качестве собственного образа требует дополнительной информации по сравнению с обычной средой выполнения JVM.
Например, GraalVM необходимо заранее знать, использует ли компонент отражение.
Аналогично, ресурсы пути к классам не включаются в собственный образ, если это не указано явно.
Следовательно, если приложению необходимо загрузить ресурс, на него необходимо ссылаться из соответствующего файла конфигурации собственного образа GraalVM.
Подсказки во время выполнения.
API {spring-framework-api}/aot/hint/RuntimeHints.html[`RuntimeHints`] собирает данные о необходимости отражения, загрузки ресурсов, сериализации и прокси-серверов JDK во время выполнения.
Следующий пример гарантирует, что `config/app.properties` может быть загружен из пути к классам во время выполнения в собственном образе:
Java
	runtimeHints.resources().registerPattern("config/app.properties");
	runtimeHints.resources().registerPattern("config/app.properties")
Подсказки во время выполнения.
Ряд контрактов обрабатываются автоматически во время обработки AOT.
Например, проверяется возвращаемый тип метода `@Controller` и добавляются соответствующие подсказки по отражению, если Spring обнаруживает, что тип должен быть сериализован (обычно в JSON).
Подсказки во время выполнения.

В случаях, когда основной контейнер не может определить такие подсказки, вы можете зарегистрировать такие подсказки программно.
Для общих случаев использования также предусмотрен ряд удобных аннотаций.
`@ImportRuntimeHints`. {spring-framework-api}/aot/hint/RuntimeHintsRegistrar.html[`RuntimeHintsRegistrar`] реализации позволяют вам получить обратный вызов к экземпляру RuntimeHints, управляемому Двигатель АОТ.
Реализации этого интерфейса можно зарегистрировать с помощью {spring-framework-api}/context/annotation/ImportRuntimeHints.html[`@ImportRuntimeHints`] для любого bean-компонента Spring или фабричного метода `@Bean`.
Реализации RuntimeHintsRegistrar обнаруживается и вызывается во время сборки.
включаемый код::./SpellCheckService[].
Если это вообще возможно, `@ImportRuntimeHints` следует использовать как можно ближе к компоненту, которому требуются подсказки.
Таким образом, если компонент не добавлен в BeanFactory, подсказки также не будут добавлены.
включаемый код::./SpellCheckService[].
Также можно зарегистрировать реализацию статически, добавив запись в META-INF/spring/aot.factories с ключом, равным полному имени интерфейса RuntimeHintsRegistrar.
`@Reflective`. {spring-framework-api}/aot/hint/annotation/Reflective.html[`@Reflective`] предоставляет идиоматический способ отметить необходимость отражения аннотированного элемента.

Например, `@EventListener` имеет метааннотацию `@Reflective`, поскольку базовая реализация вызывает аннотированный метод с использованием отражения.
`@Reflective`.
По умолчанию рассматриваются только bean-компоненты Spring, но вы можете отказаться от сканирования, используя {spring-framework-api}/context/annotation/ReflectiveScan.html[`@ReflectiveScan`].
В В приведенном ниже примере все типы в пакете com.example.app и его подпакетах являются считается:
включаемый код::./MyConfiguration[].
Сканирование происходит во время обработки AOT, и для рассмотрения типов в целевых пакетах не обязательно иметь аннотацию уровня класса.
При этом выполняется _глубокое сканирование_, и наличие `@Reflective`, напрямую или в виде метааннотации, проверяется в типах, полях, конструкторах, методах и вложенных элементах.
включаемый код::./MyConfiguration[].
По умолчанию @Reflective регистрирует подсказку вызова для аннотированного элемента.
Это можно настроить, указав собственную реализацию ReflectiveProcessor через аннотацию @Reflective.
включаемый код::./MyConfiguration[].
Авторы библиотеки могут повторно использовать эту аннотацию в своих целях.
Пример такой настройки описан в следующем разделе.
`@RegisterReflection`. {spring-framework-api}/aot/hint/annotation/RegisterReflection.html[`@RegisterReflection`] — это специализация `@Reflective`, которая обеспечивает декларативный способ регистрации отражения для произвольных типов.

`@RegisterReflection`.
ПРИМЕЧАНИЕ.
Будучи специализацией `@Reflective`, `@RegisterReflection` также обнаруживается, если вы используете `@ReflectiveScan`.
`@RegisterReflection`.
В следующем примере общедоступные конструкторы и общедоступные методы могут быть вызваны посредством отражения в AccountService: См. пример кода в исходном документе.
`@RegisterReflection` можно применить к любому целевому типу на уровне класса, но его также можно применить непосредственно к методу, чтобы лучше указать, где на самом деле требуются подсказки.
`@RegisterReflection` можно использовать в качестве метааннотации для удовлетворения более конкретных потребностей. {spring-framework-api}/aot/hint/annotation/RegisterReflectionForBinding.html[`@RegisterReflectionForBinding`] — это составная аннотация, мета-аннотированная с помощью `@RegisterReflection` и регистрирующая необходимость сериализации произвольных типов.
Типичным вариантом использования является использование DTO, которые контейнер не может вывести, например использование веб-клиента в теле метода.
`@RegisterReflection`.
В следующем примере регистрируется Order для сериализации.
См. пример кода в исходном документе.
`@RegisterReflection`.
При этом регистрируются подсказки для конструкторов, полей, свойств и компонентов записи Order.
Подсказки также регистрируются для типов, транзитивно используемых в свойствах и компонентах записи.
Другими словами, если Order предоставляет другие типы, подсказки регистрируются и для них.
Подсказки во время выполнения для преобразования на основе соглашений.

Хотя основной контейнер предоставляет встроенную поддержку автоматического преобразования многих общие типы (см.
Spring Type Conversion), некоторые преобразования поддерживаются с помощью алгоритма, основанного на соглашениях и основанного на отражении.
Подсказки во время выполнения для преобразования на основе соглашений.
В частности, если в ConversionService не зарегистрирован явный «Конвертер». для конкретной пары типов источник → целевой внутренний `ObjectToObjectConverter` попытается использовать соглашения для преобразования исходного объекта в целевой тип, делегируя к методу исходного объекта или статическому фабричному методу или конструктору тип цели.
Поскольку этот алгоритм, основанный на соглашениях, можно применять к произвольным типам в во время выполнения основной контейнер не может вывести подсказки времени выполнения, необходимые для поддержки такое размышление.
Подсказки во время выполнения для преобразования на основе соглашений.
Если вы столкнулись с проблемами преобразования на основе соглашений в собственном изображении, возникшими из-за отсутствие подсказок во время выполнения позволяет зарегистрировать необходимые подсказки программно.
Для Например, если вашему приложению требуется преобразование из `java.time.Instant` в `java.sql.Timestamp` и использует `ObjectToObjectConverter` для вызова `java.sql.Timestamp.from(Instant)`, используя отражение, вы можете реализовать собственный RuntimeHintsRegitrar для поддержки этого варианта использования в собственном образе, как показано в следующий пример.
Java
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		ReflectionHints reflectionHints = hints.reflection();

reflectionHints.registerTypeIfPresent(classLoader, "java.sql.Timestamp", hint -> hint
				.withMethod("from", List.of(TypeReference.of(Instant.class)), ExecutableMode.INVOKE)
				.onReachableType(TypeReference.of("java.sql.Timestamp")));
public class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {. `TimestampConversionRuntimeHints` затем можно зарегистрировать декларативно через <<aot.hints.import-runtime-hints>> или статически через `META-INF/spring/aot.factories` файл конфигурации.
public class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {. [ПРИМЕЧАНИЕ] = Вышеупомянутый класс TimestampConversionRuntimeHints представляет собой упрощенную версию Класс ObjectToObjectConverterRuntimeHints, включенный в структуру и зарегистрирован по умолчанию.
public class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {.
Таким образом, этот конкретный вариант использования «Мгновенный переход к временной метке» уже обрабатывается платформой.
Тестирование подсказок во время выполнения.
Spring Core также включает RuntimeHintsPredicates — утилиту для проверки соответствия существующих подсказок конкретному варианту использования.
Это можно использовать в ваших собственных тестах для проверки того, что RuntimeHintsRegistrar дает ожидаемые результаты.
Мы можем написать тест для нашей SpellCheckService и убедиться, что мы сможем загрузить словарь во время выполнения: См. пример кода в исходном документе.
Тестирование подсказок во время выполнения.
С помощью RuntimeHintsPredicates мы можем проверять подсказки по отражению, ресурсам, сериализации или генерации прокси.

Этот подход хорошо работает для модульных тестов, но подразумевает, что поведение компонента во время выполнения хорошо известно.
Тестирование подсказок во время выполнения.
Вы можете узнать больше о глобальном поведении приложения во время выполнения, запустив его набор тестов (или само приложение) с помощью {graalvm-docs}/native-image/metadata/AutomaticMetadataCollection/[агента трассировки GraalVM].
Этот агент будет записывать все соответствующие вызовы, требующие подсказок GraalVM во время выполнения, и записывать их в виде файлов конфигурации JSON.
Тестирование подсказок во время выполнения.
Для более целенаправленного обнаружения и тестирования Spring Framework предоставляет специальный модуль с основными утилитами тестирования AOT, org.springframework:spring-core-test.
Этот модуль содержит агент RuntimeHints, агент Java, который записывает все вызовы методов, связанных с подсказками во время выполнения, и помогает вам утверждать, что данный экземпляр RuntimeHints охватывает все записанные вызовы.
Давайте рассмотрим часть инфраструктуры, для которой мы хотели бы протестировать подсказки, которые мы вносим на этапе обработки AOT.
включаемый код::./SampleReflection[].
Затем мы можем написать модульный тест (нативная компиляция не требуется), который проверяет предоставленные нами подсказки: См. пример кода в исходном документе.
включаемый код::./SampleReflection[].
Если вы забыли добавить подсказку, тест завершится неудачно и предоставит некоторые подробности о вызове:

включаемый код::./SampleReflection[]. org.springframework.docs.core.aot.hints.testing.SampleReflection performReflection ИНФОРМАЦИЯ: Весенняя версия: 6.2.0.
включаемый код::./SampleReflection[].
Missing <"ReflectionHints"> for invocation <java.lang.Class#forName> with arguments ["org.springframework.core.SpringVersion",
    false,
    jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7].
включаемый код::./SampleReflection[].
Stacktrace: <"org.springframework.util.ClassUtils#forName, Line 284 io.spring.runtimehintstesting.SampleReflection#performReflection, Line 19 io.spring.runtimehintstesting.SampleReflectionRuntimeHintsTests#lambda$shouldRegisterReflectionHints$0, Line 25
включаемый код::./SampleReflection[].
Существуют различные способы настройки этого Java-агента в вашей сборке, поэтому обратитесь к документации вашего инструмента сборки и плагина выполнения тестов.
Сам агент можно настроить для инструментирования определенных пакетов (по умолчанию инструментируется только org.springframework).
Более подробную информацию вы найдете в файле {spring-framework-code}/buildSrc/README.md[Spring Framework `buildSrc` README].

Версия API.
Чтобы включить управление версиями API, используйте обратный вызов ApiVersionConfigurer для WebMvcConfigurer: См. пример кода в исходном документе.
Версия API.
Вы можете решить версию с помощью одной из встроенных опций, перечисленных ниже, или в качестве альтернативы используйте собственный ApiVersionResolver:
- Заголовок запроса
- Параметр запроса
- Сегмент пути
- Параметр типа носителя
Версия API.
Для разрешения из сегмента пути необходимо указать индекс ожидаемого сегмента пути. чтобы содержать версию.
Сегмент пути должен быть объявлен как переменная URI, например. «/\{версия}», «/api/\{версия}» и т. д., где фактическое имя не имеет значения.
Поскольку версия обычно находится в начале пути, рассмотрите возможность ее внешней настройки. как общий префикс пути для всех обработчиков через
Версия API.
По умолчанию версия анализируется с помощью SemanticVersionParser, но вы также можете настроить пользовательская ссылка:web/webmvc-versioning.adoc#mvc-versioning-parser[ApiVersionParser].
Версия API.
Поддерживаемые версии прозрачно определяются из версий, объявленных в сопоставлениях запросов. для удобства, но вы можете отключить это с помощью флага в конфигурации MVC и считайте поддерживаемыми только версии, явно настроенные в конфигурации.
Запросы с неподдерживаемой версией отклоняются с помощью `InvalidApiVersionException` приводит к ответу 400.
Версия API.
Вы можете установить ApiVersionDeprecationHandler для отправки информации об устаревших версии для клиентов.

Встроенный стандартный обработчик может установить «Устаревание», «Закат» и Заголовки «Ссылки» на основе https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].
Версия API.
После настройки управления версиями API вы можете начать сопоставлять запросы с согласно версии запроса.

XML-схемы.
В этой части приложения перечислены схемы XML для доступа к данным, включая следующие:
* Схема `tx`
* Схема `jdbc`
Схема `tx`.
Теги `tx` предназначены для настройки всех этих компонентов в рамках комплексной поддержки Spring. для транзакций.
Эти теги описаны в главе, озаглавленной
Схема `tx`.
СОВЕТ: Мы настоятельно рекомендуем вам просмотреть файл `'spring-tx.xsd'`, который поставляется с Весенняя раздача.
Этот файл содержит XML-схему для транзакции Spring. конфигурации и охватывает все различные элементы пространства имен tx, включая значения атрибутов по умолчанию и подобная информация.
Этот файл документирован встроенно, и, таким образом, информация здесь не повторяется в интересах соблюдения СУХОГО (Не Повторите себя) принцип.
Схема `tx`.
В целях полноты, чтобы использовать элементы схемы `tx`, вам необходимо иметь следующую преамбулу в верхней части файла конфигурации Spring XML.
Текст в следующий фрагмент ссылается на правильную схему, поэтому теги в пространстве имен `tx` вам доступны:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

xmlns:tx="http://www.springframework.org/schema/tx" <1>
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd <2>
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<!-- bean definitions here -->
	</beans>
Схема `tx`. <1> Объявить использование пространства имен `tx`. <2> Укажите местоположение (вместе с другими местоположениями схемы).
Схема `tx`.
ПРИМЕЧАНИЕ.
Часто, когда вы используете элементы в пространстве имен `tx`, вы также используете элементы из пространства имен `aop` (поскольку поддержка декларативных транзакций в Spring реализовано с использованием АОП).
Предыдущий фрагмент XML содержит необходимые строки. для ссылки на схему `aop`, чтобы элементы в пространстве имен `aop` были доступны тебе.

Схема `jdbc`.
Элементы `jdbc` позволяют быстро настроить встроенную базу данных или инициализировать существующий источник данных.
Эти элементы описаны в
Схема `jdbc`.
Чтобы использовать элементы схемы `jdbc`, вам необходимо иметь следующую преамбулу в начале: начало вашего XML-файла конфигурации Spring.
Текст в следующих ссылках на фрагменты правильную схему, чтобы элементы пространства имен jdbc были вам доступны:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc" <1>
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/jdbc
			https://www.springframework.org/schema/jdbc/spring-jdbc.xsd"> <2>
		<!-- bean definitions here -->
	</beans>

Схема `jdbc`. <1> Объявите использование пространства имен `jdbc`. <2> Укажите местоположение (вместе с другими местоположениями схемы).

Интеграция с конкретным сервером приложений.
Абстракция транзакций Spring обычно не зависит от сервера приложений.
Кроме того, Класс Spring `JtaTransactionManager` (который может дополнительно выполнять поиск JNDI для объекты JTA UserTransaction и TransactionManager) автоматически определяет местоположение для последний объект, который зависит от сервера приложений.
Имея доступ к JTA `TransactionManager` позволяет улучшить семантику транзакций, в частности: поддержка приостановки транзакции.
См. {spring-framework-api}/transaction/jta/JtaTransactionManager.html[`JtaTransactionManager`] javadoc для получения подробной информации.
Интеграция с конкретным сервером приложений.
Spring `JtaTransactionManager` является стандартным выбором для запуска в приложении Jakarta EE. серверах и, как известно, работает на всех распространенных серверах.
Расширенные функции, такие как приостановка транзакций, также работает на многих серверах (включая GlassFish, JBoss и Geronimo) без необходимости какой-либо специальной настройки.

Шаги запуска приложения.
В этой части приложения перечислены существующие «StartupSteps», которыми оснащен основной контейнер.
Шаги запуска приложения.
ВНИМАНИЕ: Название и подробная информация о каждом этапе запуска не являются частью публичного контракта и может быть изменен; это рассматривается как деталь реализации основного контейнера и будет следовать его поведение меняется.
Шаги запуска приложения, определенные в основном контейнере. |=== | Имя| Описание| Теги
Шаги запуска приложения. | `spring.beans.instantiate` | Создание экземпляра bean-компонента и его зависимостей. | `beanName` — имя компонента, `beanType` — тип, требуемый в точке внедрения.
Шаги запуска приложения. | `spring.beans.smart-initialize` | Инициализация bean-компонентов SmartInitializingSingleton. | `beanName` имя компонента.
Шаги запуска приложения. | `spring.context.base-packages.scan` | Сканирование базовых пакетов. | `packages` массив базовых пакетов для сканирования.
Шаги запуска приложения. | `spring.context.beans.post-process` | Фаза постобработки зерен.
Шаги запуска приложения. | `spring.context.bean-factory.post-process` | Вызов bean-компонентов BeanFactoryPostProcessor. | `postProcessor` текущий постпроцессор.

Шаги запуска приложения. | `spring.context.beandef-registry.post-process` | Вызов bean-компонентов BeanDefinitionRegistryPostProcessor. | `postProcessor` текущий постпроцессор.
Шаги запуска приложения. | `spring.context.comComponent-classes.register` | Регистрация классов компонентов через AnnotationConfigApplicationContext#register. | `classes` массив заданных классов для регистрации.
Шаги запуска приложения. | `spring.context.config-classes.enhance` | Расширение классов конфигурации с помощью прокси CGLIB. | `classCount` — количество расширенных классов.
Шаги запуска приложения. | `spring.context.config-classes.parse` | Фаза анализа классов конфигурации с помощью `ConfigurationClassPostProcessor`. | `classCount` — количество обработанных классов.

Консультирование по транзакционным операциям.
Предположим, вы хотите выполнить как транзакционные операции, так и некоторые базовые рекомендации по профилированию.
Как это сделать в контексте `<tx:annotation-driven/>`?
* Запускается настроенный аспект профилирования.
* Транзакционный совет работает.
* Запускается метод рекомендованного объекта.
* Транзакция фиксируется.
* Аспект профилирования сообщает точную продолжительность всего вызова транзакционного метода.
Когда вы вызываете метод updateFoo(Foo)`, вы хотите увидеть следующие действия:.
ПРИМЕЧАНИЕ.
Эта глава не посвящена подробному объяснению АОП (за исключением применяется к транзакциям).
См.
AOP для подробного описания АОП. конфигурации и АОП в целом.
Java
	package x.y;
	import org.aspectj.lang.ProceedingJoinPoint;
	import org.springframework.util.StopWatch;
	import org.springframework.core.Ordered;
	public class SimpleProfiler implements Ordered {
		private int order;
		// позволяет нам контролировать порядок советов
		public int getOrder() {
			return this.order;
		public void setOrder(int order) {
			this.order = order;
		// этот метод является универсальным советом
		public Object profile(ProceedingJoinPoint call) throws Throwable {
			Object returnValue;
			StopWatch clock = new StopWatch(getClass().getName());
			try {
				clock.start(call.toShortString());
				returnValue = call.proceed();
			} finally {
				clock.stop();

System.out.println(clock.prettyPrint());
			return returnValue;
	package x.y
	class SimpleProfiler : Ordered {
Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.
Заказ консультации управляется через интерфейс Ordered.
Подробную информацию о заказе консультации см.
Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.
Следующая конфигурация создает bean-компонент `fooService`, который имеет профилирование и транзакционные аспекты, применяемые к нему в желаемом порядке:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd

http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<bean id="fooService" class="x.y.service.DefaultFooService"/>
		<!-- this is the aspect -->
		<bean id="profiler" class="x.y.SimpleProfiler">
			<!-- run before the transactional advice (hence the lower order number) -->
			<property name="order" value="1"/>
		</bean>
		<tx:annotation-driven transaction-manager="txManager" order="200"/>
		<aop:config>
				<!-- this advice runs around the transactional advice -->
				<aop:aspect id="profilingAspect" ref="profiler">
					<aop:pointcut id="serviceMethodWithReturnValue"
							expression="execution(!void x.y..*Service.*(..))"/>
					<aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
				</aop:aspect>
		</aop:config>

<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
			<property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
			<property name="username" value="scott"/>
			<property name="password" value="tiger"/>
		</bean>
		<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>
	</beans>
Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.
Вы можете настроить любое количество дополнительных аспектов аналогичным образом.
Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.
В следующем примере создаются те же настройки, что и в двух предыдущих примерах, но используется чисто XML. декларативный подход:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<bean id="fooService" class="x.y.service.DefaultFooService"/>
		<!-- the profiling advice -->
		<bean id="profiler" class="x.y.SimpleProfiler">
			<!-- run before the transactional advice (hence the lower order number) -->
			<property name="order" value="1"/>
		</bean>
		<aop:config>

<aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/>
			<!-- runs after the profiling advice (cf. the order attribute) -->
			<aop:advisor advice-ref="txAdvice" pointcut-ref="entryPointMethod" order="2"/>
			<!-- order value is higher than the profiling aspect -->
			<aop:aspect id="profilingAspect" ref="profiler">
				<aop:pointcut id="serviceMethodWithReturnValue"
						expression="execution(!void x.y..*Service.*(..))"/>
				<aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
			</aop:aspect>
		</aop:config>
		<tx:advice id="txAdvice" transaction-manager="txManager">
			<tx:attributes>
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>
		<!-- other <bean/> definitions such as a DataSource and a TransactionManager here -->
	</beans>

Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.
Результатом предыдущей конфигурации является bean-компонент `fooService`, имеющий профилирование и транзакционные аспекты, применяемые к нему именно в этом порядке.
Если вам нужен совет по профилированию бежать за транзакционным советом по пути и перед транзакционная консультация по выходу, можно поменять стоимость профилирования свойство "order" аспектного компонента, чтобы оно было выше, чем свойство транзакционного совета. стоимость заказа.
Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.
Аналогичным образом можно настроить дополнительные аспекты.

Аргументы метода.
В следующей таблице показаны поддерживаемые аргументы метода контроллера.
Аргументы метода.
Реактивные типы (Reactor, RxJava, или другие) являются поддерживается для аргументов, требующих блокировки ввода-вывода (например, чтения тела запроса) для быть решена.
Это отмечено в столбце «Описание».
Реактивные типы не предполагаются по аргументам, не требующим блокировки.
Аргументы метода.
Java.util.Optional в JDK 1.8 поддерживается как аргумент метода в сочетании с аннотации, имеющие атрибут `required` (например, `@RequestParam`, `@RequestHeader`, и другие) и эквивалентен `required=false`.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `ServerWebExchange` | Доступ к полному контейнеру ServerWebExchange для HTTP-запросов и ответов. атрибуты запроса и сеанса, методы checkNotModified и другие.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `ServerHttpRequest`, `ServerHttpResponse` | Доступ к HTTP-запросу или ответу.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `Веб-сессия` | Доступ к сессии.

Это не приводит к принудительному запуску нового сеанса, если только атрибуты добавляются.
Поддерживает реактивные типы.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `java.security.Principal` | Текущий аутентифицированный пользователь — возможно, определенный класс реализации Principal, если он известен.
Поддерживает реактивные типы.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `org.springframework.http.HttpMethod` | HTTP-метод запроса.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `java.util.Locale` | Текущая локаль запроса, определяемая наиболее конкретным доступным LocaleResolver — в эффект, настроенный LocaleResolver/LocaleContextResolver.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `java.util.TimeZone` + `java.time.ZoneId` | Часовой пояс, связанный с текущим запросом, определенный с помощью LocaleContextResolver.

[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@PathVariable` | Для доступа к переменным шаблона URI.
См. ссылку:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-uri-templates [Шаблоны URI].
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@MatrixVariable` | Для доступа к парам имя-значение в сегментах пути URI.
См. ссылку:web/webflux/controller/ann-methods/matrix-variables.adoc [Матричные переменные].
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@RequestParam` | Для доступа к параметрам запроса.
Значения параметров преобразуются в объявленный аргумент метода. тип.
См. ссылку:web/webflux/controller/ann-methods/requestparam.adoc[`@RequestParam`].
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание.
Обратите внимание, что использование @RequestParam не является обязательным — например, для установки его атрибутов.

См. раздел «Любой другой аргумент» ниже в этой таблице.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@RequestHeader` | Для доступа к заголовкам запросов.
Значения заголовка преобразуются в объявленный аргумент метода. тип.
См. ссылку:web/webflux/controller/ann-methods/requestheader.adoc[`@RequestHeader`].
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@CookieValue` | Для доступа к файлам cookie.
Значения файлов cookie преобразуются в объявленный тип аргумента метода.
См. ссылку:web/webflux/controller/ann-methods/cookievalue.adoc[`@CookieValue`].
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@RequestBody` | Для доступа к телу HTTP-запроса.
Содержимое тела преобразуется в объявленный метод. тип аргумента с использованием экземпляров HttpMessageReader.
Поддерживает реактивные типы.
См. ссылку:web/webflux/controller/ann-methods/requestbody.adoc[`@RequestBody`].

[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `HttpEntity<B>` | Для доступа к заголовкам и телу запроса.
Тело преобразуется с помощью экземпляров HttpMessageReader.
Поддерживает реактивные типы.
См. ссылку:web/webflux/controller/ann-methods/httpentity.adoc[`HttpEntity`].
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@RequestPart` | Для доступа к части запроса multipart/form-data.
Поддерживает реактивные типы.
См.
Многочастный контент и Многочастные данные.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `java.util.Map` или `org.springframework.ui.Model` | Для доступа к модели, которая используется в контроллерах HTML и предоставляется шаблонам как часть рендеринга представления.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@ModelAttribute` | Для доступа к существующему атрибуту в модели (созданному, если он отсутствует) с помощью применена привязка и проверка данных.

См. также ссылку:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[`@ModelAttribute`] как `Model` и `DataBinder`.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание.
Обратите внимание, что использование @ModelAttribute не является обязательным — например, для установки его атрибутов.
См. раздел «Любой другой аргумент» ниже в этой таблице.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `Ошибки` или `BindingResult` | Для доступа к ошибкам проверки и привязки данных для объекта команды, т.е.
Аргумент `@ModelAttribute`.
Должен быть объявлен аргумент `Errors` или `BindingResult`. сразу после проверенного аргумента метода.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `SessionStatus` + `@SessionAttributes` уровня класса | Для маркировки завершения обработки формы, что приводит к очистке атрибутов сеанса. объявлен через аннотацию @SessionAttributes на уровне класса.
Дополнительную информацию см. в `@SessionAttributes`.

[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `UriComponentsBuilder` | Для подготовки URL-адреса относительно хоста, порта, схемы и контекстный путь.
См. ссылки URI.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@SessionAttribute` | Для доступа к любому атрибуту сеанса — в отличие от атрибутов модели, хранящихся в сеансе. в результате объявления `@SessionAttributes` на уровне класса.
См.
[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | `@RequestAttribute` | Для доступа к атрибутам запроса.
Дополнительную информацию см. в `@RequestAttribute`.

[cols="1,2", options="header"] |=== | Аргумент метода контроллера | Описание. | Любой другой аргумент | Если аргумент метода не соответствует ни одному из вышеперечисленных, он по умолчанию разрешается как `@RequestParam`, если это простой тип, как определено {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty], или как `@ModelAttribute`, в противном случае. |===

Построение массива.
Вы можете создавать массивы, используя знакомый синтаксис Java, при необходимости предоставляя инициализатор. чтобы массив был заполнен во время построения.
В следующем примере показано, как это сделать:
Java
	int[] numbers1 = (int[]) parser.parseExpression("new int[4]").getValue(context);
	// Массив с инициализатором
	int[] numbers2 = (int[]) parser.parseExpression("new int[] {1, 2, 3}").getValue(context);
	// Многомерный массив
	int[][] numbers3 = (int[][]) parser.parseExpression("new int[4][5]").getValue(context);
Построение массива. [ПРИМЕЧАНИЕ] = В настоящее время вы не можете предоставить инициализатор при создании многомерного массива.
Построение массива. [ВНИМАНИЕ] = Любое выражение, создающее массив, например, через `new int[4]` или `new int[] {1, 2, 3}` – невозможно скомпилировать.
См. для получения подробной информации.

Программное создание прокси @AspectJ.
В дополнение к объявлению аспектов в вашей конфигурации с помощью `<aop:config>` или `<aop:aspectj-autoproxy>`, также можно программно создавать прокси которые советуют целевые объекты.
Полную информацию о Spring AOP API см. создавать прокси, используя аспекты @AspectJ.
Программное создание прокси @AspectJ.
Вы можете использовать класс org.springframework.aop.aspectj.annotation.AspectJProxyFactory. для создания прокси для целевого объекта, которому соответствует один или несколько аспектов @AspectJ.
Базовое использование этого класса очень просто, как показано в следующем примере:
Java
	// создаем фабрику, которая может генерировать прокси для данного целевого объекта
	AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);
	// добавьте аспект, класс должен быть аспектом @AspectJ
	// вы можете вызывать это столько раз, сколько вам нужно с разными аспектами
	factory.addAspect(SecurityManager.class);
	// вы также можете добавить существующие экземпляры аспектов, тип предоставленного объекта
	// должен быть аспектом @AspectJ
	factory.addAspect(usageTracker);
	// теперь получите прокси-объект...
	MyInterfaceType proxy = factory.getProxy();
	// вы также можете добавить существующие экземпляры аспектов, тип предоставленного объекта
	// должен быть аспектом @AspectJ
	factory.addAspect(usageTracker)
Программное создание прокси @AspectJ.

Дополнительную информацию см. в {spring-framework-api}/aop/aspectj/annotation/AspectJProxyFactory.html[javadoc].

Включение поддержки @AspectJ.
Чтобы использовать аспекты @AspectJ в конфигурации Spring, вам необходимо включить поддержку Spring для настройка Spring AOP на основе аспектов @AspectJ и автоматических прокси-компонентов на основе независимо от того, советуют ли им эти аспекты.
Под автоматическим проксированием мы подразумеваем, что если Spring определяет, что компоненту соответствует один или несколько аспектов, он автоматически генерирует прокси-сервер для этого bean-компонента для перехвата вызовов методов и обеспечения выполнения рекомендаций по мере необходимости.
Включение поддержки @AspectJ.
Поддержку @AspectJ можно включить с помощью программной конфигурации или конфигурации XML.
В любом В этом случае вам также необходимо убедиться, что библиотека AspectJ `org.aspectj:aspectjweaver` находится на путь к классам вашего приложения (версия 1.9 или новее).
См. пример кода в исходном документе.

Использование `@Transactional` с AspectJ.
Вы также можете использовать поддержку `@Transactional` Spring Framework вне Spring. контейнер с помощью аспекта AspectJ.
Для этого сначала аннотируйте свои классы (и, возможно, методы ваших классов) с аннотацией @Transactional, а затем свяжите (свяжите) свое приложение с `org.springframework.transaction.aspectj.AnnotationTransactionAspect`, определенный в файл `spring-aspects.jar`.
Также необходимо настроить аспект с транзакцией менеджер.
Вы можете использовать контейнер IoC Spring Framework, чтобы позаботиться о внедрение аспекта зависимости.
Самый простой способ настройки транзакции аспект управления заключается в использовании элемента `<tx:annotation-driven/>` и указании Атрибут `mode` для `aspectj`, как описано в Поскольку здесь мы фокусируемся на приложениях, которые работают вне контейнера Spring, мы покажем вам, как это сделать программно.
ПРИМЕЧАНИЕ.
Прежде чем продолжить, вы можете прочитать.
В следующем примере показано, как создать диспетчер транзакций и настроить `AnnotationTransactionAspect`, чтобы использовать его:
Java
	// создаем соответствующий менеджер транзакций
	DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());
	// настройте AnnotationTransactionAspect для его использования; это необходимо сделать перед выполнением любых транзакционных методов
	AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);
	// настройте AnnotationTransactionAspect для его использования; это необходимо сделать перед выполнением любых транзакционных методов
	AnnotationTransactionAspect.aspectOf().transactionManager = txManager

ПРИМЕЧАНИЕ.
Прежде чем продолжить, вы можете прочитать.
ПРИМЕЧАНИЕ.
Когда вы используете этот аспект, вы должны аннотировать класс реализации (или методы внутри этого класса или обоих), а не интерфейс (если таковой имеется), который реализует класс.
АспектJ следует правилу Java, согласно которому аннотации интерфейсов не наследуются.
ПРИМЕЧАНИЕ.
Прежде чем продолжить, вы можете прочитать.
Аннотация `@Transactional` в классе определяет семантику транзакции по умолчанию. для выполнения любого публичного метода в классе.
ПРИМЕЧАНИЕ.
Прежде чем продолжить, вы можете прочитать.
Аннотация `@Transactional` для метода внутри класса переопределяет стандартную аннотацию. семантика транзакции, заданная аннотацией класса (если присутствует).
Вы можете аннотировать любой метод, независимо от видимости.
ПРИМЕЧАНИЕ.
Прежде чем продолжить, вы можете прочитать.
Чтобы объединить ваши приложения с AnnotationTransactionAspect, вам необходимо либо создать ваше приложение с помощью AspectJ (см. {aspectj-docs-devguide}/index.html[AspectJ Development Guide]) или используйте переплетение во время загрузки.
См. для обсуждения переплетения времени загрузки с AspectJ.

Объявление аспекта.
Если включена поддержка @AspectJ, любой компонент, определенный в контексте вашего приложения с помощью класс, который является аспектом @AspectJ (имеет аннотацию @Aspect), автоматически обнаруживается Spring и используется для настройки Spring AOP.
Следующие два примера демонстрируют минимальные шаги, необходимые для не очень полезного аспекта.
Объявление аспекта.
В первом из двух примеров показано определение обычного компонента в контексте приложения. который указывает на класс bean-компонента, помеченный @Aspect: См. пример кода в исходном документе.
Объявление аспекта.
Во втором из двух примеров показано определение класса NotVeryUsefulAspect, которое с аннотацией `@Aspect`: См. пример кода в исходном документе.
Объявление аспекта.
Аспекты (классы, помеченные `@Aspect`) могут иметь методы и поля, такие же, как и любые другие. другой класс.
Они также могут содержать метки, советы и введение (межтиповые). декларации.
Объявление аспекта. .Автоопределение аспектов посредством сканирования компонентов ПРИМЕЧАНИЕ.
Вы можете зарегистрировать классы аспектов как обычные bean-компоненты в конфигурации Spring XML. через методы `@Bean` в классах `@Configuration` или заставить Spring автоматически определять их через сканирование пути к классам — то же самое, что и любой другой компонент, управляемый Spring.
Однако обратите внимание, что Аннотации `@Aspect` недостаточно для автоматического обнаружения в пути к классам.

Для этого Для этой цели вам необходимо добавить отдельную аннотацию `@Component` (или, альтернативно, собственный стереотипная аннотация, которая соответствует правилам сканера компонентов Spring).
Объявление аспекта. .Консультируете аспекты с другими аспектами?
ПРИМЕЧАНИЕ.
В Spring AOP аспекты сами по себе не могут быть объектом советов от других аспекты.
Аннотация `@Aspect` к классу отмечает его как аспект и, следовательно, исключает это от автопроксирования.

Поддержка @AspectJ. @AspectJ относится к стилю объявления аспектов как обычных классов Java, аннотированных аннотации.
Стиль @AspectJ был представлен {aspectj-site}[проект AspectJ] как часть версии AspectJ 5.
Весна интерпретирует те же аннотации, что и AspectJ 5, используя библиотеку, предоставленную AspectJ. для анализа и сопоставления точек.
Однако среда выполнения AOP по-прежнему представляет собой чистый Spring AOP, и нет зависимости от компилятора AspectJ или weaver.
Поддержка @AspectJ.
ПРИМЕЧАНИЕ.
Использование компилятора AspectJ и программы Weaver позволяет использовать полную версию языка AspectJ и обсуждается в Использование AspectJ с приложениями Spring.

Использование функции «автопрокси».
До сих пор мы рассматривали явное создание прокси АОП с помощью ProxyFactoryBean или аналогичный фабричный боб.
Использование функции «автопрокси».
Spring также позволяет нам использовать определения bean-компонентов «автопрокси», которые могут автоматически прокси-определения выбранных компонентов.
Он построен на основе «постпроцессора bean-компонентов» Spring. инфраструктура, которая позволяет изменять определение любого компонента по мере загрузки контейнера.
Использование функции «автопрокси».
В этой модели вы настраиваете некоторые специальные определения bean-компонентов в файле определения bean-компонентов XML. для настройки инфраструктуры автопрокси.
Это позволяет вам объявить цели имеет право на автоматическое проксирование.
Вам не нужно использовать ProxyFactoryBean.
* С помощью создателя автоматического прокси, который ссылается на определенные bean-компоненты в текущем контексте.
* Особый случай создания автопрокси, заслуживающий отдельного рассмотрения:
Есть два способа сделать это:. автоматическое создание прокси, управляемое атрибутами метаданных на уровне источника.
Определения компонентов автопрокси.
В этом разделе описаны создатели автоматических прокси, предоставляемые Пакет `org.springframework.aop.framework.autoproxy`.
`BeanNameAutoProxyCreator`.
Класс BeanNameAutoProxyCreator — это BeanPostProcessor, который автоматически создает Прокси-серверы АОП для компонентов с именами, которые соответствуют литеральным значениям или подстановочным знакам.
Следующие пример показывает, как создать bean-компонент `BeanNameAutoProxyCreator`:
	<bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">

<property name="beanNames" value="jdk*,onlyJdk"/>
		<property name="interceptorNames">
			<list>
				<value>myInterceptor</value>
			</list>
		</property>
	</bean>
`BeanNameAutoProxyCreator`.
Как и в случае с ProxyFactoryBean, здесь имеется свойство interceptorNames, а не список. перехватчиков, чтобы обеспечить правильное поведение советников-прототипов.
Названы «перехватчиками» могут быть советниками или советами любого типа.
`BeanNameAutoProxyCreator`.
Как и в случае с автоматическим проксированием, основной смысл использования BeanNameAutoProxyCreator заключается в последовательно применять одну и ту же конфигурацию к нескольким объектам с минимальным объемом конфигурация.
Это популярный выбор для применения декларативных транзакций к нескольким объекты.
`BeanNameAutoProxyCreator`.
Определения компонентов, имена которых совпадают, например `jdkMyBean` и `onlyJdk` в предыдущем примере.
Например, это простые старые определения bean-компонентов с целевым классом.
Прокси-сервер АОП — это автоматически создается с помощью BeanNameAutoProxyCreator.
Тот же совет применяется ко всем совпадающим бобам.
Обратите внимание, что если используются советники (а не перехватчик в предыдущий пример), pointcuts могут по-разному применяться к разным компонентам.
`DefaultAdvisorAutoProxyCreator`.
Более общий и чрезвычайно мощный инструмент автоматического создания прокси — `DefaultAdvisorAutoProxyCreator`.
Это автоматически применяет подходящих советников в текущий контекст, без необходимости включать конкретные имена компонентов в автоматический прокси определение компонента советника.

Он предлагает те же преимущества последовательной конфигурации и избежание дублирования как `BeanNameAutoProxyCreator`.
* Указание определения bean-компонента `DefaultAdvisorAutoProxyCreator`.
* Указание любого количества советников в том же или связанных контекстах. Обратите внимание, что эти
Использование этого механизма предполагает:. должны быть советниками, а не перехватчиками или другими советчиками.
Это необходимо, потому что должна быть точка для оценки, проверки приемлемости каждого совета к определениям потенциальных компонентов.
Использование этого механизма предполагает:. `DefaultAdvisorAutoProxyCreator` автоматически оценивает содержащийся pointcut. в каждом советнике, чтобы увидеть, какой совет (если таковой имеется) следует применить к каждому бизнес-объекту. (например, businessObject1 и businessObject2 в примере).
Использование этого механизма предполагает:.
Это означает, что любое количество советников может быть автоматически применено к каждому бизнесу. объект.
Если ни один pointcut ни в одном из советников не соответствует какому-либо методу бизнес-объекта, объект не проксирован.
Поскольку определения компонентов добавляются для новых бизнес-объектов, при необходимости они автоматически проксируются.
Использование этого механизма предполагает:.
Преимущество автоматического проксирования в целом состоит в том, что оно делает невозможным для вызывающих абонентов или зависимости для получения непредусмотренного объекта.
Вызов `getBean("businessObject1")` для этого `ApplicationContext` возвращает прокси-сервер AOP, а не целевой бизнес-объект. («Внутренний Идиома bean`", показанная ранее, также предлагает это преимущество.)

Использование этого механизма предполагает:.
В следующем примере создается bean-компонент DefaultAdvisorAutoProxyCreator, а другой — элементы, обсуждаемые в этом разделе:
	<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>
	<bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor">
		<property name="transactionInterceptor" ref="transactionInterceptor"/>
	</bean>
	<bean id="customAdvisor" class="com.mycompany.MyAdvisor"/>
	<bean id="businessObject1" class="com.mycompany.BusinessObject1">
		<!-- Properties omitted -->
	</bean>
	<bean id="businessObject2" class="com.mycompany.BusinessObject2"/>
Использование этого механизма предполагает:. `DefaultAdvisorAutoProxyCreator` очень полезен, если вы хотите применить тот же совет. последовательно для многих бизнес-объектов.
Как только определения инфраструктуры будут готовы, вы можете добавлять новые бизнес-объекты, не включая специальную конфигурацию прокси.
Вы также можете легко добавить дополнительные аспекты (например, отслеживание или аспекты мониторинга производительности) с минимальными изменениями в конфигурации.
Использование этого механизма предполагает:. `DefaultAdvisorAutoProxyCreator` предлагает поддержку фильтрации (с использованием именования). соглашение, согласно которому оцениваются только определенные советники, что позволяет использовать несколько, настроены по-разному, AdvisorAutoProxyCreators на одной фабрике) и упорядочивание.

Консультанты могут реализовать интерфейс org.springframework.core.Ordered, чтобы гарантировать правильный порядок, если это проблема.
TransactionAttributeSourceAdvisor, используемый в предыдущий пример имеет настраиваемое значение порядка.
Настройка по умолчанию неупорядочена.

Точная настройка автоматического связывания на основе аннотаций с помощью `@Primary` или `@Fallback`
Поскольку автоматическое подключение по типу может привести к появлению нескольких кандидатов, часто необходимо иметь больший контроль над процессом выбора.
Один из способов добиться этого — использовать Spring Аннотация `@Primary`. `@Primary` указывает, что следует передать конкретный bean-компонент предпочтение, когда несколько bean-компонентов являются кандидатами на автоматическое подключение к однозначному зависимость.
Если среди кандидатов существует ровно один первичный компонент, он становится автоматически устанавливаемое значение.
Рассмотрим следующую конфигурацию, которая определяет `firstMovieCatalog` как основной `MovieCatalog`:
Java
	@Configuration
	public class MovieConfiguration {
		@Bean
		@Primary
		public MovieCatalog firstMovieCatalog() { ... }
		@Bean
		public MovieCatalog secondMovieCatalog() { ... }
	@Configuration
	class MovieConfiguration {
В качестве альтернативы, начиная с версии 6.2, существует аннотация @Fallback для разграничения. любые бобы, кроме обычных, которые нужно вводить.
Если бы только один постоянный bean-компонент остался, он также фактически является первичным:
Java
	@Configuration
	public class MovieConfiguration {
		@Bean
		public MovieCatalog firstMovieCatalog() { ... }
		@Bean
		@Fallback
		public MovieCatalog secondMovieCatalog() { ... }
	@Configuration
	class MovieConfiguration {
В обоих вариантах предыдущей конфигурации следующее «MovieRecommender» автоматически подключается к «firstMovieCatalog»:
Java
	public class MovieRecommender {
		@Autowired
		private MovieCatalog movieCatalog;

<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<context:annotation-config/>
		<bean class="example.SimpleMovieCatalog" primary="true">
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean class="example.SimpleMovieCatalog">
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean id="movieRecommender" class="example.MovieRecommender"/>
	</beans>

Точная настройка автоматического связывания на основе аннотаций с квалификаторами. `@Primary` и `@Fallback` — эффективные способы использования автоматического связывания по типу с несколькими случаи, когда может быть определен один основной (или нерезервный) кандидат.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Если вам нужен больший контроль над процессом выбора, вы можете использовать Spring `@Qualifier`. аннотация.
Вы можете связать значения квалификаторов с конкретными аргументами, сужая набор типа совпадает, так что для каждого аргумента выбирается конкретный bean-компонент.
В простейшем случае это может быть простое описательное значение, как показано в следующем примере:
Java
	public class MovieRecommender {
		@Autowired
		@Qualifier("main")
		private MovieCatalog movieCatalog;
	class MovieRecommender {
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Вы также можете указать аннотацию @Qualifier для отдельных аргументов конструктора или параметры метода, как показано в следующем примере:
Java
	public class MovieRecommender {
		private final MovieCatalog movieCatalog;
		private final CustomerPreferenceDao customerPreferenceDao;
		@Autowired
		public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
	class MovieRecommender {
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
В следующем примере показаны соответствующие определения bean-компонентов.
	<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<context:annotation-config/>
		<bean class="example.SimpleMovieCatalog">
			<qualifier value="main"/> <1>
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean class="example.SimpleMovieCatalog">
			<qualifier value="action"/> <2>
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean id="movieRecommender" class="example.MovieRecommender"/>
	</beans>

Точная настройка автоматического связывания на основе аннотаций с квалификаторами. <1> Компонент со значением квалификатора `main` связан с аргументом конструктора, который квалифицируется с тем же значением. <2> Компонент со значением квалификатора action связан с аргументом конструктора, который квалифицируется с тем же значением.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Для резервного соответствия имя компонента считается значением квалификатора по умолчанию.
Таким образом, вы можно определить компонент с идентификатором `main` вместо вложенного квалификатора, что приводит к к тому же результату сопоставления.
Однако, хотя вы можете использовать это соглашение для ссылки на конкретных bean-компонентов по имени, `@Autowired` по сути представляет собой внедрение на основе типов с помощью необязательные семантические квалификаторы.
Это означает, что значения квалификаторов, даже с именем компонента запасной вариант всегда имеет сужающую семантику в наборе совпадений типов.
Они не семантически выразить ссылку на уникальный идентификатор компонента.
Хорошие значения квалификатора — `main` или «EMEA», или «постоянный», выражающий характеристики конкретного компонента, которые независимо от идентификатора bean-компонента, который может быть сгенерирован автоматически в случае анонимного bean-компонента определение, подобное приведенному в предыдущем примере.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Квалификаторы также применимы к типизированным коллекциям, как обсуждалось ранее, например, к `Set<MovieCatalog>`.

В этом случае все соответствующие bean-компоненты, согласно заявленному квалификаторы вводятся как коллекция.
Это означает, что квалификаторы не обязательно должны быть уникальный.
Скорее, они представляют собой критерии фильтрации.
Например, вы можете определить несколько bean-компонентов `MovieCatalog` с одинаковым значением квалификатора ``action``, все из которых введенный в `Set<MovieCatalog>` с аннотацией `@Qualifier("action")`.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами. [СОВЕТ] = Разрешение значениям квалификатора выбирать имена целевых компонентов в рамках сопоставления типов. кандидатов, не требует аннотации @Qualifier в точке внедрения.
Если нет другого индикатора разрешения (например, квалификатора или основного маркера), для неуникальной ситуации зависимости Spring соответствует имени точки внедрения (то есть имя поля или имя параметра) против имен целевых компонентов и выбирает кандидат с тем же именем, если таковой имеется (либо по имени компонента, либо по связанному псевдониму).
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Начиная с версии 6.1, для этого требуется наличие флага компилятора Java `-parameters`.
Начиная с версии 6.2, контейнер применяет быстрое разрешение ярлыков для совпадений имен компонентов. обход алгоритма полного сопоставления типов, когда имя параметра соответствует имени имя компонента и отсутствие типа, квалификатора или основных условий переопределяют совпадение.
Это поэтому рекомендуется, чтобы имена ваших параметров соответствовали именам целевых компонентов.

Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
В качестве альтернативы внедрению по имени рассмотрите аннотацию JSR-250 `@Resource`. который семантически определен для идентификации конкретного целевого компонента по его уникальному имени, при этом объявленный тип не имеет значения для процесса сопоставления. `@Autowired` имеет скорее различная семантика: после выбора компонентов-кандидатов по типу указанная `String` Значение квалификатора учитывается только среди кандидатов, выбранных по типу (например, сопоставление квалификатора account с компонентами, отмеченными той же меткой квалификатора).
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Для bean-компонентов, которые сами определены как коллекция, Map или массив, @Resource. является прекрасным решением, ссылающимся на конкретную коллекцию или массив по уникальному имени.
Тем не менее, вы можете сопоставлять типы коллекций, Map и массивов с помощью Spring.
Алгоритм сопоставления типов `@Autowired` также, если информация о типе элемента сохраняется в сигнатурах возвращаемого типа @Bean или иерархиях наследования коллекций.
В этом случае вы можете использовать значения квалификаторов для выбора среди однотипных коллекций. как указано в предыдущем пункте.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами. `@Autowired` также учитывает ссылки на себя для внедрения (то есть ссылки на себя). bean-компонент, который в данный момент внедряется).
См. для получения подробной информации.

Точная настройка автоматического связывания на основе аннотаций с квалификаторами. `@Autowired` применяется к полям, конструкторам и методам с несколькими аргументами, позволяя сужение за счет аннотаций квалификаторов на уровне параметра.
Напротив, `@Resource` поддерживается только для полей и методов установки свойств компонента с одним аргументом.
Как следствие, вам следует придерживаться квалификаторов, если ваша цель инъекции — конструктор или метод с несколькими аргументами.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Вы можете создавать свои собственные аннотации квалификаторов.
Для этого определите аннотацию и укажите аннотацию @Qualifier в своем определении, как показано в следующем примере:
Java
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface Genre {
		String value();
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Затем вы можете указать пользовательский квалификатор для полей и параметров с автоматическим связыванием, как следующий пример показывает:
Java
	public class MovieRecommender {
		@Autowired
		@Genre("Action")
		private MovieCatalog actionCatalog;
		private MovieCatalog comedyCatalog;
		@Autowired
		public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
			this.comedyCatalog = comedyCatalog;
	class MovieRecommender {
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
Далее вы можете предоставить информацию для определений потенциальных компонентов.

Вы можете добавить Теги `<qualifier/>` являются подэлементами тега `<bean/>`, а затем указывают `type` и `value`, чтобы соответствовать вашим пользовательским аннотациям квалификатора.
Тип соответствует полное имя класса аннотации.
Альтернативно, для удобства, если нет риска существуют конфликтующие имена, вы можете использовать короткое имя класса.
Следующий пример демонстрирует оба подхода:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<context:annotation-config/>
		<bean class="example.SimpleMovieCatalog">
			<qualifier type="Genre" value="Action"/>

<!-- inject any dependencies required by this bean -->
		</bean>
		<bean class="example.SimpleMovieCatalog">
			<qualifier type="example.Genre" value="Comedy"/>
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean id="movieRecommender" class="example.MovieRecommender"/>
	</beans>
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
В Сканирование путей к классам и управляемые компоненты вы можете увидеть альтернативу на основе аннотаций предоставление метаданных квалификатора в XML.
В частности, см.
Предоставление метаданных квалификаторов с аннотациями.
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.
В некоторых случаях может быть достаточно использования аннотации без значения.
Это может быть полезно, когда аннотация служит более общей цели и может применяться ко всем несколько различных типов зависимостей.
Например, вы можете предоставить офлайн-версию каталог, в котором можно осуществлять поиск при отсутствии подключения к Интернету.
Сначала определите простая аннотация, как показано в следующем примере:
Java
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface Offline {
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class Offline
Точная настройка автоматического связывания на основе аннотаций с квалификаторами.

Затем добавьте аннотацию к полю или свойству, которое необходимо автоматически связать, как показано на рисунке. следующий пример:
Java
	public class MovieRecommender {
		@Autowired
		@Offline // <1>
		private MovieCatalog offlineCatalog;
Точная настройка автоматического связывания на основе аннотаций с квалификаторами. <1> Эта строка добавляет аннотацию `@Offline`.
class MovieRecommender {. <1> Эта строка добавляет аннотацию `@Offline`.
class MovieRecommender {.
Теперь для определения bean-компонента требуется только квалификатор type, как показано в следующем примере:
	<bean class="example.SimpleMovieCatalog">
		<qualifier type="Offline"/> <1>
		<!-- inject any dependencies required by this bean -->
	</bean>
class MovieRecommender {. <1> Этот элемент определяет квалификатор.
class MovieRecommender {.
Вы также можете определить пользовательские аннотации квалификаторов, которые принимают именованные атрибуты в дополнение или вместо простого атрибута `value`.
Если несколько значений атрибута затем указано в поле или параметре для автоматического подключения, определение компонента должно соответствовать все такие значения атрибутов следует рассматривать как кандидаты для автоматического связывания.
В качестве примера: рассмотрим следующее определение аннотации:
Java
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface MovieQualifier {
		String genre();
		Format format();
Java
	public enum Format {

VHS, DVD, BLURAY
	enum class Format {
		VHS, DVD, BLURAY
В данном случае «Формат» — это перечисление, определенное следующим образом:.
Поля, подлежащие автоматической привязке, помечаются пользовательским квалификатором и включают значения. для обоих атрибутов: «жанр» и «формат», как показано в следующем примере:
Java
	public class MovieRecommender {
		@Autowired
		@MovieQualifier(format=Format.VHS, genre="Action")
		private MovieCatalog actionVhsCatalog;
		@Autowired
		@MovieQualifier(format=Format.VHS, genre="Comedy")
		private MovieCatalog comedyVhsCatalog;
		@Autowired
		@MovieQualifier(format=Format.DVD, genre="Action")
		private MovieCatalog actionDvdCatalog;
		@Autowired
		@MovieQualifier(format=Format.BLURAY, genre="Comedy")
		private MovieCatalog comedyBluRayCatalog;
	class MovieRecommender {
В данном случае «Формат» — это перечисление, определенное следующим образом:.
Наконец, определения bean-компонентов должны содержать соответствующие значения квалификаторов.
Этот пример также демонстрирует, что вы можете использовать метаатрибуты компонента вместо Элементы `<квалификатор/>`.
Если доступен, элемент `<qualifier/>` и его атрибуты принимают приоритет, но механизм автоматического подключения использует значения, указанные в `<meta/>` теги, если такой квалификатор отсутствует, как в двух последних определениях bean-компонентов в следующий пример:

<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<context:annotation-config/>
		<bean class="example.SimpleMovieCatalog">
			<qualifier type="MovieQualifier">
				<attribute key="format" value="VHS"/>
				<attribute key="genre" value="Action"/>
			</qualifier>
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean class="example.SimpleMovieCatalog">
			<qualifier type="MovieQualifier">
				<attribute key="format" value="VHS"/>

<attribute key="genre" value="Comedy"/>
			</qualifier>
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean class="example.SimpleMovieCatalog">
			<meta key="format" value="DVD"/>
			<meta key="genre" value="Action"/>
			<!-- inject any dependencies required by this bean -->
		</bean>
		<bean class="example.SimpleMovieCatalog">
			<meta key="format" value="BLURAY"/>
			<meta key="genre" value="Comedy"/>
			<!-- inject any dependencies required by this bean -->
		</bean>
	</beans>

Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Аннотацию `@Inject` JSR 330 можно использовать вместо аннотации Spring `@Autowired` в примеры включены в этот раздел.
Дополнительную информацию см. в здесь.
Использование `@Autowired`.
Вы можете применить аннотацию @Autowired к конструкторам, как показано в следующем примере:
Java
	public class MovieRecommender {
		private final CustomerPreferenceDao customerPreferenceDao;
		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
Использование `@Autowired`. [СОВЕТ] = Аннотация `@Autowired` для такого конструктора не требуется, если целевой компонент определяет только один конструктор.
Однако если доступно несколько конструкторов и есть нет основного конструктора или конструктора по умолчанию, хотя бы один из конструкторов должен быть аннотирован с `@Autowired`, чтобы указать контейнеру, какой из них использовать.
Посмотреть обсуждение по ссылке:core/beans/annotation-config/autowired.adoc#beans-autowired-annotation-constructor-solve [разрешение конструктора] для получения подробной информации.
Использование `@Autowired`.
Вы можете применить аннотацию `@Autowired` к _традиционным_ методам установки, так как следующий пример показывает:
Java
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Autowired
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
	class SimpleMovieLister {
Использование `@Autowired`.

Вы можете применить `@Autowired` к методам с произвольными именами и несколькими аргументами, как следующий пример показывает:
Java
	public class MovieRecommender {
		private MovieCatalog movieCatalog;
		private CustomerPreferenceDao customerPreferenceDao;
		@Autowired
		public void prepare(MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
	class MovieRecommender {
Использование `@Autowired`.
Вы также можете применить `@Autowired` к полям и даже смешать его с конструкторами, поскольку следующий пример показывает:
Java
	public class MovieRecommender {
		private final CustomerPreferenceDao customerPreferenceDao;
		@Autowired
		private MovieCatalog movieCatalog;
		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
Использование `@Autowired`. [СОВЕТ] = Убедитесь, что ваши целевые компоненты (например, MovieCatalog или CustomerPreferenceDao) последовательно объявляются по типу, который вы используете для аннотированных `@Autowired` точки инъекции.
В противном случае внедрение может завершиться неудачей из-за ошибки «совпадение типа не найдено» в время выполнения.
Использование `@Autowired`.
Для XML-определенных bean-компонентов или классов компонентов, найденных с помощью сканирования пути к классам, контейнер обычно заранее знает тип бетона.
Однако для фабричных методов `@Bean` вам необходимо чтобы убедиться, что объявленный возвращаемый тип достаточно выразителен.

Для компонентов которые реализуют несколько интерфейсов или для компонентов, потенциально упоминаемых их типа реализации, объявите наиболее конкретный тип возвращаемого значения в вашем фабричном методе (по адресу по крайней мере настолько конкретно, насколько того требуют точки инъекции, относящиеся к вашему компоненту).
Использование `@Autowired`. .[[beans-autowired-annotation-self-injection]]Самовнедрение **** `@Autowired` также учитывает ссылки на себя для внедрения (то есть ссылки на себя). bean-компонент, который в данный момент внедряется).
Использование `@Autowired`.
Однако обратите внимание, что самоинъекция — это запасной механизм.
Регулярная зависимость от других компоненты всегда имеют приоритет.
В этом смысле ссылки на себя не участвуют в регулярный выбор кандидатов для автоматического подключения и поэтому никогда не являются первичными.
Вкл. наоборот, они всегда имеют самый низкий приоритет.
Использование `@Autowired`.
На практике ссылки на себя следует использовать только в крайнем случае – например, для вызов других методов в том же экземпляре через транзакционный прокси компонента.
Как Альтернативно, рассмотрите возможность выделения затронутых методов в отдельный компонент-делегат в такой сценарий.
Использование `@Autowired`.
Другой альтернативой является использование `@Resource`, который может получить прокси обратно к текущему bean по своему уникальному имени.

Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Попытка внедрить результаты методов `@Bean` в тот же класс `@Configuration` по сути, это также сценарий самореференции.
Либо лениво разрешать такие ссылки в сигнатуре метода там, где это действительно необходимо (в отличие от автоматически подключаемого поля в классе конфигурации) или объявить затронутые методы `@Bean` как `статические`, отделение их от содержащего экземпляра класса конфигурации и его жизненного цикла.
В противном случае такие bean-компоненты рассматриваются только на резервной фазе с соответствующими bean-компонентами. вместо этого в других классах конфигурации, выбранных в качестве основных кандидатов (если таковые имеются). = ****
Использование `@Autowired`.
Вы также можете поручить Spring предоставить все bean-компоненты определенного типа из `ApplicationContext`, добавив аннотацию `@Autowired` к полю или методу, который ожидает массив этого типа, как показано в следующем примере:
Java
	public class MovieRecommender {
		@Autowired
		private MovieCatalog[] movieCatalogs;
	class MovieRecommender {
Использование `@Autowired`.
То же самое относится и к типизированным коллекциям, как показано в следующем примере:
Java
	public class MovieRecommender {
		private Set<MovieCatalog> movieCatalogs;
		@Autowired
		public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
	class MovieRecommender {

Использование `@Autowired`. [СОВЕТ] = Ваши целевые bean-компоненты могут реализовать интерфейс org.springframework.core.Ordered или использовать аннотацию @Order или стандартную аннотацию @Priority, если вам нужны элементы в массиве или списке сортироваться в определенном порядке.
В противном случае их заказ следует за регистрацией. порядок соответствующих определений целевого компонента в контейнере.
Использование `@Autowired`.
Вы можете объявить аннотацию @Order на уровне целевого класса и в методах @Bean. потенциально для отдельных определений bean-компонентов (в случае нескольких определений, которые используйте тот же класс bean-компонента).
Значения `@Order` могут влиять на приоритеты в точках ввода, но имейте в виду, что они не влияют на порядок запуска синглтона, который является ортогональная проблема, определяемая отношениями зависимости и объявлениями `@DependsOn`.
Использование `@Autowired`.
Обратите внимание, что аннотации `@Order` в классах конфигурации влияют только на оценку. порядок в общем наборе классов конфигурации при запуске.
Такой уровень конфигурации значения порядка вообще не влияют на содержащиеся в нем методы `@Bean`.
Для заказа на уровне компонента: каждый метод `@Bean` должен иметь собственную аннотацию `@Order`, которая применяется внутри набор нескольких совпадений для конкретного типа компонента (возвращаемого фабричным методом).
Использование `@Autowired`.

Обратите внимание, что стандартная аннотация `jakarta.annotation.Priority` недоступна на Уровень `@Bean`, поскольку его нельзя объявить в методах.
Его семантику можно смоделировать через значения `@Order` в сочетании с `@Primary` для одного bean-компонента для каждого типа.
Использование `@Autowired`.
Даже введенные экземпляры Map могут быть автоматически подключены, если ожидаемый тип ключа — String.
Значения карты — это все bean-компоненты ожидаемого типа, а ключи — соответствующие имена компонентов, как показано в следующем примере:
Java
	public class MovieRecommender {
		private Map<String, MovieCatalog> movieCatalogs;
		@Autowired
		public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
	class MovieRecommender {
Использование `@Autowired`.
По умолчанию автоматическое связывание завершается неудачно, если для данного объекта не доступны соответствующие компоненты-кандидаты. точка инъекции.
В случае объявленного массива, коллекции или карты по крайней мере один ожидается соответствующий элемент.
Использование `@Autowired`.
Поведение по умолчанию — рассматривать аннотированные методы и поля как указывающие на необходимость зависимости.
Вы можете изменить это поведение, как показано в следующем примере: позволяя платформе пропускать невыполнимую точку внедрения, отмечая ее как необязательный (т. е. установив для атрибута `required` в `@Autowired` значение `false`):
Java
	public class SimpleMovieLister {
		private MovieFinder movieFinder;

@Autowired(required = false)
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
	class SimpleMovieLister {
Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Необязательный метод вообще не будет вызываться, если его зависимость (или одна из его зависимости, в случае нескольких аргументов) недоступен.
Необязательное поле будет в таких случаях вообще не заполняется, оставляя значение по умолчанию.
Использование `@Autowired`.
Другими словами, установка атрибута `required` в значение `false` означает, что соответствующее свойство является _необязательным_ для целей автоматического подключения, и это свойство будет игнорируется, если его нельзя выполнить автоматически.
Это позволяет присваивать свойствам значения по умолчанию. это можно при желании переопределить с помощью внедрения зависимостей.
Использование `@Autowired`.
Внедренные аргументы конструктора и фабричного метода являются особым случаем, поскольку `обязательные` атрибут в `@Autowired` имеет несколько иное значение из-за конструктора Spring алгоритм разрешения, который потенциально может иметь дело с несколькими конструкторами.
Конструктор и аргументы фабричного метода фактически требуются по умолчанию, но с некоторыми особыми правила в сценарии с одним конструктором, например многоэлементные точки внедрения (массивы, коллекции, карты), разрешающие пустые экземпляры, если соответствующие bean-компоненты недоступны.
Это допускает общий шаблон реализации, в котором все зависимости могут быть объявлены в уникальный конструктор с несколькими аргументами — например, объявленный как единый общедоступный конструктор без аннотации @Autowired.

Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Только один конструктор любого класса компонента может объявить `@Autowired` с `required`. атрибуту присвоено значение true, что указывает на автоматическое связывание конструктора _the_ при использовании в качестве Spring. боб.
Как следствие, если атрибут `required` оставить со значением по умолчанию `true`, только один конструктор может быть помечен с помощью `@Autowired`.
Если несколько конструкторов объявить аннотацию, все они должны будут объявить `required=false`, чтобы быть рассматриваются как кандидаты на автоматическое связывание (аналог `autowire=constructor` в XML).
Конструктор с наибольшим количеством зависимостей, которые можно удовлетворить путем сопоставления будут выбраны бобы в контейнере Spring.
Если ни один из кандидатов не может быть удовлетворен, тогда будет использоваться основной конструктор/конструктор по умолчанию (если он присутствует).
Аналогично, если класс объявляет несколько конструкторов, но ни один из них не имеет аннотации `@Autowired`, тогда Будет использоваться основной конструктор/конструктор по умолчанию (если он присутствует).
Если класс объявляет только один конструктор, он будет использоваться всегда, даже если не аннотирован.
Обратите внимание, что аннотированный конструктор не обязательно должен быть общедоступным.
Использование `@Autowired`.
В качестве альтернативы вы можете выразить необязательный характер конкретной зависимости. через `java.util.Optional` Java, как показано в следующем примере:
	public class SimpleMovieLister {
		@Autowired

public void setMovieFinder(Optional<MovieFinder> movieFinder) {
Java
	public class SimpleMovieLister {
		@Autowired
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
	class SimpleMovieLister {
Использование `@Autowired`.
Вы также можете использовать `@Autowired` для интерфейсов, которые хорошо известны и являются разрешимыми. зависимости: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`, «ApplicationEventPublisher» и «MessageSource».
Эти интерфейсы и их расширенные интерфейсы, такие как «ConfigurableApplicationContext» или «ResourcePatternResolver», разрешается автоматически, без необходимости специальной настройки.
Следующий пример автопроводки объект ApplicationContext:
Java
	public class MovieRecommender {
		@Autowired
		private ApplicationContext context;
		public MovieRecommender() {
class MovieRecommender {. [ПРИМЕЧАНИЕ] = Аннотации `@Autowired`, `@Inject`, `@Value` и `@Resource` обрабатываются Spring.
Реализации BeanPostProcessor.
Это означает, что вы не можете применить эти аннотации внутри ваших собственных типов BeanPostProcessor или BeanFactoryPostProcessor (если таковые имеются).
class MovieRecommender {.
Эти типы должны быть «подключены» явно с использованием XML или метода Spring `@Bean`.

Основные понятия: @Bean и @Configuration.
Основными артефактами поддержки конфигурации Java в Spring являются Классы с аннотациями `@Configuration` и методы с аннотациями `@Bean`.
Аннотация `@Bean` используется для указания того, что метод создает экземпляр, настраивает и инициализирует новый объект, которым будет управлять контейнер Spring IoC.
Для тех, кто знаком с XML-конфигурацией Spring `<beans/>` аннотация `@Bean` играет ту же роль, что и элемент `<bean/>`.
Вы можете использовать методы с аннотациями `@Bean` с любым Spring `@Компонент`.
Однако чаще всего они используются с bean-компонентами `@Configuration`.
Аннотация класса с помощью @Configuration указывает, что его основная цель — источник определений компонентов.
Более того, классы `@Configuration` позволяют взаимодействовать между компонентами. зависимости определяются путем вызова других методов `@Bean` в том же классе.
Простейший возможный класс `@Configuration` выглядит следующим образом:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public MyServiceImpl myService() {
			return new MyServiceImpl();
	@Configuration
	class AppConfig {
	<beans>
		<bean id="myService" class="com.acme.services.MyServiceImpl"/>
	</beans>

Предыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:. .@Классы конфигурации с локальными вызовами между методами @Bean или без них? **** В распространенных сценариях методы @Bean должны быть объявлены внутри классов @Configuration. обеспечение того, чтобы применялась полная обработка класса конфигурации и что перекрестный метод поэтому ссылки перенаправляются в систему управления жизненным циклом контейнера.
Это предотвращает случайный вызов того же метода `@Bean` через обычный Вызов метода Java, который помогает уменьшить количество мелких ошибок, которые трудно отследить.
Предыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:.
Когда методы `@Bean` объявляются внутри классов, которые не помечены `@Configuration` или когда объявлен `@Configuration(proxyBeanMethods=false)`, они называются обрабатываемыми в «облегченном» режиме.
В таких сценариях Методы `@Bean` по сути являются механизмом фабричных методов общего назначения без специальная обработка во время выполнения (то есть без создания для нее подкласса CGLIB).
Пользовательский вызов такого метода Java не будет перехвачен контейнером и поэтому ведет себя так же, как обычный вызов метода, каждый раз создавая новый экземпляр. вместо повторного использования существующего одноэлементного (или ограниченного) экземпляра для данного bean-компонента.
Предыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:.

Как следствие, методы `@Bean` в классах без проксирования во время выполнения не предназначены для вообще объявлять зависимости между компонентами.
Вместо этого ожидается, что они будут действовать по своим содержащий поля компонента и, необязательно, аргументы, которые может использовать фабричный метод. объявите, чтобы получить участников с автоматическим подключением.
Поэтому такой метод `@Bean` никогда не требуется вызывать другие методы `@Bean`; каждый такой призыв может быть выражен через вместо этого аргумент фабричного метода.
Положительным побочным эффектом здесь является отсутствие CGLIB. создание подклассов должно применяться во время выполнения, что снижает накладные расходы и занимаемую площадь. ****
Предыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:.
Аннотации `@Bean` и `@Configuration` подробно обсуждаются в следующих разделах.
Однако сначала мы рассмотрим различные способы создания контейнера Spring с использованием Конфигурация на основе Java.

Обзор контейнера.
Интерфейс `org.springframework.context.ApplicationContext` представляет Spring IoC. контейнер и отвечает за создание экземпляров, настройку и сборку компонентов.
Контейнер получает инструкции по компонентам для создания, настройки и настройки. собрать, прочитав метаданные конфигурации.
Метаданные конфигурации могут быть представлены как аннотированные классы компонентов, классы конфигурации с фабричными методами или внешние XML-файлы или сценарии Groovy.
В любом формате вы можете составить свое приложение и богатая взаимозависимость между этими компонентами.
Обзор контейнера.
Несколько реализаций интерфейса ApplicationContext являются частью ядра Spring.
В автономных приложениях обычно создается экземпляр {spring-framework-api}/context/annotation/AnnotationConfigApplicationContext.html[`AnnotationConfigApplicationContext`] или {spring-framework-api}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`].
Обзор контейнера.
В большинстве сценариев приложений явный пользовательский код не требуется для создания экземпляра одного или нескольких приложений. больше экземпляров контейнера Spring IoC.
Например, в сценарии простого веб-приложения: достаточно простого стандартного XML-дескриптора веб-дескриптора в файле `web.xml` приложения (см.
В сценарии Spring Boot контекст приложения загружается автоматически. на основе общих соглашений по установке.
Обзор контейнера.
На следующей диаграмме показано общее представление о том, как работает Spring.

Ваши классы приложений объединяются с метаданными конфигурации, так что после того, как `ApplicationContext` Созданный и инициализированный, вы получаете полностью настроенную и исполняемую систему или приложение.
Метаданные конфигурации.
Как показано на предыдущей диаграмме, контейнер Spring IoC использует форму метаданные конфигурации.
Эти метаданные конфигурации показывают, как вы, как разработчик приложения, сообщите контейнеру Spring создать экземпляр, настроить, и соберите компоненты в своем приложении.
Метаданные конфигурации.
Сам контейнер Spring IoC полностью отделен от формата, в котором этот метаданные конфигурации фактически записываются.
Сегодня многие разработчики выбирают
* Конфигурация на основе аннотаций: определение bean-компонентов с помощью
Метаданные конфигурации. метаданные конфигурации на основе аннотаций в классах компонентов вашего приложения.
* конфигурация на основе Java: определите внешние по отношению к вашему приложению bean-компоненты.
Метаданные конфигурации. классы с помощью классов конфигурации на основе Java.
Чтобы использовать эти функции, см. {spring-framework-api}/context/annotation/Configuration.html[`@Configuration`], {spring-framework-api}/context/annotation/Bean.html[`@Bean`], {spring-framework-api}/context/annotation/Import.html[`@Import`], и аннотации {spring-framework-api}/context/annotation/DependsOn.html[`@DependsOn`].
Метаданные конфигурации.

Конфигурация Spring состоит как минимум из одного, а обычно из более чем одного определения компонента. что контейнер должен справиться.
В конфигурации Java обычно используются аннотации `@Bean`. методы внутри класса `@Configuration`, каждый из которых соответствует одному определению компонента.
Метаданные конфигурации.
Эти определения bean-компонентов соответствуют реальным объектам, из которых состоит ваше приложение.
Обычно вы определяете объекты уровня обслуживания, объекты уровня персистентности, такие как репозитории или объекты доступа к данным (DAO), объекты представления, такие как веб-контроллеры, объекты инфраструктуры, такие как JPA `EntityManagerFactory`, очереди JMS и т. д.
Обычно в контейнере не настраиваются детальные объекты домена, поскольку обычно ответственность за создание и загрузку лежит на репозиториях и бизнес-логике. объекты домена.
XML как DSL внешней конфигурации.
Метаданные конфигурации на основе XML настраивают эти bean-компоненты как элементы `<bean/>` внутри элемент верхнего уровня `<beans/>`.
В следующем примере показана базовая структура Метаданные конфигурации на основе XML:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean id="..." class="..."> <1> <2>
			<!-- collaborators and configuration for this bean go here -->
		</bean>
		<bean id="..." class="...">
			<!-- collaborators and configuration for this bean go here -->
		</bean>
		<!-- more bean definitions go here -->
	</beans>
XML как DSL внешней конфигурации. <1> Атрибут `id` — это строка, которая идентифицирует определение отдельного компонента. <2> Атрибут `class` определяет тип компонента и использует полностью квалифицированный имя класса.
XML как DSL внешней конфигурации.
Значение атрибута id можно использовать для ссылки на взаимодействующие объекты.
XML для ссылки на взаимодействующие объекты в этом примере не показано.
См.
XML как DSL внешней конфигурации.
Для создания экземпляра контейнера путь или пути к файлам ресурсов XML. необходимо передать конструктору ClassPathXmlApplicationContext, который позволит метаданные конфигурации загрузки контейнера из различных внешних ресурсов, таких как в качестве локальной файловой системы, Java `CLASSPATH` и так далее.
Java

ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
XML как DSL внешней конфигурации. [ПРИМЕЧАНИЕ] = После того, как вы узнаете о контейнере Spring IoC, возможно, вам захочется узнать больше о Spring.
Абстракция `Ресурс` (как описано в который обеспечивает удобный механизм для чтения InputStream из определенных мест в синтаксисе URI.
В частности, пути «Ресурсы» используются для создания контекстов приложений. как описано в Контексты приложений и пути к ресурсам.
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">
		<!-- services -->
		<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
			<property name="accountDao" ref="accountDao"/>
			<property name="itemDao" ref="itemDao"/>

<!-- additional collaborators and configuration for this bean go here -->
		</bean>
		<!-- more bean definitions for services go here -->
	</beans>
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean id="accountDao"
			class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>
		<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>
		<!-- more bean definitions for data access objects go here -->
	</beans>
В следующем примере показан файл daos.xml объектов доступа к данным:.

В предыдущем примере уровень обслуживания состоит из класса PetStoreServiceImpl. и два объекта доступа к данным типов JpaAccountDao и JpaItemDao (на основе по стандарту объектно-реляционного сопоставления JPA).
Элемент `property name` относится к имя свойства JavaBean, а элемент `ref` относится к имени другого bean-компонента. определение.
Эта связь между элементами `id` и `ref` выражает зависимость между взаимодействующие объекты.
Подробную информацию о настройке зависимостей объекта см.
Составление метаданных конфигурации на основе XML.
Может быть полезно, чтобы определения компонентов охватывали несколько файлов XML.
Часто каждый отдельный Файл конфигурации XML представляет собой логический уровень или модуль вашей архитектуры.
Составление метаданных конфигурации на основе XML.
Вы можете использовать конструктор ClassPathXmlApplicationContext для загрузки определений bean-компонентов из XML-фрагменты.
Этот конструктор принимает несколько местоположений `Resource`, как показано в используйте одно или несколько вхождений элемента `<import/>` для загрузки определений компонентов из другой файл или файлы.
В следующем примере показано, как это сделать:
	<beans>
		<import resource="services.xml"/>
		<import resource="resources/messageSource.xml"/>
		<bean id="bean1" class="..."/>
		<bean id="bean2" class="..."/>
	</beans>
Составление метаданных конфигурации на основе XML.

В предыдущем примере определения внешних компонентов загружаются из файлов `services.xml` и `messageSource.xml`.
Все пути к местоположению относительно файла определения, выполняющего импорт, поэтому `services.xml` должен находиться в тот же каталог или путь к классам, что и файл, выполняющий импорт, в то время как `messageSource.xml` должен находиться в папке `resources` под расположение импортируемого файла.
Как видите, косая черта в начале игнорируется.
Однако, учитывая поскольку эти пути относительны, лучше вообще не использовать косую черту. содержимое импортируемых файлов, включая элемент верхнего уровня `<beans/>`, должно быть действительными определениями XML-компонентов в соответствии со схемой Spring.
Составление метаданных конфигурации на основе XML. [ПРИМЕЧАНИЕ] = Можно, но не рекомендуется ссылаться на файлы в родительских каталогах с помощью относительный путь "../".
Это создает зависимость от файла, находящегося за пределами текущего приложение.
В частности, эта ссылка не рекомендуется для URL-адресов `classpath:` (для например `classpath:../services.xml`), где процесс разрешения во время выполнения выбирает «`ближайший`» корневой путь к классу, а затем просматривает его родительский каталог.
Путь к классам изменения конфигурации могут привести к выбору другого, неправильного каталога.
Составление метаданных конфигурации на основе XML.

Вы всегда можете использовать полные местоположения ресурсов вместо относительных путей: для например, `file:C:/config/services.xml` или `classpath:/config/services.xml`.
Однако будьте осознавая, что вы связываете конфигурацию своего приложения с конкретным абсолютным локации.
Обычно предпочтительнее сохранять косвенность для таких абсолютных значений. местоположения – например, с помощью заполнителей "${...}", которые разрешаются с помощью JVM. свойства системы во время выполнения.
Составление метаданных конфигурации на основе XML.
Само пространство имен предоставляет функцию директив импорта.
Далее функции конфигурации, выходящие за рамки простых определений компонентов, доступны в некоторых вариантах пространств имен XML, предоставляемых Spring, например, пространств имен context и util.
Использование контейнера. «ApplicationContext» — это интерфейс расширенной фабрики, способной поддерживать реестр различных bean-компонентов и их зависимостей.
Используя метод `T getBean(String name, Class<T> requireType)` вы можете получить экземпляры ваших bean-компонентов.
Использование контейнера. `ApplicationContext` позволяет вам читать определения bean-компонентов и получать к ним доступ, как показано ниже. пример показывает:
Java
	// создавать и настраивать bean-компоненты
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
	// получить настроенный экземпляр
	PetStoreService service = context.getBean("petStore", PetStoreService.class);

// использовать настроенный экземпляр
	List<String> userList = service.getUsernameList();
Использование контейнера.
В конфигурации Groovy загрузка выглядит очень похоже.
У него другой контекст класс реализации, который поддерживает Groovy (но также понимает определения XML-компонентов).
В следующем примере показана конфигурация Groovy:
Java
	ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
Использование контейнера.
Самый гибкий вариант — GenericApplicationContext в сочетании с считывателем. делегаты - например, с помощью `XmlBeanDefinitionReader` для файлов XML, как показано ниже. пример показывает:
Java
	GenericApplicationContext context = new GenericApplicationContext();
	new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
	context.refresh();
Использование контейнера.
Вы также можете использовать GroovyBeanDefinitionReader для файлов Groovy, как показано ниже. пример показывает:
Java
	GenericApplicationContext context = new GenericApplicationContext();
	new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
	context.refresh();
Использование контейнера.
Вы можете смешивать и сопоставлять такие делегаты чтения в одном и том же ApplicationContext, чтение определений компонентов из различных источников конфигурации.
Использование контейнера.

Затем вы можете использовать getBean для получения экземпляров ваших bean-компонентов. `Контекст приложения` В интерфейсе есть несколько других методов получения bean-компонентов, но в идеале ваше приложение код никогда не должен их использовать.
Действительно, код вашего приложения не должен содержать вызовов метода `getBean()` вообще и, таким образом, вообще не зависит от Spring API.
Например, Интеграция Spring с веб-фреймворками обеспечивает внедрение зависимостей для различных веб-приложений. компоненты инфраструктуры, такие как контроллеры и компоненты, управляемые JSF, что позволяет вам объявлять зависимость от конкретного компонента через метаданные (например, аннотацию автоматического подключения).

Использование аннотации `@Bean`. `@Bean` — это аннотация уровня метода и прямой аналог XML-элемента `<bean/>`.
Аннотация поддерживает некоторые атрибуты, предлагаемые `<bean/>`, например:
* init-method
* destroy-method
* autowiring
* `имя`.
Использование аннотации `@Bean`.
Вы можете использовать аннотацию `@Bean` в аннотации `@Configuration` или в Класс с аннотацией `@Component`.
Объявление компонента.
Чтобы объявить компонент, вы можете аннотировать метод аннотацией `@Bean`.
Вы используете это метод для регистрации определения компонента в `ApplicationContext` типа указанный как возвращаемое значение метода.
По умолчанию имя компонента такое же, как имя метода.
В следующем примере показано объявление метода @Bean:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public TransferServiceImpl transferService() {
			return new TransferServiceImpl();
	@Configuration
	class AppConfig {
	<beans>
		<bean id="transferService" class="com.acme.TransferServiceImpl"/>
	</beans>
Предыдущая конфигурация в точности эквивалентна следующему Spring XML:.
Оба объявления делают компонент с именем TransferService доступным в `ApplicationContext`, привязанный к экземпляру объекта типа `TransferServiceImpl`, как следующее текстовое изображение показывает:
transferService -> com.acme.TransferServiceImpl.
Вы также можете использовать методы по умолчанию для определения компонентов.

Это позволяет композицию бобов конфигурации путем реализации интерфейсов с определениями компонентов в методах по умолчанию.
Java
	public interface BaseConfig {
		@Bean
		default TransferServiceImpl transferService() {
			return new TransferServiceImpl();
	@Configuration
	public class AppConfig implements BaseConfig {
transferService -> com.acme.TransferServiceImpl.
Вы также можете объявить свой метод `@Bean` с помощью интерфейса (или базового класса). тип возвращаемого значения, как показано в следующем примере:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl();
	@Configuration
	class AppConfig {
transferService -> com.acme.TransferServiceImpl.
Однако это ограничивает видимость прогнозирования типа опережения указанными значениями. тип интерфейса («TransferService»).
Затем с полным типом (`TransferServiceImpl`) известен контейнеру только после того, как был создан экземпляр затронутого одноэлементного компонента.
Неленивые одноэлементные компоненты создаются в соответствии с порядком их объявления. поэтому вы можете увидеть разные результаты сопоставления типов в зависимости от того, когда другой компонент пытается найти соответствие по необъявленному типу (например, `@Autowired TransferServiceImpl`, который разрешается только после создания экземпляра bean-компонента TransferService).
transferService -> com.acme.TransferServiceImpl.
СОВЕТ: Если вы постоянно ссылаетесь на свои типы через объявленный сервисный интерфейс, ваш Возвращаемые типы `@Bean` могут безопасно присоединиться к этому проектному решению.

Однако для компонентов которые реализуют несколько интерфейсов или для компонентов, потенциально упоминаемых их типа реализации, безопаснее объявить максимально конкретный тип возвращаемого значения. (по крайней мере, настолько конкретно, насколько того требуют точки инъекции, относящиеся к вашему компоненту).
Зависимости компонентов.
Метод, аннотированный `@Bean`, может иметь произвольное количество параметров, описывающих зависимости, необходимые для сборки этого компонента.
Например, если наш TransferService требуется AccountRepository, мы можем материализовать эту зависимость с помощью метода параметр, как показано в следующем примере:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
	@Configuration
	class AppConfig {
Зависимости компонентов.
Механизм разрешения во многом идентичен зависимостям на основе конструктора. инъекция.
См. для более подробной информации.
Получение обратных вызовов жизненного цикла.
Любые классы, определенные с помощью аннотации `@Bean`, поддерживают обычные обратные вызовы жизненного цикла. и может использовать аннотации @PostConstruct и @PreDestroy из JSR-250.
См. детали.
Получение обратных вызовов жизненного цикла.
Обычные обратные вызовы Spring lifecycle полностью поддерживаются как ну.
Если компонент реализует `InitializingBean`, `DisposableBean` или `Lifecycle`, их соответствующие методы вызываются контейнером.
Стандартный набор интерфейсов `*Aware` (например, BeanFactoryAware,.

Аннотация `@Bean` поддерживает указание произвольной инициализации и уничтожения. методы обратного вызова, очень похожие на атрибуты Spring XML `init-method` и `destroy-method` на элементе bean, как показано в следующем примере:
Java
	public class BeanOne {
		public void init() {
			// логика инициализации
	public class BeanTwo {
		public void cleanup() {
			// логика разрушения
	@Configuration
	public class AppConfig {
		@Bean(initMethod = "init")
		public BeanOne beanOne() {
			return new BeanOne();
		@Bean(destroyMethod = "cleanup")
		public BeanTwo beanTwo() {
			return new BeanTwo();
@Configuration class AppConfig {. [ПРИМЕЧАНИЕ] = По умолчанию bean-компоненты, определенные с конфигурацией Java, имеют общедоступное «закрытие» или «завершение работы». метод автоматически подключается к обратному вызову уничтожения.
Если у вас есть публичный `close` или `shutdown`, и вы не хотите, чтобы он вызывался, когда контейнер выключается, вы можете добавить `@Bean(destroyMethod = "")` в определение вашего компонента, чтобы отключить режим по умолчанию `(выведенный)`.
@Configuration class AppConfig {.
Возможно, вы захотите сделать это по умолчанию для ресурса, который вы приобретаете с помощью JNDI, поскольку его Жизненный цикл управляется вне приложения.

В частности, обязательно всегда делайте это для DataSource, так как известно, что это проблематично на серверах приложений Jakarta EE.
@Configuration class AppConfig {.
В следующем примере показано, как предотвратить обратный вызов автоматического уничтожения для `Источник данных`:
Java
	@Bean(destroyMethod = "")
	public DataSource dataSource() throws NamingException {
		return (DataSource) jndiTemplate.lookup("MyDS");
@Configuration class AppConfig {.
Кроме того, с методами `@Bean` вы обычно используете программный поиск JNDI, либо используя помощники Spring `JndiTemplate` или `JndiLocatorDelegate` или прямой JNDI Использование `InitialContext`, но не вариант `JndiObjectFactoryBean` (который заставил бы вы должны объявить тип возвращаемого значения как тип FactoryBean вместо фактической цели типа, что затрудняет использование вызовов перекрестных ссылок в других методах `@Bean`, которые намерен сослаться на предоставленный здесь ресурс).
@Configuration class AppConfig {.
В случае BeanOne из примера выше предыдущего примечания это будет одинаково допустимо вызывать метод init() непосредственно во время построения, так как следующий пример показывает:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public BeanOne beanOne() {
			BeanOne beanOne = new BeanOne();
			beanOne.init();
			return beanOne;
	@Configuration
	class AppConfig {
@Configuration class AppConfig {.

СОВЕТ: Когда вы работаете непосредственно в Java, вы можете делать со своими объектами все, что захотите, и делать не всегда нужно полагаться на жизненный цикл контейнера.
Указание области действия компонента.
Spring включает аннотацию @Scope, позволяющую указать область действия bean-компонента.
Использование аннотации `@Scope`.
Вы можете указать, что ваши bean-компоненты, определенные с помощью аннотации `@Bean`, должны иметь конкретный объем.
Вы можете использовать любую из стандартных областей, указанных в
Использование аннотации `@Scope`.
Областью действия по умолчанию является `singleton`, но вы можете переопределить это с помощью аннотации `@Scope`, как показано в следующем примере:
Java
	@Configuration
	public class MyConfiguration {
		@Bean
		@Scope("prototype")
		public Encryptor encryptor() {
	@Configuration
	class MyConfiguration {
`@Scope` и `scoped-proxy`.
Spring предлагает удобный способ работы с ограниченными зависимостями через таким прокси при использовании конфигурации XML является элемент `<aop:scoped-proxy/>`.
Настройка ваших bean-компонентов на Java с помощью аннотации @Scope обеспечивает эквивалентную поддержку. с атрибутом proxyMode.
По умолчанию используется ScopedProxyMode.DEFAULT. обычно указывает, что не следует создавать прокси-сервер с заданной областью, если не указан другой прокси по умолчанию. настроен на уровне инструкций сканирования компонентов.

Вы можете указать `ScopedProxyMode.TARGET_CLASS`, `ScopedProxyMode.INTERFACES` или `ScopedProxyMode.NO`.
`@Scope` и `scoped-proxy`.
Если вы портируете пример прокси-сервера с ограниченной областью действия из справочной документации XML (см. это похоже на следующее:
Java
	// bean-компонент в области сеанса HTTP, представленный как прокси
	@Bean
	@SessionScope
	public UserPreferences userPreferences() {
		return new UserPreferences();
	@Bean
	public Service userService() {
		UserService service = new SimpleUserService();
		// ссылка на прокси-компонент userPreferences
		service.setUserPreferences(userPreferences());
		return service;
Настройка именования компонентов.
По умолчанию классы конфигурации используют имя метода @Bean в качестве имени объекта. полученный боб.
Однако эту функциональность можно переопределить с помощью атрибута `name`. как показано в следующем примере:
Java
	@Configuration
	public class AppConfig {
		@Bean("myThing")
		public Thing thing() {
			return new Thing();
	@Configuration
	class AppConfig {
Псевдонимы компонентов.
Как обсуждалось в Именование компонентов, это иногда желательно дать одному компоненту несколько имен, что также известно как псевдонимы компонентов.
Атрибут `name` аннотации `@Bean` для этой цели принимает массив String.
В следующем примере показано, как установить несколько псевдонимов для компонента:
Java
	@Configuration
	public class AppConfig {

@Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
		public DataSource dataSource() {
			// создать экземпляр, настроить и вернуть компонент DataSource...
	@Configuration
	class AppConfig {
Описание компонента.
Иногда полезно предоставить более подробное текстовое описание компонента.
Это может быть особенно полезным, когда bean-компоненты предоставляются (возможно, через JMX) для целей мониторинга.
Описание компонента.
Чтобы добавить описание к `@Bean`, вы можете использовать {spring-framework-api}/context/annotation/Description.html[`@Description`] аннотация, как показано в следующем примере:
Java
	@Configuration
	public class AppConfig {
		@Bean
		@Description("Provides a basic example of a bean")
		public Thing thing() {
			return new Thing();
	@Configuration
	class AppConfig {

Ссылки на компоненты.
Если контекст оценки настроен с помощью преобразователя bean-компонентов, вы можете искать bean-компоненты из выражения, используя символ `@` в качестве префикса.
Следующий пример показывает, как чтобы сделать это:
Java
	ExpressionParser parser = new SpelExpressionParser();
	StandardEvaluationContext context = new StandardEvaluationContext();
	context.setBeanResolver(new MyBeanResolver());
	// В конечном итоге это приведет к вызову разрешения(контекст, "someBean") в MyBeanResolver.
	// во время оценки.
	Object bean = parser.parseExpression("@someBean").getValue(context);
Ссылки на компоненты. [ПРИМЕЧАНИЕ] = Если имя компонента содержит точку (`.`) или другие специальные символы, вы должны указать имя компонента в виде _строкового литерала_ – например, `@'order.service'`.
Ссылки на компоненты.
Чтобы получить доступ к самому фабричному компоненту, вам следует вместо этого добавить к имени компонента префикс `&`. символ.
В следующем примере показано, как это сделать:
Java
	ExpressionParser parser = new SpelExpressionParser();
	StandardEvaluationContext context = new StandardEvaluationContext();
	context.setBeanResolver(new MyBeanResolver());
	// В конечном итоге это приведет к вызову разрешения(контекст, "&someFactoryBean") на
	// MyBeanResolver во время оценки.

Object factoryBean = parser.parseExpression("&someFactoryBean").getValue(context);

Выражения в определениях компонентов.
Вы можете использовать выражения SpEL с метаданными конфигурации для определения экземпляров компонента.
В обоих В некоторых случаях синтаксис определения выражения имеет вид `#{ <строка выражения> }`.
Выражения в определениях компонентов.
Все bean-компоненты в контексте приложения доступны как предопределенные переменные с их общее название компонента.
Сюда входят стандартные контекстные компоненты, такие как `environment` (типа `org.springframework.core.env.Environment`), а также `systemProperties` и `systemEnvironment` (типа `Map<String, Object>`) для доступа к среде выполнения.
Выражения в определениях компонентов.
Чтобы указать значение по умолчанию, вы можете разместить аннотацию @Value на полях, методах, и параметры метода или конструктора (или эквивалент XML).
Выражения в определениях компонентов.
В следующем примере задается значение поля по умолчанию: См. пример кода в исходном документе.
Выражения в определениях компонентов.
Обратите внимание, что здесь не обязательно добавлять к предопределенной переменной префикс символа `#`.
Выражения в определениях компонентов.
В следующем примере показан эквивалент, но для метода установки свойства: См. пример кода в исходном документе.
Выражения в определениях компонентов.
Методы и конструкторы с автоматическим подключением также могут использовать аннотацию @Value, как показано ниже. примеры показывают: См. пример кода в исходном документе.
Выражения в определениях компонентов.

Вы также можете обращаться к другим свойствам компонента по имени, как показано в следующем примере: См. пример кода в исходном документе.

API `BeanFactory`.
API BeanFactory обеспечивает базовую основу для функциональности Spring IoC.
Его конкретные контракты в основном используются в интеграции с другими частями Spring и связанные сторонние фреймворки и их реализация DefaultListableBeanFactory. является ключевым делегатом в контейнере GenericApplicationContext более высокого уровня.
API `BeanFactory`. `BeanFactory` и связанные с ним интерфейсы (такие как `BeanFactoryAware`, `InitializingBean`, `DisposableBean`) являются важными точками интеграции для других компонентов платформы.
Не требуя каких-либо аннотаций или даже размышлений, они позволяют очень эффективно взаимодействие между контейнером и его компонентами.
Компоненты прикладного уровня могут использовать те же интерфейсы обратного вызова, но обычно предпочитают декларативную зависимость вместо этого внедрение либо посредством аннотаций, либо посредством программной конфигурации.
API `BeanFactory`.
Обратите внимание, что основной уровень API BeanFactory и его DefaultListableBeanFactory реализации не делайте предположений о формате конфигурации или каких-либо аннотации компонентов, которые будут использоваться.
Все эти варианты доступны через расширения. (например, XmlBeanDefinitionReader и AutowiredAnnotationBeanPostProcessor) и работать с общими объектами BeanDefinition в качестве основного представления метаданных.
В этом суть того, что делает контейнер Spring таким гибким и расширяемым.
API `BeanFactory`. «BeanFactory» или «ApplicationContext»?
API `BeanFactory`.
В этом разделе объясняются различия между BeanFactory и Уровни контейнера `ApplicationContext` и их влияние на начальную загрузку.
API `BeanFactory`.

Вам следует использовать ApplicationContext, если у вас нет веских причин не делать этого.
GenericApplicationContext и его подкласс AnnotationConfigApplicationContext. как общие реализации для пользовательской начальной загрузки.
Это основная запись указывает на основной контейнер Spring для всех распространенных целей: загрузки конфигурации файлы, запуск сканирования пути к классам, программная регистрация определений компонентов и аннотированные классы, а также (начиная с версии 5.0) регистрацию определений функциональных компонентов.
API `BeanFactory`.
Поскольку ApplicationContext включает в себя все функциональные возможности BeanFactory, он обычно рекомендуется вместо простой BeanFactory, за исключением случаев, когда полный необходим контроль над обработкой бобов.
Внутри `ApplicationContext` (например, Реализация GenericApplicationContext), обнаружено несколько видов bean-компонентов. по соглашению (то есть по имени или типу компонента — в частности, постпроцессоры), в то время как простой `DefaultListableBeanFactory` не зависит от каких-либо специальных bean-компонентов.
API `BeanFactory`.
Для многих расширенных функций контейнера, таких как обработка аннотаций и проксирование AOP, необходимая точка расширения `BeanPostProcessor`.
Если вы используете только простой `DefaultListableBeanFactory`, такие постпроцессоры не быть обнаружен и активирован по умолчанию.
Эта ситуация может сбить с толку, потому что на самом деле в конфигурации вашего компонента все в порядке.
Скорее, в таком сценарии контейнер необходимо полностью загрузить посредством дополнительной настройки.
API `BeanFactory`.
В следующей таблице перечислены функции, предоставляемые BeanFactory и Интерфейсы и реализации ApplicationContext.

API `BeanFactory`. .Матрица функций [cols="50%,25%,25%"] |=== | Особенность | `БинФабрика` | `Контекст приложения`
| Автоматическая регистрация BeanFactoryPostProcessor. | Нет | Да. | Удобный доступ к MessageSource (для интернационализации) | Нет | Да
| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===.
Чтобы явно зарегистрировать постпроцессор компонента с помощью DefaultListableBeanFactory, вам необходимо программно вызвать `addBeanPostProcessor`, как показано в следующем примере:
Java
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	// заполняем фабрику определениями компонентов
	// теперь регистрируемые все экземпляры BeanPostProcessor
	factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
	factory.addBeanPostProcessor(new MyBeanPostProcessor());
	// теперь начните использовать фабрику
	// теперь регистрируемые все экземпляры BeanPostProcessor
	factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())
	factory.addBeanPostProcessor(MyBeanPostProcessor())
	// теперь начните использовать фабрику
| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===.
Чтобы применить BeanFactoryPostProcessor к простому DefaultListableBeanFactory, вам нужно вызвать его метод postProcessBeanFactory, как показано в следующем примере:
Java
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
	reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));
	// извлекаем некоторые значения свойств из файла свойств
	PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();

cfg.setLocation(new FileSystemResource("jdbc.properties"));
	// теперь собственно займусь заменой
	cfg.postProcessBeanFactory(factory);
	// теперь собственно займусь заменой
	cfg.postProcessBeanFactory(factory)
| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===.
В обоих случаях явные шаги регистрации неудобны, что почему различные варианты ApplicationContext предпочтительнее простого `DefaultListableBeanFactory` в приложениях, поддерживаемых Spring, особенно когда полагаясь на экземпляры BeanFactoryPostProcessor и BeanPostProcessor для расширенного функциональность контейнера в типичной корпоративной настройке.
| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===. [ПРИМЕЧАНИЕ] = AnnotationConfigApplicationContext имеет все распространенные постпроцессоры аннотаций. зарегистрирован и может привлечь дополнительные процессоры под охватывает через аннотации конфигурации, такие как `@EnableTransactionManagement`.
На уровне абстракции модели конфигурации Spring на основе аннотаций: понятие постпроцессоров компонентов становится просто деталью внутреннего контейнера.

IoC-контейнер.
В этой главе рассматривается контейнер Spring Inversion of Control (IoC).

Проверка Java-бина.
Spring Framework обеспечивает поддержку {bean-validation-site}[Проверка Java Bean] API.
Обзор проверки компонентов.
Bean Validation обеспечивает общий способ проверки посредством объявления ограничений и метаданные для приложений Java.
Чтобы использовать его, вы аннотируете свойства модели предметной области с помощью ограничения декларативной проверки, которые затем применяются средой выполнения.
Есть встроенные ограничения, а также вы можете определить свои собственные ограничения.
Java
	public class PersonForm {
		private String name;
		private int age;
Java
	public class PersonForm {
		@NotNull
		@Size(max=64)
		private String name;
		@Min(0)
		private int age;
Проверка компонентов позволяет объявлять ограничения, как показано в следующем примере:.
Затем валидатор Bean Validation проверяет экземпляры этого класса на основе объявленного ограничения.
См. {bean-validation-site}[Bean Validation] для получения общей информации о API.
См. документацию https://hibernate.org/validator/[Hibernate Validator] для конкретные ограничения.
Чтобы узнать, как настроить поставщика проверки компонентов в качестве Spring Блин, продолжай читать.
Настройка поставщика проверки компонентов.
Spring обеспечивает полную поддержку API проверки компонентов, включая загрузку Поставщик проверки компонентов как компонент Spring.
Это позволяет вам ввести `jakarta.validation.ValidatorFactory` или `jakarta.validation.Validator`, где проверка необходим в вашем приложении.
Настройка поставщика проверки компонентов.

Вы можете использовать LocalValidatorFactoryBean для настройки валидатора по умолчанию как Spring. bean-компонент, как показано в следующем примере:
Java
	import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
	@Configuration
	public class AppConfig {
		@Bean
		public LocalValidatorFactoryBean validator() {
			return new LocalValidatorFactoryBean();
XML
	<bean id="validator"
		class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
Настройка поставщика проверки компонентов.
Базовая конфигурация в предыдущем примере запускает проверку bean-компонента для инициализации с помощью используя механизм начальной загрузки по умолчанию.
Поставщик проверки компонентов, например Hibernate.
Ожидается, что валидатор присутствует в пути к классам и обнаруживается автоматически.
Внедрить валидатор Джакарты.
LocalValidatorFactoryBean реализует как jakarta.validation.ValidatorFactory, так и `jakarta.validation.Validator`, поэтому вы можете добавить ссылку на последний в применить логику проверки, если вы предпочитаете работать напрямую с API проверки компонентов, как показано в следующем примере:
Java
	import jakarta.validation.Validator;
	@Service
	public class MyService {
		@Autowired
		private Validator validator;
	import jakarta.validation.Validator;
Внедрить Spring-валидатор.
В дополнение к реализации `jakarta.validation.Validator`, `LocalValidatorFactoryBean` также адаптируется к `org.springframework.validation.Validator`, поэтому вы можете ввести ссылку ко второму, если вашему компоненту требуется API Spring Validation.
Java
	import org.springframework.validation.Validator;

@Service
	public class MyService {
		@Autowired
		private Validator validator;
Например:.
При использовании как `org.springframework.validation.Validator`, `LocalValidatorFactoryBean` вызывает базовый `jakarta.validation.Validator`, а затем адаптирует от ConstraintViolation до FieldError и регистрирует их с помощью объекта Errors. передается в метод `validate`.
* Аннотация `@Constraint`, объявляющая ограничение и его настраиваемые свойства.
* Реализация интерфейса `jakarta.validation.ConstraintValidator`, который реализует
Каждое ограничение проверки компонента состоит из двух частей:. поведение ограничения.
Каждое ограничение проверки компонента состоит из двух частей:.
Чтобы связать объявление с реализацией, каждая аннотация `@Constraint` ссылается на соответствующий класс реализации ConstraintValidator.
Во время выполнения ConstraintValidatorFactory создает экземпляр реализации, на которую ссылается, когда В вашей доменной модели встречается аннотация ограничения.
Каждое ограничение проверки компонента состоит из двух частей:.
По умолчанию LocalValidatorFactoryBean настраивает SpringConstraintValidatorFactory. который использует Spring для создания экземпляров ConstraintValidator.
Это позволяет вашему заказу ConstraintValidators получают преимущества от внедрения зависимостей, как и любой другой bean-компонент Spring.
Каждое ограничение проверки компонента состоит из двух частей:.
В следующем примере показано пользовательское объявление `@Constraint`, за которым следует связанный Реализация ConstraintValidator, использующая Spring для внедрения зависимостей:
Java
	@Target({ElementType.METHOD, ElementType.FIELD})
	@Retention(RetentionPolicy.RUNTIME)

@Constraint(validatedBy=MyConstraintValidator.class)
	public @interface MyConstraint {
Java
	import jakarta.validation.ConstraintValidator;
	public class MyConstraintValidator implements ConstraintValidator {
		@Autowired;
		private Foo aDependency;
Каждое ограничение проверки компонента состоит из двух частей:.
Как показано в предыдущем примере, реализация ConstraintValidator может иметь свои зависимости. `@Autowired`, как и любой другой компонент Spring.
Spring-управляемая проверка метода.
Вы можете интегрировать функцию проверки метода Bean Validation в Контекст Spring через определение bean-компонента `MethodValidationPostProcessor`: См. пример кода в исходном документе.
Spring-управляемая проверка метода.
Чтобы иметь право на проверку метода на основе Spring, целевые классы должны быть аннотированы. с аннотацией Spring `@Validated`, которая при желании также может объявить проверку группы для использования.
См. {spring-framework-api}/validation/beanvalidation/MethodValidationPostProcessor.html[`MethodValidationPostProcessor`] подробности настройки можно узнать у поставщиков Hibernate Validator и Bean Validation.
Spring-управляемая проверка метода. [СОВЕТ] = Проверка метода опирается на AOP Proxy целевые классы, либо динамические прокси JDK для методов интерфейсов, либо прокси CGLIB.
Существуют определенные ограничения на использование прокси, некоторые из которых описаны в разделе всегда использовать методы и методы доступа в прокси-классах; прямой доступ к полю не будет работать.
Spring-управляемая проверка метода.

Spring MVC и WebFlux имеют встроенную поддержку одной и той же проверки базового метода, но без необходимость АОП.
Поэтому проверьте остальную часть этого раздела, а также посмотрите Spring MVC.
Исключения проверки метода.
По умолчанию jakarta.validation.ConstraintViolationException вызывается с набором ConstraintViolation возвращается jakarta.validation.Validator.
В качестве альтернативы, вместо этого вы можете вызвать исключение MethodValidationException с помощью ConstraintViolation. адаптирован к ошибкам MessageSourceResolvable.
Для включения установите следующий флаг: См. пример кода в исходном документе.
Исключения проверки метода. `MethodValidationException` содержит список ``ParameterValidationResult``, который группируйте ошибки по параметру метода, и каждая предоставляет `MethodParameter`, аргумент значение и список ошибок MessageSourceResolvable, адаптированный из ``ConstraintViolation``.
Для параметров метода `@Valid` с каскадными нарушениями полей и свойств, параметр «ParameterValidationResult» — это «ParameterErrors», который реализует `org.springframework.validation.Errors` и выдает ошибки проверки как ``FieldError``.
Настройка ошибок проверки.
Адаптированные ошибки MessageSourceResolvable можно превратить в сообщения об ошибках. отображение пользователям через настроенный «MessageSource» с указанием локали и языка. пакеты ресурсов.
В этом разделе приведен пример для иллюстрации.
Java
	record Person(@Size(min = 1, max = 10) String name) {
	@Validated
	public class MyService {
		void addStudent(@Valid Person person, @Max(2) int degrees) {

@Validated
	class MyService {
- Коды ошибок `"Size.person.name"`, `"Size.name"`, `"Size.java.lang.String"` и `"Size"`
ConstraintViolation в Person.name() адаптируется к FieldError следующим образом:. — Аргументы сообщения «имя», «10» и «1» (имя поля и атрибуты ограничения).
- Сообщение по умолчанию «размер должен быть от 1 до 10».
ConstraintViolation в Person.name() адаптируется к FieldError следующим образом:.
Чтобы настроить сообщение по умолчанию, вы можете добавить свойства к пакеты ресурсов, используя любой из приведенных выше кодов ошибок и аргументов сообщения.
Отметим также, что Аргумент сообщения `"name"` сам по себе является `MessageSourceResolvable` с кодами ошибок. `"person.name"` и `"name"` также могут быть настроены.
Например:
Свойства.
Size.person.name=Please, provide a {0} that is between {2} and {1} characters long person.name=username
Свойства. «ConstraintViolation» в параметре метода «градусы» адаптирован к `MessageSourceResolvable` со следующим:

- Коды ошибок `"Max.myService#addStudent.grades"`, `"Max.grades"`, `"Max.int"`, `"Max"`
- Аргументы сообщения «градусы» и 2 (имя поля и атрибут ограничения)
- Сообщение по умолчанию «должно быть меньше или равно 2»
Свойства.
Чтобы настроить приведенное выше сообщение по умолчанию, вы можете добавить такое свойство, как:
Дополнительные параметры конфигурации.
Конфигурации по умолчанию LocalValidatorFactoryBean достаточно для большинства случаи.
Существует несколько вариантов конфигурации для различных проверок компонентов. конструкции, от интерполяции сообщений до разрешения обхода.
См. {spring-framework-api}/validation/beanvalidation/LocalValidatorFactoryBean.html[`LocalValidatorFactoryBean`] javadoc для получения дополнительной информации об этих параметрах.
Настройка DataBinder.
Вы можете настроить экземпляр DataBinder с помощью Validator.
После настройки вы можете вызовите «Валидатор», вызвав «binder.validate()».
Любые «ошибки» проверки автоматически добавляется в `BindingResult` связывателя.
Настройка DataBinder.
В следующем примере показано, как программно использовать DataBinder для вызова проверки. логика после привязки к целевому объекту:
Java
	Foo target = new Foo();
	DataBinder binder = new DataBinder(target);
	binder.setValidator(new FooValidator());
	// привязать к целевому объекту
	binder.bind(propertyValues);
	// проверить целевой объект

binder.validate();
	// получает BindingResult, включающий все ошибки проверок
	BindingResult results = binder.getBindingResult();
	// привязать к целевому объекту
	binder.bind(propertyValues)
	// проверить целевой объект
	binder.validate()
Настройка DataBinder.
Вы также можете настроить DataBinder с несколькими экземплярами Validator через `dataBinder.addValidators` и `dataBinder.replaceValidators`.
Это полезно, когда объединение глобально настроенной проверки bean-компонента с настроенным Spring `Validator` локально в экземпляре DataBinder.
См.
Весенняя проверка MVC.
См.
Validation в главе Spring MVC.

HTTP-кэширование может значительно повысить производительность веб-приложения.
HTTP-кэширование вращается вокруг заголовка ответа Cache-Control и последующего условного запроса. заголовки, такие как Last-Modified и ETag. `Cache-Control` советует приватное (например, браузер) и публичные (например, прокси) кэши, как кэшировать и повторно использовать ответы.
Используется заголовок `ETag`. сделать условный запрос, который может привести к 304 (NOT_MODIFIED) без тела, если содержимое не изменилось. `ETag` можно рассматривать как более продвинутого преемника заголовок «Last-Modified».
HTTP-кэширование.
В этом разделе описаны параметры, связанные с HTTP-кешированием, доступные в Spring WebFlux.
`КэшКонтроль`. {spring-framework-api}/http/CacheControl.html[`CacheControl`] обеспечивает поддержку настройка параметров, связанных с заголовком Cache-Control и принимаемых в качестве аргумента в ряде мест:
* Контроллеры
* Статические ресурсы
`КэшКонтроль`.
Хотя {rfc-site}/rfc7234#section-5.2.2[RFC 7234] описывает все возможные директивы для заголовка ответа Cache-Control, тип CacheControl принимает используйте подход, ориентированный на конкретные случаи, который фокусируется на общих сценариях, как показано в следующем примере:
Java
	// Кэш на час - "Cache-Control: max-age=3600"

CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);
	// Запретить кеширование — «Cache-Control: no-store»
	CacheControl ccNoStore = CacheControl.noStore();
	// Кэш на десять дней в публичных и частных тайниках,
	// публичные кэши не должны трансформировать ответ
	// «Cache-Control: max-age=864000, общедоступный, без преобразования»
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
Контроллеры могут добавлять явную поддержку HTTP-кэширования.
Мы рекомендуем это сделать, поскольку Значение `lastModified` или `ETag` для ресурса необходимо вычислить, прежде чем его можно будет сравнить. против заголовков условных запросов.
Контроллер может добавить ETag и Cache-Control. настройки на `ResponseEntity`, как показано в следующем примере:
Java
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {
		Book book = findBook(id);
		String version = book.getVersion();
		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // также доступен LastModified
				.body(book);
		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))

.eTag(version) // также доступен LastModified
				.body(book)
Контроллеры.
В предыдущем примере отправляется ответ 304 (NOT_MODIFIED) с пустым телом, если сравнение к заголовкам условного запроса указывает, что содержимое не изменилось.
В противном случае К ответу добавляются заголовки `ETag` и `Cache-Control`.
Контроллеры.
Вы также можете проверить заголовки условных запросов в контроллере, как показано в следующем примере:
Java
	@RequestMapping
	public String myHandleMethod(ServerWebExchange exchange, Model model) {
		long eTag = ... // <1>
		if (exchange.checkNotModified(eTag)) {
			return null; // <2>
		model.addAttribute(...); // <3>
		return "myViewName";
Контроллеры. <1> Расчет для конкретного приложения. <2> Ответ установлен на 304 (NOT_MODIFIED).
Никакой дальнейшей обработки. <3> Продолжить обработку запроса.
		if (exchange.checkNotModified(eTag)) {
			return null// <2>
		model.addAttribute(...) // <3>
		return "myViewName"
Контроллеры. <1> Расчет для конкретного приложения. <2> Ответ установлен на 304 (NOT_MODIFIED).
Никакой дальнейшей обработки. <3> Продолжить обработку запроса.
Контроллеры.

Существует три варианта проверки условных запросов на соответствие значениям eTag:lastModified. ценности, или и то, и другое.
Для условных запросов GET и HEAD вы можете установить ответ на 304 (НЕ_МОДИФИЦИРОВАНО).
Для условных POST, PUT и DELETE вы можете вместо этого установить ответ до 412 (PRECONDITION_FAILED), чтобы предотвратить одновременное изменение.
Статические ресурсы.
Вы должны обслуживать статические ресурсы с помощью Cache-Control и заголовков условного ответа. для оптимальной производительности.
См. раздел о настройке

Наследование определения компонента.
Определение компонента может содержать много информации о конфигурации, включая конструктор. аргументы, значения свойств и информация, специфичная для контейнера, такая как инициализация. метод, имя статического фабричного метода и т. д.
Определение дочернего компонента наследует данные конфигурации из родительского определения.
Дочернее определение может переопределить некоторые значения или добавьте другие по мере необходимости.
Использование определений родительских и дочерних компонентов может значительно сэкономить. набора текста.
По сути, это форма шаблонизации.
Наследование определения компонента.
Если вы работаете с интерфейсом ApplicationContext программно, дочерний компонент определения представлены классом ChildBeanDefinition.
Большинство пользователей не работают с ними на этом уровне.
Вместо этого они декларативно настраивают определения компонентов в классе. например, ClassPathXmlApplicationContext.
При использовании конфигурации на основе XML метаданных, вы можете указать определение дочернего компонента, используя атрибут «parent», указание родительского компонента в качестве значения этого атрибута.
Следующий пример показывает, как чтобы сделать это:
	<bean id="inheritedTestBean" abstract="true"
			class="org.springframework.beans.TestBean">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>
Наследование определения компонента. <1> Обратите внимание на атрибут «parent».
Наследование определения компонента.

Определение дочернего компонента использует класс компонента из родительского определения, если ни один из них не используется. указан, но также может переопределить его.
В последнем случае дочерний класс компонента должен быть совместим с родительским элементом (то есть он должен принимать значения свойств родительского объекта).
Наследование определения компонента.
Определение дочернего компонента наследует область действия, значения аргументов конструктора, значения свойств и метод переопределяет родительский метод с возможностью добавления новых значений.
Любая область действия, инициализация метод, метод уничтожения или настройки `статического` фабричного метода, которые вы указываете переопределить соответствующие родительские настройки.
Наследование определения компонента.
Остальные настройки всегда берутся из дочернего определения: зависит от, режим автоматического подключения, проверка зависимостей, синглтон и отложенная инициализация.
Наследование определения компонента.
Предыдущий пример явно помечает определение родительского компонента как абстрактное, используя атрибут `абстрактный`.
Если в родительском определении не указан класс, явно требуется пометить определение родительского компонента как «абстрактное», как показано в следующем примере. показывает:
	<bean id="inheritedTestBeanWithoutClass" abstract="true">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>
Наследование определения компонента.
Родительский компонент не может быть создан сам по себе, поскольку он неполный и также явно отмечен как «абстрактный».

Когда определение является «абстрактным», оно можно использовать только как чистое определение шаблонного компонента, которое служит родительским определением для детские определения.
Попытка использовать такой «абстрактный» родительский компонент отдельно, ссылаясь на к нему как к свойству ref другого bean-компонента или выполнив явный вызов getBean() с помощью Идентификатор родительского компонента возвращает ошибку.
Аналогично, внутренняя часть контейнера Метод preInstantiateSingletons() игнорирует определения bean-компонентов, которые определены как абстрактно.
Наследование определения компонента.
ПРИМЕЧАНИЕ. `ApplicationContext` по умолчанию предварительно создает все синглтоны.
Следовательно, это важно (по крайней мере, для одноэлементных bean-компонентов), что если у вас есть определение (родительского) bean-компонента который вы собираетесь использовать только в качестве шаблона, и это определение определяет класс, который вы необходимо обязательно установить для атрибута __abstract__ значение __true__, иначе приложение context фактически (попытается) предварительно создать экземпляр `абстрактного` bean-компонента.

Выбор подхода к доступу к базе данных JDBC.
Вы можете выбрать один из нескольких подходов, чтобы сформировать основу для доступа к базе данных JDBC.
В дополнение к трем вариантам JdbcTemplate, SimpleJdbcInsert и SimpleJdbcCall. подход оптимизирует метаданные базы данных, а стиль объектов РСУБД приводит к более объектно-ориентированный подход.
Начав использовать один из этих подходов, вы все равно можете смешивать и сопоставьте, чтобы включить функцию из другого подхода.
* JdbcTemplate — это классический и самый популярный подход Spring JDBC. Это
Выбор подхода к доступу к базе данных JDBC.
Подход «самого низкого уровня» и все остальные используют «JdbcTemplate».
* NamedParameterJdbcTemplate оборачивает JdbcTemplate для предоставления именованных параметров.
Выбор подхода к доступу к базе данных JDBC. вместо традиционных заполнителей JDBC `?`.
Этот подход обеспечивает лучшее документация и простота использования, когда у вас есть несколько параметров для оператора SQL.
* SimpleJdbcInsert и SimpleJdbcCall оптимизируют метаданные базы данных, чтобы ограничить объем
Выбор подхода к доступу к базе данных JDBC. необходимой конфигурации.
Этот подход упрощает кодирование, так что вам нужно только укажите имя таблицы или процедуры и карту параметров, соответствующих столбцу имена.
Это работает только в том случае, если база данных предоставляет адекватные метаданные.
Если база данных делает не предоставлять эти метаданные, вам необходимо предоставить явную настройку параметров.
* Объекты РСУБД, включая MappingSqlQuery, SqlUpdate и StoredProcedure.

Выбор подхода к доступу к базе данных JDBC. требуют от вас создания многоразовых и потокобезопасных объектов во время инициализации вашего уровень доступа к данным.
Этот подход позволяет вам определить строку запроса, объявить параметры и скомпилируйте запрос.
Как только вы это сделаете, `execute(...)`, `update(...)` и Методы findObject(...)` можно вызывать несколько раз с различными значениями параметров.

Выбор стиля объявления АОП для использования.
После того, как вы решили, что какой-либо аспект является лучшим подходом для реализации данного требование, как вы решаете между использованием Spring AOP или AspectJ и между Стиль аспектного языка (кода), стиль аннотации @AspectJ или стиль Spring XML?
Эти На решения влияет ряд факторов, включая требования приложения, инструменты разработки и знакомство команды с АОП.
Выбор стиля объявления АОП для использования.
Spring AOP или Full AspectJ?
Выбор стиля объявления АОП для использования.
Используйте самое простое, что может сработать.
Spring AOP проще, чем использование полного AspectJ, поскольку нет необходимости внедрять в вашу разработку компилятор/weaver AspectJ и строить процессы.
Если вам нужно только посоветовать выполнение операций на Spring beans, Spring AOP — правильный выбор.
Если вам нужно сообщить об объектах, не управляемых контейнер Spring (обычно такой как объекты домена), вам необходимо использовать АспектДж.
Вам также необходимо использовать AspectJ, если вы хотите указать точки соединения, отличные от выполнение простых методов (например, получение или установка точек соединения полей и т. д.).
Выбор стиля объявления АОП для использования.
Когда вы используете AspectJ, у вас есть выбор синтаксиса языка AspectJ (также известного как «стиль кода») или стиль аннотации @AspectJ.

Если аспекты играют большую роль роль в вашем дизайне, и вы можете использовать https://www.eclipse.org/ajdt/[AspectJ Инструменты разработки (AJDT)] для Eclipse, синтаксис языка AspectJ является предпочтительный вариант.
Это чище и проще, потому что язык был целенаправленно предназначен для написания аспектов.
Если вы не используете Eclipse или у вас всего несколько аспектов которые не играют важной роли в вашем приложении, вы можете рассмотреть возможность использования стиль @AspectJ, придерживаясь обычной компиляции Java в вашей IDE и добавляя этап вплетения аспектов в ваш сценарий сборки.
Выбор стиля объявления АОП для использования. @AspectJ или XML для Spring AOP?
Выбор стиля объявления АОП для использования.
Если вы решили использовать Spring AOP, у вас есть выбор: стиль @AspectJ или XML.
Необходимо учитывать различные компромиссы.
Выбор стиля объявления АОП для использования.
Стиль XML может быть наиболее знаком существующим пользователям Spring, и он поддерживается подлинными POJO.
При использовании АОП в качестве инструмента настройки корпоративных служб XML может оказаться хорошим помощником. выбор (хороший тест — считаете ли вы выражение pointcut частью вашего конфигурацию, которую вы, возможно, захотите изменить самостоятельно).
В стиле XML это возможно, из вашей конфигурации будет яснее, какие аспекты присутствуют в системе.
Выбор стиля объявления АОП для использования.
Стиль XML имеет два недостатка.

Во-первых, он не полностью отражает реализация требования, которое оно адресует, в одном месте.
Принцип DRY гласит: что должно быть единое, недвусмысленное и авторитетное представление любой части знания внутри системы.
При использовании стиля XML знание того, как требование реализуется, разделяется на объявление класса поддерживающего компонента и XML в файл конфигурации.
Когда вы используете стиль @AspectJ, эта информация инкапсулируется. в одном модуле: аспект.
Во-вторых, стиль XML немного более ограничен в возможностях. он может выражать стиль @AspectJ: только модель создания экземпляра аспекта «singleton». поддерживается, и невозможно объединить именованные точки, объявленные в XML.
Например, в стиле @AspectJ можно написать что-то вроде следующего:
Java
	@Pointcut("execution(* get*())")
	public void propertyAccess() {}
	@Pointcut("execution(com.xyz.Account+ *(..))")
	public void operationReturningAnAccount() {}
	@Pointcut("propertyAccess() && operationReturningAnAccount()")
	public void accountPropertyAccess() {}
	<aop:pointcut id="propertyAccess"
			expression="execution(* get*())"/>
	<aop:pointcut id="operationReturningAnAccount"
			expression="execution(com.xyz.Account+ *(..))"/>

В стиле XML вы можете объявить первые две точки:.
Недостатком подхода XML является то, что вы не можете определить `accountPropertyAccess` pointcut путем объединения этих определений.
В стиле XML вы можете объявить первые две точки:.
Стиль @AspectJ поддерживает дополнительные модели создания экземпляров и более широкие возможности pointcut. состав.
Его преимущество заключается в сохранении аспекта как модульного блока.
Он также имеет преимущество в том, что аспекты @AspectJ могут быть поняты (и, следовательно, использованы) как Spring AOP и AspectJ.
Итак, если вы позже решите, что вам нужны возможности AspectJ для реализации дополнительных требований вы можете легко перейти на классическую настройку AspectJ.
В целом команда Spring предпочитает стиль @AspectJ для пользовательских аспектов, выходящих за рамки простого. настройка корпоративных сервисов.

Сканирование пути к классам и управляемые компоненты.
В большинстве примеров в этой главе используется XML для указания метаданных конфигурации, которые создает каждое определение BeanDefinition внутри контейнера Spring.
Предыдущий раздел (Конфигурация контейнера на основе аннотаций) демонстрирует, как предоставить множество метаданных конфигурации на уровне исходного кода. аннотации.
Однако даже в этих примерах определения «базовых» компонентов явно указаны. определены в XML-файле, тогда как аннотации управляют только внедрением зависимостей.
Сканирование пути к классам и управляемые компоненты.
В этом разделе описан вариант неявного обнаружения компонентов-кандидатов путем сканирование пути к классам.
Компоненты-кандидаты — это классы, соответствующие фильтру. критерии и иметь соответствующее определение компонента, зарегистрированное в контейнере.
Это устраняет необходимость использования XML для регистрации компонентов.
Вместо этого вы можете использовать аннотации (например, `@Component`), выражения типа AspectJ или ваши собственные пользовательские критерии фильтра, чтобы выбрать, в каких классах зарегистрированы определения компонентов контейнер.
Сканирование пути к классам и управляемые компоненты. [ПРИМЕЧАНИЕ] = Вы можете определить bean-компоненты, используя Java, а не файлы XML.
Взгляните на Аннотации `@Configuration`, `@Bean`, `@Import` и `@DependsOn` для примеров. о том, как использовать эти функции.
`@Component` и дополнительные аннотации стереотипов.

Аннотация `@Repository` — это маркер любого класса, который выполняет роль или _стереотип_ репозитория (также известный как объект доступа к данным или DAO).
Среди применений этого маркера представляет собой автоматический перевод исключений, как описано в
`@Component` и дополнительные аннотации стереотипов.
Spring предоставляет дополнительные аннотации стереотипов: @Component, @Service и `@Контроллер`. `@Component` — это общий стереотип для любого компонента, управляемого Spring. `@Repository`, `@Service` и `@Controller` являются специализациями `@Component` для более конкретные варианты использования (в сохранении, обслуживании и представлении) слои соответственно).
Таким образом, вы можете аннотировать свои классы компонентов с помощью `@Component`, но путем аннотирования их `@Repository`, `@Service` или `@Controller` вместо этого ваши классы более подходят для обработки с помощью инструментов или связывания с аспектами.
Например, эти стереотипные аннотации являются идеальной мишенью для точечные разрезы. `@Repository`, `@Service` и `@Controller` также могут несут дополнительную семантику в будущих выпусках Spring Framework.
Таким образом, если вы выбирая между использованием `@Component` или `@Service` для вашего уровня обслуживания, `@Service` явно лучший выбор.

Аналогично, как говорилось ранее, `@Repository` уже поддерживается в качестве маркера для автоматического перевода исключений на вашем уровне персистентности.
Использование метааннотаций и составных аннотаций.
Многие из аннотаций, предоставляемых Spring, можно использовать в качестве метааннотаций в вашем проекте. собственный код.
Метааннотация — это аннотация, которую можно применить к другой аннотации.
Например, в аннотации `@Service` упоминается ранее имеет метааннотацию `@Component`, как показано в следующем примере:
Java
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Component // <1>
	public @interface Service {
Использование метааннотаций и составных аннотаций. <1> Метааннотация `@Component` приводит к тому, что `@Service` обрабатывается так же, как `@Component`.
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Component // <1>
	annotation class Service {
Использование метааннотаций и составных аннотаций. <1> Метааннотация `@Component` приводит к тому, что `@Service` обрабатывается так же, как `@Component`.
Использование метааннотаций и составных аннотаций.
Вы также можете комбинировать метааннотации для создания «составных аннотаций».
Например, аннотация `@RestController` из Spring MVC состоит из `@Controller` и `@ResponseBody`.
Использование метааннотаций и составных аннотаций.

Кроме того, составные аннотации могут дополнительно переобъявлять атрибуты из метааннотации для настройки.
Это может быть особенно полезно, когда вы хотите предоставить только подмножество атрибутов метааннотации.
Например, Весна Аннотация `@SessionScope` жестко кодирует имя области в `session`, но по-прежнему позволяет настройка `proxyMode`.
В следующем листинге показано определение Аннотация `@SessionScope`:
Java
	@Target({ElementType.TYPE, ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	public @interface SessionScope {
		 * Alias for {@link Scope#proxyMode}.
		 * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
		@AliasFor(annotation = Scope.class)
		ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;
Java
	@Service
	@SessionScope
	public class SessionScopedService {
	@Service
	@SessionScope
	class SessionScopedService {
Затем вы можете использовать @SessionScope без объявления proxyMode следующим образом:.
Вы также можете переопределить значение ProxyMode, как показано в следующем примере:
Java
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	public class SessionScopedUserService implements UserService {
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	class SessionScopedUserService : UserService {
Затем вы можете использовать @SessionScope без объявления proxyMode следующим образом:.

Более подробную информацию см. {spring-framework-wiki}/Spring-Annotation-Programming-Model [Модель программирования Spring-аннотаций] вики-страница.
Автоматическое обнаружение классов и регистрация определений компонентов.
Spring может автоматически обнаруживать стереотипные классы и регистрировать соответствующие.
Экземпляры BeanDefinition с ApplicationContext.
Например, следующие два класса имеют право на такое автоматическое обнаружение:
Java
	@Service
	public class SimpleMovieLister {
		private final MovieFinder movieFinder;
		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
Java
	@Repository
	public class JpaMovieFinder implements MovieFinder {
		// реализация опущена для ясности
	@Repository
	class JpaMovieFinder : MovieFinder {
		// реализация опущена для ясности
Автоматическое обнаружение классов и регистрация определений компонентов.
Чтобы автоматически обнаружить эти классы и зарегистрировать соответствующие bean-компоненты, вам необходимо добавить `@ComponentScan` в ваш класс `@Configuration`, где атрибут `basePackages` настроен с общим родительским пакетом для двух классов.
Альтернативно, вы можете укажите список, разделенный запятыми, точками с запятой или пробелами, который включает родительский пакет каждого класса.
Java
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
Автоматическое обнаружение классов и регистрация определений компонентов.

СОВЕТ: Для краткости в предыдущем примере можно было бы использовать неявный атрибут value вместо этого используйте аннотацию: `@ComponentScan("org.example")`
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<context:component-scan base-package="org.example"/>
	</beans>
В следующем примере используется конфигурация XML:.
СОВЕТ: Использование `<context:comComponent-scan>` неявно включает функциональность `<context:annotation-config>`.
Обычно нет необходимости включать Элемент `<context:annotation-config>` при использовании `<context:comComponent-scan>`.

В следующем примере используется конфигурация XML:. [ПРИМЕЧАНИЕ] = Для сканирования пакетов classpath требуется наличие соответствующего каталога. записи в пути к классам.
Когда вы создаете JAR-файлы с помощью Ant, убедитесь, что вы не активируйте переключатель «только файлы» задачи JAR.
Кроме того, каталоги путей к классам могут не быть предоставляется на основе политик безопасности в некоторых средах — например, автономные приложения на JDK 1.7.0_45 и выше (для этого требуется настройка Trusted-Library в ваших манифестах — см. {stackoverflow-questions}/19394570/java-jre-7u45-breaks-classloader-getresources).
В следующем примере используется конфигурация XML:.
На пути к модулю (система модулей Java) сканирование пути к классам Spring обычно работает как ожидаемо.
Однако убедитесь, что ваши классы компонентов экспортированы в файл `module-info`. дескрипторы.
Если вы ожидаете, что Spring будет вызывать закрытые члены ваших классов, сделайте уверены, что они «открыты» (то есть, что они используют объявление «opens» вместо объявление `exports` в вашем дескрипторе `module-info`).
В следующем примере используется конфигурация XML:.
Кроме того, `AutowiredAnnotationBeanPostProcessor` и `CommonAnnotationBeanPostProcessor` оба неявно включаются, когда вы используете Элемент `<context:comComponent-scan>`.

Это означает, что два компонента определяются автоматически. и соединены вместе - и все это без каких-либо метаданных конфигурации bean-компонентов, представленных в XML.
В следующем примере используется конфигурация XML:.
ПРИМЕЧАНИЕ.
Вы можете отключить регистрацию `AutowiredAnnotationBeanPostProcessor` и `CommonAnnotationBeanPostProcessor`, включив атрибут `annotation-config` со значением «ложь».
Заполнители свойств и шаблоны в стиле Ant.
Атрибуты `basePackages` и `value` в `@ComponentScan` поддерживают свойство `${...}`. заполнители, которые разрешаются для пакета Environment, а также пакета Ant-style. такие шаблоны, как `"org.example.++**+++"`.
Заполнители свойств и шаблоны в стиле Ant.
Кроме того, можно указать несколько пакетов или шаблонов отдельно или внутри одна строка — например, `{"org.example.config", "org.example.service.+++**+++"}` или `"org.example.config, org.example.service.++++**++++"`.
Заполнители свойств и шаблоны в стиле Ant.
В следующем примере указывается заполнитель свойства app.scan.packages для неявный атрибут value в @ComponentScan.
Java

<1> Заполнитель свойства `app.scan.packages`, который будет сопоставлен с `Environment`.
Следующий листинг представляет файл свойств, который определяет app.scan.packages. собственность.
В предыдущем примере предполагается, что этот файл свойств был зарегистрированный в «Среде» — например, через «@PropertySource» или аналогичный механизм.
Использование фильтров для настройки сканирования.
По умолчанию классы, помеченные `@Component`, `@Repository`, `@Service`, `@Controller`, `@Configuration` или пользовательская аннотация, которая сама помечена с помощью `@Component`, являются единственные обнаруженные компоненты-кандидаты.
Однако вы можете изменить и расширить это поведение. путем применения пользовательских фильтров.
Добавьте их как атрибуты includeFilters или excludeFilters. аннотация `@ComponentScan` (или как `<context:include-filter />` или `<context:exclude-filter />` дочерние элементы элемента `<context:comComponent-scan>` в XML-конфигурация).
Для каждого элемента фильтра требуются атрибуты `type` и `expression`.
В следующей таблице описаны параметры фильтрации:
.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | аннотация (по умолчанию) | `org.example.SomeAnnotation` | Аннотация должна быть _присутствующей_ или _метаприсутствующей_ на уровне типа в целевых компонентах.

.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | назначаемый | `org.example.SomeClass` | Класс (или интерфейс), которому можно назначить (расширить или реализовать) целевые компоненты.
.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | аспектj | `org.example..*Сервис+` | Выражение типа AspectJ, которому должны соответствовать целевые компоненты.
.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | регулярное выражение | `org\.example\.Default.*` | Выражение регулярного выражения, которое должно соответствовать именам классов целевых компонентов.
.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | обычай | `org.example.MyTypeFilter` | Пользовательская реализация интерфейса org.springframework.core.type.TypeFilter. |===
.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание.
В следующем примере показана конфигурация @ComponentScan, исключающая все Аннотации `@Repository` и вместо них включают репозитории ``Stub``:
Java
	@Configuration
	@ComponentScan(basePackages = "org.example",
			includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),

excludeFilters = @Filter(Repository.class))
	public class AppConfig {
	<beans>
		<context:component-scan base-package="org.example">
			<context:include-filter type="regex"
					expression=".*Stub.*Repository"/>
			<context:exclude-filter type="annotation"
					expression="org.springframework.stereotype.Repository"/>
		</context:component-scan>
	</beans>
В следующем листинге показан эквивалентный XML:.
ПРИМЕЧАНИЕ.
Вы также можете отключить фильтры по умолчанию, установив `useDefaultFilters=false` в аннотации или указав `use-default-filters="false"` в качестве атрибута Элемент `<comComponent-scan/>`.
Это эффективно отключает автоматическое обнаружение классов. аннотированный или метааннотированный с помощью `@Component`, `@Repository`, `@Service`, `@Controller`, `@RestController` или `@Configuration`.
Именование автоматически обнаруженных компонентов.
Когда компонент автоматически обнаруживается в процессе сканирования, его имя компонента имеет вид генерируется с помощью стратегии BeanNameGenerator, известной этому сканеру.
Именование автоматически обнаруженных компонентов.
По умолчанию используется AnnotationBeanNameGenerator.
На весну если вы укажете имя через атрибут `value` аннотации, это имя будет использоваться как имя в соответствующем определении компонента.

Это соглашение также применяется, когда Вместо аннотаций стереотипов Spring используется аннотация `@jakarta.inject.Named`.
Именование автоматически обнаруженных компонентов.
Начиная с Spring Framework 6.1, имя атрибута аннотации, которое используется для указания имя компонента больше не обязательно должно быть «значением».
Пользовательские аннотации стереотипов могут объявить атрибут с другим именем (например, `name`) и аннотировать этот атрибут с `@AliasFor(annotation = Component.class, атрибут = "value")`.
Посмотреть исходный код объявление `ControllerAdvice#name()` для конкретного примера.
Именование автоматически обнаруженных компонентов. [ВНИМАНИЕ] = Начиная с Spring Framework 6.1, поддержка стереотипных имен на основе соглашений устарела. и будет удалено в будущей версии платформы.
Следовательно, сложившийся стереотип аннотации должны использовать @AliasFor для объявления явного псевдонима для атрибута value. в `@Component`.
См. объявление исходного кода `Repository#value()` и `ControllerAdvice#name()` для конкретных примеров.
Именование автоматически обнаруженных компонентов.
Если явное имя компонента не может быть получено из такой аннотации или любого другого обнаруженный компонент (например, обнаруженный с помощью пользовательских фильтров), имя компонента по умолчанию Генератор возвращает неполное имя класса без заглавных букв.
Например, если были обнаружены следующие классы компонентов, имена будут `myMovieLister` и `movieFinderImpl`.
Java
	@Service("myMovieLister")

public class SimpleMovieLister {
	@Service("myMovieLister")
	class SimpleMovieLister {
Java
	@Repository
	public class MovieFinderImpl implements MovieFinder {
	@Repository
	class MovieFinderImpl : MovieFinder {
Именование автоматически обнаруженных компонентов.
Если вы не хотите полагаться на стратегию именования компонентов по умолчанию, вы можете предоставить собственную стратегия именования компонентов.
Во-первых, реализовать {spring-framework-api}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`] интерфейс и обязательно включите конструктор без аргументов по умолчанию.
Затем предоставьте полную квалифицированное имя класса при настройке сканера, как в следующем примере аннотации. и шоу определения компонента.
Именование автоматически обнаруженных компонентов.
СОВЕТ: Если вы столкнулись с конфликтом имен из-за того, что несколько автоматически обнаруженных компонентов имеют одно и то же неполное имя класса (т. е. классы с одинаковыми именами, но находящиеся в разные пакеты), вам может потребоваться настроить BeanNameGenerator, который по умолчанию имеет значение полное имя класса для сгенерированного имени компонента. `FullyQualifiedAnnotationBeanNameGenerator` находится в пакете Для таких целей можно использовать `org.springframework.context.annotation`.
Java
	@Configuration
	@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
	public class AppConfig {
	<beans>
		<context:component-scan base-package="org.example"
			name-generator="org.example.MyNameGenerator" />
	</beans>

Именование автоматически обнаруженных компонентов.
Как правило, рассмотрите возможность указания имени с аннотацией всякий раз, когда другие компоненты могут явно ссылаться на него.
С другой стороны, автоматически сгенерированные имена подходят, когда контейнер отвечает за проводку.
Предоставление области для автоматически определяемых компонентов.
Как и в случае с компонентами, управляемыми Spring, стандартная и наиболее распространенная область действия для автоматически определяемые компоненты — это «singleton».
Однако иногда вам нужна другая область применения. это можно указать с помощью аннотации `@Scope`.
Вы можете указать название область действия внутри аннотации, как показано в следующем примере:
Java
	@Scope("prototype")
	@Repository
	public class MovieFinderImpl implements MovieFinder {
	@Scope("prototype")
	@Repository
	class MovieFinderImpl : MovieFinder {
Предоставление области для автоматически определяемых компонентов.
ПРИМЕЧАНИЕ.
Аннотации `@Scope` анализируются только для конкретного класса bean-компонента (для аннотированных компоненты) или фабричный метод (для методов @Bean).
В отличие от XML-компонента определений, нет понятия наследования определений компонентов и наследования иерархии на уровне классов не имеют значения для целей метаданных.
Предоставление области для автоматически определяемых компонентов.
Подробную информацию о веб-областях, таких как «запрос» или «сеанс» в контексте Spring, см. см. области запросов, сеансов, приложений и WebSocket.

Как и в случае с предварительно созданными аннотациями для этих областей, вы также можете создать свою собственную область видимости. аннотации с использованием подхода мета-аннотаций Spring: например, пользовательская аннотация мета-аннотация с `@Scope("prototype")`, возможно, также объявляющая собственный режим прокси-сервера с ограниченной областью действия.
Предоставление области для автоматически определяемых компонентов.
ПРИМЕЧАНИЕ.
Чтобы предоставить собственную стратегию решения задач, а не полагаться на основанный на аннотациях подход, вы можете реализовать {spring-framework-api}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`] интерфейс.
Обязательно включите конструктор без аргументов по умолчанию.
Тогда вы можете предоставить полное имя класса при настройке сканера, как показано в следующем примере. аннотация и определение компонента показывают:
Java
	@Configuration
	@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
	public class AppConfig {
	<beans>
		<context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
	</beans>
Предоставление области для автоматически определяемых компонентов.
При использовании определенных областей, не являющихся одноэлементными, может потребоваться создание прокси для объекты с ограниченной областью действия.
Обоснование описано в Для этой цели в компоненте сканирования доступен атрибутscoped-proxy. элемент.

Три возможных значения: «нет», «интерфейсы» и «targetClass».
Например, следующая конфигурация приводит к созданию стандартных динамических прокси JDK:
Java
	@Configuration
	@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
	public class AppConfig {
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
	class AppConfig {
	<beans>
		<context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
	</beans>
Предоставление метаданных квалификаторов с аннотациями.
Аннотация `@Qualifier` обсуждается в Примеры в этом разделе демонстрируют использование аннотации @Qualifier и пользовательские аннотации квалификаторов для обеспечения детального управления при разрешении автоматического связывания. кандидаты.
Поскольку эти примеры были основаны на определениях XML-компонентов, квалификатор метаданные были предоставлены в определениях компонентов-кандидатов с использованием квалификатора или мета. дочерние элементы элемента bean в XML.
Полагаясь на сканирование пути к классам для автоматическое обнаружение компонентов, вы можете предоставить метаданные квалификатора на уровне типа. аннотации к классу-кандидату.
Следующие три примера демонстрируют это. техника:
Java
	@Component
	@Qualifier("Action")
	public class ActionMovieCatalog implements MovieCatalog {
	@Component
	@Qualifier("Action")
	class ActionMovieCatalog : MovieCatalog
Java
	@Component
	@Genre("Action")
	public class ActionMovieCatalog implements MovieCatalog {
	@Component

@Genre("Action")
	class ActionMovieCatalog : MovieCatalog {
Java
	@Component
	@Offline
	public class CachingMovieCatalog implements MovieCatalog {
@Component @Offline class CachingMovieCatalog: MovieCatalog {.
ПРИМЕЧАНИЕ.
Как и в случае с большинством альтернатив на основе аннотаций, имейте в виду, что метаданные аннотаций привязан к самому определению класса, в то время как использование XML позволяет использовать несколько bean-компонентов одного и того же типа, чтобы предоставлять варианты метаданных квалификаторов, поскольку это метаданные предоставляются для каждого экземпляра, а не для каждого класса.
Определение метаданных компонента внутри компонентов.
Компоненты Spring также могут вносить в контейнер метаданные определения компонента.
Вы можете сделать это с той же аннотацией `@Bean`, используемой для определения метаданных компонента в `@Configuration` аннотированные классы.
В следующем примере показано, как это сделать:
Java
	@Component
	public class FactoryMethodComponent {
		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		public void doWork() {
			// Реализация метода компонента опущена
	@Component
	class FactoryMethodComponent {
Определение метаданных компонента внутри компонентов.
Предыдущий класс — это компонент Spring, в котором есть код, специфичный для приложения. метод `doWork()`.
Однако он также вносит свой вклад в определение компонента, у которого есть фабрика. метод, ссылающийся на метод publicInstance().

Аннотация `@Bean` идентифицирует фабричный метод и другие свойства определения компонента, такие как значение квалификатора через аннотация `@Qualifier`.
Другие аннотации уровня метода, которые можно указать: `@Scope`, `@Lazy` и пользовательские аннотации квалификаторов.
Определение метаданных компонента внутри компонентов. [СОВЕТ] = В дополнение к его роли для инициализации компонента вы также можете разместить `@Lazy` аннотации к точкам внедрения, отмеченным `@Autowired` или `@Inject`.
В этом контексте это приводит к внедрению прокси-сервера с ленивым разрешением.
Однако такой прокси-подход является довольно ограниченным.
Для сложных ленивых взаимодействий, особенно в сочетании с дополнительными зависимостями вместо этого мы рекомендуем `ObjectProvider<MyTargetBean>`.
Определение метаданных компонента внутри компонентов.
Как обсуждалось ранее, поддерживаются автоматически связываемые поля и методы с дополнительными поддержка автоматического подключения методов `@Bean`.
В следующем примере показано, как это сделать:
Java
	@Component
	public class FactoryMethodComponent {
		private static int i;
		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		// использование специального квалификатора и автоматическое связывание параметров метода
		@Bean
		protected TestBean protectedInstance(
				@Qualifier("public") TestBean spouse,
				@Value("#{privateInstance.age}") String country) {

TestBean tb = new TestBean("protectedInstance", 1);
			tb.setSpouse(spouse);
			tb.setCountry(country);
			return tb;
		@Bean
		private TestBean privateInstance() {
			return new TestBean("privateInstance", i++);
		@Bean
		@RequestScope
		public TestBean requestScopedInstance() {
			return new TestBean("requestScopedInstance", 3);
	@Component
	class FactoryMethodComponent {
Определение метаданных компонента внутри компонентов.
В примере автоматически привязывается параметр метода `String` `country` к значению `age`. свойство другого компонента с именем PrivateInstance.
Элемент языка выражений Spring определяет значение свойства через обозначение `#{ <выражение> }`.
Для `@Value` аннотаций, преобразователь выражений предварительно настроен для поиска имен компонентов, когда разрешение текста выражения.
Определение метаданных компонента внутри компонентов.
Начиная с Spring Framework 4.3, вы также можете объявить параметр фабричного метода типа `InjectionPoint` (или его более конкретный подкласс: `DependencyDescriptor`) для получить доступ к запрашивающей точке внедрения, которая запускает создание текущего компонента.
Обратите внимание, что это относится только к фактическому созданию экземпляров компонента, а не к внедрение существующих экземпляров.
Как следствие, эта функция имеет наибольший смысл для бобы области прототипа.

Для других областей фабричный метод видит только точка внедрения, которая инициировала создание нового экземпляра компонента в заданной области (например, зависимость, которая вызвала создание ленивого одноэлементного компонента).
В таких сценариях вы можете использовать предоставленные метаданные точки внедрения с семантической осторожностью.
В следующем примере показано, как использовать InjectionPoint:
Java
	@Component
	public class FactoryMethodComponent {
		@Bean @Scope("prototype")
		public TestBean prototypeInstance(InjectionPoint injectionPoint) {
			return new TestBean("prototypeInstance for " + injectionPoint.getMember());
	@Component
	class FactoryMethodComponent {
Определение метаданных компонента внутри компонентов.
Методы `@Bean` в обычном компоненте Spring обрабатываются иначе, чем их аналоги внутри класса Spring `@Configuration`.
Разница в том, что `@Component` классы не дополнены CGLIB для перехвата вызова методов и полей.
Проксирование CGLIB — это средство вызова методов или полей внутри методов `@Bean`. в классах `@Configuration` создает ссылки на метаданные компонента для взаимодействующих объектов.
Такие методы не вызываются с обычной семантикой Java, а проходят через контейнер для обеспечения обычного управления жизненным циклом и проксирования Spring. bean-компоненты, даже при обращении к другим bean-компонентам посредством программного вызова методов `@Bean`.
Напротив, вызов метода или поля в методе `@Bean` внутри простого `@Component` класс имеет стандартную семантику Java, без специальной обработки CGLIB или других применение ограничений.

Определение метаданных компонента внутри компонентов. [ПРИМЕЧАНИЕ] = Вы можете объявить методы `@Bean` как `статические`, что позволит вызывать их без создание содержащего их класса конфигурации в качестве экземпляра.
Это делает особый смысл при определении bean-компонентов постпроцессора (например, типа BeanFactoryPostProcessor). или `BeanPostProcessor`), поскольку такие bean-компоненты инициализируются на ранней стадии в контейнере. жизненный цикл и не должны запускать другие части конфигурации на этом этапе.
Определение метаданных компонента внутри компонентов.
Вызовы статических методов `@Bean` никогда не перехватываются контейнером, даже внутри него.
Классы `@Configuration` (как описано ранее в этом разделе) по техническим причинам ограничения: создание подклассов CGLIB может переопределить только нестатические методы.
Как следствие, прямой вызов другого метода `@Bean` имеет стандартную семантику Java, в результате чего в независимом экземпляре, возвращаемом прямо из самого фабричного метода.
Определение метаданных компонента внутри компонентов.
Видимость методов `@Bean` в языке Java не оказывает непосредственного влияния на полученное определение bean-компонента в контейнере Spring.
Вы можете свободно заявить о своем фабричные методы, которые вы считаете подходящими для классов, отличных от `@Configuration`, а также для статических методы где угодно.
Однако обычные методы `@Bean` в классах `@Configuration` требуют быть переопределяемыми, то есть их нельзя объявлять как «частные» или «окончательные».

Определение метаданных компонента внутри компонентов.
Методы `@Bean` также обнаруживаются в базовых классах данного компонента или класс конфигурации, а также методы Java по умолчанию, объявленные в интерфейсах реализованный компонентом или классом конфигурации.
Это позволяет реализовать множество гибкость в составлении сложных конфигураций, даже с несколькими наследование возможно с помощью методов Java по умолчанию.
Определение метаданных компонента внутри компонентов.
Наконец, один класс может содержать несколько методов @Bean для одного и того же объекта. bean-компонент, как сочетание нескольких фабричных методов, которые можно использовать в зависимости от доступных зависимости во время выполнения.
Это тот же алгоритм, что и при выборе «самого жадного» конструктор или фабричный метод в других сценариях конфигурации: вариант с наибольшее количество выполнимых зависимостей выбирается во время построения, аналогично тому, как контейнер выбирает между несколькими конструкторами @Autowired.

Коллекция Проекция.
Проекция позволяет коллекции управлять вычислением подвыражения, и результатом будет новая коллекция.
Синтаксис проекции: `.![projectionExpression]`.
Например, Предположим, у нас есть список изобретателей, но нам нужен список городов, в которых они родились.
По сути, мы хотим оценить «placeOfBirth.city» для каждой записи в изобретателе. список.
В следующем примере для этого используется проекция:
Java
	// оценивается как ["Смилян", "Идвор"]
	List placesOfBirth = parser.parseExpression("members.![placeOfBirth.city]")
			.getValue(societyContext, List.class);
Коллекция Проекция.
Проекция поддерживается для массивов и всего, что реализует java.lang.Iterable или `java.util.Map`.
При использовании карты для управления проекцией выражение проекции имеет вид оценивается для каждой записи на карте (представленной как Java `Map.Entry`).
Результат проекции на карту — это список, состоящий из оценок проекции выражение против каждой записи карты.
Коллекция Проекция. [ПРИМЕЧАНИЕ] = Язык выражений Spring также поддерживает безопасную навигацию для проецирования коллекции.
Коллекция Проекция.
См. для получения подробной информации.

Выбор коллекции.
Выбор — это мощная функция языка выражений, которая позволяет преобразовать исходную коллекцию в другую коллекцию, выбирая из ее записей.
Выбор коллекции.
Выбор использует синтаксис `.?[selectionExpression]`.
Он фильтрует коллекцию и возвращает новую коллекцию, содержащую подмножество исходных элементов.
Например, Выборка позволяет нам легко получить список сербских изобретателей, как показывает следующий пример:
Java
	List<Inventor> list = (List<Inventor>) parser.parseExpression(
			"members.?[nationality == 'Serbian']").getValue(societyContext);
Выбор коллекции.
Выбор поддерживается для массивов и всего, что реализует java.lang.Iterable или `java.util.Map`.
Для массива или Iterable оценивается выражение выбора. против каждого отдельного элемента.
На карте оценивается выражение выбора против каждой записи карты (объекты типа Java `Map.Entry`).
Каждая запись на карте имеет свое `key` и `value` доступны как свойства для использования при выборе.
Выбор коллекции.
Учитывая `Map`, хранящуюся в переменной с именем `#map`, следующее выражение возвращает новый карта, состоящая из тех элементов исходной карты, значение записи которых меньше чем 27:
Java
	Map newMap = parser.parseExpression("#map.?[value < 27]").getValue(Map.class);
Выбор коллекции.

Помимо возврата всех выбранных элементов, вы можете получить только первый или последний элемент.
Чтобы получить первый элемент, соответствующий выражению выбора, синтаксис: `.^[selectionExpression]`.
Чтобы получить последний элемент, соответствующий выделенному выражение, синтаксис — `.$[selectionExpression]`.
Выбор коллекции. [ПРИМЕЧАНИЕ] = Язык выражений Spring также поддерживает безопасную навигацию при выборе коллекции.
Выбор коллекции.
См. для получения подробной информации.

Составление конфигураций на основе Java.
Функция конфигурации Spring на основе Java позволяет создавать аннотации, что позволяет сократить сложность вашей конфигурации.
Использование аннотации `@Import`.
Подобно тому, как элемент `<import/>` используется в файлах Spring XML для облегчения модульности конфигурации, аннотация `@Import` позволяет загружать определения `@Bean` из другой класс конфигурации, как показано в следующем примере:
Java
	@Configuration
	public class ConfigA {
		@Bean
		public A a() {
			return new A();
	@Configuration
	@Import(ConfigA.class)
	public class ConfigB {
		@Bean
		public B b() {
			return new B();
	@Configuration
	class ConfigA {
Использование аннотации `@Import`.
Теперь вместо необходимости указывать ConfigA.class и ConfigB.class при для создания экземпляра контекста необходимо явно указать только `ConfigB`, так как следующий пример показывает:
Java
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);
		// теперь оба компонента A и B будут доступны...
		A a = ctx.getBean(A.class);
		B b = ctx.getBean(B.class);
Использование аннотации `@Import`.

Этот подход упрощает создание экземпляра контейнера, поскольку необходимо иметь дело только с одним классом. вместо того, чтобы требовать от вас запоминания потенциально большого количества Классы `@Configuration` во время сборки.
Использование аннотации `@Import`.
СОВЕТ: Начиная с Spring Framework 4.2, `@Import` также поддерживает ссылки на обычные компоненты. классы, аналогичные методу AnnotationConfigApplicationContext.register.
Это особенно полезно, если вы хотите избежать сканирования компонентов, используя несколько классы конфигурации в качестве точек входа для явного определения всех ваших компонентов.
Внедрение зависимостей в импортированные определения `@Bean`.
Предыдущий пример работает, но является упрощенным.
В большинстве практических сценариев бобы имеют зависимости друг от друга в классах конфигурации.
При использовании XML это не проблема, потому что компилятор не задействован, и вы можете объявить `ref="someBean"` и доверите Spring решить эту проблему во время инициализации контейнера.
При использовании классов `@Configuration` компилятор Java накладывает ограничения на модель конфигурации, в которой ссылки на другие компоненты должны соответствовать допустимому синтаксису Java.
Внедрение зависимостей в импортированные определения `@Bean`.
К счастью, решить эту проблему просто.
Как метод `@Bean` может иметь произвольное количество параметров, описывающих компонент. зависимости.
Рассмотрим следующий более реалистичный сценарий с несколькими `@Configuration` классы, каждый из которых зависит от bean-компонентов, объявленных в других:
Java
	@Configuration
	public class ServiceConfig {

@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
	@Configuration
	public class RepositoryConfig {
		@Bean
		public AccountRepository accountRepository(DataSource dataSource) {
			return new JdbcAccountRepository(dataSource);
	@Configuration
	@Import({ServiceConfig.class, RepositoryConfig.class})
	public class SystemTestConfig {
		@Bean
		public DataSource dataSource() {
			// вернуть новый источник данных
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		// все связано между классами конфигурации...
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	@Configuration
	class ServiceConfig {
	@Configuration
	class RepositoryConfig {
Внедрение зависимостей в импортированные определения `@Bean`.
Есть еще один способ добиться того же результата.
Помните, что классы `@Configuration` в конечном итоге только еще один компонент в контейнере: это означает, что они могут воспользоваться преимуществами Внедрение `@Autowired` и `@Value` и другие функции такие же, как и у любого другого bean-компонента.

Внедрение зависимостей в импортированные определения `@Bean`. [ВНИМАНИЕ] = Убедитесь, что зависимости, которые вы вводите таким образом, имеют только самый простой вид. `@Конфигурация` классы обрабатываются довольно рано во время инициализации контекста и вызывают зависимость такое внедрение может привести к неожиданной ранней инициализации.
По возможности прибегайте к внедрение на основе параметров, как в предыдущем примере.
Внедрение зависимостей в импортированные определения `@Bean`.
Избегайте доступа к локально определенным bean-компонентам в методе @PostConstruct в той же конфигурации. класс.
Это фактически приводит к циклической ссылке, поскольку семантически нестатические методы `@Bean` требуют вызова полностью инициализированного экземпляра класса конфигурации.
С циклическими ссылками запрещено (например, в Spring Boot 2.6+), это может вызвать исключение BeanCurrentlyInCreationException.
Внедрение зависимостей в импортированные определения `@Bean`.
Кроме того, будьте особенно осторожны с определениями BeanPostProcessor и BeanFactoryPostProcessor. через `@Bean`.
Обычно их следует объявлять как статические методы @Bean, не запуская создание экземпляра содержащего их класса конфигурации.
В противном случае `@Autowired` и `@Value` могут не работать. поработайте над самим классом конфигурации, поскольку его можно создать как экземпляр компонента раньше, чем {spring-framework-api}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`].
Внедрение зависимостей в импортированные определения `@Bean`.

В следующем примере показано, как один компонент можно автоматически подключить к другому компоненту:
Java
	@Configuration
	public class ServiceConfig {
		@Autowired
		private AccountRepository accountRepository;
		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(accountRepository);
	@Configuration
	public class RepositoryConfig {
		private final DataSource dataSource;
		public RepositoryConfig(DataSource dataSource) {
			this.dataSource = dataSource;
		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
	@Configuration
	@Import({ServiceConfig.class, RepositoryConfig.class})
	public class SystemTestConfig {
		@Bean
		public DataSource dataSource() {
			// вернуть новый источник данных
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		// все связано между классами конфигурации...
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	@Configuration
	class ServiceConfig {
Внедрение зависимостей в импортированные определения `@Bean`.
СОВЕТ: Обратите внимание, что нет необходимости указывать @Autowired, если целевой компонент определяет только один конструктор.
Внедрение зависимостей в импортированные определения `@Bean`. [дискретный] Полностью соответствующие импортные компоненты для удобства навигации.
Внедрение зависимостей в импортированные определения `@Bean`.

В предыдущем сценарии использование @Autowired работает хорошо и обеспечивает желаемый результат. модульность, но определение того, где именно объявляются определения автоматически подключенных компонентов, является все еще несколько двусмысленно.
Например, как разработчик, просматривающий ServiceConfig, как вы точно знаете, где объявлен bean-компонент @Autowired AccountRepository?
Это не явно в коде, и это может быть нормально.
Обратите внимание, что {spring-site-tools}[Spring Tools] Поддержка IDE предоставляет инструменты, которые могут отображать графики. показать, как все подключено, и это может быть все, что вам нужно.
Кроме того, ваша Java IDE может легко найти все объявления и использования типа AccountRepository и быстро показать вы указываете расположение методов `@Bean`, которые возвращают этот тип.
Внедрение зависимостей в импортированные определения `@Bean`.
В случаях, когда эта двусмысленность неприемлема и вы хотите иметь прямую навигацию из вашей IDE из одного класса `@Configuration` в другой, рассмотрите возможность автоматического подключения сами классы конфигурации.
В следующем примере показано, как это сделать:
Java
	@Configuration
	public class ServiceConfig {
		@Autowired
		private RepositoryConfig repositoryConfig;
		@Bean
		public TransferService transferService() {
			// перейдите «через» класс конфигурации к методу @Bean!
			return new TransferServiceImpl(repositoryConfig.accountRepository());
@Configuration class ServiceConfig {.
В предыдущей ситуации определение AccountRepository совершенно явно.
Однако ServiceConfig теперь тесно связан с RepositoryConfig.

Это компромисс.
Эту тесную связь можно несколько смягчить, используя интерфейсы или абстрактные классы `@Configuration` на основе классов.
Рассмотрим следующий пример:
Java
	@Configuration
	public class ServiceConfig {
		@Autowired
		private RepositoryConfig repositoryConfig;
		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(repositoryConfig.accountRepository());
	@Configuration
	public interface RepositoryConfig {
		@Bean
		AccountRepository accountRepository();
	@Configuration
	public class DefaultRepositoryConfig implements RepositoryConfig {
		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(...);
	@Configuration
	@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
	public class SystemTestConfig {
		@Bean
		public DataSource dataSource() {
			// вернуть источник данных
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	@Configuration
	class ServiceConfig {
	@Configuration
	interface RepositoryConfig {
	@Configuration
	class DefaultRepositoryConfig : RepositoryConfig {
@Configuration class ServiceConfig {.
Теперь ServiceConfig слабо связан с конкретным `DefaultRepositoryConfig`, а встроенные инструменты IDE по-прежнему полезны: вы можете легко получить иерархию типов реализаций RepositoryConfig.

В этом кстати, навигация по классам `@Configuration` и их зависимостям не станет исключением. чем обычный процесс навигации по интерфейсному коду.
Влияние на запуск синглтонов, определенных `@Bean`.
Если вы хотите повлиять на порядок создания запуска определенных одноэлементных компонентов, рассмотрите объявив некоторые из них как `@Lazy` для создания при первом доступе, а не при запуске.
Влияние на запуск синглтонов, определенных `@Bean`. `@DependsOn` заставляет сначала инициализировать некоторые другие компоненты, гарантируя, что указанные bean-компоненты создаются до текущего bean-компонента, за пределами того, что у последнего подразумевают прямые зависимости.
Фоновая инициализация.
Начиная с версии 6.2, есть опция фоновой инициализации: `@Bean(bootstrap=BACKGROUND)` позволяет выделить определенные bean-компоненты для фоновой инициализации, охватывая весь шаг создания компонента для каждого такого компонента при запуске контекста.
Фоновая инициализация.
Зависимые bean-компоненты с неленивыми точками внедрения автоматически ждут экземпляр bean-компонента. быть завершено.
Все обычные фоновые инициализации принудительно завершаются в конце. запуска контекста.
Разрешается завершать только bean-компоненты, дополнительно помеченные как `@Lazy`. позже (вплоть до первого фактического доступа).
Фоновая инициализация обычно выполняется вместе с `@Lazy` (или `ObjectProvider`).
Точки инъекции в зависимых bean-компонентах.

В противном случае основной поток начальной загрузки будет блокируется, когда фактический экземпляр bean-компонента, инициализированный в фоновом режиме, необходимо внедрить раньше.
Фоновая инициализация.
Эта форма одновременного запуска применяется к отдельным компонентам: если такой компонент зависит от другие bean-компоненты, они должны быть уже инициализированы либо просто путем объявленный ранее, или через `@DependsOn`, который обеспечивает инициализацию в основном загрузочный поток до запуска фоновой инициализации затронутого bean-компонента.
Фоновая инициализация. [ПРИМЕЧАНИЕ] = Компонент `bootstrapExecutor` типа `Executor` должен быть объявлен для фона. загрузка, чтобы быть действительно активной.
В противном случае фоновые маркеры будут игнорироваться. время выполнения.
Фоновая инициализация.
Исполнитель начальной загрузки может быть ограниченным исполнителем только для целей запуска или общим пул потоков, который служит и для других целей.
Условно включать классы `@Configuration` или методы `@Bean`.
Часто бывает полезно условно включить или отключить полный класс @Configuration. или даже отдельные методы `@Bean`, основанные на произвольном состоянии системы.
Один общий примером этого является использование аннотации `@Profile` для активации bean-компонентов только тогда, когда определенный профиль включен в Spring `Environment` (см.
Профили определения компонентов подробности).
Условно включать классы `@Configuration` или методы `@Bean`.

Аннотация `@Profile` на самом деле реализована с использованием гораздо более гибкой аннотации. называется {spring-framework-api}/context/annotation/Conditional.html[`@Conditional`].
Аннотация `@Conditional` указывает на конкретные `org.springframework.context.annotation.Condition` реализации, которые должны быть проконсультироваться перед регистрацией `@Bean`.
Условно включать классы `@Configuration` или методы `@Bean`.
Реализации интерфейса Condition предоставляют функцию match(...)`. метод, который возвращает true или false.
Например, следующий листинг показывает фактическое Реализация `Condition`, используемая для `@Profile`:
Java
	@Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		// Читаем атрибуты аннотации @Profile
		MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
		if (attrs != null) {
			for (Object value : attrs.get("value")) {
				if (context.getEnvironment().matchesProfiles((String[]) value)) {
					return true;
			return false;
		return true;
Условно включать классы `@Configuration` или методы `@Bean`.
См. {spring-framework-api}/context/annotation/Conditional.html[`@Conditional`] javadoc для более подробной информации.

Объединение конфигурации Java и XML.
Поддержка класса @Configuration в Spring не претендует на 100% полную замену. для Spring XML.
Некоторые средства, такие как пространства имен Spring XML, остаются идеальным способом настроить контейнер.
В тех случаях, когда XML удобен или необходим, у вас есть выбор: либо создать экземпляр контейнера «XML-ориентированным», используя, например, ClassPathXmlApplicationContext или создайте его экземпляр «Java-ориентированным» способом, используя AnnotationConfigApplicationContext и аннотация @ImportResource для импорта XML. по мере необходимости.
XML-ориентированное использование классов `@Configuration`.
Возможно, будет предпочтительнее загрузить контейнер Spring из XML и включить Классы `@Configuration` в специальной форме.
Например, в большой существующей базе кода использующий Spring XML, проще создавать классы `@Configuration` на по мере необходимости и включать их из существующих XML-файлов.
Далее в этом разделе мы рассмотрим варианты использования классов `@Configuration` в подобной ситуации, ориентированной на XML.
[дискретный] Объявление классов `@Configuration` как простых элементов Spring `<bean/>`.
Помните, что классы @Configuration в конечном итоге являются определениями компонентов в контейнере.
В этой серии примеров мы создаем класс @Configuration с именем AppConfig и включите его в `system-test-config.xml` как определение `<bean/>`.

Потому что `<context:annotation-config/>` включен, контейнер распознает аннотация `@Configuration` и обрабатывает методы `@Bean`, объявленные в `AppConfig` правильно.
Java
	@Configuration
	public class AppConfig {
		@Autowired
		private DataSource dataSource;
		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(accountRepository());
	@Configuration
	class AppConfig {
	<beans>
		<!-- enable processing of annotations such as @Autowired and @Configuration -->
		<context:annotation-config/>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
		<bean class="com.acme.AppConfig"/>
		<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>
	</beans>
Java
	public static void main(String[] args) {

ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
		TransferService transferService = ctx.getBean(TransferService.class);
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb jdbc.username=sa jdbc.password=.
ПРИМЕЧАНИЕ.
В файле `system-test-config.xml` AppConfig `<bean/>` не объявляет `id`. атрибут.
Хотя это было бы приемлемо, в этом нет необходимости, учитывая, что никакой другой bean-компонент когда-либо ссылается на него, и маловероятно, что оно будет явно получено из контейнера по имени.
Аналогично, компонент DataSource автоматически подключается только по типу, поэтому явный идентификатор компонента не является строго обязательным.
[дискретный] Использование <context:comComponent-scan/> для выбора классов `@Configuration`.
Поскольку `@Configuration` имеет мета-аннотацию `@Component`, `@Configuration`-аннотирован классы автоматически становятся кандидатами на сканирование компонентов.
Используя тот же сценарий, что и описанный в предыдущем примере, мы можем переопределить `system-test-config.xml`, чтобы принять преимущество сканирования компонентов.

Обратите внимание, что в этом случае нам не нужно явно объявлять `<context:annotation-config/>`, потому что `<context:comComponent-scan/>` включает то же самое функциональность.
	<beans>
		<!-- picks up and registers AppConfig as a bean definition -->
		<context:component-scan base-package="com.acme"/>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
		<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>
	</beans>
`@Configuration` Классно-ориентированное использование XML с `@ImportResource`.
В приложениях, где классы @Configuration являются основным механизмом настройки контейнере, возможно, все равно придется использовать хотя бы немного XML.
В таких случаях вы можете использовать @ImportResource и определять столько XML, сколько вам нужно.
Тем самым достигается «Java-ориентированный» подход к настройке контейнера сводит XML к минимуму.

Следующий пример (который включает класс конфигурации, XML-файл, определяющий bean-компонент, файл свойств и метод `main()`) показывает, как использовать `@ImportResource` аннотация для достижения «Java-ориентированной» конфигурации, которая использует XML по мере необходимости:
Java
	@Configuration
	@ImportResource("classpath:/com/acme/properties-config.xml")
	public class AppConfig {
		@Value("${jdbc.url}")
		private String url;
		@Value("${jdbc.username}")
		private String username;
		@Value("${jdbc.password}")
		private String password;
		@Bean
		public DataSource dataSource() {
			return new DriverManagerDataSource(url, username, password);
		@Bean
		public AccountRepository accountRepository(DataSource dataSource) {
			return new JdbcAccountRepository(dataSource);
		@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
	@Configuration
	@ImportResource("classpath:/com/acme/properties-config.xml")
	class AppConfig {
	<beans>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
	</beans>
Java
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);

TransferService transferService = ctx.getBean(TransferService.class);

Краткие определения прокси.
Особенно при определении транзакционных прокси-серверов вы можете получить множество похожих прокси-серверов. определения.
Использование определений родительского и дочернего bean-компонентов, а также внутреннего bean-компонента. определения, могут привести к более чистым и кратким определениям прокси.
Краткие определения прокси.
Сначала мы создаем родительское определение, шаблон и определение компонента для прокси следующим образом:
	<bean id="txProxyTemplate" abstract="true"
			class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
		<property name="transactionManager" ref="transactionManager"/>
		<property name="transactionAttributes">
			<props>
				<prop key="*">PROPAGATION_REQUIRED</prop>
			</props>
		</property>
	</bean>
Краткие определения прокси.
Это никогда не создается само по себе, поэтому на самом деле оно может быть неполным.
Затем каждый прокси необходимо создать определение дочернего компонента, который обертывает цель прокси как определение внутреннего компонента, поскольку цель в любом случае никогда не используется сама по себе.
В следующем примере показан такой дочерний компонент:
	<bean id="myService" parent="txProxyTemplate">
		<property name="target">
			<bean class="org.springframework.samples.MyServiceImpl">
			</bean>
		</property>
	</bean>
Краткие определения прокси.

Вы можете переопределить свойства родительского шаблона.
В следующем примере мы переопределяем настройки распространения транзакций:
	<bean id="mySpecialService" parent="txProxyTemplate">
		<property name="target">
			<bean class="org.springframework.samples.MySpecialServiceImpl">
			</bean>
		</property>
		<property name="transactionAttributes">
			<props>
				<prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
				<prop key="find*">PROPAGATION_REQUIRED,readOnly</prop>
				<prop key="load*">PROPAGATION_REQUIRED,readOnly</prop>
				<prop key="store*">PROPAGATION_REQUIRED</prop>
			</props>
		</property>
	</bean>
Краткие определения прокси.
Обратите внимание, что в примере родительского компонента мы явно пометили определение родительского компонента как быть абстрактным, установив для атрибута `abstract` значение `true`, как описано создан экземпляр.
Контексты приложений (но не простые фабрики компонентов) по умолчанию предварительно создать экземпляр всех синглтонов.
Поэтому важно (по крайней мере, для одноэлементных bean-компонентов) что если у вас есть определение (родительского) компонента, которое вы собираетесь использовать только в качестве шаблона, и это определение указывает класс, вы должны обязательно установить `abstract` атрибут `истина`.

В противном случае контекст приложения фактически пытается предварительно создайте его.

Конфигурация WebFlux.
Конфигурация Java WebFlux объявляет компоненты, необходимые для обработки запросы с аннотированными контроллерами или функциональными конечными точками, а также предлагает API для настроить конфигурацию.
Это означает, что вам не нужно понимать суть bean-компоненты, созданные конфигурацией Java.
Однако, если вы хотите их понять, вы можете увидеть их в `WebFluxConfigurationSupport` или узнать больше о том, что они собой представляют. в Специальные типы компонентов.
Конфигурация WebFlux.
Для более сложных настроек, недоступных в API конфигурации, вы можете получить полный контроль над конфигурацией через
Включение конфигурации WebFlux.
Вы можете использовать аннотацию @EnableWebFlux в своей конфигурации Java, как показано в следующем примере:
Java
	@Configuration
	@EnableWebFlux
	public class WebConfig {
	@Configuration
	@EnableWebFlux
	class WebConfig
Включение конфигурации WebFlux.
ПРИМЕЧАНИЕ.
При использовании Spring Boot вы можете использовать классы @Configuration типа WebFluxConfigurer, но без `@EnableWebFlux` для сохранения настроек Spring Boot WebFlux.
Подробности смотрите в {spring-boot-docs-ref}/web/reactive.html#web.reactive.webflux.auto-configuration [специальная документация по Spring Boot].
Включение конфигурации WebFlux.
В предыдущем примере регистрируется несколько Spring WebFlux. доступен в пути к классам — для JSON, XML и других.
API конфигурации WebFlux.
В вашей конфигурации Java вы можете реализовать интерфейс WebFluxConfigurer, как показано в следующем примере:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {

// Реализация методов настройки...
	// Реализация методов настройки...
Конвертация, форматирование.
По умолчанию установлены средства форматирования для различных типов чисел и дат, а также поддержка для настройки через `@NumberFormat`, `@DurationFormat` и `@DateTimeFormat` в полях и параметры.
Конвертация, форматирование.
Чтобы зарегистрировать пользовательские форматировщики и конвертеры в конфигурации Java, используйте следующее:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void addFormatters(FormatterRegistry registry) {
	@Configuration
	class WebConfig : WebFluxConfigurer {
Конвертация, форматирование.
По умолчанию Spring WebFlux учитывает запрос Locale при анализе и форматировании даты. ценности.
Это работает для форм, где даты представлены как строки с формой «входа». поля.
Однако для полей формы «дата» и «время» браузеры используют фиксированный формат, определенный в спецификации HTML.
В таких случаях форматирование даты и времени можно настроить следующим образом:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void addFormatters(FormatterRegistry registry) {
			DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
			registrar.setUseIsoFormat(true);
			registrar.registerFormatters(registry);
	@Configuration
	class WebConfig : WebFluxConfigurer {
Конвертация, форматирование.
ПРИМЕЧАНИЕ.
См. `FormatterRegistrar` SPI и FormattingConversionServiceFactoryBean для получения дополнительной информации о том, когда используйте реализации FormatterRegistrar.
Валидация.

По умолчанию, если присутствует Bean Validation в пути к классам (например, Hibernate Validator), `LocalValidatorFactoryBean` зарегистрирован как глобальная ссылка:core/validation/validator.adoc[validator] для использования с `@Valid` и `@Validated` для аргументов метода `@Controller`.
Валидация.
В вашей конфигурации Java вы можете настроить глобальный экземпляр Validator, как показано в следующем примере:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public Validator getValidator() {
	@Configuration
	class WebConfig : WebFluxConfigurer {
Валидация.
Обратите внимание, что вы также можете зарегистрировать реализации `Validator` локально, как показано в следующем примере:
Java
	@Controller
	public class MyController {
		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
	@Controller
	class MyController {
Валидация.
СОВЕТ: Если вам нужно где-то внедрить LocalValidatorFactoryBean, создайте bean-компонент и отметьте его `@Primary`, чтобы избежать конфликта с объявленным в конфигурации MVC.
Резолверы типов контента.
Вы можете настроить, как Spring WebFlux определяет запрошенные типы мультимедиа для Экземпляры `@Controller` из запроса.
По умолчанию проверяется только заголовок Accept. но вы также можете включить стратегию на основе параметров запроса.
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
	@Configuration
	class WebConfig : WebFluxConfigurer {
Кодеки HTTP-сообщений.

В следующем примере показано, как настроить способ чтения и записи тела запроса и ответа:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			configurer.defaultCodecs().maxInMemorySize(512 * 1024);
	@Configuration
	class WebConfig : WebFluxConfigurer {
Кодеки HTTP-сообщений. `ServerCodecConfigurer` предоставляет набор средств чтения и записи по умолчанию.
Вы можете использовать его, чтобы добавить больше читателей и писателей, настройте те, которые используются по умолчанию, или полностью замените те, которые используются по умолчанию.
Кодеки HTTP-сообщений.
Для Джексона рассмотрите возможность использования построителя формата Джексона, например JsonMapper.Builder, для настройки параметров Джексона по умолчанию. свойства.
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
	@Configuration
	class WebConfig : WebFluxConfigurer {
В следующем примере показано, как настроить разрешение просмотра:.
ViewResolverRegistry содержит ярлыки для технологий просмотра, с помощью которых Spring Framework интегрируется.
В следующем примере используется FreeMarker (который также требует настройки базовая технология просмотра FreeMarker):
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();
		// Настроить Freemarker...
		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("classpath:/templates");
			return configurer;

@Configuration
	class WebConfig : WebFluxConfigurer {
		// Настроить Freemarker...
В следующем примере показано, как настроить разрешение просмотра:.
Вы также можете подключить любую реализацию ViewResolver, как показано в следующем примере:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			ViewResolver resolver = ... ;
			registry.viewResolver(resolver);
	@Configuration
	class WebConfig : WebFluxConfigurer {
В следующем примере показано, как настроить разрешение просмотра:.
Для поддержки согласование контента и рендеринга других форматов. посредством разрешения представления (кроме HTML) вы можете настроить одно или несколько представлений по умолчанию на основе в реализации HttpMessageWriterView, которая принимает любой из доступных
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();
			JacksonJsonEncoder encoder = new JacksonJsonEncoder();
			registry.defaultViews(new HttpMessageWriterView(encoder));
	@Configuration
	class WebConfig : WebFluxConfigurer {
В следующем примере показано, как настроить разрешение просмотра:.
См.
Технологии просмотра для получения дополнительной информации о технологиях представления, интегрированных с Spring WebFlux.
Статические ресурсы.
Эта опция обеспечивает удобный способ обслуживания статических ресурсов из списка Местоположение на основе {spring-framework-api}/core/io/Resource.html[`Resource`].
Статические ресурсы.

В следующем примере для запроса, начинающегося с `/resources`, относительный путь будет равен используется для поиска и обслуживания статических ресурсов относительно `/static` в пути к классам.
Ресурсы обслуживаются со сроком действия в один год, чтобы обеспечить максимальное использование кэша браузера. и сокращение количества HTTP-запросов, выполняемых браузером.
Заголовок Last-Modified также оценивается, и, если он присутствует, возвращается код состояния «304».
Следующий список показывает пример:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
	@Configuration
	class WebConfig : WebFluxConfigurer {
Статические ресурсы.
См. также поддержка HTTP-кэширования для статических ресурсов.
Статические ресурсы.
Обработчик ресурсов также поддерживает цепочку реализации {spring-framework-api}/web/reactive/resource/ResourceResolver.html[`ResourceResolver`] и реализации {spring-framework-api}/web/reactive/resource/ResourceTransformer.html[`ResourceTransformer`], который можно использовать для создания набора инструментов для работы с оптимизированными ресурсами.
Статические ресурсы.

Вы можете использовать VersionResourceResolver для URL-адресов ресурсов с поддержкой версий на основе хеша MD5. вычисляется на основе контента, фиксированной версии приложения или другой информации.
А «ContentVersionStrategy» (хэш MD5) — хороший выбор, за некоторыми заметными исключениями (например, Ресурсы JavaScript, используемые с загрузчиком модулей).
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
	@Configuration
	class WebConfig : WebFluxConfigurer {
В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.
Вы можете использовать ResourceUrlProvider для перезаписи URL-адресов и применения полной цепочки преобразователей и трансформеры (например, для вставки версий).
Конфигурация WebFlux предоставляет ResourceUrlProvider. чтобы его можно было вводить другим.
В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.
В отличие от Spring MVC, на данный момент в WebFlux нет возможности прозрачно перезаписывать статические URL-адреса ресурсов, поскольку не существует технологий просмотра, которые могли бы использовать неблокирующую цепочку. резольверов и трансформаторов.
При обслуживании только локальных ресурсов обходным путем является использование `ResourceUrlProvider` напрямую (например, через пользовательский элемент) и заблокировать.

В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.
Обратите внимание, что при использовании как EncodedResourceResolver (например, Gzip, в кодировке Brotli), так и `VersionedResourceResolver`, они должны быть зарегистрированы именно в этом порядке, чтобы обеспечить версии всегда надежно вычисляются на основе незакодированного файла.
В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.
Для https://www.webjars.org/documentation[WebJars] URL-адреса с версиями, например `/webjars/jquery/1.2.0/jquery.min.js` — рекомендуемый и наиболее эффективный способ их использования.
Местоположение связанного ресурса настраивается «из коробки» с помощью Spring Boot (или может быть настроено вручную через `ResourceHandlerRegistry`) и не требует добавления Зависимость `org.webjars:webjars-locator-lite`.
В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.
URL-адреса без версий, такие как `/webjars/jquery/jquery.min.js`, поддерживаются через `WebJarsResourceResolver`, который автоматически регистрируется при Библиотека `org.webjars:webjars-locator-lite` присутствует в пути к классам.

Резолвер может перезаписать URL-адреса, включающие версию jar, а также могут сопоставляться с входящими URL-адресами без версий. -- например, с `/webjars/jquery/jquery.min.js` на `/webjars/jquery/1.2.0/jquery.min.js`.
В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.
СОВЕТ: Конфигурация Java, основанная на ResourceHandlerRegistry, предоставляет дополнительные возможности. для детального контроля, например, поведения последнего изменения и оптимизированного разрешения ресурсов.
Сопоставление путей.
Вы можете настроить параметры, связанные с сопоставлением путей.
Подробную информацию об отдельных опциях см. {spring-framework-api}/web/reactive/config/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.
В следующем примере показано, как использовать PathMatchConfigurer:
включаемый код::./WebConfig[]. [СОВЕТ] = Spring WebFlux полагается на проанализированное представление пути запроса, называемое `RequestPath` для доступа к декодированным значениям сегмента пути, с удаленным содержимым точки с запятой. (то есть переменные пути или матрицы).
Это означает, что в отличие от Spring MVC вам не нужно указывать декодировать ли путь запроса или удалять содержимое точки с запятой для цели сопоставления путей.
включаемый код::./WebConfig[].

Spring WebFlux также не поддерживает сопоставление шаблонов суффиксов, в отличие от Spring MVC, где мы также отходят от полагаться на это.
Версия API.
Чтобы включить управление версиями API, используйте обратный вызов ApiVersionConfigurer для WebFluxConfigurer:
Java
	@Configuration
	public class WebConfiguration implements WebFluxConfigurer {
		@Override
		public void configureApiVersioning(ApiVersionConfigurer configurer) {
			configurer.useRequestHeader("API-Version");
	@Configuration
	class WebConfiguration : WebFluxConfigurer {
Версия API.
Вы можете решить версию с помощью одной из встроенных опций, перечисленных ниже, или в качестве альтернативы используйте собственный ApiVersionResolver:
- Заголовок запроса
- Параметр запроса
- Сегмент пути
- Параметр типа носителя
Версия API.
Для разрешения из сегмента пути необходимо указать индекс ожидаемого сегмента пути. чтобы содержать версию.
Сегмент пути должен быть объявлен как переменная URI, например. «/\{версия}», «/api/\{версия}» и т. д., где фактическое имя не имеет значения.
Поскольку версия обычно находится в начале пути, рассмотрите возможность ее внешней настройки. как общий префикс пути для всех обработчиков через
Версия API.
По умолчанию версия анализируется с помощью SemanticVersionParser, но вы также можете настроить пользовательская ссылка:web/webflux-versioning.adoc#webflux-versioning-parser[ApiVersionParser].
Версия API.

Поддерживаемые версии прозрачно определяются из версий, объявленных в сопоставлениях запросов. для удобства, но вы можете отключить это с помощью флага в конфигурации WebFlux и считайте поддерживаемыми только версии, явно настроенные в конфигурации.
Запросы с неподдерживаемой версией отклоняются с помощью `InvalidApiVersionException` приводит к ответу 400.
Версия API.
Вы можете установить ApiVersionDeprecationHandler для отправки информации об устаревших версии для клиентов.
Встроенный стандартный обработчик может установить «Устаревание», «Закат» и Заголовки «Ссылки» на основе https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].
Версия API.
После настройки управления версиями API вы можете начать сопоставлять запросы с согласно версии запроса.
Блокировка выполнения.
Конфигурация Java WebFlux позволяет вам настроить выполнение блокировки в WebFlux.
Блокировка выполнения.
Вы можете вызвать методы контроллера блокировки в отдельном потоке, предоставив `AsyncTaskExecutor`, такой как {spring-framework-api}/core/task/VirtualThreadTaskExecutor.html[`VirtualThreadTaskExecutor`] следующим образом:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void configureBlockingExecution(BlockingExecutionConfigurer configurer) {
			AsyncTaskExecutor executor = ...
			configurer.setExecutor(executor);
	@Configuration
	class WebConfig : WebFluxConfigurer {
Блокировка выполнения.

По умолчанию методы контроллера, тип возвращаемого значения которых не распознается настроенным `ReactiveAdapterRegistry` считается блокирующим, но вы можете установить собственный контроллер. предикат метода через BlockingExecutionConfigurer.
Вебсокетсервис.
Конфигурация Java WebFlux объявляет bean-компонент WebSocketHandlerAdapter, который обеспечивает поддержка вызова обработчиков WebSocket.
Это означает, что все, что осталось сделать в Чтобы обработать запрос на рукопожатие WebSocket, необходимо сопоставить `WebSocketHandler` с URL-адресом. через SimpleUrlHandlerMapping.
Вебсокетсервис.
В некоторых случаях может потребоваться создать bean-компонент WebSocketHandlerAdapter с предоставил службу WebSocketService, которая позволяет настраивать свойства сервера WebSocket.
Например:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public WebSocketService getWebSocketService() {
			TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
			strategy.setMaxSessionIdleTimeout(0L);
			return new HandshakeWebSocketService(strategy);
	@Configuration
	class WebConfig : WebFluxConfigurer {
* Предоставляет конфигурацию Spring по умолчанию для приложений WebFlux.
* обнаруживает и делегирует реализации `WebFluxConfigurer` для настройки этой конфигурации.
`@EnableWebFlux` импортирует `DelegatingWebFluxConfiguration`, который:.
В расширенном режиме вы можете удалить `@EnableWebFlux` и расширить его непосредственно из `ДелегированиеWebFluxConfiguration` вместо реализации `WebFluxConfigurer`, как показано в следующем примере:
Java
	@Configuration
	public class WebConfig extends DelegatingWebFluxConfiguration {
	@Configuration
	class WebConfig : DelegatingWebFluxConfiguration {
`@EnableWebFlux` импортирует `DelegatingWebFluxConfiguration`, который:.

Вы можете сохранить существующие методы в `WebConfig`, но теперь вы также можете переопределить объявления компонентов. из базового класса и по-прежнему иметь любое количество других реализаций `WebMvcConfigurer` путь к классам.

Использование аннотации `@Configuration`. `@Configuration` — это аннотация уровня класса, указывающая, что объект является источником определения бобов.
Классы `@Configuration` объявляют bean-компоненты через `@Bean`-аннотацию. методы.
Вызовы методов `@Bean` в классах `@Configuration` также могут использоваться для определения межкомпонентные зависимости.
См. для общего ознакомления.
Внедрение межкомпонентных зависимостей.
Когда компоненты имеют зависимости друг от друга, выразить эту зависимость очень просто. как если бы один метод компонента вызывал другой, как показано в следующем примере:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public BeanOne beanOne() {
			return new BeanOne(beanTwo());
		@Bean
		public BeanTwo beanTwo() {
			return new BeanTwo();
	@Configuration
	class AppConfig {
Внедрение межкомпонентных зависимостей.
В предыдущем примере beanOne получает ссылку на beanTwo через конструктор. инъекция.
Внедрение межкомпонентных зависимостей.
ПРИМЕЧАНИЕ.
Этот метод объявления зависимостей между компонентами работает только в том случае, если используется метод `@Bean`. объявляется внутри класса @Configuration.
Вы не можете объявлять зависимости между компонентами используя простые классы `@Component`.
Внедрение метода поиска.
Как отмечалось ранее, внедрение метода поиска представляет собой расширенная функция, которую следует использовать редко.
Это полезно в тех случаях, когда Компонент с областью действия Singleton зависит от компонента с областью действия прототипа.

Использование Java для этого Тип конфигурации предоставляет естественные средства для реализации этого шаблона.
В следующем примере показано, как использовать внедрение метода поиска:
Java
	public abstract class CommandManager {
		public Object process(Object commandState) {
			// возьмите новый экземпляр соответствующего командного интерфейса
			Command command = createCommand();
			// установить состояние экземпляра команды (надеюсь, нового)
			command.setState(commandState);
			return command.execute();
		// окей... но где реализация этого метода?
		protected abstract Command createCommand();
Внедрение метода поиска.
Используя конфигурацию Java, вы можете создать подкласс CommandManager, в котором абстрактный метод createCommand() переопределяется таким образом, что он ищет новый (прототип) командный объект.
В следующем примере показано, как это сделать:
Java
	@Bean
	@Scope("prototype")
	public AsyncCommand asyncCommand() {
		AsyncCommand command = new AsyncCommand();
		// добавьте сюда зависимости по мере необходимости
		return command;
	@Bean
	public CommandManager commandManager() {
		// вернуть новую анонимную реализацию CommandManager с помощью createCommand()
		// переопределено для возврата нового прототипа командного объекта
		return new CommandManager() {
			protected Command createCommand() {
				return asyncCommand();
Дополнительная информация о внутренней работе конфигурации на основе Java.
Рассмотрим следующий пример, который показывает, что аннотированный метод @Bean вызывается дважды:
Java
	@Configuration
	public class AppConfig {
		@Bean

public ClientService clientService1() {
			ClientServiceImpl clientService = new ClientServiceImpl();
			clientService.setClientDao(clientDao());
			return clientService;
		@Bean
		public ClientService clientService2() {
			ClientServiceImpl clientService = new ClientServiceImpl();
			clientService.setClientDao(clientDao());
			return clientService;
		@Bean
		public ClientDao clientDao() {
			return new ClientDaoImpl();
	@Configuration
	class AppConfig {
Дополнительная информация о внутренней работе конфигурации на основе Java. `clientDao()` был вызван один раз в `clientService1()` и один раз в `clientService2()`.
Поскольку этот метод создает новый экземпляр ClientDaoImpl и возвращает его, вам следует обычно ожидается наличие двух экземпляров (по одному для каждой службы).
Это определенно было бы Проблема: в Spring экземпляры bean-компонентов по умолчанию имеют область действия «singleton».
Это вот тут и начинается волшебство: все классы `@Configuration` подразделяются на подклассы во время запуска. с `CGLIB`.
В подклассе дочерний метод сначала проверяет контейнер на наличие кэшированные (с ограниченной областью действия) bean-компоненты перед тем, как они вызовут родительский метод и создадут новый экземпляр.
Дополнительная информация о внутренней работе конфигурации на основе Java.
ПРИМЕЧАНИЕ.
Поведение может различаться в зависимости от области действия вашего компонента.
Мы говорим про синглтоны здесь.

Дополнительная информация о внутренней работе конфигурации на основе Java. [ПРИМЕЧАНИЕ] = Нет необходимости добавлять CGLIB в ваш путь к классам, поскольку классы CGLIB переупакованы. в пакете `org.springframework.cglib` и включен непосредственно в пакет `spring-core` JAR.
Дополнительная информация о внутренней работе конфигурации на основе Java. [СОВЕТ] = Есть несколько ограничений, поскольку CGLIB динамически добавляет функции время запуска.
В частности, классы конфигурации не должны быть окончательными.
Однако любой конструкторы разрешены в классах конфигурации, включая использование `@Autowired` или единственное объявление конструктора, отличное от стандартного, для внедрения по умолчанию.
Дополнительная информация о внутренней работе конфигурации на основе Java.
Если вы предпочитаете избегать каких-либо ограничений, налагаемых CGLIB, рассмотрите возможность объявления вашего `@Bean` методы для классов, отличных от `@Configuration` (например, для простых классов `@Component` вместо этого) или аннотируя свой класс конфигурации с помощью `@Configuration(proxyBeanMethods = false)`.
Межметодные вызовы между методами `@Bean` затем не перехватываются, поэтому вам придется полагаться исключительно на внедрение зависимостей на этапе там уровень конструктора или метода.

1. Введение. `configuration` предоставляет единый конфигурационный слой: YAML-файлы, аннотации и переменные окружения с поддержкой профилей и валидации значений на старте.
- централизует настройки приложения;
- минимизирует runtime-ошибки через раннюю валидацию;
- упрощает перенос между окружениями (`dev`, `stage`, `prod`).
```xml
```java
    @Required
    private String url;
    @Required
    private String username;
    private String password;
    private int poolSize = 16;
    public String getUrl() { return url; }
    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public int getPoolSize() { return poolSize; }
```java
    private final DatasourceConfig config;
    public ReportRepository(DatasourceConfig config) {
        this.config = config;
    public String connectionInfo() {
        // Никогда не логируйте пароль.
        return config.getUrl() + "|" + config.getUsername();
```yaml
    url: jdbc:postgresql://db:5432/reports
    username: report_user
    password: ${DB_PASSWORD}
    pool-size: 24
    profile: prod
    strict-binding: true
    fail-on-unknown-keys: true
- `DB_PASSWORD` -> `lilipup.datasource.password`
- `LILIPUP_DATASOURCE_POOL_SIZE` -> `lilipup.datasource.pool-size`

- Всегда помечайте критичные поля аннотацией `@Required`.
- Всегда включайте `fail-on-unknown-keys=true` в production, чтобы ловить опечатки в YAML.
- Проверяйте наличие всех секретов в окружении до старта (пароли, токены, ключи).
- Не храните реальные секреты в репозитории; используйте env/secret-manager.
- Убедитесь, что `strict-binding=true`, если конфиг используется для безопасности и доступа к данным.
- `ConfigBindingException`: не удалось привести строку к целевому типу.
- `MissingRequiredPropertyException`: отсутствует обязательное поле.
- `UnknownPropertyException`: в YAML найден неизвестный ключ при strict режиме.
```java
    private final ConfigResolver resolver;
    public TimeoutProvider(ConfigResolver resolver) {
        this.resolver = resolver;
    public int requestTimeoutMs() {
        // Fallback не должен маскировать критичную misconfiguration.
        return resolver.getInt("lilipup.http.request-timeout-ms").orElse(3000);
- Храните профильные конфиги в `application-<profile>.yaml`.
- Используйте объектные конфиги (`@ConfigProperties`) вместо хаотичного чтения строковых ключей.
- Разделяйте «бизнес-конфиги» и «инфраструктурные конфиги» по префиксам.
- Делайте fail-fast на этапе bootstrap, а не в runtime-запросах.

- Добавляйте smoke-test, который поднимает контекст со всеми production-ключами.

* Использование `DataSource`
* Использование `DataSourceUtils`
* Реализация `SmartDataSource`
* Расширение `AbstractDataSource`
* Использование `SingleConnectionDataSource`
* Использование `DriverManagerDataSource`
* Использование `TransactionAwareDataSourceProxy`
* Использование `DataSourceTransactionManager`/`JdbcTransactionManager`
Использование источника данных.
Spring получает соединение с базой данных через DataSource. «Источник данных» — это часть спецификации JDBC и является фабрикой обобщенных соединений.
Это позволяет контейнер или фреймворк скрывают проблемы пула соединений и управления транзакциями из кода приложения.
Как разработчику, вам не обязательно знать подробности о том, как подключиться к базе данных.
Это обязанность администратора, который настраивает источник данных.
Скорее всего, вы выполняете обе роли при разработке и тестировании кода, но вы не обязательно знать, как настроен источник производственных данных.
Использование источника данных.
Когда вы используете уровень JDBC Spring, вы можете получить источник данных из JNDI или настройте свою собственную реализацию пула соединений, предоставленную третьей стороной.
Традиционным выбором являются Apache Commons DBCP и C3P0 с классами DataSource в стиле bean-компонентов; для современного пула соединений JDBC вместо этого рассмотрите HikariCP с его API в стиле компоновщика.
Использование источника данных.
ПРИМЕЧАНИЕ.
Вам следует использовать классы DriverManagerDataSource и SimpleDriverDataSource. (как включено в дистрибутив Spring) только в целях тестирования!
Эти варианты не обеспечивают объединение в пул и снижают производительность при выполнении нескольких запросов на соединение.
Использование источника данных.
В следующем разделе используется реализация Spring DriverManagerDataSource.

Несколько других вариантов DataSource будут рассмотрены позже.
Чтобы настроить DriverManagerDataSource:. .
Получите соединение с DriverManagerDataSource, как вы обычно получаете JDBC. соединение..
Укажите полное имя класса драйвера JDBC, чтобы `DriverManager` может загрузить класс драйвера..
Укажите URL-адрес, который зависит от драйверов JDBC. (См. документацию к вашему драйверу для правильного значения.).
Укажите имя пользователя и пароль для подключения к базе данных.
Чтобы настроить DriverManagerDataSource:.
В следующем примере показано, как настроить DriverManagerDataSource: См. пример кода в исходном документе.
Чтобы настроить DriverManagerDataSource:.
Следующие два примера показывают базовое подключение и настройку для DBCP и C3P0.
Чтобы узнать о дополнительных параметрах, помогающих управлять функциями объединения, см. продукт документация для соответствующих реализаций пула соединений.
Чтобы настроить DriverManagerDataSource:.
В следующем примере показана конфигурация DBCP: См. пример кода в исходном документе.
Чтобы настроить DriverManagerDataSource:.
В следующем примере показана конфигурация C3P0: См. пример кода в исходном документе.
Использование DataSourceUtils.
Класс DataSourceUtils — это удобный и мощный вспомогательный класс, который предоставляет `статические` методы для получения соединений из JNDI и закрытия соединений при необходимости.
Он поддерживает связанное с потоком соединение JDBC с DataSourceTransactionManager, но также с JtaTransactionManager и JpaTransactionManager.
Использование DataSourceUtils.
Обратите внимание, что JdbcTemplate подразумевает доступ к соединению DataSourceUtils, используя его. за каждой операцией JDBC, неявно участвуя в текущей транзакции.
Реализация SmartDataSource.

Интерфейс SmartDataSource должен быть реализован классами, которые могут предоставить подключение к реляционной базе данных.
Он расширяет интерфейс DataSource, позволяя классы, которые его используют, запрашивают, следует ли закрывать соединение после заданного операция.
Такое использование эффективно, если вы знаете, что вам нужно повторно использовать соединение.
Расширение «AbstractDataSource». «AbstractDataSource» — это «абстрактный» базовый класс для Spring «DataSource». реализации.
Он реализует код, общий для всех реализаций DataSource.
Вам следует расширить класс AbstractDataSource, если вы пишете свой собственный DataSource. реализация.
Использование SingleConnectionDataSource.
Класс SingleConnectionDataSource является реализацией SmartDataSource. интерфейс, который окружает одно соединение, которое не закрывается после каждого использования.
Это не поддерживает многопоточность.
Использование SingleConnectionDataSource.
Если какой-либо клиентский код вызывает метод close, предполагая соединение из пула (как при использовании инструменты сохранения), вам следует установить для свойства `suppressClose` значение `true`.
Эта настройка возвращает прокси-сервер с подавлением закрытия, который оборачивает физическое соединение.
Обратите внимание, что вы можете больше не привязывайте это к собственному Oracle Connection или аналогичному объекту.
Использование SingleConnectionDataSource.
SingleConnectionDataSource — это прежде всего тестовый класс.
Обычно это позволяет легко тестировать кода вне сервера приложений в сочетании с простой средой JNDI.
В отличие от DriverManagerDataSource, он постоянно использует одно и то же соединение. избегая чрезмерного создания физических соединений.
Использование DriverManagerDataSource.

Класс DriverManagerDataSource является реализацией стандартного DataSource. интерфейс, который настраивает простой драйвер JDBC через свойства компонента и возвращает новый «Соединение» каждый раз.
Использование DriverManagerDataSource.
Эта реализация полезна для тестовых и автономных сред за пределами Jakarta EE. контейнер, либо как bean-компонент DataSource в контейнере Spring IoC, либо совместно с простой средой JNDI.
Вызовы `Connection.close()` с учетом пула закройте соединение, чтобы любой код сохранения, поддерживающий `DataSource`, должен работать.
Однако, использовать пулы соединений в стиле JavaBean (например, commons-dbcp) очень просто, даже в тесте среды, что почти всегда предпочтительнее использовать такой пул соединений, а не `DriverManagerDataSource`.
Использование TransactionAwareDataSourceProxy.
TransactionAwareDataSourceProxy — это прокси для целевого DataSource.
Прокси оборачивает это выберите DataSource, чтобы добавить информацию о транзакциях, управляемых Spring.
В этом отношении это аналогичен транзакционному JNDI DataSource, предоставляемому сервером Jakarta EE.
Использование TransactionAwareDataSourceProxy.
ПРИМЕЧАНИЕ.
Использовать этот класс желательно редко, за исключением случаев, когда необходимо обновить уже существующий код. вызывается и передается стандартная реализация интерфейса JDBC DataSource.
В этом случае вы все еще можете использовать этот код и в то же время иметь этот код участие в управляемых Spring транзакциях.
Обычно предпочтительнее написать свой собственный новый код, используя абстракции более высокого уровня для управления ресурсами, такие как `JdbcTemplate` или `DataSourceUtils`.
Использование TransactionAwareDataSourceProxy.

См. {spring-framework-api}/jdbc/datasource/TransactionAwareDataSourceProxy.html[`TransactionAwareDataSourceProxy`] javadoc для более подробной информации.
Использование DataSourceTransactionManager/JdbcTransactionManager.
Класс DataSourceTransactionManager является классом PlatformTransactionManager. реализация для одного JDBC DataSource.
Он связывает JDBC `Connection` из указанного `DataSource` в текущий выполняющийся поток, потенциально позволяя использовать одно связанное с потоком `Соединение` для каждого `DataSource`.
Использование DataSourceTransactionManager/JdbcTransactionManager.
Код приложения необходим для получения соединения JDBC через `DataSourceUtils.getConnection(DataSource)` вместо стандарта Java EE `DataSource.getConnection`.
Он выдает непроверенные исключения `org.springframework.dao`. вместо проверенных `SQLExceptions`.
Все классы фреймворка (например, JdbcTemplate) используют эта стратегия неявно.
Если не используется с менеджером транзакций, стратегия поиска ведет себя точно так же, как DataSource.getConnection, и поэтому может использоваться в любом случае.
Использование DataSourceTransactionManager/JdbcTransactionManager.
Класс DataSourceTransactionManager поддерживает точки сохранения (PROPAGATION_NESTED), пользовательские уровни изоляции и тайм-ауты, которые применяются в соответствии с соответствующим оператором JDBC. таймауты запросов.
Для поддержки последнего код приложения должен либо использовать JdbcTemplate, либо вызовите метод DataSourceUtils.applyTransactionTimeout(..) для каждого созданного оператора.
Использование DataSourceTransactionManager/JdbcTransactionManager.
Вы можете использовать DataSourceTransactionManager вместо JtaTransactionManager в случай с одним ресурсом, поскольку он не требует, чтобы контейнер поддерживал транзакцию JTA координатор.

Переключение между этими менеджерами транзакций — это всего лишь вопрос конфигурации. при условии, что вы придерживаетесь требуемого шаблона поиска соединений.
Обратите внимание, что JTA не поддерживает точки сохранения или пользовательские уровни изоляции и имеет другой механизм тайм-аута, но в остальном демонстрирует аналогичное поведение с точки зрения ресурсов JDBC и управления фиксацией/откатом JDBC.
Использование DataSourceTransactionManager/JdbcTransactionManager.
Для отложенного получения фактических подключений к ресурсам в стиле JTA Spring предоставляет соответствующий прокси-класс `DataSource` для целевого пула соединений: см. {spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].
Это особенно полезно для потенциально пустых транзакций без фактического оператора. выполнение (никогда не получая реальный ресурс в таком сценарии), а также перед маршрутный `DataSource`, что означает использование синхронизированного с транзакцией флага только для чтения и/или уровень изоляции (например, IsolationLevelDataSourceRouter).
Использование DataSourceTransactionManager/JdbcTransactionManager. `LazyConnectionDataSourceProxy` также обеспечивает специальную поддержку соединения только для чтения. пул для использования во время транзакции только для чтения, избегая накладных расходов на переключение JDBC.
Флаг соединения, доступный только для чтения, в начале и конце каждой транзакции при выборке. его из основного пула соединений (что может быть дорогостоящим в зависимости от драйвера JDBC).
Использование DataSourceTransactionManager/JdbcTransactionManager.
ПРИМЕЧАНИЕ.

Начиная с версии 5.3, Spring предоставляет расширенный вариант JdbcTransactionManager, который добавляет возможности трансляции исключений при фиксации/откате (в соответствии с `JdbcTemplate`).
Где DataSourceTransactionManager всегда выдает только TransactionSystemException. (аналог JTA), `JdbcTransactionManager` преобразует ошибки блокировки базы данных и т. д. в соответствующие подклассы DataAccessException.
Обратите внимание, что код приложения должен быть подготовлен к таким исключениям, а не исключительно к «TransactionSystemException».
В таких случаях рекомендуется использовать JdbcTransactionManager.
Использование DataSourceTransactionManager/JdbcTransactionManager.
С точки зрения поведения исключений, JdbcTransactionManager примерно эквивалентен `JpaTransactionManager`, а также `R2dbcTransactionManager`, служащий непосредственным компаньон/замена друг друга.
DataSourceTransactionManager, с другой стороны. эквивалентен `JtaTransactionManager` и может служить его прямой заменой.

Конструкторы.
Вы можете вызывать конструкторы, используя оператор new.
Вы должны использовать полностью квалифицированное имя класса для всех типов, кроме тех, которые находятся в пакете `java.lang` («Целое число», «С плавающей запятой», «Строка» и т. д.).
Конструкторы.
В следующем примере показано, как использовать оператор new для вызова конструкторов.
Java
	Inventor einstein = parser.parseExpression(
		"new org.spring.samples.spel.inventor.Inventor('Альберт Эйнштейн', 'Немецкий')"))
			.getValue(Inventor.class);
	// создать новый экземпляр Inventor в методе add() списка.
	parser.parseExpression(
		"Members.add(new org.spring.samples.spel.inventor.Inventor('Альберт Эйнштейн', 'Немецкий'))")
			.getValue(societyContext);
	// создать новый экземпляр Inventor в методе add() списка.
	parser.parseExpression(
		"Members.add(new org.spring.samples.spel.inventor.Inventor('Альберт Эйнштейн', 'Немецкий'))")
			.getValue(societyContext)

Типы контента.
Вы можете настроить, как Spring MVC определяет запрошенные типы мультимедиа из запроса. (например, заголовок Accept, расширение URL-адреса, параметр запроса и т. д.).
Типы контента.
По умолчанию проверяется только заголовок Accept.
Типы контента.
Если вам необходимо использовать разрешение типа контента на основе URL-адреса, рассмотрите возможность использования параметра запроса стратегия по расширению пути.
См. и Соответствие суффикса и RFD для подробнее.
Типы контента.
Вы можете настроить разрешение запрошенного типа контента, как показано в следующем примере: См. пример кода в исходном документе.

Дополнительные возможности ApplicationContext.
Как обсуждалось в введение в главу, `org.springframework.beans.factory` пакет предоставляет базовую функциональность для управления и манипулирования bean-компонентами, в том числе в программный способ.
Пакет `org.springframework.context` добавляет {spring-framework-api}/context/ApplicationContext.html[`ApplicationContext`] интерфейс, который расширяет интерфейс BeanFactory в дополнение к расширению других интерфейсы для обеспечения дополнительных функций в большем количестве приложений фреймворк-ориентированный стиль.
Многие люди используют `ApplicationContext` совершенно декларативную моду, даже не создавая ее программно, а опираясь на поддерживают такие классы, как «ContextLoader», для автоматического создания экземпляра `ApplicationContext` как часть обычного процесса запуска веб-приложения Jakarta EE.
Дополнительные возможности ApplicationContext.
Чтобы улучшить функциональность BeanFactory в более ориентированном на инфраструктуру стиле, контекст пакет также предоставляет следующие функциональные возможности:
* Доступ к сообщениям в стиле i18n, через интерфейс MessageSource.
* Доступ к ресурсам, таким как URL-адреса и файлы, через интерфейс ResourceLoader.
* Публикация событий, а именно для bean-компонентов, реализующих интерфейс ApplicationListener,
Дополнительные возможности ApplicationContext. с помощью интерфейса ApplicationEventPublisher.
* Загрузка нескольких (иерархических) контекстов, позволяющая каждому сосредоточиться на одном
Дополнительные возможности ApplicationContext. конкретный уровень, например веб-уровень приложения, через Интерфейс HierarchicalBeanFactory.
Интернационализация с использованием MessageSource.

Интерфейс ApplicationContext расширяет интерфейс MessageSource и следовательно, обеспечивает функциональность интернационализации («i18n»).
Spring также предоставляет Интерфейс HierarchicalMessageSource, который может разрешать сообщения иерархически.
Вместе эти интерфейсы обеспечивают основу, на которой Spring обрабатывает сообщения. разрешение.
Методы, определенные в этих интерфейсах, включают:
* `String getMessage(String code, Object[] args, String default, Locale loc)`: базовый
Интернационализация с использованием MessageSource. метод, используемый для получения сообщения из MessageSource.
Когда сообщение не найдено для указанной локали используется сообщение по умолчанию.
Любые переданные аргументы становятся значения замены, используя функциональность MessageFormat, предоставляемую стандартом. библиотека.
* `String getMessage(String code, Object[] args, Locale loc)`: по сути то же самое, что и
Интернационализация с использованием MessageSource. предыдущий метод, но с одним отличием: нельзя указать сообщение по умолчанию.
Если сообщение не может быть найдено, выдается исключение NoSuchMessageException.
* `String getMessage(MessageSourceResolvable разрешимый, языковой стандарт)`: Все свойства
Интернационализация с использованием MessageSource. используемые в предыдущих методах, также заключены в класс с именем `MessageSourceResolvable`, который вы можете использовать с этим методом.
Интернационализация с использованием MessageSource.
Когда «ApplicationContext» загружается, он автоматически ищет «MessageSource». bean-компонент, определенный в контексте.
Компонент должен иметь имя messageSource.
Если такой боб найден, все вызовы предыдущих методов делегируются источнику сообщения.

Если нет источник сообщения найден, ApplicationContext пытается найти родительский элемент, содержащий боб с таким же названием.
Если да, то он использует этот компонент в качестве MessageSource.
Если `ApplicationContext` не может найти источник сообщений, пустой `DelegatingMessageSource` создается для того, чтобы иметь возможность принимать вызовы к методы, определенные выше.
Интернационализация с использованием MessageSource.
Spring предоставляет три реализации MessageSource: ResourceBundleMessageSource, ReloadableResourceBundleMessageSource. и «StaticMessageSource».
Все они реализуют HierarchicalMessageSource для выполнения вложенных обмен сообщениями. `StaticMessageSource` используется редко, но предоставляет программные способы добавлять сообщения в источник.
В следующем примере показан ResourceBundleMessageSource:
	<beans>
		<bean id="messageSource"
				class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basenames">
				<list>
					<value>format</value>
					<value>exceptions</value>
					<value>windows</value>
				</list>
			</property>
		</bean>
	</beans>
Интернационализация с использованием MessageSource.
В примере предполагается, что у вас есть три пакета ресурсов, которые называются «формат», «исключения» и «окна». определенный в вашем пути к классам.
Любой запрос на разрешение сообщения обрабатывается стандартным для JDK способом разрешения сообщений через объекты ResourceBundle.
Для В целях примера предположим, что содержимое двух из приведенных выше файлов пакета ресурсов следующие:

message=Alligators rock!
	argument.required=The {0} argument is required.
in exceptions.properties.
В следующем примере показана программа для запуска функции MessageSource.
Помните, что все реализации ApplicationContext также являются MessageSource. реализации и поэтому могут быть преобразованы в интерфейс MessageSource.
Java
	public static void main(String[] args) {
		MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
		String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
		System.out.println(message);
[literal,subs="дословно,цитаты"].
Alligators rock!
[literal,subs="дословно,цитаты"].
Подводя итог, можно сказать, что MessageSource определен в файле beans.xml, который существует в корне вашего пути к классам.
Определение bean-компонента `messageSource` относится к количество пакетов ресурсов через свойство basenames.
Три файла, которые переданные в списке свойству `basenames`, существуют как файлы в корне вашего путь к классам и называются «format.properties», «Exceptions.properties» и `windows.properties` соответственно.
[literal,subs="дословно,цитаты"].
В следующем примере показаны аргументы, передаваемые при поиске сообщений.
Эти аргументы преобразуются в объекты String и вставляются в заполнители в поисковом сообщении.
	<beans>

<!-- this MessageSource is being used in a web application -->
		<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basename" value="exceptions"/>
		</bean>
		<!-- lets inject the above MessageSource into this POJO -->
		<bean id="example" class="com.something.Example">
			<property name="messages" ref="messageSource"/>
		</bean>
	</beans>
Java
	public class Example {
		private MessageSource messages;
		public void setMessages(MessageSource messages) {
			this.messages = messages;
		public void execute() {
			String message = this.messages.getMessage("argument.required",
				new Object [] {"userDao"}, "Required", Locale.ENGLISH);
			System.out.println(message);
	class Example {
[literal,subs="дословно,цитаты"].
Аргумент userDao является обязательным.
[literal,subs="дословно,цитаты"].
Что касается интернационализации («i18n»), различные Spring MessageSource реализации следуют тем же правилам разрешения локали и резервного варианта, что и стандартный JDK. `РесурсБундл`.

Короче говоря, продолжая пример, определенный `messageSource` ранее, если вы хотите разрешить сообщения в соответствии с британской локалью (en-GB), вы создаст файлы с именами «format_en_GB.properties», «Exceptions_en_GB.properties» и `windows_en_GB.properties` соответственно.
[literal,subs="дословно,цитаты"].
Обычно разрешение локали управляется окружающей средой приложение.
В следующем примере локаль, для которой (британские) сообщения разрешено указывается вручную:
Java
	public static void main(final String[] args) {
		MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
		String message = resources.getMessage("argument.required",
			new Object [] {"userDao"}, "Required", Locale.UK);
		System.out.println(message);
[literal,subs="дословно,цитаты"].
Эбагум парень, аргумент 'userDao' обязателен, я говорю, обязателен.
[literal,subs="дословно,цитаты"].
Вы также можете использовать интерфейс MessageSourceAware для получения ссылки на любой `MessageSource`, который был определен.
Любой компонент, определенный в В `ApplicationContext`, реализующий интерфейс `MessageSourceAware`, вводится MessageSource контекста приложения при создании и настройке компонента.
[literal,subs="дословно,цитаты"].
ПРИМЕЧАНИЕ.

Поскольку MessageSource в Spring основан на ResourceBundle в Java, он не объединяет пакеты с тем же базовым именем, но будет использовать только первый найденный пакет.
Последующие пакеты сообщений с тем же базовым именем игнорируются.
[literal,subs="дословно,цитаты"].
ПРИМЕЧАНИЕ.
В качестве альтернативы ResourceBundleMessageSource Spring предоставляет Класс ReloadableResourceBundleMessageSource.
Этот вариант поддерживает тот же пакет формат файла, но он более гибок, чем стандартный формат на основе JDK.
Реализация ResourceBundleMessageSource.
В частности, он позволяет читать файлы из любого местоположения ресурса Spring (не только из пути к классам) и поддерживает горячую перезагрузка файлов свойств пакета (при этом эффективно кэшируя их между собой).
См. {spring-framework-api}/context/support/ReloadableResourceBundleMessageSource.html[`ReloadableResourceBundleMessageSource`] javadoc для получения подробной информации.
Стандартные и пользовательские события.
Обработка событий в ApplicationContext обеспечивается через ApplicationEvent. класс и интерфейс ApplicationListener.
Если компонент, реализующий Интерфейс ApplicationListener развертывается в контексте каждый раз, когда `ApplicationEvent` публикуется в `ApplicationContext`, о чем уведомляется этот компонент.
По сути, это стандартный шаблон проектирования Observer.
Стандартные и пользовательские события.
СОВЕТ: Начиная с Spring 4.2, инфраструктура мероприятий была значительно улучшена и предлагает
Стандартные и пользовательские события. возможность публикации любого произвольного события (то есть объекта, который не обязательно расшириться из `ApplicationEvent`).

Когда такой объект публикуется, мы оборачиваем его в событие для вас.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение. | `ContextRefreshedEvent` | Публикуется, когда `ApplicationContext` инициализируется или обновляется (например, используя метод Refresh() в интерфейсе ConfigurationApplicationContext).
Здесь «`initialized`» означает, что все bean-компоненты загружены, bean-компоненты постпроцессора обнаружены. и активированы, синглтоны создаются заранее, а объект ApplicationContext готов к использованию.
Пока контекст не закрыт, может быть запущено обновление. несколько раз, при условии, что выбранный `ApplicationContext` действительно поддерживает такое «горячее» освежает.
Например, XmlWebApplicationContext поддерживает горячее обновление, но GenericApplicationContext — нет.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение. | `ContextStartedEvent` | Публикуется, когда ApplicationContext запускается с помощью метода start() в Интерфейс `ConfigurableApplicationContext`.
Здесь «запущено» означает, что весь «жизненный цикл» bean-компоненты получают явный сигнал запуска.
Обычно этот сигнал используется для перезапуска компонентов. после явной остановки, но его также можно использовать для запуска компонентов, которые не были настроен на автозапуск (например, компоненты, которые еще не запустились на инициализация).

.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение. | `ContextStoppedEvent` | Публикуется, когда `ApplicationContext` остановлен с помощью метода `stop()` в Интерфейс `ConfigurableApplicationContext`.
Здесь «остановлено» означает, что весь «жизненный цикл» bean-компоненты получают явный сигнал остановки.
Остановленный контекст может быть перезапущен через вызов `start()`.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение. | `ContextClosedEvent` | Публикуется, когда ApplicationContext закрывается с помощью метода close(). через интерфейс «ConfigurableApplicationContext» или через перехватчик завершения работы JVM.
Здесь, «закрытый» означает, что все одноэлементные компоненты будут уничтожены.
Как только контекст закрыт, срок его службы подходит к концу, и его невозможно обновить или перезапустить.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение. | `RequestHandledEvent` | Веб-событие, сообщающее всем компонентам о том, что HTTP-запрос был обслужен.
Это Событие публикуется после завершения запроса.
Это событие применимо только к веб-приложения, использующие Spring DispatcherServlet.

.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение. | `ServletRequestHandledEvent` | Подкласс RequestHandledEvent, который добавляет контекстную информацию, специфичную для сервлета.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
Вы также можете создавать и публиковать свои собственные события.
В следующем примере показан простой класс, расширяющий базовый класс Spring `ApplicationEvent`:
Java
	public class BlockedListEvent extends ApplicationEvent {
		private final String address;
		private final String content;
		public BlockedListEvent(Object source, String address, String content) {
			super(source);
			this.address = address;
			this.content = content;
		// аксессор и другие методы...
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
Чтобы опубликовать пользовательское ApplicationEvent, вызовите метод publishEvent() в `ApplicationEventPublisher`.
Обычно это делается путем создания класса, реализующего `ApplicationEventPublisherAware` и зарегистрировать его как bean-компонент Spring.
Следующие пример показывает такой класс:
Java
	public class EmailService implements ApplicationEventPublisherAware {
		private List<String> blockedList;
		private ApplicationEventPublisher publisher;
		public void setBlockedList(List<String> blockedList) {
			this.blockedList = blockedList;
		public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
			this.publisher = publisher;

public void sendEmail(String address, String content) {
			if (blockedList.contains(address)) {
				publisher.publishEvent(new BlockedListEvent(this, address, content));
				return;
			// отправить письмо...
	class EmailService : ApplicationEventPublisherAware {
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
Во время настройки контейнер Spring обнаруживает, что EmailService реализует `ApplicationEventPublisherAware` и автоматически вызывает `setApplicationEventPublisher()`.
На самом деле переданный параметр — это Spring сам контейнер.
Вы взаимодействуете с контекстом приложения через его Интерфейс ApplicationEventPublisher.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
Чтобы получить собственный ApplicationEvent, вы можете создать класс, реализующий `ApplicationListener` и зарегистрируйте его как bean-компонент Spring.
Следующий пример показывает такой класс:
Java
	public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {
		private String notificationAddress;
		public void setNotificationAddress(String notificationAddress) {
			this.notificationAddress = notificationAddress;
		public void onApplicationEvent(BlockedListEvent event) {
			// уведомляем соответствующие стороны через NotificationAddress...
	class BlockedListNotifier : ApplicationListener<BlockedListEvent> {
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.

Обратите внимание, что ApplicationListener обычно параметризуется типом вашего пользовательского события (BlockedListEvent в предыдущем примере).
Это означает, что метод onApplicationEvent() может оставаться типобезопасным, что позволяет избежать необходимости приведения типов.
Вы можете зарегистрировать столько прослушивателей событий, сколько пожелаете, но учтите, что по умолчанию прослушиватели событий получают события синхронно.
Это означает, что метод publicEvent() блокируется до тех пор, пока все прослушиватели не завершат обработку события.
Одним из преимуществ этого синхронного и однопоточного подхода является то, что, когда прослушиватель получает событие, он работает внутри контекста транзакции издателя, если контекст транзакции доступен.
Если возникает необходимость в другой стратегии публикации событий, например асинхронной обработке событий по умолчанию, см. javadoc для интерфейса Spring {spring-framework-api}/context/event/ApplicationEventMulticaster.html[`ApplicationEventMulticaster`] и реализация {spring-framework-api}/context/event/SimpleApplicationEventMulticaster.html[`SimpleApplicationEventMulticaster`] для параметров конфигурации, которые можно применить к пользовательскому определению bean-компонента applicationEventMulticaster.
В этих случаях ThreadLocals и контекст ведения журнала не передаются для обработки событий.
См. раздел наблюдения `@EventListener` для получения дополнительной информации о проблемах наблюдаемости.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
В следующем примере показаны определения компонентов, используемые для регистрации и настройки каждого из классы выше:

<bean id="emailService" class="example.EmailService">
		<property name="blockedList">
			<list>
				<value>known.spammer@example.org</value>
				<value>known.hacker@example.org</value>
				<value>john.doe@example.org</value>
			</list>
		</property>
	</bean>
	<bean id="blockedListNotifier" class="example.BlockedListNotifier">
		<property name="notificationAddress" value="blockedlist@example.org"/>
	</bean>
	<!-- optional: a custom ApplicationEventMulticaster definition -->
	<bean id="applicationEventMulticaster" class="org.springframework.context.event.SimpleApplicationEventMulticaster">
		<property name="taskExecutor" ref="..."/>
		<property name="errorHandler" ref="..."/>
	</bean>
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
Объединив все это вместе, можно сказать, что метод sendEmail() компонента emailService если есть сообщения электронной почты, которые следует заблокировать, вызывается пользовательское событие типа «BlockedListEvent» опубликован.

Компонент `blockedListNotifier` зарегистрирован как `ApplicationListener` и получает `BlockedListEvent`, после чего он может уведомить соответствующие стороны.
.Встроенные события [cols="30%,70%"] |=== | Событие| Объяснение.
ПРИМЕЧАНИЕ.
Механизм событий Spring предназначен для простой связи между bean-компонентами Spring. в одном и том же контексте приложения.
Однако для более сложных предприятий потребности в интеграции, отдельно поддерживаемое Проект {spring-site-projects}/spring-integration/[Spring Integration] предоставляет полная поддержка создания легких, https://www.enterpriseintegrationpatterns.com[ориентированный на шаблоны], управляемый событиями архитектуры, основанные на известной модели программирования Spring.
Прослушиватели событий на основе аннотаций.
Вы можете зарегистрировать прослушиватель событий в любом методе управляемого компонента, используя метод Аннотация `@EventListener`.
BlockedListNotifier можно переписать следующим образом:
Java
	public class BlockedListNotifier {
		private String notificationAddress;
		public void setNotificationAddress(String notificationAddress) {
			this.notificationAddress = notificationAddress;
		@EventListener
		public void processBlockedListEvent(BlockedListEvent event) {
			// уведомляем соответствующие стороны через NotificationAddress...
	class BlockedListNotifier {
Прослушиватели событий на основе аннотаций.
ПРИМЕЧАНИЕ.
Не делайте такие bean-компоненты ленивыми, поскольку ApplicationContext будет учитывать это и не будет регистрировать метод для прослушивания событий.
Прослушиватели событий на основе аннотаций.

Сигнатура метода еще раз объявляет тип события, которое он прослушивает. но на этот раз с гибким именем и без реализации специального интерфейса прослушивателя.
Тип события также можно сузить с помощью дженериков, если фактический тип события разрешает ваш общий параметр в его иерархии реализации.
Прослушиватели событий на основе аннотаций.
Если ваш метод должен прослушивать несколько событий или вы хотите определить его без вообще, типы событий также можно указать в самой аннотации. следующий пример показывает, как это сделать:
Java
	@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
	public void handleContextStart() {
Прослушиватели событий на основе аннотаций.
Также можно добавить дополнительную фильтрацию во время выполнения, используя атрибут Condition. аннотации, которая определяет выражение `SpEL`, которое должно соответствовать для фактического вызова метода для определенного события.
Прослушиватели событий на основе аннотаций.
В следующем примере показано, как можно переписать наш уведомитель, чтобы он вызывался только в том случае, если Атрибут события `content` равен `my-event`:
Java
	@EventListener(condition = "#blEvent.content == 'my-event'")
	public void processBlockedListEvent(BlockedListEvent blEvent) {
		// уведомляем соответствующие стороны через NotificationAddress...
Прослушиватели событий на основе аннотаций.
Каждое выражение SpEL оценивается в соответствии с выделенным контекстом.
В следующей таблице перечислены элементы, доступные контексту, чтобы вы могли использовать их для условной обработки событий:

Прослушиватели событий на основе аннотаций. .Метаданные событий доступны в выражениях SpEL. |=== | Имя| Местоположение| Описание| Пример
Прослушиватели событий на основе аннотаций. | Событие | корневой объект | Фактический ApplicationEvent. | `#root.event` или `event`
Прослушиватели событий на основе аннотаций. | Массив аргументов | корневой объект | Аргументы (в виде массива объектов), используемые для вызова метода. | `#root.args` или `args`; `args[0]` для доступа к первому аргументу и т. д.
Прослушиватели событий на основе аннотаций. | __Имя аргумента__ | контекст оценки | Имя конкретного аргумента метода.
Если имена недоступны (например, потому что код был скомпилирован без флага `-parameters`), отдельные аргументы также доступны с использованием синтаксиса `#a<#arg>`, где `<#arg>` обозначает индекс аргумента (начиная с 0). | `#blEvent` или `#a0` (вы также можете использовать обозначение параметра `#p0` или `#p<#arg>` в качестве псевдонима) |===
Прослушиватели событий на основе аннотаций.
Обратите внимание, что `#root.event` предоставляет вам доступ к базовому событию, даже если ваш метод подпись фактически относится к произвольному объекту, который был опубликован.
Прослушиватели событий на основе аннотаций.

Если вам необходимо опубликовать событие как результат обработки другого события, вы можете изменить сигнатура метода для возврата события, которое должно быть опубликовано, как показано в следующем примере:
Java
	@EventListener
	public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {
		// уведомляем соответствующие стороны через NotificationAddress и
		// затем опубликуйте ListUpdateEvent...
ПРИМЕЧАНИЕ.
Эта функция не поддерживается для.
Метод handleBlockedListEvent() публикует новое событие ListUpdateEvent для каждого `BlockedListEvent`, который он обрабатывает.
Если вам нужно опубликовать несколько событий, вы можете вернуться вместо этого используйте `Collection` или массив событий.
Асинхронные слушатели.
Если вы хотите, чтобы конкретный прослушиватель обрабатывал события асинхронно, вы можете повторно использовать В следующем примере показано, как это сделать:
Java
	@EventListener
	@Async
	public void processBlockedListEvent(BlockedListEvent event) {
		// BlockedListEvent обрабатывается в отдельном потоке
* Если асинхронный прослушиватель событий выдает исключение, оно не передается в
Помните о следующих ограничениях при использовании асинхронных событий:. звонящий.
См. {spring-framework-api}/aop/interceptor/AsyncUncaughtExceptionHandler.html[`AsyncUncaughtExceptionHandler`] для более подробной информации.
* Методы прослушивания асинхронных событий не могут публиковать последующее событие, возвращая
Помните о следующих ограничениях при использовании асинхронных событий:. ценность.
Если вам нужно опубликовать другое событие в результате обработки, добавьте {spring-framework-api}/context/ApplicationEventPublisher.html[`ApplicationEventPublisher`] опубликовать событие вручную.

* ThreadLocals и контекст ведения журнала по умолчанию не передаются при обработке событий.
Помните о следующих ограничениях при использовании асинхронных событий:.
См. раздел наблюдения `@EventListener` для получения дополнительной информации о проблемах наблюдаемости.
Порядок слушателей.
Если вам нужно, чтобы один прослушиватель вызывался перед другим, вы можете добавить `@Order` аннотация к объявлению метода, как показано в следующем примере:
Java
	@EventListener
	@Order(42)
	public void processBlockedListEvent(BlockedListEvent event) {
		// уведомляем соответствующие стороны через NotificationAddress...
Общие события.
Вы также можете использовать дженерики для дальнейшего определения структуры вашего мероприятия.
Рассмотрите возможность использования `EntityCreatedEvent<T>`, где `T` — это тип фактического созданного объекта.
Например, вы может создать следующее определение прослушивателя, чтобы получать только `EntityCreatedEvent` для `Человек`:
Java
	@EventListener
	public void onPersonCreated(EntityCreatedEvent<Person> event) {
Общие события.
Из-за стирания типа это работает только в том случае, если вызываемое событие разрешает общий параметры, по которым фильтрует прослушиватель событий (то есть что-то вроде `класс PersonCreatedEvent расширяет EntityCreatedEvent<Person> {... }`).
Общие события.
В определенных обстоятельствах это может стать довольно утомительным, если все события происходят по одному и тому же сценарию. структуру (как и должно быть в случае события в предыдущем примере).

В таком случае вы можете реализовать ResolvableTypeProvider, чтобы направлять структуру за пределы среды выполнения. окружающая среда обеспечивает.
Следующее событие показывает, как это сделать:
Java
	public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {
		public EntityCreatedEvent(T entity) {
			super(entity);
		@Override
		public ResolvableType getResolvableType() {
			return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
	class EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {
Общие события.
СОВЕТ: Это работает не только для ApplicationEvent, но и для любого произвольного объекта, который вы отправляете как событие.
Общие события.
Наконец, как и в случае с классической реализацией ApplicationListener, фактическая многоадресная рассылка происходит через контекстный объект ApplicationEventMulticaster во время выполнения.
По умолчанию это SimpleApplicationEventMulticaster с синхронной публикацией событий в вызывающем потоке.
Это можно заменить/настроить с помощью определения bean-компонента applicationEventMulticaster, например, для асинхронной обработки всех событий и/или для обработки исключений прослушивателя:
	@Bean
	ApplicationEventMulticaster applicationEventMulticaster() {
		SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();
		multicaster.setTaskExecutor(...);
		multicaster.setErrorHandler(...);
		return multicaster;
Удобный доступ к низкоуровневым ресурсам.
Для оптимального использования и понимания контекстов приложений вам следует ознакомиться с себя с помощью абстракции Spring `Resource`, как описано в
Удобный доступ к низкоуровневым ресурсам.

Контекст приложения — это ResourceLoader, который можно использовать для загрузки объектов Resource. «Ресурс» — это, по сути, более многофункциональная версия класса JDK «java.net.URL».
Фактически, реализации Resource оборачивают экземпляр java.net.URL, где соответствующий. «Ресурс» может получить ресурсы низкого уровня практически из любого места в мире. прозрачная мода, в том числе из пути к классам, местоположения файловой системы, где угодно описывается стандартным URL-адресом и некоторыми другими вариантами.
Если расположение ресурса строка — это простой путь без каких-либо специальных префиксов, откуда берутся эти ресурсы. специфичен и соответствует фактическому типу контекста приложения.
Удобный доступ к низкоуровневым ресурсам.
Вы можете настроить компонент, развернутый в контексте приложения, для реализации специального интерфейс обратного вызова ResourceLoaderAware для автоматического обратного вызова время инициализации с самим контекстом приложения, передаваемым как ResourceLoader.
Вы также можете предоставить свойства типа «Ресурс», которые будут использоваться для доступа к статическим ресурсам.
Они вводятся в него, как и любые другие свойства.
Вы можете указать эти `Resource` свойства как простые пути `String` и полагаются на автоматическое преобразование из этого текста. строки в фактические объекты Resource при развертывании компонента.
Удобный доступ к низкоуровневым ресурсам.
Путь или пути к местоположению, предоставленные конструктору ApplicationContext, на самом деле строки ресурсов и, в простой форме, обрабатываются соответствующим образом в соответствии с конкретными реализация контекста.

Например, ClassPathXmlApplicationContext обрабатывает простой путь к местоположению как местоположение пути к классам.
Вы также можете использовать пути к местоположению (строки ресурсов). со специальными префиксами для принудительной загрузки определений из пути к классам или URL-адреса, независимо от фактического типа контекста.
Отслеживание запуска приложений.
ApplicationContext управляет жизненным циклом приложений Spring и предоставляет богатые возможности. модель программирования вокруг компонентов.
В результате сложные приложения могут иметь одинаковое сложные графы компонентов и этапы запуска.
Отслеживание запуска приложений.
Отслеживание шагов запуска приложения с помощью конкретных показателей может помочь понять, где время тратится на этапе запуска, но его также можно использовать как способ улучшить понять жизненный цикл контекста в целом.
Отслеживание запуска приложений. «AbstractApplicationContext» (и его подклассы) оснащен `ApplicationStartup`, который собирает данные `StartupStep` о различных этапах запуска:
* жизненный цикл контекста приложения (сканирование базовых пакетов, управление классами конфигурации)
* жизненный цикл bean-компонентов (создание экземпляра, интеллектуальная инициализация, постобработка)
* обработка событий приложения
Java
	// создаем шаг запуска и начинаем запись
	try (StartupStep scanPackages = getApplicationStartup().start("spring.context.base-packages.scan")) {
        // добавляем информацию о тегах к текущему шагу
        scanPackages.tag("packages", () -> Arrays.toString(basePackages));
        // выполняем фактическую фазу, которую мы инструментируем

this.scanner.scan(basePackages);
Вот пример инструментов в AnnotationConfigApplicationContext:.
Контекст приложения уже оснащен несколькими шагами.
После записи эти этапы запуска можно собирать, отображать и анализировать с помощью специальных инструментов.
Полный список существующих шагов запуска можно найти на странице
Вот пример инструментов в AnnotationConfigApplicationContext:.
Реализация ApplicationStartup по умолчанию является безоперационным вариантом для минимальных накладных расходов.
Это означает, что по умолчанию при запуске приложения не будут собираться никакие метрики.
Spring Framework поставляется с реализацией для отслеживания шагов запуска с помощью Java Flight Recorder: `FlightRecorderApplicationStartup`.
Чтобы использовать этот вариант, вы должны настроить его экземпляр. в `ApplicationContext`, как только он будет создан.
Вот пример инструментов в AnnotationConfigApplicationContext:.
Разработчики также могут использовать инфраструктуру ApplicationStartup, если они предоставляют собственную. подкласс `AbstractApplicationContext`, или если они хотят собрать более точные данные.
Вот пример инструментов в AnnotationConfigApplicationContext:.
ВНИМАНИЕ: `ApplicationStartup` предназначен для использования только во время запуска приложения и для основной контейнер; это ни в коем случае не замена профилировщикам Java или библиотеки метрик, такие как https://micrometer.io[Micrometer].
Вот пример инструментов в AnnotationConfigApplicationContext:.
Чтобы начать сбор пользовательского `StartupStep`, компоненты могут либо получить `ApplicationStartup` экземпляр непосредственно из контекста приложения, сделайте так, чтобы их компонент реализовывал `ApplicationStartupAware`, или запросите тип «ApplicationStartup» в любой точке внедрения.

Вот пример инструментов в AnnotationConfigApplicationContext:.
ПРИМЕЧАНИЕ.
Разработчикам не следует использовать пространство имен `"spring.*"` при создании пользовательских шагов запуска.
Это пространство имен зарезервировано для внутреннего использования Spring и может быть изменено.
Удобное создание экземпляра ApplicationContext для веб-приложений.
Вы можете создавать экземпляры ApplicationContext декларативно, используя, например, `Контекстный загрузчик`.
Конечно, вы также можете создавать экземпляры ApplicationContext. программно, используя одну из реализаций ApplicationContext.
Удобное создание экземпляра ApplicationContext для веб-приложений.
Вы можете зарегистрировать ApplicationContext, используя ContextLoaderListener, в качестве следующий пример показывает:
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
	</context-param>
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
Удобное создание экземпляра ApplicationContext для веб-приложений.
Слушатель проверяет параметр contextConfigLocation.
Если параметр не существует, прослушиватель использует `/WEB-INF/applicationContext.xml` по умолчанию.
Когда параметр существует, прослушиватель разделяет `String`, используя предопределенный разделители (запятая, точка с запятой и пробел) и использует значения в качестве мест, где осуществляется поиск контекстов приложения.
Также поддерживаются шаблоны путей в стиле Ant.

Примеры: `/WEB-INF/{asterisk}Context.xml` (для всех файлов, имена которых заканчиваются на `Context.xml` и которые находятся в каталоге `WEB-INF`) и `/WEB-INF/**/*Context.xml` (для всех таких файлов в любом подкаталоге WEB-INF).
Развертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.
Можно развернуть Spring `ApplicationContext` как файл RAR, инкапсулирующий контекст и все необходимые классы компонентов и JAR-библиотеки в развертывании Jakarta EE RAR. единица.
Это эквивалент начальной загрузки автономного `ApplicationContext` (только размещенного в среде Jakarta EE), имея возможность доступа к серверам Jakarta EE. развертывание RAR является более естественной альтернативой сценарию развертывания безголового файла WAR.
По сути, файл WAR без каких-либо точек входа HTTP, который используется только для загрузки Spring `ApplicationContext` в среде Jakarta EE.
Развертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.
Развертывание RAR идеально подходит для контекстов приложений, которым не нужны точки входа HTTP, но скорее состоят только из конечных точек сообщений и запланированных заданий.

Бобы в таком контексте могут использовать ресурсы сервера приложений, такие как менеджер транзакций JTA и JDBC с привязкой к JNDI. экземпляры DataSource и экземпляры JMS ConnectionFactory, а также могут регистрироваться в JMX-сервер платформы — все через стандартное управление транзакциями Spring и JNDI. и средства поддержки JMX.
Компоненты приложения также могут взаимодействовать с приложением. серверный JCA WorkManager через абстракцию TaskExecutor Spring.
Развертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.
См. javadoc {spring-framework-api}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter`] class для деталей конфигурации, необходимых для развертывания RAR.
Развертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.
Для простого развертывания Spring ApplicationContext в виде файла RAR Jakarta EE:
Развертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE. .
Пакет все классы приложений в файл RAR (который представляет собой стандартный файл JAR с другим расширение файла)..
Добавьте все необходимые JAR-файлы библиотеки в корень архива RAR..
Добавить Дескриптор развертывания `META-INF/ra.xml` (как показано в {spring-framework-api}/jca/context/SpringContextResourceAdapter.html[javadoc для `SpringContextResourceAdapter`]) и соответствующие файлы определения bean-компонентов Spring XML (обычно `META-INF/applicationContext.xml`)..

Поместите полученный файл RAR в свой каталог развертывания сервера приложений.
Развертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.
ПРИМЕЧАНИЕ.
Такие модули развертывания RAR обычно являются автономными.
Они не раскрывают компоненты к внешнему миру, даже к другим модулям того же приложения.
Взаимодействие с `ApplicationContext` на основе RAR обычно возникает через адресаты JMS, с которыми он совместно используется. другие модули.
ApplicationContext на основе RAR также может, например, планировать некоторые задания. или реагировать на новые файлы в файловой системе (и тому подобное).
Если необходимо разрешить синхронный доступ извне, он может (например) экспортировать конечные точки RMI, которые можно использовать другими модулями приложения на том же компьютере.

Регистрация LoadTimeWeaver.
LoadTimeWeaver используется Spring для динамического преобразования классов по мере их появления. загружен в виртуальную машину Java (JVM).
Регистрация LoadTimeWeaver.
Чтобы включить переплетение во время загрузки, вы можете добавить `@EnableLoadTimeWeaving` в один из ваших Классы `@Configuration`, как показано в следующем примере:
Java
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig {
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig
Регистрация LoadTimeWeaver.
В качестве альтернативы для конфигурации XML вы можете использовать элемент context:load-time-weaver:
	<beans>
		<context:load-time-weaver/>
	</beans>
Регистрация LoadTimeWeaver.
После настройки для ApplicationContext любой компонент внутри этого ApplicationContext может реализовать LoadTimeWeaverAware, тем самым получая ссылку на время загрузки экземпляр ткача.
Это особенно полезно в сочетании с необходимо для преобразования класса JPA.
Проконсультируйтесь с {spring-framework-api}/orm/jpa/LocalContainerEntityManagerFactoryBean.html[`LocalContainerEntityManagerFactoryBean`] javadoc для более подробной информации.
Дополнительную информацию о переплетении времени загрузки AspectJ см.

Аннотированные контроллеры.
Spring WebFlux предоставляет модель программирования на основе аннотаций, где `@Controller` и Компоненты `@RestController` используют аннотации для выражения сопоставления запросов, ввода запроса, обрабатывать исключения и многое другое.
Аннотированные контроллеры имеют гибкие сигнатуры методов и не нужно расширять базовые классы или реализовывать определенные интерфейсы.
Java
	@RestController
	public class HelloController {
		@GetMapping("/hello")
		public String handle() {
			return "Hello WebFlux";
	@RestController
	class HelloController {
В следующем листинге показан базовый пример:.
В предыдущем примере метод возвращает строку для записи в тело ответа.

Преобразование типа.
По умолчанию установлены средства форматирования для различных типов чисел и дат, а также поддержка для настройки через `@NumberFormat`, `@DurationFormat` и `@DateTimeFormat` в полях и параметры.
Преобразование типа.
Чтобы зарегистрировать пользовательские форматтеры и конвертеры, используйте следующее: См. пример кода в исходном документе.
Преобразование типа.
По умолчанию Spring MVC учитывает запрос Locale при анализе и форматировании даты. ценности.
Это работает для форм, где даты представлены как строки с формой «входа». поля.
Однако для полей формы «дата» и «время» браузеры используют фиксированный формат, определенный в спецификации HTML.
В таких случаях форматирование даты и времени можно настроить следующим образом: См. пример кода в исходном документе.
Преобразование типа.
ПРИМЕЧАНИЕ.
См.
SPI `FormatterRegistrar`. и FormattingConversionServiceFactoryBean для получения дополнительной информации о том, когда использовать Реализации FormatterRegistrar.

Преобразование типа пружины.
Пакет `core.convert` предоставляет общую систему преобразования типов.
Система определяет SPI для реализации логики преобразования типов и API для выполнения преобразований типов на время выполнения.
Внутри контейнера Spring вы можете использовать эту систему в качестве альтернативы Реализации `PropertyEditor` для преобразования строк значений свойств внешнего компонента в необходимые типы недвижимости.
Вы также можете использовать общедоступный API в любом месте вашего приложения. где требуется преобразование типов.
Конвертер SPI.
SPI для реализации логики преобразования типов прост и строго типизирован, как показано ниже. определение интерфейса показывает:
	package org.springframework.core.convert.converter;
	public interface Converter<S, T> {
		T convert(S source);
Конвертер SPI.
Чтобы создать свой собственный преобразователь, реализуйте интерфейс «Конвертер» и параметризуйте «S». как тип, из которого вы конвертируете, и `T` как тип, в который вы конвертируете.
Вы также можете прозрачно применить такой конвертер, если необходимо преобразовать коллекцию или массив `S` преобразуется в массив или коллекцию `T` при условии, что делегирующий массив или коллекция конвертер также зарегистрирован (что по умолчанию делает `DefaultConversionService`).
Конвертер SPI.
Для каждого вызова Convert(S) аргумент источника гарантированно не будет нулевым.
Ваш `Конвертер` может выдать любое непроверенное исключение, если преобразование не удалось.

В частности, он должен выдать `IllegalArgumentException`, чтобы сообщить о недопустимом исходном значении.
Позаботьтесь о том, чтобы ваша реализация «Конвертера» была потокобезопасной.
Конвертер SPI.
Несколько реализаций конвертера предоставляются в пакете `core.convert.support` как удобство.
К ним относятся преобразователи строк в числа и другие распространенные типы.
В следующем листинге показан класс StringToInteger, который является типичной реализацией Converter:
	package org.springframework.core.convert.support;
	final class StringToInteger implements Converter<String, Integer> {
		public Integer convert(String source) {
			return Integer.valueOf(source);
Использование ConverterFactory.
Когда вам нужно централизовать логику преобразования для всей иерархии классов (например, при преобразовании объектов String в Enum), вы можете реализовать «ConverterFactory», как показано в следующем примере:
	package org.springframework.core.convert.converter;
	public interface ConverterFactory<S, R> {
		<T extends R> Converter<S, T> getConverter(Class<T> targetType);
Использование ConverterFactory.
Параметризуйте `S` как тип, из которого вы конвертируете, а `R` как определяющий базовый тип. __range__ классов, в которые вы можете преобразовать.
Затем реализуйте `getConverter(Class<T>)`, где «T» — подкласс «R».
	package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {
		public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
			return new StringToEnumConverter(targetType);
		private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {
			private Class<T> enumType;
			public StringToEnumConverter(Class<T> enumType) {
				this.enumType = enumType;
			public T convert(String source) {
				return (T) Enum.valueOf(this.enumType, source.trim());
Использование GenericConverter.
Если вам требуется более сложная реализация «Конвертера», рассмотрите возможность использования Интерфейс `GenericConverter`.
С более гибкой, но менее строго типизированной подписью, чем `Конвертер`, `GenericConverter` поддерживает преобразование между несколькими источниками и целями. типы.
Кроме того, GenericConverter предоставляет дескрипторы исходного и целевого типов. который вы можете использовать при реализации логики преобразования.
Такие дескрипторы типов позволяют преобразование типов должно осуществляться аннотацией в источнике дескриптора (например, поле или метод) или с помощью общей информации, объявленной в сигнатуре поля, методе подпись и т. д.
В следующем листинге показано определение GenericConverter. интерфейс:
	package org.springframework.core.convert.converter;
	public interface GenericConverter {
		public Set<ConvertiblePair> getConvertibleTypes();
		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

Использование GenericConverter.
Чтобы реализовать GenericConverter, необходимо, чтобы getConvertibleTypes() возвращал поддерживаемые типы. пары исходный → целевой тип.
Затем реализуйте Convert(Object, TypeDescriptor, TypeDescriptor)`, чтобы содержать логику преобразования.
Исходный TypeDescriptor предоставляет доступ к исходному полю или методу, содержащему преобразуемое значение.
Цель `TypeDescriptor` обеспечивает доступ к целевому полю или методу, в котором преобразованное значение должен быть установлен.
Использование GenericConverter.
Хорошим примером GenericConverter является преобразователь, который преобразует массив Java и коллекция.
Такой ArrayToCollectionConverter анализирует поле или метод. который объявляет тип целевой коллекции для разрешения типа элемента коллекции.
Это позволяет каждому элементу исходного массива быть преобразовано в тип элемента коллекции перед коллекция устанавливается в целевом поле или передается целевому методу или конструктору.
Использование GenericConverter.
ПРИМЕЧАНИЕ.
Поскольку GenericConverter представляет собой более сложный интерфейс SPI, вам следует использовать это только тогда, когда вам это нужно.
В качестве базового типа отдавайте предпочтение Converter или ConverterFactory. потребности в конверсии.
Использование «ConditionalGenericConverter».
Иногда вам нужно, чтобы «Конвертер» запускался только в том случае, если определенное условие выполняется.

Для Например, вы можете запустить «Конвертер», только если в файле присутствует определенная аннотация. целевое поле или метод, или вы можете запустить `Конвертер` только в том случае, если определенное метод (например, метод static valueOf) определен для целевого типа. «ConditionalGenericConverter» — это объединение «GenericConverter» и Интерфейсы `ConditionalConverter`, которые позволяют вам определять такие пользовательские критерии соответствия:
	public interface ConditionalConverter {
		boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
	public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
Использование «ConditionalGenericConverter».
Хорошим примером ConditionalGenericConverter является IdToEntityConverter, который преобразует между постоянным идентификатором объекта и ссылкой на объект.
Такой `IdToEntityConverter` может соответствовать только в том случае, если целевой тип сущности объявляет статический метод поиска (например, `findAccount(Long)`).
Вы можете выполнить такую проверку метода поиска в реализации `соответствует (TypeDescriptor, TypeDescriptor)`.
API «ConversionService».
ConversionService определяет унифицированный API для выполнения логики преобразования типов на время выполнения.
Преобразователи часто выполняются за следующим фасадным интерфейсом:
	package org.springframework.core.convert;
	public interface ConversionService {
		boolean canConvert(Class<?> sourceType, Class<?> targetType);
		<T> T convert(Object source, Class<T> targetType);
		boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);
		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

API «ConversionService».
Большинство реализаций ConversionService также реализуют ConverterRegistry, который предоставляет SPI для регистрации преобразователей.
Внутри ConversionService реализация делегирует своим зарегистрированным преобразователям выполнение логики преобразования типов.
API «ConversionService».
Надежная реализация ConversionService представлена в файле core.convert.support. пакет.
GenericConversionService — это реализация общего назначения, подходящая для использовать в большинстве сред.
ConversionServiceFactory предоставляет удобную фабрику для создание общих конфигураций ConversionService.
Настройка ConversionService.
ConversionService — это объект без сохранения состояния, предназначенный для создания экземпляра в приложении. при запуске, а затем распределяется между несколькими потоками.
В приложении Spring вы обычно настройте экземпляр ConversionService для каждого контейнера Spring (или ApplicationContext).
Spring берет этот ConversionService и использует его всякий раз, когда тип преобразование должно выполняться платформой.
Вы также можете ввести это `ConversionService` в любой из ваших bean-компонентов и вызывайте его напрямую.
Настройка ConversionService.
ПРИМЕЧАНИЕ.
Если в Spring не зарегистрирована служба ConversionService, исходный файл на основе PropertyEditor используется система.
Настройка ConversionService.
Чтобы зарегистрировать ConversionService по умолчанию в Spring, добавьте следующее определение bean-компонента с идентификатором `conversionService`:
	<bean id="conversionService"
		class="org.springframework.context.support.ConversionServiceFactoryBean"/>
Настройка ConversionService.
Служба ConversionService по умолчанию может конвертировать строки, числа, перечисления, коллекции, карты и другие распространенные типы.

Чтобы дополнить или переопределить преобразователи по умолчанию с помощью вашего собственные преобразователи, установите свойство «конвертеры».
Значения свойств могут быть реализованы любой из интерфейсов Converter, ConverterFactory или GenericConverter.
	<bean id="conversionService"
			class="org.springframework.context.support.ConversionServiceFactoryBean">
		<property name="converters">
			<set>
				<bean class="example.MyCustomConverter"/>
			</set>
		</property>
	</bean>
Настройка ConversionService.
Также часто используется ConversionService в приложении Spring MVC.
См.
Настройка ConversionService.
В определенных ситуациях вам может потребоваться применить форматирование во время преобразования.
См. для получения подробной информации об использовании FormattingConversionServiceFactoryBean.
Программное использование ConversionService.
Чтобы программно работать с экземпляром ConversionService, вы можете добавить ссылку на это так же, как и для любого другого компонента.
В следующем примере показано, как это сделать:
Java
	@Service
	public class MyService {
		private final ConversionService conversionService;
		public MyService(ConversionService conversionService) {
			this.conversionService = conversionService;
		public void doIt() {
			this.conversionService.convert(...)
Программное использование ConversionService.
В большинстве случаев вы можете использовать метод Convert, который определяет TargetType, но он не работает с более сложными типами, такими как коллекция параметризованных элементов.

Например, если вы хотите программно преобразовать «Список» «Целое число» в «Список» «Строка», вам необходимо предоставить формальное определение исходного и целевого типов.
Программное использование ConversionService.
К счастью, TypeDescriptor предоставляет различные возможности, упрощающие эту задачу. как показано в следующем примере:
Java
	DefaultConversionService cs = new DefaultConversionService();
	List<Integer> input = ...
	cs.convert(input,
		TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class)), // <1>
		TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class))); // <2>
<1> Дескриптор типа `List<Integer>` <2> Дескриптор типа `List<String>`.
Обратите внимание, что DefaultConversionService автоматически регистрирует конвертеры, которые подходит для большинства сред.
Сюда входят преобразователи коллекций, скалярные конвертеры и базовые преобразователи «Объект» в «Строка».
Вы можете зарегистрировать такие же преобразователи с любым ConverterRegistry, используя статический addDefaultConverters. метод в классе DefaultConversionService.
<1> Дескриптор типа `List<Integer>` <2> Дескриптор типа `List<String>`.

Преобразователи типов значений повторно используются для массивов и коллекций, поэтому существует нет необходимости создавать специальный преобразователь для преобразования из «Коллекции» «S» в `Сбор` `T`, предполагая, что стандартная обработка сбора является подходящей.

`@CookieValue`.
Вы можете использовать аннотацию @CookieValue, чтобы привязать значение файла cookie HTTP к аргументу метода. в контроллере.
Java
	@GetMapping("/demo")
	public void handle(@CookieValue("JSESSIONID") String cookie) { // <1>
В следующем примере кода показано, как получить значение файла cookie:. <1> Получите значение файла cookie.
В следующем примере кода показано, как получить значение файла cookie:.
Преобразование типов применяется автоматически, если тип параметра целевого метода не `Строка`.
См. ссылку:web/webflux/controller/ann-methods/typeconversion.adoc [Преобразование типов].

1. Введение. `core` — базовый модуль Lilipup Framework, который отвечает за контейнер компонентов, внедрение зависимостей, событийную шину и базовые абстракции запуска приложения.
- стандартизирует инициализацию приложения;
- управляет жизнью компонентов через контейнер `LilipupContext`;
- предоставляет единый API для модулей `configuration`, `validation`, `security`, `scheduler`, `kafka`, `monitoring`.
```xml
```groovy
```java
    public static void main(String[] args) {
        LilipupApplication.run(App.class, args);
```java
    private final TaxService taxService;
    // Конструкторное внедрение предпочтительнее: гарантирует неизменяемость зависимостей.
    @Inject
    public InvoiceService(TaxService taxService) {
        this.taxService = taxService;
    public long calculateTotal(long baseAmount) {
        return baseAmount + taxService.taxFor(baseAmount);
    public long taxFor(long amount) {
        return Math.round(amount * 0.2);
```java
    private final EventPublisher publisher;
    public OrderFlow(EventPublisher publisher) {
        this.publisher = publisher;
    public void placeOrder(String orderId) {
        publisher.publish(new OrderCreatedEvent(orderId));
    @OnEvent
    public void onOrderCreated(OrderCreatedEvent event) {
        // Локальная реакция: запись метрики, подготовка к отправке в Kafka и т.д.

System.out.println("Order accepted: " + event.orderId());
```yaml
    name: billing-service
    profile: prod
    scan-packages:
      - com.example.app
      - com.example.shared
    lazy-init: false
    fail-fast: true
    event-bus:
      async: true
      workers: 8
- `lilipup.core.lazy-init`: откладывает создание бинов до первого запроса;
- `lilipup.core.fail-fast`: завершает запуск при ошибках графа зависимостей;
- `lilipup.core.event-bus.async`: включает асинхронную доставку событий.
- Всегда проверяйте, что `scan-packages` включает все модули с компонентами, иначе часть бинов не будет создана.
- Всегда включайте `fail-fast=true` для production, чтобы не запускаться с полубитым контейнером.
- Перед публикацией доменных событий проверяйте валидность payload (не `null`, корректные идентификаторы).
- Не создавайте циклические зависимости между компонентами (`A -> B -> A`).
- Проверяйте, что асинхронный `event-bus` имеет достаточное число `workers` под нагрузкой.
- `BeanResolutionException`: контейнер не может найти/создать зависимость.
- `CircularDependencyException`: цикл в графе DI.
- `EventDispatchTimeoutException`: обработчик события не уложился в таймаут.
```java

public static void main(String[] args) {
        try {
            LilipupApplication.run(App.class, args);
        } catch (BootstrapException ex) {
            // В реальном проекте: структурированный лог + аварийное уведомление.
            System.err.println("Startup failed: " + ex.getMessage());
            System.exit(1);
- Используйте конструкторное внедрение как default.
- Разделяйте `@Component` и инфраструктурные бины (`@Factory`) по пакетам.
- Ограничивайте область сканирования (`scan-packages`) для ускорения старта.
- Доменные события делайте immutable (`record` / финальные поля).
- Не размещайте тяжелую I/O-логику в синхронных обработчиках событий.

Использование CustomAutowireConfigurer. {spring-framework-api}/beans/factory/annotation/CustomAutowireConfigurer.html[`CustomAutowireConfigurer`] это `BeanFactoryPostProcessor`, который позволяет вам зарегистрировать свой собственный квалификатор типы аннотаций, даже если они не снабжены аннотацией Spring `@Qualifier`.
В следующем примере показано, как использовать CustomAutowireConfigurer:
	<bean id="customAutowireConfigurer"
			class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
		<property name="customQualifierTypes">
			<set>
				<value>example.CustomQualifier</value>
			</set>
		</property>
	</bean>
* Значение `autowire-candidate` каждого определения bean-компонента.
* Любые шаблоны `default-autowire-candidates`, доступные в элементе `<beans/>`.
* Наличие аннотаций `@Qualifier` и любых зарегистрированных пользовательских аннотаций.
с помощью CustomAutowireConfigurer.
Когда несколько bean-компонентов квалифицируются как кандидаты для автоматического подключения, определение «основного» следующим образом: если ровно одно определение компонента среди кандидатов имеет "первичное" атрибуту присвоено значение true, он выбирается.

API конфигурации MVC.
В конфигурации Java вы можете реализовать интерфейс WebMvcConfigurer, как следующий пример показывает: См. пример кода в исходном документе.
API конфигурации MVC.
В XML вы можете проверять атрибуты и подэлементы `<mvc:annotation-driven/>`.
Вы можете просмотрите https://schema.spring.io/mvc/spring-mvc.xsd [XML-схему Spring MVC] или используйте функция завершения кода вашей IDE, чтобы узнать, какие атрибуты и доступны подэлементы.

Поддержка ДАО.
Поддержка Data Access Object (DAO) в Spring призвана упростить работу с технологии доступа к данным (такие как JDBC, Hibernate или JPA) согласованным образом.
Это позволяет довольно легко переключаться между вышеупомянутыми технологиями сохранения, а также позволяет вам писать код, не беспокоясь о перехвате исключений, которые специфичны для каждой технологии.
Согласованная иерархия исключений.
Spring обеспечивает удобный перевод исключений, специфичных для конкретной технологии, таких как `SQLException` в свою собственную иерархию классов исключений, которая имеет `DataAccessException` как корневое исключение.
Эти исключения оборачивают исходное исключение, поэтому никогда не возникает любой риск того, что вы можете потерять любую информацию о том, что могло пойти не так.
Согласованная иерархия исключений.
Помимо исключений JDBC, Spring также может обертывать исключения, специфичные для JPA и Hibernate. преобразование их в набор сфокусированных исключений времени выполнения.
Это позволяет вам справиться с большинством невосстанавливаемые постоянные исключения только на соответствующих уровнях, без необходимости раздражающие шаблонные блоки catch-and-throw и объявления исключений в ваших DAO. (Однако вы все равно можете перехватывать и обрабатывать исключения в любом месте.) Как упоминалось выше, Исключения JDBC (включая диалекты, специфичные для базы данных) также преобразуются в тот же иерархия, что означает, что вы можете выполнять некоторые операции с JDBC в рамках согласованной модель программирования.
Согласованная иерархия исключений.
Предыдущее обсуждение справедливо для различных классов шаблонов, поддерживаемых Spring. для различных фреймворков ORM.

Если вы используете классы на основе перехватчиков, приложение должно позаботьтесь об обработке HibernateExceptions и PersistenceExceptions, желательно с помощью делегирование `convertHibernateAccessException(..)` или `convertJpaAccessException(..)` методы соответственно `SessionFactoryUtils`.
Эти методы преобразуют исключения к исключениям, совместимым с исключениями в `org.springframework.dao` иерархия исключений.
Поскольку `PersistenceExceptions` не отмечены, они также могут быть выброшены. (однако принося в жертву общую абстракцию DAO с точки зрения исключений).
Согласованная иерархия исключений.
На следующем изображении показана иерархия исключений, предоставляемая Spring. (Обратите внимание, что иерархия классов, подробно описанная на изображении, показывает только подмножество всей Иерархия DataAccessException.)
Аннотации, используемые для настройки классов DAO или репозитория.
Лучший способ гарантировать, что ваши объекты доступа к данным (DAO) или репозитории предоставляют перевод исключений заключается в использовании аннотации `@Repository`.
Эта аннотация также позволяет поддержке сканирования компонентов находить и настраивать ваши DAO и репозитории без необходимости предоставления для них записей конфигурации XML.
Следующий пример показывает как использовать аннотацию `@Repository`:
Java
	@Repository // <1>
	public class SomeMovieFinder implements MovieFinder {
Аннотации, используемые для настройки классов DAO или репозитория. <1> Аннотация `@Repository`.
	@Repository // <1>
	class SomeMovieFinder : MovieFinder {
Аннотации, используемые для настройки классов DAO или репозитория. <1> Аннотация `@Repository`.

Аннотации, используемые для настройки классов DAO или репозитория.
Любая реализация DAO или репозитория требует доступа к постоянному ресурсу. в зависимости от используемой технологии сохранения.
Например, репозиторий на основе JDBC. необходим доступ к источнику данных JDBC, а репозиторию на основе JPA необходим доступ к `EntityManager`.
Самый простой способ добиться этого — создать зависимость от ресурсов. внедряется с помощью одного из `@Autowired`, `@Inject`, `@Resource` или `@PersistenceContext` аннотации.
Следующий пример работает для репозитория JPA:
Java
	@Repository
	public class JpaMovieFinder implements MovieFinder {
		@PersistenceContext
		private EntityManager entityManager;
	@Repository
	class JpaMovieFinder : MovieFinder {
Аннотации, используемые для настройки классов DAO или репозитория.
Если вы используете классические API-интерфейсы Hibernate, вы можете внедрить SessionFactory, как показано ниже. пример показывает:
Java
	@Repository
	public class HibernateMovieFinder implements MovieFinder {
		private SessionFactory sessionFactory;
		@Autowired
		public void setSessionFactory(SessionFactory sessionFactory) {
			this.sessionFactory = sessionFactory;
Аннотации, используемые для настройки классов DAO или репозитория.
Последний пример, который мы здесь показываем, относится к типичной поддержке JDBC.
У вас может быть `DataSource` вводится в метод инициализации или конструктор, где вы должны создать JdbcTemplate. и другие классы поддержки доступа к данным (такие как SimpleJdbcCall и другие), используя этот `Источник данных`.
В следующем примере происходит автоматическое подключение DataSource:
Java
	@Repository

public class JdbcMovieFinder implements MovieFinder {
		private JdbcTemplate jdbcTemplate;
		@Autowired
		public void init(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
Аннотации, используемые для настройки классов DAO или репозитория.
ПРИМЕЧАНИЕ.
Подробную информацию о том, как настройте контекст приложения, чтобы использовать эти аннотации.

Привязка данных полезна для привязки пользовательского ввода к целевому объекту, где пользовательский ввод представляет собой карту. с путями к свойствам в качестве ключей, следуя соглашениям JavaBeans. `DataBinder` — основной класс, поддерживающий это, и он предоставляет два способа привязки пользователя ввод:
- Привязка конструктора — привязать пользовательский ввод к
Привязка данных. конструктор общедоступных данных, ищущий значения аргументов конструктора во входных данных пользователя.
- Привязка свойства — привязать пользовательский ввод к установщикам,
Привязка данных. сопоставление ключей из пользовательского ввода со свойствами структуры целевого объекта.
Привязка данных.
Вы можете применить как конструктор, так и привязку свойства или только одну.
1. Создайте DataBinder с null в качестве целевого объекта.
2. Установите targetType для целевого класса.
3. Вызовите `construct`.
Чтобы использовать привязку конструктора:.
Целевой класс должен иметь один общедоступный конструктор или один закрытый конструктор. с аргументами.
Если существует несколько конструкторов, то конструктор по умолчанию, если он присутствует. используется.
Чтобы использовать привязку конструктора:.
По умолчанию значения аргументов ищутся по именам параметров конструктора.
Spring MVC и WebFlux поддерживает пользовательское сопоставление имен через аннотацию @BindParam в конструкторе. параметры или поля, если они присутствуют.
При необходимости вы также можете настроить NameResolver на `DataBinder`, чтобы настроить имя используемого аргумента.
Чтобы использовать привязку конструктора:.

Если параметр конструктора является объектом, он создается рекурсивно в том же способом, но через вложенный путь к свойству.
Это означает, что привязка конструктора создает оба целевой объект и любые объекты, которые он содержит.
Чтобы использовать привязку конструктора:.
Привязка конструктора поддерживает аргументы List, Map и массива, преобразованные из одну строку, например список, разделенный запятыми, или на основе индексированных ключей, таких как `accounts[2].name` или `account[KEY].name`.
Чтобы использовать привязку конструктора:.
Ошибки привязки и преобразования отражаются в BindingResult объекта DataBinder.
Если цель создана успешно, то в качестве цели устанавливается созданный экземпляр. после вызова `construct`.
Привязка свойств с помощью BeanWrapper.
Пакет `org.springframework.beans` соответствует стандарту JavaBeans.
JavaBean — это класс с конструктором без аргументов по умолчанию, и это следует соглашение об именах, согласно которому (например) свойство с именем `bingoMadness` будет имеют метод установки `setBingoMadness(..)` и метод получения `getBingoMadness()`.
Для дополнительную информацию о JavaBeans и спецификации см. {java-api}/java.desktop/java/beans/package-summary.html[javabeans].
Привязка свойств с помощью BeanWrapper.
Одним из весьма важных классов в пакете bean-компонентов является интерфейс BeanWrapper и его соответствующая реализация (`BeanWrapperImpl`).

Как указано в javadoc, `BeanWrapper` предлагает функциональные возможности для установки и получения значений свойств (индивидуально или в массово), получить дескрипторы свойств и запросить свойства, чтобы определить, являются ли они читаемый или записываемый.
Кроме того, BeanWrapper предлагает поддержку вложенных свойств. возможность настройки свойств вложенных свойств на неограниченную глубину. `BeanWrapper` также поддерживает возможность добавления стандартных JavaBeans `PropertyChangeListeners` и VetoableChangeListeners без необходимости поддержки кода в целевом классе.
И последнее, но не менее важное: BeanWrapper обеспечивает поддержку установки индексированных свойств. `BeanWrapper` обычно не используется кодом приложения напрямую, а используется `DataBinder` и `BeanFactory`.
Привязка свойств с помощью BeanWrapper.
Принцип работы `BeanWrapper` частично определяется его названием: он оборачивает компонент в выполнять действия над этим компонентом, такие как установка и получение свойств.
Установка и получение основных и вложенных свойств.
Установка и получение свойств осуществляется через `setPropertyValue` и getPropertyValue — перегруженные варианты метода BeanWrapper.
См. их Javadoc для детали.
В таблице ниже показаны некоторые примеры этих соглашений:
.Примеры свойств |=== | Выражение| Объяснение. | `имя` | Указывает свойство name, которое соответствует getName() или isName(). и `setName(..)`.

.Примеры свойств |=== | Выражение| Объяснение. | `аккаунт.имя` | Указывает вложенное свойство `name` свойства `account`, которое соответствует (например) методы `getAccount().setName()` или `getAccount().getName()`.
.Примеры свойств |=== | Выражение| Объяснение. | `счета[2]` | Указывает _третий_ элемент индексированного свойства account.
Индексированные свойства может иметь тип массива, списка или другой естественно упорядоченной коллекции.
.Примеры свойств |=== | Выражение| Объяснение. | `аккаунты[KEY]` | Указывает значение записи карты, индексированной значением `KEY`. |===
.Примеры свойств |=== | Выражение| Объяснение. (Следующий раздел не является для вас жизненно важным, если вы не планируете работать с непосредственно `BeanWrapper`.
Если вы используете только DataBinder и BeanFactory и их реализации по умолчанию, вам следует перейти к
.Примеры свойств |=== | Выражение| Объяснение.
Следующие два примера классов используют BeanWrapper для получения и установки свойства:
Java
	public class Company {
		private String name;
		private Employee managingDirector;
		public String getName() {
			return this.name;
		public void setName(String name) {
			this.name = name;
		public Employee getManagingDirector() {
			return this.managingDirector;

public void setManagingDirector(Employee managingDirector) {
			this.managingDirector = managingDirector;
Java
	public class Employee {
		private String name;
		private float salary;
		public String getName() {
			return this.name;
		public void setName(String name) {
			this.name = name;
		public float getSalary() {
			return salary;
		public void setSalary(float salary) {
			this.salary = salary;
.Примеры свойств |=== | Выражение| Объяснение.
Следующие фрагменты кода показывают несколько примеров того, как извлекать и манипулировать некоторыми из свойства экземпляров ``Company`` и ``Employee``:
Java
	BeanWrapper company = new BeanWrapperImpl(new Company());
	// установка названия компании..
	company.setPropertyValue("name", "Some Company Inc.");
	// ... также можно сделать так:
	PropertyValue value = new PropertyValue("name", "Some Company Inc.");
	company.setPropertyValue(value);
	// ок, создадим директора и привяжем его к компании:
	BeanWrapper jim = new BeanWrapperImpl(new Employee());
	jim.setPropertyValue("name", "Jim Stravinsky");
	company.setPropertyValue("managingDirector", jim.getWrappedInstance());
	// получение зарплаты управляющего директора через компанию

Float salary = (Float) company.getPropertyValue("managingDirector.salary");
``PropertyEditor``s.
Spring использует концепцию PropertyEditor для преобразования между `Объект` и `Строка`.
Это может быть удобно представлять свойства иначе, чем сам объект.
Например, «Дата» может быть представлен в удобочитаемом виде (как ``String`: `'2007-14-09'`), в то время как мы все еще можем преобразовать удобочитаемую форму обратно в исходную дату (или даже лучше преобразовать любую дату, введенную в удобочитаемой форме, обратно в объекты Date).
Это поведение может быть достигнуто путем регистрации пользовательских редакторов типа `java.beans.PropertyEditor`.
Регистрация пользовательских редакторов в BeanWrapper или альтернативно, в конкретном контейнере IoC (как упоминалось в предыдущей главе), дает ему знание того, как преобразовать свойства к нужному типу.
Подробнее о `PropertyEditor`, см. {java-api}/java.desktop/java/beans/package-summary.html [javadoc пакета `java.beans` от Oracle].
* Установка свойств bean-компонентов выполняется с помощью реализаций PropertyEditor.
Несколько примеров использования редактирования свойств в Spring:.

Когда вы используете `String` в качестве значения свойства некоторого bean-компонента, который вы объявляете в XML-файле Spring (если установщик соответствующего свойства имеет `Class` параметр) использует ClassEditor, чтобы попытаться преобразовать параметр в объект Class.
* Анализ параметров HTTP-запроса в среде Spring MVC выполняется с использованием всех видов
Несколько примеров использования редактирования свойств в Spring:. реализаций PropertyEditor, которые вы можете вручную связать во всех подклассах `Командный Контроллер`.
Несколько примеров использования редактирования свойств в Spring:.
Spring имеет ряд встроенных реализаций PropertyEditor, упрощающих жизнь.
Все они расположены в папке org.springframework.beans.propertyeditors. пакет.
Большинство (но не все, как указано в следующей таблице) по умолчанию регистрируются `BeanWrapperImpl`.
Если редактор свойств каким-либо образом настраивается, вы можете все равно зарегистрируйте свой собственный вариант, чтобы заменить вариант по умолчанию.
В следующей таблице описаны различные реализации PropertyEditor, предоставляемые Spring:
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `ByteArrayPropertyEditor` | Редактор байтовых массивов.
Преобразует строки в соответствующие им байты представления.
Зарегистрировано по умолчанию с помощью BeanWrapperImpl.

.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `Редактор классов` | Анализирует строки, представляющие классы, в фактические классы и наоборот.
Когда класс не найден, выдается исключение IllegalArgumentException.
По умолчанию зарегистрировано `BeanWrapperImpl`.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `Пользовательский логический редактор` | Настраиваемый редактор свойств для логических свойств.
По умолчанию зарегистрировано `BeanWrapperImpl`, но его можно переопределить, зарегистрировав его собственный экземпляр как специальный редактор.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `CustomCollectionEditor` | Редактор свойств коллекций, преобразующий любую исходную коллекцию в заданную цель.
Тип «Коллекция».
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `CustomDateEditor` | Настраиваемый редактор свойств для java.util.Date, поддерживающий пользовательский формат DateFormat.
НЕ зарегистрирован по умолчанию.
Должен быть зарегистрирован пользователем в соответствующем формате по мере необходимости.

.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `CustomNumberEditor` | Настраиваемый редактор свойств для любого подкласса Number, например Integer, Long, Float или `Двойник`.
По умолчанию регистрируется BeanWrapperImpl, но может быть переопределен с помощью регистрация его пользовательского экземпляра в качестве пользовательского редактора.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `Редактор файлов` | Преобразует строки в объекты java.io.File.
По умолчанию зарегистрировано `BeanWrapperImpl`.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `InputStreamEditor` | Односторонний редактор свойств, который может принимать строку и создавать (через промежуточные `ResourceEditor` и `Resource`) и `InputStream`, чтобы `InputStream` свойства могут быть заданы непосредственно в виде строк.
Обратите внимание, что использование по умолчанию не закрывается. `InputStream` для вас.
По умолчанию регистрируется BeanWrapperImpl.

.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `Редактор локали` | Может преобразовывать строки в объекты Locale и наоборот (формат строки: `[язык]\_[страна]_[вариант]`, то же, что и метод `toString()` «Локаль»).
Также принимает пробелы в качестве разделителей в качестве альтернативы подчеркиванию.
По умолчанию регистрируется BeanWrapperImpl.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `Редактор шаблонов` | Может преобразовывать строки в объекты java.util.regex.Pattern и наоборот.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `Редактор свойств` | Может конвертировать строки (отформатированные в формате, определенном в javadoc класс `java.util.Properties`) для объектов `Properties`.
По умолчанию зарегистрировано от `BeanWrapperImpl`.
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `StringTrimmerEditor` | Редактор свойств, который обрезает строки.
Опционально позволяет преобразовать пустую строку в значение `null`.
НЕ зарегистрировано по умолчанию — должно быть зарегистрировано пользователем.

.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение. | `URLEditor` | Может преобразовать строковое представление URL-адреса в реальный объект URL.
По умолчанию регистрируется BeanWrapperImpl. |===
.Встроенный редактор PropertyEditor. [cols="30%,70%"] |=== | Класс| Объяснение.
Spring использует java.beans.PropertyEditorManager для установки пути поиска свойства. редакторы, которые могут понадобиться.
Путь поиска также включает `sun.bean.editors`, который включает реализации PropertyEditor для таких типов, как Font, Color и большинства примитивные типы.
Также обратите внимание, что стандартная инфраструктура JavaBeans автоматически обнаруживает классы PropertyEditor (без необходимости их регистрации) явно), если они находятся в том же пакете, что и класс, который они обрабатывают, и имеют одинаковый имя этого класса с добавлением `Editor`.
Например, можно было бы иметь следующее структуру класса и пакета, которой было бы достаточно для того, чтобы класс `SomethingEditor` был распознается и используется как PropertyEditor для свойств типа Something.
    pop
      Something
      SomethingEditor // PropertyEditor для класса Something
com chank.
Обратите внимание, что здесь вы также можете использовать стандартный механизм JavaBeans `BeanInfo`. (описано в некоторой степени {java-tutorial}/javabeans/advanced/customization.html [здесь]).

В следующем примере используется механизм BeanInfo для явной регистрации одного или нескольких Экземпляры PropertyEditor со свойствами связанного класса:
    pop
      Something
      SomethingBeanInfo // BeanInfo для класса Something
com chank.
Следующий исходный код Java для указанного класса SomethingBeanInfo. связывает CustomNumberEditor со свойством age класса Something:
Java
	public class SomethingBeanInfo extends SimpleBeanInfo {
		public PropertyDescriptor[] getPropertyDescriptors() {
			try {
				final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
				PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
					@Override
					public PropertyEditor createPropertyEditor(Object bean) {
						return numberPE;
				return new PropertyDescriptor[] { ageDescriptor };
			catch (IntrospectionException ex) {
				throw new Error(ex.toString());
	class SomethingBeanInfo : SimpleBeanInfo() {
Пользовательский редактор свойств.
При установке свойств компонента в виде строковых значений контейнер Spring IoC в конечном итоге использует стандартные реализации JavaBeans PropertyEditor для преобразования этих строк в сложный тип собственность.
Spring предварительно регистрирует ряд пользовательских реализаций PropertyEditor (например, для преобразовать имя класса, выраженное в виде строки, в объект «Класс»).
Кроме того, Стандартный механизм поиска JavaBeans `PropertyEditor` позволяет использовать `PropertyEditor`. чтобы класс был назван соответствующим образом и помещен в тот же пакет, что и класс для которого он обеспечивает поддержку, поэтому его можно найти автоматически.
Пользовательский редактор свойств.

Если есть необходимость зарегистрировать другие пользовательские редакторы свойств, можно использовать несколько механизмов. доступен.
Самый ручной подход, который обычно не удобен и не рекомендуется использовать метод `registerCustomEditor()` Интерфейс ConfigurationBeanFactory, если у вас есть ссылка на BeanFactory.
Другой (чуть более удобный) механизм — использовать специальную фабрику бобов. постпроцессор под названием CustomEditorConfigurer.
Хотя вы можете использовать постпроцессоры Bean Factory с реализациями BeanFactory, CustomEditorConfigurer имеет настройкой вложенного свойства, поэтому мы настоятельно рекомендуем использовать ее с `ApplicationContext`, где вы можете развернуть его аналогично любому другому компоненту и где его можно автоматически обнаружить и применить.
Пользовательский редактор свойств.
Обратите внимание, что все фабрики компонентов и контексты приложений автоматически используют ряд встроенные редакторы свойств с помощью BeanWrapper для обрабатывать преобразования свойств.
Стандартные редакторы свойств, которые использует `BeanWrapper`. регистры перечислены в файле предыдущий раздел.
Кроме того, ApplicationContext также переопределяет или добавляет дополнительные редакторы для обработки поиск ресурсов способом, соответствующим конкретному типу контекста приложения.
Пользовательский редактор свойств.
Стандартные экземпляры JavaBeans PropertyEditor используются для преобразования значений свойств. выражается в виде строк фактического сложного типа свойства.
Вы можете использовать CustomEditorConfigurer, постпроцессор фабрики компонентов, позволяющий удобно добавлять поддержка дополнительных экземпляров PropertyEditor для ApplicationContext.
Пользовательский редактор свойств.
Рассмотрим следующий пример, в котором определяется пользовательский класс ExoticType и другой класс под названием DependsOnExoticType, для которого в качестве свойства необходимо установить ExoticType:
Java
	package example;
	public class ExoticType {
		private String name;

public ExoticType(String name) {
			this.name = name;
	public class DependsOnExoticType {
		private ExoticType type;
		public void setType(ExoticType type) {
			this.type = type;
	package example
	class DependsOnExoticType {
Пользовательский редактор свойств.
Когда все настроено правильно, мы хотим иметь возможность назначать свойство типа как строка, которую PropertyEditor преобразует в фактическое значение Экземпляр ExoticType.
Следующее определение компонента показывает, как установить эту связь:
	<bean id="sample" class="example.DependsOnExoticType">
		<property name="type" value="aNameForExoticType"/>
	</bean>
Java
	package example;
	import java.beans.PropertyEditorSupport;
	// преобразует строковое представление в объект ExoticType
	public class ExoticTypeEditor extends PropertyEditorSupport {
		public void setAsText(String text) {
			setValue(new ExoticType(text.toUpperCase()));
	package example
	// преобразует строковое представление в объект ExoticType
	class ExoticTypeEditor : PropertyEditorSupport() {
Реализация PropertyEditor может выглядеть примерно так:.
Наконец, в следующем примере показано, как использовать CustomEditorConfigurer для регистрации нового PropertyEditor с помощью `ApplicationContext`, который затем сможет использовать его по мере необходимости:
	<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="customEditors">
			<map>
				<entry key="example.ExoticType" value="example.ExoticTypeEditor"/>

</map>
		</property>
	</bean>
`Редактор свойствРегистратор`.
Другой механизм регистрации редакторов свойств в контейнере Spring — это создайте и используйте PropertyEditorRegistrar.
Этот интерфейс особенно полезен, когда вам нужно использовать один и тот же набор редакторов свойств в нескольких разных ситуациях.
Вы можете написать соответствующий регистратор и повторно использовать его в каждом случае.
Экземпляры PropertyEditorRegistrar работают совместно с интерфейсом, называемым `PropertyEditorRegistry`, интерфейс, реализованный Spring `BeanWrapper`. (и DataBinder).
Экземпляры PropertyEditorRegistrar особенно удобны. при использовании вместе с CustomEditorConfigurer (описано называется `setPropertyEditorRegistrars(..)`.
Добавлены экземпляры PropertyEditorRegistrar. таким образом в CustomEditorConfigurer можно легко использовать совместно с DataBinder и Контроллеры Spring MVC.
Кроме того, это позволяет избежать необходимости синхронизации на пользовательских редакторы: ожидается, что PropertyEditorRegistrar создаст новый PropertyEditor. экземпляры для каждой попытки создания компонента.
Java
	package com.foo.editors.spring;
	public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {
		public void registerCustomEditors(PropertyEditorRegistry registry) {
			// ожидается, что будут созданы новые экземпляры PropertyEditor.
			registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());
			// здесь можно зарегистрировать столько редакторов пользовательских свойств, сколько потребуется...
	package com.foo.editors.spring
	class CustomPropertyEditorRegistrar : PropertyEditorRegistrar {
			// здесь можно зарегистрировать столько редакторов пользовательских свойств, сколько потребуется...

В следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.
См. также пример `org.springframework.beans.support.ResourceEditorRegistrar`.
Реализация PropertyEditorRegistrar.
Обратите внимание, как в реализации `registerCustomEditors(..)`, он создает новые экземпляры каждого редактора свойств.
В следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.
В следующем примере показано, как настроить CustomEditorConfigurer и внедрить экземпляр. нашего CustomPropertyEditorRegistrar в него:
	<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="propertyEditorRegistrars">
			<list>
				<ref bean="customPropertyEditorRegistrar"/>
			</list>
		</property>
	</bean>
	<bean id="customPropertyEditorRegistrar"
		class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>
В следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.
Наконец (и немного отклоняясь от темы этой главы) для тех из вас, используя веб-инфраструктуру Spring MVC, используя `PropertyEditorRegistrar` в сочетании с веб-контроллерами привязки данных может быть очень удобно.
Следующие В примере используется PropertyEditorRegistrar в реализации метода @InitBinder:
Java
	@Controller
	public class RegisterUserController {
		private final PropertyEditorRegistrar customPropertyEditorRegistrar;
		RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
			this.customPropertyEditorRegistrar = propertyEditorRegistrar;
		@InitBinder
		void initBinder(WebDataBinder binder) {
			this.customPropertyEditorRegistrar.registerCustomEditors(binder);

// другие методы, связанные с регистрацией Пользователя
В следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.
Этот стиль регистрации PropertyEditor может привести к созданию лаконичного кода (реализация метода `@InitBinder` имеет длину всего одну строку) и позволяет использовать общий `PropertyEditor` регистрационный код должен быть инкапсулирован в класс, а затем разделен между как можно большим количеством контроллеров. по мере необходимости.

Буферы данных и кодеки.
Java NIO предоставляет ByteBuffer, но многие библиотеки создают собственный API-интерфейс байтового буфера. особенно для сетевых операций, где повторное использование буферов и/или использование прямых буферов полезно для производительности.
Например, Netty имеет иерархию ByteBuf, Jetty использует объединенные байтовые буферы с обратным вызовом, который необходимо освободить, и так далее.
Модуль Spring-Core предоставляет набор абстракций для работы с различными байтовыми буферами.
API следующим образом:
* `DataBufferFactory` абстрагирует создание буфера данных.
* `DataBuffer` представляет собой байтовый буфер, который может быть
* `DataBufferUtils` предлагает служебные методы для буферов данных.
* <<Кодеки>> декодируют или кодируют потоки буфера данных в объекты более высокого уровня.
DataBufferFactory используется для создания буферов данных одним из двух способов:. .
Выделите новый буфер данных, при необходимости заранее указав емкость, если она известна. более эффективен, даже несмотря на то, что реализации `DataBuffer` могут увеличиваться и уменьшаться по требованию..
Оберните существующий `byte[]` или `java.nio.ByteBuffer`, который украшает данные данными реализация DataBuffer, не требующая выделения.
DataBufferFactory используется для создания буферов данных одним из двух способов:.
Обратите внимание, что приложения WebFlux не создают DataBufferFactory напрямую, а вместо этого создают получить к нему доступ через ServerHttpResponse или ClientHttpRequest на стороне клиента.

Тип фабрики зависит от базового клиента или сервера, например: `NettyDataBufferFactory` для Reactor Netty, `DefaultDataBufferFactory` для других.
`Буфер данных`.
Интерфейс DataBuffer предлагает операции, аналогичные java.nio.ByteBuffer, но также дает несколько дополнительных преимуществ, некоторые из которых основаны на Netty `ByteBuf`.
Ниже приведен неполный список преимуществ:
* Чтение и запись с независимыми позициями, т. е. не требующий вызова `flip()` для
`Буфер данных`. чередовать чтение и запись.
* Емкость расширяется по требованию, как и в случае с `java.lang.StringBuilder`.
* Объединенные буферы и подсчет ссылок через `PooledDataBuffer`.
* Просмотрите буфер как `java.nio.ByteBuffer`, `InputStream` или `OutputStream`.
* Определите индекс или последний индекс для данного байта.
`PooledDataBuffer`.
Как объяснено в Javadoc для {java-api}/java.base/java/nio/ByteBuffer.html[ByteBuffer], байтовые буферы могут быть прямыми или непрямыми.
Прямые буферы могут находиться вне кучи Java. что устраняет необходимость копирования для собственных операций ввода-вывода.
Это делает прямые буферы особенно полезны для получения и отправки данных через сокет, но они также более дорого создавать и выпускать, что приводит к идее объединения буферов.
`PooledDataBuffer`.

PooledDataBuffer — это расширение DataBuffer, которое помогает при подсчете ссылок. необходим для пула байтовых буферов.
Как это работает?
Когда `PooledDataBuffer` выделенный счетчик ссылок равен 1.
Вызовы `retain()` увеличивают счетчик, в то время как вызовы Release() уменьшают его.
Пока счетчик больше 0, буфер гарантированно не выпустят.
Когда счетчик уменьшается до 0, буфер пула может быть освобождается, что на практике может означать, что зарезервированная память для буфера возвращается в пул памяти.
`PooledDataBuffer`.
Обратите внимание: вместо того, чтобы напрямую работать с PooledDataBuffer, в большинстве случаев лучше использовать удобные методы DataBufferUtils, которые применяют выпуск или сохранение к `DataBuffer`, только если он является экземпляром `PooledDataBuffer`.
* Объединение потока буферов данных в единый буфер, возможно, с нулевой копией, например, через
DataBufferUtils предлагает ряд служебных методов для работы с буферами данных:. составные буферы, если это поддерживается базовым API байтового буфера.
* Превратите `InputStream` или NIO `Channel` в `Flux<DataBuffer>`, и наоборот
DataBufferUtils предлагает ряд служебных методов для работы с буферами данных:. `Publisher<DataBuffer>` в `OutputStream` или NIO `Channel`.
* Методы освобождения или сохранения `DataBuffer`, если буфер является экземпляром
DataBufferUtils предлагает ряд служебных методов для работы с буферами данных:. `PooledDataBuffer`.

* Пропустить или взять из потока байтов до достижения определенного количества байтов.
* `Encoder` для кодирования `Publisher<T>` в поток буферов данных.
* `Decoder` для декодирования `Publisher<DataBuffer>` в поток объектов более высокого уровня.
Пакет `org.springframework.core.codec` предоставляет следующие стратегические интерфейсы:.
Модуль Spring-core предоставляет byte[], ByteBuffer, DataBuffer, Resource и Реализации кодировщика и декодера `String`.
Модуль Spring-Web добавляет Jackson JSON, Джексон Смайл, JAXB2, протокольные буферы и другие кодеры и декодеры.
См.
Использование `DataBuffer`.
При работе с буферами данных необходимо уделять особое внимание освобождению буферов. поскольку они могут быть в пуле [в пуле].
Мы будем использовать кодеки для иллюстрации как это работает, но эти концепции применимы в более широком смысле.
Давайте посмотрим, что должны делать кодеки внутренне для управления буферами данных.
Использование `DataBuffer`. `Декодер` последним читает буферы входных данных перед созданием более высокого уровня. объекты, и поэтому он должен освободить их следующим образом:
Использование `DataBuffer`. .
Если «Декодер» просто читает каждый входной буфер и готов выпустите его немедленно, это можно сделать через `DataBufferUtils.release(dataBuffer)`..

Если «Декодер» использует операторы «Flux» или «Mono», такие как «FlatMap», «Reduce» и другие, которые предварительно выбирают и кэшируют элементы данных внутри себя или используют такие операторы, как `filter`, `skip` и другие, которые пропускают элементы, затем `doOnDiscard(DataBuffer.class, DataBufferUtils::release)` необходимо добавить в цепочка композиции, чтобы гарантировать, что такие буферы будут освобождены до их удаления, возможно также в результате ошибки или сигнала отмены..
Если «Декодер» каким-либо другим способом удерживает один или несколько буферов данных, он должен убедитесь, что они освобождаются при полном чтении или в случае ошибки или сигналов отмены, которые происходят до того, как кэшированные буферы данных будут прочитаны и освобождены.
Использование `DataBuffer`.
Обратите внимание, что DataBufferUtils#join предлагает безопасный и эффективный способ агрегирования данных. буферный поток в один буфер данных.
Аналогично `skipUntilByteCount` и TakeUntilByteCount — это дополнительные безопасные методы, которые могут использовать декодеры.
Использование `DataBuffer`. `Кодировщик` выделяет буферы данных, которые другие должны прочитать (и освободить).
Итак, «Кодер» особо нечего делать.
Однако `Кодер` должен позаботиться об освобождении буфера данных, если возникает ошибка сериализации при заполнении буфера данными.
Например:
Java
	DataBuffer buffer = factory.allocateBuffer();
	boolean release = true;
	try {

// сериализовать и заполнить буфер..
		release = false;
	finally {
		if (release) {
			DataBufferUtils.release(buffer);
	return buffer;
Использование `DataBuffer`.
Потребитель «Кодировщика» отвечает за освобождение получаемых им буферов данных.
В приложении WebFlux выходные данные «Кодировщика» используются для записи на HTTP-сервер. ответ или HTTP-запрос клиента, и в этом случае освобождение буферов данных является ответственность за запись кода в ответ сервера или в запрос клиента.
Использование `DataBuffer`.
Обратите внимание, что при работе в Netty имеются параметры отладки для https://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks [устранение проблем с утечками буфера].

Декларативное управление транзакциями.
ПРИМЕЧАНИЕ.
Большинство пользователей Spring Framework выбирают декларативное управление транзакциями.
Этот вариант имеет наименьшее влияние на код приложения и, следовательно, наиболее соответствует идеалам неинвазивный легкий контейнер.
Декларативное управление транзакциями Spring Framework стало возможным благодаря Spring. аспектно-ориентированное программирование (АОП).
Однако, поскольку код транзакционных аспектов с дистрибутивом Spring Framework и может использоваться в шаблонном режиме, AOP Обычно не обязательно понимать концепции, чтобы эффективно использовать этот код.
Декларативное управление транзакциями Spring Framework похоже на EJB CMT в том смысле, что вы можете указать поведение транзакции (или его отсутствие) вплоть до уровня отдельного метода.
Вы можете выполнить вызов setRollbackOnly() в контексте транзакции, если необходимо.
Различия между двумя типами управления транзакциями заключаются в следующем:
* В отличие от EJB CMT, который привязан к JTA, декларативная транзакция Spring Framework
Декларативное управление транзакциями. управление работает в любой среде.
Он может работать с транзакциями JTA или локальными транзакции с использованием JDBC, JPA или Hibernate путем настройки конфигурации файлы.
* Вы можете применить декларативное управление транзакциями Spring Framework к любому классу.
Декларативное управление транзакциями. а не просто специальные классы, такие как EJB.
* Spring Framework предлагает декларативный
Декларативное управление транзакциями. эквивалент.
Предоставляется как программная, так и декларативная поддержка правил отката.
* Spring Framework позволяет настраивать поведение транзакций с помощью АОП.
Декларативное управление транзакциями.

Например, вы можете вставить собственное поведение в случае отката транзакции. ты может также добавить произвольный совет наряду с советом по транзакциям.
С EJB CMT вы не может влиять на управление транзакциями контейнера, за исключением случаев, когда `setRollbackOnly()`.
* Spring Framework не поддерживает распространение контекстов транзакций между
Декларативное управление транзакциями. удаленные вызовы, как это делают высокопроизводительные серверы приложений.
Если вам нужна эта функция, мы рекомендую вам использовать EJB.
Однако прежде чем использовать такую функцию, подумайте внимательно: потому что обычно никто не хочет, чтобы транзакции охватывали удаленные вызовы.
Декларативное управление транзакциями.
Концепция правил отката важна.
Они позволяют указать, какие исключения (и метательные объекты) должны вызывать автоматический откат.
Вы можете указать это декларативно, в конфигурации, а не в коде Java.
Итак, хотя вы все равно можете вызвать setRollbackOnly() объект TransactionStatus для отката текущей транзакции, чаще всего вы можно указать правило, согласно которому MyApplicationException всегда должно приводить к откату. существенным преимуществом этого варианта является то, что бизнес-объекты не зависят от Транзакционная инфраструктура.
Например, им обычно не нужно импортировать Spring.
API транзакций или другие API Spring.
Декларативное управление транзакциями.

Хотя поведение EJB-контейнера по умолчанию автоматически откатывает транзакцию на системное исключение (обычно исключение времени выполнения), EJB CMT не откатывает транзакция автоматически при исключении приложения (т. е. проверенном исключении кроме `java.rmi.RemoteException`).
Хотя поведение Spring по умолчанию для декларативное управление транзакциями соответствует соглашению EJB (откат происходит автоматически только для непроверенных исключений), часто бывает полезно настроить это поведение.

Сервлет по умолчанию.
Spring MVC позволяет сопоставлять `DispatcherServlet` с `/` (таким образом переопределяя сопоставление сервлета контейнера по умолчанию), при этом позволяя выполнять запросы статических ресурсов. обрабатывается сервлетом контейнера по умолчанию.
Он настраивает `DefaultServletHttpRequestHandler` с сопоставлением URL-адресов `/**` и самым низким приоритетом. относительно других сопоставлений URL-адресов.
Сервлет по умолчанию.
Этот обработчик пересылает все запросы сервлету по умолчанию.
Следовательно, оно должно остаются последними в порядке всех остальных URL-адресов HandlerMappings.
Это случае, если вы используете `<mvc:annotation-driven>`.
Альтернативно, если вы настроите собственный настроенный экземпляр HandlerMapping, обязательно установите для его свойства order значение ниже, чем у DefaultServletHttpRequestHandler, который равен Integer.MAX_VALUE.
Сервлет по умолчанию.
В следующем примере показано, как включить эту функцию, используя настройки по умолчанию: См. пример кода в исходном документе.
Сервлет по умолчанию.
Предостережение относительно переопределения сопоставления сервлетов `/` заключается в том, что `RequestDispatcher` для Сервлет по умолчанию должен быть получен по имени, а не по пути. `DefaultServletHttpRequestHandler` пытается автоматически определить сервлет по умолчанию для контейнер во время запуска, используя список известных имен для большинства основных сервлетов контейнеры (включая Tomcat, Jetty, GlassFish, JBoss, WebLogic и WebSphere).

Если сервлет по умолчанию был настроен под другим именем или если используется другой контейнер сервлетов, где имя сервлета по умолчанию неизвестно, тогда вы должны явно указать имя сервлета по умолчанию, как показано в следующем примере: См. пример кода в исходном документе.

Обзор компонента.
Контейнер Spring IoC управляет одним или несколькими компонентами.
Эти бобы созданы с помощью метаданные конфигурации, которые вы предоставляете в контейнер (например, в форме XML определения `<bean/>`).
Обзор компонента.
Внутри самого контейнера эти определения bean-компонентов представлены как BeanDefinition. объекты, которые содержат (помимо прочей информации) следующие метаданные:
* Имя класса с указанием пакета: обычно это фактический класс реализации
Обзор компонента. bean-компонент определяется.
* Элементы конфигурации поведения компонента, которые определяют, как компонент должен вести себя в
Обзор компонента. контейнер (область действия, обратные вызовы жизненного цикла и т. д.).
* Ссылки на другие bean-компоненты, необходимые для выполнения bean-компонентом своей работы. Эти
Обзор компонента. ссылки также называются соавторами или зависимостями.
* Другие параметры конфигурации, которые необходимо установить во вновь созданном объекте — например, размер
Обзор компонента. ограничение пула или количества соединений, используемых в компоненте, который управляет пул соединений.
Обзор компонента.
Эти метаданные преобразуются в набор свойств, которые составляют определение каждого компонента.
В следующей таблице описаны эти свойства:
Обзор компонента. .Определение компонента |=== | Недвижимость| Объяснено в...
| Метод уничтожения | Обратные вызовы разрушения |===.

Помимо определений компонентов, содержащих информацию о том, как создать конкретный bean, реализации `ApplicationContext` также позволяют регистрировать существующие объекты, созданные вне контейнера (пользователями).
Это делается путем доступа к `BeanFactory` ApplicationContext через метод `getAutowireCapableBeanFactory()`, который возвращает реализацию DefaultListableBeanFactory. `DefaultListableBeanFactory` поддерживает эту регистрацию через `registerSingleton(..)` и `registerBeanDefinition(..)` методы.
Однако типичные приложения работают исключительно с компонентами, определенными посредством обычных Метаданные определения компонента.
| Метод уничтожения | Обратные вызовы разрушения |===. [ПРИМЕЧАНИЕ] = Метаданные компонента и экземпляры Singleton, предоставленные вручную, необходимо зарегистрировать как можно раньше. насколько это возможно, чтобы контейнер правильно рассуждал о них во время автопроводки и другие шаги самоанализа.
При переопределении существующих метаданных и существующих в некоторой степени поддерживаются экземпляры Singleton, регистрация новых bean-компонентов в среда выполнения (одновременно с живым доступом к фабрике) официально не поддерживается и может привести к исключениям одновременного доступа, несогласованному состоянию в контейнере компонентов или к тому и другому.
Переопределение компонентов.
Переопределение компонента происходит, когда компонент регистрируется с использованием идентификатора, который уже выделено.
Хотя переопределение bean-компонента возможно, оно затрудняет чтение конфигурации.
Переопределение компонентов.
ВНИМАНИЕ: переопределение bean-компонентов будет прекращено в будущем выпуске.
Переопределение компонентов.

Чтобы полностью отключить переопределение bean-компонента, вы можете установить `allowBeanDefinitionOverriding` установите флаг false в ApplicationContext перед его обновлением.
В такой установке Исключение выдается, если используется переопределение компонента.
Переопределение компонентов.
По умолчанию контейнер регистрирует каждую попытку переопределить компонент на уровне INFO, чтобы вы можете соответствующим образом адаптировать свою конфигурацию.
Хотя это и не рекомендуется, вы можете отключить эти журналы, установив для флагаallowBeanDefinitionOverriding значение true.
Переопределение компонентов. .Конфигурация Java **** Если вы используете конфигурацию Java, соответствующий метод @Bean всегда автоматически переопределяет отсканированный класс bean-компонента с тем же именем компонента, что и возвращаемый тип Метод `@Bean` соответствует этому классу компонента.
Это просто означает, что контейнер вызовет фабричный метод `@Bean` в пользу любого предварительно объявленного конструктора в классе компонента. ****
Переопределение компонентов.
ПРИМЕЧАНИЕ.
Мы признаем, что переопределение bean-компонентов в тестовых сценариях удобно, и существует явная поддержка этого.
Пожалуйста, обратитесь к
Именование компонентов.
Каждый компонент имеет один или несколько идентификаторов.
Эти идентификаторы должны быть уникальными в пределах контейнер, в котором размещается компонент.
Компонент обычно имеет только один идентификатор.
Однако, если это требуется более одного, лишние можно считать псевдонимами.
Именование компонентов.
В метаданных конфигурации на основе XML вы используете атрибут `id`, атрибут `name` или оба для указания идентификаторов bean-компонентов.

Атрибут `id` позволяет указать ровно один `id`.
Обычно эти имена буквенно-цифровые («myBean», «someService» и т. д.), но они также может содержать специальные символы.
Если вы хотите ввести другие псевдонимы для bean, вы также можете указать их в атрибуте `name`, разделив их запятой (`,`), точка с запятой (`;`) или пробел.
Хотя атрибут `id` определен как Тип `xsd:string`, уникальность bean `id` обеспечивается контейнером, но не XML парсеры.
Именование компонентов.
Вам не требуется указывать имя или идентификатор компонента.
Если вы не предоставите `name` или `id` явно, контейнер генерирует уникальное имя для этого компонента.
Однако, если вы хотите обратиться к этому компоненту по имени, используя элемент `ref` или Для поиска в стиле Service Locator необходимо указать имя.
Мотивы не предоставления имени связаны с использованием inner beans и соавторы автопроводки.
Именование компонентов. .Соглашения об именах компонентов **** Соглашение заключается в использовании стандартного соглашения Java для имен полей экземпляров, когда называние фасоли.
То есть имена компонентов начинаются со строчной буквы и имеют верблюжий регистр. оттуда.
Примеры таких имен включают `accountManager`, `accountService`, `userDao`, `loginController` и т. д.
Именование компонентов.

Последовательное именование bean-компонентов упрощает чтение и понимание вашей конфигурации.
Кроме того, если вы используете Spring AOP, это очень помогает при применении советов к набору компонентов. связанные по имени. ****
Именование компонентов.
ПРИМЕЧАНИЕ.
При сканировании компонентов в пути к классам Spring генерирует имена компонентов для безымянных компонентов. компоненты, следуя правилам, описанным ранее: по сути, взяв простое имя класса и переводим его первоначальный символ в нижний регистр.
Однако в (необычном) специальном случай, когда имеется более одного символа и первый, и второй символы написаны в верхнем регистре, исходный регистр сохраняется.
Это те же правила, что и определяется `java.beans.Introspector.decapitalize` (который здесь использует Spring).
Использование псевдонима для компонента вне определения компонента.
В самом определении компонента вы можете указать более одного имени компонента, используя комбинация до одного имени, указанного атрибутом `id`, и любого количества других имена в атрибуте `name`.
Эти имена могут быть эквивалентными псевдонимами одного и того же компонента. и полезны в некоторых ситуациях, например, когда каждый компонент приложения ссылайтесь на общую зависимость, используя имя компонента, специфичное для этого компонента. сам.
Использование псевдонима для компонента вне определения компонента.
Указание всех псевдонимов, в которых фактически определен компонент, не всегда адекватно. однако.
Иногда желательно ввести псевдоним для компонента, который определен в другом месте.

Обычно это происходит в больших системах, где конфигурация разделена. среди каждой подсистемы, причем каждая подсистема имеет свой собственный набор определений объектов.
В метаданных конфигурации на основе XML вы можете использовать элемент `<alias/>` для выполнения это.
В следующем примере показано, как это сделать:
	<alias name="fromName" alias="toName"/>
Использование псевдонима для компонента вне определения компонента.
В этом случае bean-компонент (в том же контейнере) с именем fromName также может: после использования этого определения псевдонима будет называться «toName».
Использование псевдонима для компонента вне определения компонента.
Например, метаданные конфигурации для подсистемы A могут ссылаться на источник данных по имя `subsystemA-dataSource`.
Метаданные конфигурации для подсистемы B могут относиться к источник данных по имени subsystemB-dataSource.
При составлении основного приложения использующее обе эти подсистемы, основное приложение обращается к источнику данных по имя `myApp-dataSource`.
Чтобы все три имени относились к одному и тому же объекту, вы можете добавьте следующие определения псевдонимов в метаданные конфигурации:
	<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
	<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
Использование псевдонима для компонента вне определения компонента.

Теперь каждый компонент и основное приложение могут ссылаться на источник данных по имени. которое является уникальным и гарантированно не противоречит никакому другому определению (фактически создание пространства имен), но они ссылаются на один и тот же компонент.
Использование псевдонима для компонента вне определения компонента. .Java-конфигурация **** Если вы используете конфигурацию Java, аннотацию @Bean можно использовать для предоставления псевдонимов.
Дополнительную информацию см. в Использование аннотации `@Bean`. ****
Создание экземпляров Beans.
Определение компонента — это, по сути, рецепт создания одного или нескольких объектов. контейнер просматривает рецепт именованного компонента, когда его об этом спрашивают, и использует конфигурацию метаданные, инкапсулированные определением этого компонента, для создания (или получения) реального объекта.
Создание экземпляров Beans.
Если вы используете метаданные конфигурации на основе XML, вы указываете тип (или класс) объекта. который должен быть создан в атрибуте `class` элемента `<bean/>`.
Это Атрибут `class` (который внутренне является свойством `Class` в `BeanDefinition` экземпляр) обычно является обязательным. (Исключения см. и Наследование определения компонента.) Вы можете использовать свойство Class одним из двух способов:
* Обычно для указания класса компонента, который будет создан в случае, когда контейнер
Создание экземпляров Beans. сам непосредственно создает компонент, рефлексивно вызывая его конструктор, что-то вроде эквивалентно коду Java с оператором new.

* Чтобы указать фактический класс, содержащий статический фабричный метод, который
Создание экземпляров Beans. вызывается для создания объекта, в менее распространенном случае, когда контейнер вызывает `статический` фабричный метод класса для создания компонента.
Возвращенный тип объекта при вызове `статического` фабричного метода может быть тот же или другой класс класс целиком.
Создание экземпляров Beans. .Имена вложенных классов **** Если вы хотите настроить определение компонента для вложенного класса, вы можете использовать либо метод двоичное имя или исходное имя вложенного класса.
Создание экземпляров Beans.
Например, если у вас есть класс SomeThing в пакете com.example и этот класс `SomeThing` имеет `статический` вложенный класс под названием `OtherThing`, они могут быть разделяются знаком доллара (`$`) или точкой (`.`).
Таким образом, значение атрибута class в определением компонента будет `com.example.SomeThing$OtherThing` или `com.example.SomeThing.OtherThing`. ****
Создание экземпляра с помощью конструктора.
Когда вы создаете компонент с помощью конструктора, все обычные классы могут использоваться и совместим с Spring.
То есть разрабатываемый класс не нуждается в реализации любые конкретные интерфейсы или быть закодированы определенным образом.
Просто указание bean-компонента класса должно хватить.
Однако в зависимости от того, какой тип IoC вы используете для этого конкретного bean, вам может понадобиться конструктор по умолчанию (пустой).

Создание экземпляра с помощью конструктора.
Контейнер Spring IoC может управлять практически любым классом, которым вы хотите управлять.
Это не ограничивается управлением настоящими JavaBeans.
Большинство пользователей Spring предпочитают настоящие JavaBeans с моделируются только конструктор по умолчанию (без аргументов) и соответствующие сеттеры и геттеры после свойств в контейнере.
Вы также можете попробовать более экзотические блюда в стиле без бобов. классы в вашем контейнере.
Если, например, вам нужно использовать устаревший пул соединений который абсолютно не соответствует спецификации JavaBean, Spring может управлять им как ну.
Создание экземпляра с помощью конструктора.
С помощью метаданных конфигурации на основе XML вы можете указать свой класс bean-компонента следующим образом:
	<bean id="exampleBean" class="examples.ExampleBean"/>
	<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
Создание экземпляра с помощью конструктора.
Подробно о механизме передачи аргументов конструктору (если требуется) и установка свойств экземпляра объекта после его создания, см.
Создание экземпляра с помощью конструктора.
ПРИМЕЧАНИЕ.
В случае аргументов конструктора контейнер может выбрать соответствующий конструктор среди нескольких перегруженных конструкторов.
При этом, чтобы избежать двусмысленностей, рекомендуется сделать подписи конструктора максимально простыми.
Создание экземпляра с помощью статического фабричного метода.

При определении bean-компонента, который вы создаете с помощью статического фабричного метода, используйте класс атрибут, чтобы указать класс, который содержит `статический` фабричный метод и атрибут с именем `factory-method`, чтобы указать имя самого фабричного метода.
Вы должны быть возможность вызвать этот метод (с необязательными аргументами, как описано ниже) и вернуть живой объект, который впоследствии обрабатывается так, как если бы он был создан с помощью конструктора.
Одно из применений такого определения компонента — вызов «статических» фабрик в устаревшем коде.
Создание экземпляра с помощью статического фабричного метода.
Следующее определение компонента указывает, что компонент будет создан путем вызова заводской метод.
В определении не указан тип (класс) возвращаемого объекта, а скорее класс, содержащий фабричный метод.
В этом примере Метод createInstance() должен быть статическим.
В следующем примере показано, как укажите фабричный метод:
	<bean id="clientService"
		class="examples.ClientService"
		factory-method="createInstance"/>
Создание экземпляра с помощью статического фабричного метода.
В следующем примере показан класс, который будет работать с предыдущим определением компонента:
Java
	public class ClientService {
		private static ClientService clientService = new ClientService();
		private ClientService() {}
		public static ClientService createInstance() {
			return clientService;
Создание экземпляра с помощью статического фабричного метода.

Подробности о механизме предоставления (необязательных) аргументов фабричному методу. и установка свойств экземпляра объекта после того, как объект возвращается с фабрики, см. подробные сведения о зависимостях и конфигурации.
Создание экземпляра с помощью статического фабричного метода.
ПРИМЕЧАНИЕ.
В случае аргументов фабричного метода контейнер может выбрать соответствующий метод среди нескольких перегруженных методов с тем же именем.
При этом, чтобы избежать двусмысленностей, рекомендуется сделать сигнатуры фабричных методов максимально простыми.
Создание экземпляра с помощью статического фабричного метода. [СОВЕТ] = Типичным проблемным случаем с перегрузкой фабричных методов является Mockito с его многочисленными перегрузки метода `mock`.
Выберите наиболее конкретный вариант «макета»:
	<bean id="clientService" class="org.mockito.Mockito" factory-method="mock">
		<constructor-arg type="java.lang.Class" value="examples.ClientService"/>
		<constructor-arg type="java.lang.String" value="clientService"/>
	</bean>
Создание экземпляра с использованием метода фабрики экземпляра.
Аналогично созданию экземпляра через метод [статический фабричный метод] создание экземпляра с помощью фабричного метода экземпляра вызывает нестатический метод существующего компонента из контейнера для создания нового компонента.

Чтобы использовать это механизм, оставьте атрибут class пустым, а в атрибуте Factory-Bean укажите укажите имя bean-компонента в текущем (или родительском, или предковом) контейнере, который содержит метод экземпляра, который должен быть вызван для создания объекта.
Установите имя сам фабричный метод с атрибутом Factory-method.
Следующий пример показывает как настроить такой bean:
	<!-- the factory bean, which contains a method called createClientServiceInstance() -->
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>
	<!-- the bean to be created via the factory bean -->
	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>
Java
	public class DefaultServiceLocator {
		private static ClientService clientService = new ClientServiceImpl();
		public ClientService createClientServiceInstance() {
			return clientService;
В следующем примере показан соответствующий класс:.
Один фабричный класс также может содержать более одного фабричного метода, как показано в следующем примере:
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>
	<bean id="clientService"
		factory-bean="serviceLocator"

factory-method="createClientServiceInstance"/>
	<bean id="accountService"
		factory-bean="serviceLocator"
		factory-method="createAccountServiceInstance"/>
Java
	public class DefaultServiceLocator {
		private static ClientService clientService = new ClientServiceImpl();
		private static AccountService accountService = new AccountServiceImpl();
		public ClientService createClientServiceInstance() {
			return clientService;
		public AccountService createAccountServiceInstance() {
			return accountService;
В следующем примере показан соответствующий класс:.
Этот подход показывает, что самим фабричным компонентом можно управлять и настраивать его с помощью внедрение зависимостей (DI).
См.
Подробные сведения о зависимостях и конфигурации.
В следующем примере показан соответствующий класс:.
ПРИМЕЧАНИЕ.
В документации Spring «фабричный компонент» относится к компоненту, настроенному в Spring-контейнер, который создает объекты через `FactoryBean` (обратите внимание на заглавные буквы) относится к специфичному для Spring
Определение типа выполнения компонента.
Тип времени выполнения конкретного bean-компонента определить непросто.
Указанный класс в определение метаданных компонента — это просто начальная ссылка на класс, потенциально объединенная с объявленным фабричным методом или являющимся классом FactoryBean, что может привести к другой тип времени выполнения bean-компонента или вообще не установлен в случае уровня экземпляра фабричный метод (который вместо этого разрешается через указанное имя Factory-Bean).

Кроме того, прокси-сервер AOP может обернуть экземпляр компонента прокси-сервером на основе интерфейса с ограниченное раскрытие фактического типа целевого компонента (только его реализованные интерфейсы).
Определение типа выполнения компонента.
Рекомендуемый способ узнать о фактическом типе среды выполнения конкретного компонента: вызов BeanFactory.getType для указанного имени компонента.
Это требует всего вышеперечисленного учитывает все случаи и возвращает тип объекта, который вызывает вызов `BeanFactory.getBean`. собираюсь вернуться за тем же именем компонента.

Зависимости.
Типичное корпоративное приложение не состоит из одного объекта (или компонента в Весенний разговор).
Даже самое простое приложение имеет несколько объектов, которые работают вместе для представить то, что конечный пользователь видит как целостное приложение.
В следующем разделе объясняется, как вы переходите от определения ряда самостоятельных определений компонентов к полностью реализованному приложение, в котором объекты взаимодействуют для достижения цели.

Настройка различной транзакционной семантики для разных компонентов.
Рассмотрим сценарий, в котором у вас есть несколько объектов уровня обслуживания, и вы хотите применить совершенно другую конфигурацию транзакций к каждому из них.
Вы можете сделать это путем определения отдельных элементов `<aop:advisor/>` с разными `pointcut` и Значения атрибута advice-ref.
Настройка различной транзакционной семантики для разных компонентов.
Для сравнения сначала предположим, что все ваши классы уровня обслуживания определено в корневом пакете `x.y.service`.
Чтобы сделать все bean-компоненты, являющиеся экземплярами классов определенные в этом пакете (или в подпакетах) и имеющие имена, заканчивающиеся на `Service`, имеют конфигурации транзакций по умолчанию, вы можете написать следующее:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans

https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<aop:config>
			<aop:pointcut id="serviceOperation"
					expression="execution(* x.y.service..*Service.*(..))"/>
			<aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>
		</aop:config>
		<!-- these two beans will be transactional... -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>
		<bean id="barService" class="x.y.service.extras.SimpleBarService"/>
		<!-- ... and these two beans won't -->
		<bean id="anotherService" class="org.xyz.SomeService"/> <!-- (not in the right package) -->

<bean id="barManager" class="x.y.service.SimpleBarManager"/> <!-- (doesn't end in 'Service') -->
		<tx:advice id="txAdvice">
			<tx:attributes>
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>
		<!-- other transaction infrastructure beans such as a TransactionManager omitted... -->
	</beans>
Настройка различной транзакционной семантики для разных компонентов.
В следующем примере показано, как настроить два разных компонента с совершенно разными настройки транзакции:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans

https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<aop:config>
			<aop:pointcut id="defaultServiceOperation"
					expression="execution(* x.y.service.*Service.*(..))"/>
			<aop:pointcut id="noTxServiceOperation"
					expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>
			<aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>
			<aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>
		</aop:config>
		<!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>

<!-- this bean will also be transactional, but with totally different transactional settings -->
		<bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>
		<tx:advice id="defaultTxAdvice">
			<tx:attributes>
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>
		<tx:advice id="noTxAdvice">
			<tx:attributes>
				<tx:method name="*" propagation="NEVER"/>
			</tx:attributes>
		</tx:advice>
		<!-- other transaction infrastructure beans such as a TransactionManager omitted... -->
	</beans>

`ДиспетчерХандлер`.
Spring WebFlux, как и Spring MVC, разработан на основе шаблона фронт-контроллера. где центральный WebHandler, DispatcherHandler, предоставляет общий алгоритм для обработка запросов, в то время как фактическая работа выполняется настраиваемыми компонентами делегирования.
Эта модель является гибкой и поддерживает разнообразные рабочие процессы.
`ДиспетчерХандлер`.
DispatcherHandler обнаруживает необходимые ему компоненты делегата из конфигурации Spring.
Он также спроектирован как bean-компонент Spring и реализует ApplicationContextAware. для доступа к контексту, в котором он работает.
Если DispatcherHandler объявлен с помощью bean-компонента имя `webHandler`, оно, в свою очередь, обнаруживается {spring-framework-api}/web/server/adapter/WebHttpHandlerBuilder.html[`WebHttpHandlerBuilder`], который объединяет цепочку обработки запросов, как описано в
* `DispatcherHandler` с именем bean-компонента `webHandler`
* Компоненты `WebFilter` и `WebExceptionHandler`
* специальные компоненты `DispatcherHandler`
* Другие
Конфигурация Spring в приложении WebFlux обычно содержит:.
Конфигурация передается WebHttpHandlerBuilder для построения цепочки обработки. как показано в следующем примере:
Java
	ApplicationContext context = ...
	HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();
Специальные типы бобов.
DispatcherHandler делегирует специальные bean-компоненты для обработки запросов и рендеринга. соответствующие ответы.
Под «специальными компонентами» мы подразумеваем управляемые Spring экземпляры Object, которые реализовать контракты платформы WebFlux.

Обычно они имеют встроенные контракты, но вы можете настроить их свойства, расширить или заменить их.
Специальные типы бобов.
В следующей таблице перечислены специальные bean-компоненты, обнаруженные DispatcherHandler.
Обратите внимание, что есть также некоторые другие компоненты, обнаруженные на более низком уровне (см. в API веб-обработчика).
[cols="1,2", options="header"] |=== | Тип фасоли | Объяснение. | `HandlerMapping` | Сопоставьте запрос с обработчиком.
Сопоставление основано на некоторых критериях, деталях которые различаются в зависимости от реализации HandlerMapping — аннотированные контроллеры, простые Сопоставления шаблонов URL-адресов и другие.
[cols="1,2", options="header"] |=== | Тип фасоли | Объяснение.
Основными реализациями HandlerMapping являются RequestMappingHandlerMapping для Аннотированные методы @RequestMapping, RouterFunctionMapping для функциональной конечной точки. маршруты и SimpleUrlHandlerMapping для явной регистрации шаблонов путей URI. и экземпляры WebHandler.
[cols="1,2", options="header"] |=== | Тип фасоли | Объяснение. | `Адаптер Обработчика` | Помогите DispatcherHandler вызвать обработчик, сопоставленный с запросом, независимо от как на самом деле вызывается обработчик.
Например, вызов аннотированного контроллера требует разрешения аннотаций.
Основная цель HandlerAdapter — защитить `DispatcherHandler` из таких подробностей.

[cols="1,2", options="header"] |=== | Тип фасоли | Объяснение. | `HandlerResultHandler` | Обработайте результат вызова обработчика и завершите ответ.
См. ссылку:web/webflux/dispatcher-handler.adoc#webflux-resulthandling [Обработка результатов].
Конфигурация WebFlux.
Приложения могут объявлять инфраструктурные компоненты (перечисленные в разделе которые необходимы для обработки запросов.
Однако в большинстве случаев это лучшая отправная точка.
Он объявляет необходимые bean-компоненты и обеспечивает более высокий уровень API обратного вызова конфигурации для его настройки.
Конфигурация WebFlux.
ПРИМЕЧАНИЕ.
Spring Boot использует конфигурацию WebFlux для настройки Spring WebFlux, а также предоставляет множество дополнительных удобных опций.
* Каждому `HandlerMapping` предлагается найти соответствующий обработчик, и используется первое совпадение.
* Если обработчик найден, он запускается через соответствующий `HandlerAdapter`, который
DispatcherHandler обрабатывает запросы следующим образом:. предоставляет возвращаемое значение выполнения как HandlerResult.
* HandlerResult передается соответствующему HandlerResultHandler для завершения
DispatcherHandler обрабатывает запросы следующим образом:. обработка путем прямой записи ответа или использования представления для рендеринга.
Обработка результатов.
Возвращаемое значение вызова обработчика через HandlerAdapter упаковывается как HandlerResult вместе с некоторым дополнительным контекстом и передается первому `HandlerResultHandler`, который заявляет о его поддержке.
В следующей таблице показаны доступные Реализации HandlerResultHandler, все из которых объявлены в

Обработка результатов. [cols="1,2,1", options="header"] |=== | Тип обработчика результатов | Возвращаемые значения | Порядок по умолчанию
Обработка результатов. | `ResponseEntityResultHandler` | `ResponseEntity`, обычно из экземпляров `@Controller`.
Обработка результатов. | `ServerResponseResultHandler` | `ServerResponse`, обычно от функциональных конечных точек.
Обработка результатов. | `ResponseBodyResultHandler` | Обрабатывать возвращаемые значения из методов @ResponseBody или классов @RestController. | 100
Обработка результатов. | `ViewResolutionResultHandler` | `CharSequence`, {spring-framework-api}/web/reactive/result/view/View.html[`View`], {spring-framework-api}/ui/Model.html[Модель], `Карта`, {spring-framework-api}/web/reactive/result/view/Rendering.html[Визуализация], или любой другой «Объект» рассматривается как атрибут модели.
Обработка результатов.
См. также ссылку:web/webflux/dispatcher-handler.adoc#webflux-viewsolve [Разрешение просмотра]. | `Целое.MAX_VALUE`
Исключения.
Реализации HandlerAdapter могут обрабатывать внутренние исключения при вызове запроса. обработчик, например метод контроллера.
Однако исключение может быть отложено, если запрос обработчик возвращает асинхронное значение.
Исключения.

HandlerAdapter может предоставлять свой механизм обработки исключений как `DispatchExceptionHandler` устанавливается на `HandlerResult`, который он возвращает.
Когда это будет установлено, DispatcherHandler также применит его к обработке результата.
Исключения.
HandlerAdapter также может реализовать DispatchExceptionHandler.
В этом случае DispatcherHandler применит его к исключениям, возникающим до отображения обработчика. например, во время сопоставления обработчика или ранее, например, в `WebFilter`.
Исключения.
См. также ссылку:web/webflux/controller/ann-Exceptions.adoc[Exceptions] в разделе «Аннотированный контроллер» или
Посмотреть разрешение.
Разрешение просмотра позволяет выполнять рендеринг в браузере с помощью HTML-шаблона и модели без привязывая вас к определенной технологии просмотра.
В Spring WebFlux разрешение просмотра равно поддерживается через специальную ссылку:web/webflux/dispatcher-handler.adoc#webflux-resulthandling[HandlerResultHandler] который использует экземпляры ViewResolver для сопоставления строки (представляющей имя логического представления) с экземпляр `View`.
Затем View используется для отображения ответа.
Посмотреть разрешение.
Веб-приложениям необходимо использовать библиотеку рендеринга просмотра для поддержки этого варианта использования.
Обращение.
HandlerResult, переданный в ViewResolutionResultHandler, содержит возвращаемое значение. из обработчика и модели, содержащей атрибуты, добавленные во время запроса обработка.
Возвращаемое значение обрабатывается как одно из следующих:
* `String`, `CharSequence`: логическое имя представления, которое должно быть преобразовано в `View` через
Обращение. список настроенных реализаций ViewResolver.

* `void`: выберите имя представления по умолчанию на основе пути запроса за вычетом начального и
Обращение. завершающую косую черту и преобразуйте ее в «View».
То же самое происходит, когда имя представления не было предоставлено (например, был возвращен атрибут модели) или было возвращено асинхронное значение. (например, «Моно» заполнено пустым).
* {spring-framework-api}/web/reactive/result/view/Rendering.html[Рендеринг]: API для
Обращение. просмотреть сценарии разрешения.
Изучите возможности вашей IDE с автодополнением кода.
* «Модель», «Карта»: дополнительные атрибуты модели, которые будут добавлены в модель по запросу.
* Любое другое: любое другое возвращаемое значение (кроме простых типов, как определено
Обращение. {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]) рассматривается как атрибут модели, добавляемый в модель.
Имя атрибута является производным из имени класса, используя {spring-framework-api}/core/Conventions.html[conventions], если не присутствует аннотация метода-обработчика `@ModelAttribute`.
Обращение.
Модель может содержать асинхронные реактивные типы (например, из Reactor или RxJava).
Приор для рендеринга AbstractView преобразует такие атрибуты модели в конкретные значения. и обновляет модель.

Реактивные типы с одним значением разрешаются в одно значение. значение или отсутствие значения (если пусто), а реактивные типы с несколькими значениями (например, `Flux<T>`) собрано и разрешено в `List<T>`.
Обращение.
Настроить разрешение представления так же просто, как добавить bean-компонент ViewResolutionResultHandler. в вашу конфигурацию Spring.
WebFlux Config предоставляет специальный API конфигурации для разрешения просмотра.
Обращение.
См.
View Technologies для получения дополнительной информации о технологиях просмотра, интегрированных с Spring WebFlux.
Перенаправление.
Специальный префикс `redirect:` в имени представления позволяет выполнить перенаправление. `UrlBasedViewResolver` (и его подклассы) распознают это как инструкцию, которую нужен редирект.
Остальная часть имени представления — это URL-адрес перенаправления.
Перенаправление.
Конечный эффект такой же, как если бы контроллер вернул RedirectView или `Rendering.redirectTo("abc").build()`, но теперь сам контроллер может работают в терминах логических имен представлений.
Имя представления, например `redirect:/some/resource` относится к текущему приложению, а имя представления, например `redirect:https://example.com/arvary/path` перенаправляет на абсолютный URL-адрес.
Перенаправление.
ПРИМЕЧАНИЕ: в отличие от стека сервлетов, Spring WebFlux не поддерживает отправку «FORWARD», поэтому префиксы «forward:» в результате не поддерживаются.
Согласование содержания.

ViewResolutionResultHandler поддерживает согласование содержимого.
Он сравнивает запрос типы мультимедиа с типами мультимедиа, поддерживаемыми каждым выбранным «Просмотром».
Первый `Вид` который поддерживает запрошенные типы носителя.
Согласование содержания.
Для поддержки таких типов мультимедиа, как JSON и XML, Spring WebFlux предоставляет `HttpMessageWriterView`, который представляет собой специальный `View`, который визуализируется через просмотры через Конфигурация WebFlux.
Представления по умолчанию: всегда выбираются и используются, если они соответствуют запрошенному типу носителя.

Поддержка встроенной базы данных.
Пакет `org.springframework.jdbc.datasource.embedded` обеспечивает поддержку встроенных Механизмы баз данных Java.
Поддержка https://www.hsqldb.org[HSQL], https://www.h2database.com[H2] и https://db.apache.org/derby[Derby] предоставляются. изначально.
Вы также можете использовать расширяемый API для подключения новых встроенных типов баз данных и Реализации DataSource.
Поддержка встроенной базы данных.
Зачем использовать встроенную базу данных?
Поддержка встроенной базы данных.
Встроенная база данных может быть полезна на этапе разработки проекта из-за ее легкий характер.
Преимущества включают простоту настройки, быстрый запуск, тестируемость и возможность быстрого развития вашего SQL во время разработки.
Создание встроенной базы данных.
Вы можете представить экземпляр встроенной базы данных как компонент, как показано в следующем примере: См. пример кода в исходном документе.
Создание встроенной базы данных.
Предыдущая конфигурация создает встроенную базу данных H2, заполняемую SQL из ресурсы `schema.sql` и `test-data.sql` в корне пути к классам.
Кроме того, как Рекомендуется встроенной базе данных присваивать уникальное имя. встроенная база данных доступна контейнеру Spring как компонент типа `javax.sql.DataSource`, который затем можно при необходимости внедрить в объекты доступа к данным.
Создание встроенной базы данных.

См. {spring-framework-api}/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html[javadoc для `EmbeddedDatabaseBuilder`] для получения более подробной информации обо всех поддерживаемых опциях.
Выбор типа встроенной базы данных.
В этом разделе описывается, как выбрать одну из трех встроенных баз данных, которые Spring поддерживает.
Он включает в себя следующие темы:
* Использование HSQL
* Использование H2
* Использование Derby
Использование HSQL.
Spring поддерживает HSQL 1.8.0 и выше.
HSQL является встроенной базой данных по умолчанию, если ни один тип не указан. явно указано.
Чтобы явно указать HSQL, установите атрибут `type` тег `embedded-database` в `HSQL`.
Если вы используете API-интерфейс конструктора, вызовите `setType(EmbeddedDatabaseType)` с `EmbeddedDatabaseType.HSQL`.
Использование H2.
Spring поддерживает базу данных H2.
Чтобы включить H2, установите атрибут `type` тег `embedded-database` в `H2`.
Если вы используете API-интерфейс конструктора, вызовите `setType(EmbeddedDatabaseType)` с `EmbeddedDatabaseType.H2`.
Использование Дерби.
Spring поддерживает Apache Derby 10.5 и выше.
Чтобы включить Derby, установите `type` атрибут тега `embedded-database` равен `DERBY`.
Если вы используете API конструктора, вызовите метод setType(EmbeddedDatabaseType) с помощью EmbeddedDatabaseType.DERBY.
Настройка типа встроенной базы данных.

Хотя каждый поддерживаемый тип имеет настройки подключения по умолчанию, возможно при необходимости настроить их.
В следующем примере используется H2 с пользовательским драйвером:
Java
	@Configuration
	public class DataSourceConfig {
		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
					.setDatabaseConfigurer(EmbeddedDatabaseConfigurers
							.customizeConfigurer(H2, this::customize))
					.addScript("schema.sql")
					.build();
		private EmbeddedDatabaseConfigurer customize(EmbeddedDatabaseConfigurer defaultConfigurer) {
			return new EmbeddedDatabaseConfigurerDelegate(defaultConfigurer) {
				@Override
				public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {
					super.configureConnectionProperties(properties, databaseName);
					properties.setDriverClass(CustomDriver.class);
	@Configuration
	class DataSourceConfig {
Тестирование логики доступа к данным с помощью встроенной базы данных.
Встроенные базы данных предоставляют простой способ тестирования кода доступа к данным.
Следующий пример – это Шаблон теста интеграции доступа к данным, использующий встроенную базу данных.
Использование такого шаблона может быть полезен в единичных случаях, когда встроенную базу данных не нужно повторно использовать в ходе тестирования. занятия.
Однако если вы хотите создать встроенную базу данных, которая будет использоваться совместно с набором тестов, рассмотрите возможность использования Spring TestContext Framework и настройка встроенной базы данных как bean-компонента в Spring `ApplicationContext`, как описано в Создание встроенной базы данных.
В следующем листинге показан тестовый шаблон:
Java
	public class DataAccessIntegrationTestTemplate {
		private EmbeddedDatabase db;
		@BeforeEach
		public void setUp() {

// Создает размещение данных HSQL в памяти, заполненных скриптами по умолчанию.
			// путь к классам:schema.sql и путь к классам:data.sql
			db = new EmbeddedDatabaseBuilder()
					.generateUniqueName(true)
					.addDefaultScripts()
					.build();
		@Test
		public void testDataAccess() {
			JdbcTemplate template = new JdbcTemplate(db);
			template.query( /* ... */ );
		@AfterEach
		public void tearDown() {
			db.shutdown();
	class DataAccessIntegrationTestTemplate {
Генерация уникальных имен для встроенных баз данных.
Команды разработчиков часто сталкиваются с ошибками во встроенных базах данных, если их набор тестов случайно пытается воссоздать дополнительные экземпляры той же базы данных.
Это может произойти довольно легко, если за это отвечает файл конфигурации XML или класс @Configuration. для создания встроенной базы данных и последующего повторного использования соответствующей конфигурации. в нескольких сценариях тестирования в одном наборе тестов (то есть в одной JVM). процесс) - например, интеграционные тесты для встроенных баз данных, чьи Конфигурация `ApplicationContext` различается только в зависимости от того, какое определение bean-компонента профили активны.
Генерация уникальных имен для встроенных баз данных.

Основной причиной таких ошибок является тот факт, что Spring `EmbeddedDatabaseFactory` (используется внутренне как элементом пространства имен XML `<jdbc:embedded-database>`, так и элементом `EmbeddedDatabaseBuilder` для конфигурации Java) устанавливает имя встроенной базы данных `testdb`, если не указано иное.
В случае `<jdbc:embedded-database>`, встроенной базе данных обычно присваивается имя, равное идентификатору компонента (часто что-то вроде `dataSource`).
Таким образом, последующие попытки создания встроенной базы данных не приводит к созданию новой базы данных.
Вместо этого повторно используется тот же URL-адрес соединения JDBC. и попытки создать новую встроенную базу данных фактически указывают на существующую встроенная база данных, созданная на основе той же конфигурации.
Генерация уникальных имен для встроенных баз данных.
Чтобы решить эту распространенную проблему, Spring Framework 4.2 обеспечивает поддержку генерации уникальные имена для встроенных баз данных.
Чтобы включить использование сгенерированных имен, используйте одно из следующие варианты.
* `EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()`
* `EmbeddedDatabaseBuilder.generateUniqueName()`
* `<jdbc:embedded-databasegenerate-name="true" ... >`
Расширение поддержки встроенной базы данных.
Вы можете расширить поддержку встроенной базы данных Spring JDBC двумя способами:
* Внедрите EmbeddedDatabaseConfigurer для поддержки нового типа встроенной базы данных.
* Реализуйте DataSourceFactory для поддержки новой реализации DataSource, например

Расширение поддержки встроенной базы данных. пул соединений для управления подключениями к встроенной базе данных.
Расширение поддержки встроенной базы данных.
Мы рекомендуем вам внести свой вклад в расширение сообщества Spring по адресу {spring-framework-issues}[Проблемы с GitHub].

Включить конфигурацию MVC.
Вы можете использовать аннотацию @EnableWebMvc для включения конфигурации MVC с программной конфигурацией или `<mvc:annotation-driven>` с конфигурацией XML, как показано в следующем примере: См. пример кода в исходном документе.
Включить конфигурацию MVC.
ВНИМАНИЕ: Начиная с версии 7.0, поддержка пространства имен конфигурации XML для Spring MVC устарела.
Пока нет планов по его полному удалению, но конфигурация XML не будет обновлена. модель конфигурации Java.
Включить конфигурацию MVC.
ПРИМЕЧАНИЕ.
При использовании Spring Boot вы можете использовать классы @Configuration типа WebMvcConfigurer, но без @EnableWebMvc, чтобы сохранить настройки Spring Boot MVC.
Более подробную информацию см. в раздел MVC Config API и в {spring-boot-docs-ref}/web/servlet.html#web.servlet.spring-mvc.auto-configuration[специальной документации Spring Boot].
Включить конфигурацию MVC.
В предыдущем примере регистрируется несколько Spring MVC. доступные в пути к классам (например, конвертеры полезной нагрузки для JSON, XML и другие).

Абстракция окружающей среды.
Интерфейс {spring-framework-api}/core/env/Environment.html[`Environment`] — это абстракция, интегрированная в контейнер, которая моделирует два ключевых аспекты среды приложения: profiles и ссылка:core/beans/environment.adoc#beans-property-source-abstraction[properties].
Абстракция окружающей среды.
Профиль — это именованная логическая группа определений компонентов, которая должна быть зарегистрирована в контейнер только в том случае, если данный профиль активен.
Бобы могут быть назначены профилю независимо от того, определено ли оно в XML или с аннотациями.
Роль объекта «Среда» с отношение к профилям заключается в определении того, какие профили (если таковые имеются) активны в данный момент, и какие профили (если есть) должны быть активны по умолчанию.
Абстракция окружающей среды.
Свойства играют важную роль практически во всех приложениях и могут возникать из различные источники: файлы свойств, системные свойства JVM, системная среда. переменные, JNDI, параметры контекста сервлета, специальные объекты «Свойства», объекты «Карта» и т. д. дальше.
Роль объекта «Среда» по отношению к свойствам заключается в предоставлении пользователь с удобным сервисным интерфейсом для настройки источников свойств и решения свойства от них.
Профили определения компонентов предоставляют механизм в основном контейнере, который позволяет регистрация разных bean-компонентов в разных средах.

Слово «окружающая среда» может означать разные вещи для разных пользователей, и эта функция может помочь во многих варианты использования, в том числе:
* Работа с источником данных в памяти в процессе разработки, а не поиск того же источника.
Профили определения компонентов. источник данных из JNDI во время контроля качества или производства.
* Регистрация инфраструктуры мониторинга только при развертывании приложения в
Профили определения компонентов. среда исполнения.
* Регистрация индивидуальных реализаций bean-компонентов для клиента A по сравнению с клиентом.
Профили определения компонентов.
Развертывания Б.
Профили определения компонентов.
Рассмотрим первый вариант использования в практическом приложении, требующем `Источник данных`.
В тестовой среде конфигурация может выглядеть следующим образом:
Java
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder()
			.setType(EmbeddedDatabaseType.HSQL)
			.addScript("my-schema.sql")
			.addScript("my-test-data.sql")
			.build();
Профили определения компонентов.
Теперь рассмотрим, как это приложение можно развернуть в отделе контроля качества или в производстве. среде, предполагая, что источник данных для приложения зарегистрирован с каталогом JNDI производственного сервера приложений.
Наш bean-компонент dataSource теперь выглядит следующим образом:
Java
	@Bean(destroyMethod = "")
	public DataSource dataSource() throws Exception {
		Context ctx = new InitialContext();

return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
Профили определения компонентов.
Проблема в том, как переключаться между использованием этих двух вариантов в зависимости от текущая среда.
Со временем пользователи Spring разработали несколько способов сделать это, обычно полагаясь на комбинацию переменных системной среды и операторы XML `<import/>`, содержащие токены pass:q[`${placeholder}`], которые разрешают к правильному пути к файлу конфигурации в зависимости от значения среды переменная.
Профили определения компонентов — это основная функция контейнера, которая обеспечивает решение этой проблемы.
Профили определения компонентов.
Если мы обобщим вариант использования, показанный в предыдущем примере bean-компонента, специфичного для конкретной среды, определения, мы в конечном итоге сталкиваемся с необходимостью зарегистрировать определенные определения bean-компонентов в определенных контекстах, но не в других.
Вы можете сказать, что хотите зарегистрировать определенный профиль определений bean-компонентов в ситуации A и другой профиль в ситуация Б.
Мы начинаем с обновления нашей конфигурации, чтобы отразить эту потребность.
Использование `@Profile`. {spring-framework-api}/context/annotation/Profile.html[`@Profile`] аннотация позволяет указать, что компонент имеет право на регистрацию. когда один или несколько указанных профилей активны.
Используя наш предыдущий пример, мы можно переписать конфигурацию dataSource следующим образом:
Java
	@Configuration

@Profile("development")
	public class StandaloneDataConfig {
		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
	@Configuration
	@Profile("development")
	class StandaloneDataConfig {
Java
	@Configuration
	@Profile("production")
	public class JndiDataConfig {
		@Bean(destroyMethod = "") // <1>
		public DataSource dataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
Использование `@Profile`. <1> `@Bean(destroyMethod = "")` отключает вывод метода уничтожения по умолчанию.
	@Configuration
	@Profile("production")
	class JndiDataConfig {
Использование `@Profile`. <1> `@Bean(destroyMethod = "")` отключает вывод метода уничтожения по умолчанию.
Использование `@Profile`.
ПРИМЕЧАНИЕ.
Как упоминалось ранее, с методами `@Bean` вы обычно предпочитаете использовать программные методы.

JNDI-поиск, используя либо помощники Spring `JndiTemplate`/`JndiLocatorDelegate`, либо прямое использование JNDI `InitialContext`, показанное ранее, но не JndiObjectFactoryBean` вариант, который заставит вас объявить тип возвращаемого значения как тип FactoryBean.
Использование `@Profile`.
Строка профиля может содержать простое имя профиля (например, «производство») или выражение профиля.
Выражение профиля позволяет реализовать более сложную логику профиля. выраженное (например, «производство и США-Восток»).
Следующие операторы поддерживаются в выражения профиля:
* `!`: логическое `НЕ` профиля.
* `&`: логическое `И` профилей.
* `|`: логическое "ИЛИ" профилей.
Использование `@Profile`.
ПРИМЕЧАНИЕ.
Нельзя смешивать операторы `&` и `|` без использования круглых скобок.
Например, `производство и США-Восток | eu-central` не является допустимым выражением.
Это должно быть выражено как `производство & (США-Восток | ЕС-Центр)`.
Использование `@Profile`.
Вы можете использовать @Profile в качестве ссылки:core/beans/classpath-scanning.adoc#beans-meta-annotations[meta-annotation] для этой цели. создания пользовательской аннотации.
В следующем примере определяется пользовательский аннотация `@Production`, которую можно использовать в качестве замены `@Profile("производство")`:

Java
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Profile("production")
	public @interface Production {
	@Target(AnnotationTarget.CLASS)
	@Retention(AnnotationRetention.RUNTIME)
	@Profile("production")
	annotation class Production
Использование `@Profile`.
СОВЕТ: Если класс `@Configuration` помечен как `@Profile`, все методы `@Bean` и Аннотации `@Import`, связанные с этим классом, игнорируются, если только один или несколько из указанные профили активны.
Если отмечен класс `@Component` или `@Configuration` с `@Profile({"p1", "p2"})` этот класс не регистрируется и не обрабатывается, если профили «p1» или «p2» активированы.
Если данный профиль имеет префикс NOT (`!`), аннотированный элемент регистрируется только в том случае, если профиль не активный.
Например, для `@Profile({"p1", "!p2"})` регистрация произойдет, если профиль «p1» активен или профиль «p2» не активен.
Использование `@Profile`. `@Profile` также может быть объявлен на уровне метода, чтобы включать только один конкретный компонент. класса конфигурации (например, для альтернативных вариантов определенного компонента), как следующий пример показывает:
Java
	@Configuration
	public class AppConfig {

@Bean("dataSource")
		@Profile("development") // <1>
		public DataSource standaloneDataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
		@Bean("dataSource")
		@Profile("production") // <2>
		public DataSource jndiDataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
Использование `@Profile`. <1> Метод `standaloneDataSource` доступен только в профиле `development`. <2> Метод jndiDataSource доступен только в рабочем профиле.
	@Configuration
	class AppConfig {
Использование `@Profile`. <1> Метод `standaloneDataSource` доступен только в профиле `development`. <2> Метод jndiDataSource доступен только в рабочем профиле.

Использование `@Profile`. [ПРИМЕЧАНИЕ] = При использовании `@Profile` в методах `@Bean` может применяться особый сценарий: перегруженные методы `@Bean` с тем же именем метода Java (аналог конструктора перегрузки), условие `@Profile` должно быть последовательно объявлено на всех перегруженные методы.
Если условия несовместны, то только условие на первое объявление среди перегруженных методов имеет значение.
Следовательно, `@Profile` может не использоваться для выбора перегруженного метода с определенной сигнатурой аргумента другой.
Разрешение между всеми фабричными методами для одного и того же компонента соответствует Spring Алгоритм разрешения конструктора во время создания.
Использование `@Profile`.
Если вы хотите определить альтернативные компоненты с разными условиями профиля, используйте разные имена методов Java, которые указывают на одно и то же имя компонента, используя имя `@Bean` атрибут, как показано в предыдущем примере.
Если все подписи аргументов одинаковы (например, все варианты имеют фабричные методы без аргументов), это единственный способ представить такое расположение в допустимом классе Java в первую очередь (поскольку может быть только один метод с определенным именем и сигнатурой аргумента).
Профили определения XML-компонентов.
Аналогом XML является атрибут `profile` элемента `<beans>`.
Наш предыдущий образец Конфигурацию можно переписать в двух XML-файлах следующим образом:
	<beans profile="development"

xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xsi:schemaLocation="...">
		<jdbc:embedded-database id="dataSource">
			<jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
			<jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
		</jdbc:embedded-database>
	</beans>
	<beans profile="production"
		xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">
		<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
	</beans>
Профили определения XML-компонентов.

Также можно избежать разделения и вложения элементов `<beans/>` в один и тот же файл, как показано в следующем примере:
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">
		<!-- other bean definitions -->
		<beans profile="development">
			<jdbc:embedded-database id="dataSource">
				<jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
				<jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
			</jdbc:embedded-database>
		</beans>
		<beans profile="production">
			<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
		</beans>
	</beans>
Профили определения XML-компонентов.

В Spring-bean.xsd разрешены только такие элементы, как последние в файле.
Это должно помочь обеспечить гибкость без необходимости беспорядок в файлах XML.
Профили определения XML-компонентов. [ПРИМЕЧАНИЕ] = Аналог XML не поддерживает выражения профиля, описанные ранее.
Это возможно, однако, чтобы отменить профиль, используйте оператор `!`.
Также возможно применить логическое «и» путем вложения профилей, как показано в следующем примере:
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">
		<!-- other bean definitions -->
		<beans profile="production">
			<beans profile="us-east">
				<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
			</beans>
		</beans>
	</beans>
Профили определения XML-компонентов.

В предыдущем примере bean-компонент `dataSource` доступен, если оба `production` и `dataSource` Профили `us-east` активны.
Активация профиля.
Теперь, когда мы обновили нашу конфигурацию, нам все еще нужно указать Spring, какой профиль активен.
Если бы мы запустили наш пример приложения прямо сейчас, мы бы увидели выброшено исключение NoSuchBeanDefinitionException, поскольку контейнер не смог найти bean-компонент Spring с именем dataSource.
Активация профиля.
Активировать профиль можно несколькими способами, но самый простой – это сделать это программно с помощью API «Среды», который доступен через `Контекст приложения`.
В следующем примере показано, как это сделать:
Java
	AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
	ctx.getEnvironment().setActiveProfiles("development");
	ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
	ctx.refresh();
Активация профиля.
Кроме того, вы также можете декларативно активировать профили через Свойство Spring.profiles.active, которое можно указать через системную среду. переменные, системные свойства JVM, параметры контекста сервлета в `web.xml` или даже в виде запись в JNDI (см. `PropertySource` Abstraction).
В интеграционных тестах активен профили можно объявить с помощью аннотации @ActiveProfiles в файле Spring-test. модуль (см. конфигурация контекста с профилями среды).
Активация профиля.

Обратите внимание, что профили не являются предложением «или-или».
Вы можете активировать несколько профили сразу.
Программно вы можете предоставить несколько имен профилей `setActiveProfiles()`, который принимает `String...` varargs.
Следующий пример активирует несколько профилей:
Java
	ctx.getEnvironment().setActiveProfiles("profile1", "profile2");
	ctx.getEnvironment().setActiveProfiles("profile1", "profile2")
Активация профиля.
Декларативно `spring.profiles.active` может принимать список имен профилей, разделенных запятыми, как показано в следующем примере:
	-Dspring.profiles.active="profile1,profile2"
Профиль по умолчанию представляет собой профиль, который включается, если ни один профиль не активен.
Рассмотрим следующий пример:
Java
	@Configuration
	@Profile("default")
	public class DefaultDataConfig {
		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.build();
	@Configuration
	@Profile("default")
	class DefaultDataConfig {
Профиль по умолчанию.
Если ни один профиль не активен, `dataSource` создано.
Вы можете рассматривать это как способ предоставить определение по умолчанию для одного или нескольких фасоль.
Если какой-либо профиль включен, профиль по умолчанию не применяется.

Профиль по умолчанию.
Имя профиля по умолчанию — «default».
Вы можете изменить имя профиль по умолчанию, используя `setDefaultProfiles()` в `Среде` или, декларативно, используя свойство Spring.profiles.default.
Абстракция PropertySource.
Абстракция Spring «Среда» обеспечивает операции поиска в настраиваемой области. иерархия источников собственности.
Рассмотрим следующий листинг:
Java
	ApplicationContext ctx = new GenericApplicationContext();
	Environment env = ctx.getEnvironment();
	boolean containsMyProperty = env.containsProperty("my-property");
	System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
Абстракция PropertySource.
В предыдущем фрагменте мы видим высокоуровневый способ запроса Spring, является ли свойство my-property определены для текущей среды.
Чтобы ответить на этот вопрос, объект «Среда» выполняет поиск по набору {spring-framework-api}/core/env/PropertySource.html[`PropertySource`] объекты.
PropertySource — это простая абстракция над любым источником пар ключ-значение.
Spring {spring-framework-api}/core/env/StandardEnvironment.html[`StandardEnvironment`] настроен с двумя объектами PropertySource, один из которых представляет набор системных свойств JVM. (`System.getProperties()`) и один, представляющий набор переменных системной среды. (`System.getenv()`).

Абстракция PropertySource.
ПРИМЕЧАНИЕ.
Эти источники свойств по умолчанию присутствуют для StandardEnvironment для использования в автономном режиме. приложения. {spring-framework-api}/web/context/support/StandardServletEnvironment.html[`StandardServletEnvironment`] заполняется дополнительными источниками свойств по умолчанию, включая конфигурацию сервлета, сервлет параметры контекста и {spring-framework-api}/jndi/JndiPropertySource.html[`JndiPropertySource`] если JNDI доступен.
Абстракция PropertySource.
Конкретно, когда вы используете StandardEnvironment, вызов env.containsProperty("my-property")` возвращает true, если в файле присутствует системное свойство my-property или переменная среды my-property. время выполнения.
Абстракция PropertySource. [СОВЕТ] = Выполняемый поиск является иерархическим.
По умолчанию системные свойства имеют приоритет над переменные среды.
Итак, если свойство my-property установлено в обоих местах во время вызов `env.getProperty("my-property")`, значение системного свойства "wins`" и возвращается.
Обратите внимание, что значения свойств не объединяются. но скорее полностью перекрыто предыдущей записью.
Абстракция PropertySource.
Для общего StandardServletEnvironment полная иерархия выглядит следующим образом: записи с самым высоким приоритетом вверху:
Абстракция PropertySource. .
Параметры ServletConfig (если применимо — например, в случае контекста DispatcherServlet).
Параметры ServletContext (записи параметров контекста web.xml).

Переменные среды JNDI (записи `java:comp/env/`).
Свойства системы JVM (аргументы командной строки `-D`).
Системная среда JVM (переменные среды операционной системы)
Абстракция PropertySource.
Самое главное, что весь механизм настраивается.
Возможно, у вас есть собственный источник свойств, которые вы хотите интегрировать в этот поиск.
Для этого реализуйте и создайте свой собственный PropertySource и добавьте его в набор PropertySources для текущая `Окружающая среда`.
В следующем примере показано, как это сделать:
Java
Абстракция PropertySource.
ConfigurableApplicationContext ctx = new GenericApplicationContext(); MutablePropertySources sources = ctx.getEnvironment().getPropertySources(); sources.addFirst(new MyPropertySource());
Абстракция PropertySource.
В предыдущем коде MyPropertySource был добавлен с наивысшим приоритетом в поиск.
Если он содержит свойство my-property, оно обнаруживается и возвращается в пользу любое свойство my-property в любом другом PropertySource. {spring-framework-api}/core/env/MutablePropertySources.html[`MutablePropertySources`] API предоставляет ряд методов, которые позволяют точно манипулировать набором источники собственности.
Использование `@PropertySource`. {spring-framework-api}/context/annotation/PropertySource.html[`@PropertySource`] аннотация предоставляет удобный и декларативный механизм для добавления PropertySource. к «Среде» Spring.
Использование `@PropertySource`.

Учитывая файл app.properties, содержащий пару ключ-значение testbean.name=myTestBean, следующий класс `@Configuration` использует `@PropertySource` таким образом, что вызов testBean.getName() возвращает myTestBean:
Java
	   @Autowired
	   Environment env;
	   @Bean
	   public TestBean testBean() {
		   TestBean testBean = new TestBean();
		   testBean.setName(env.getProperty("testbean.name"));
		   return testBean;
	@Configuration
	@PropertySource("classpath:/com/myco/app.properties")
	class AppConfig {
@Configuration @PropertySource("classpath:/com/myco/app.properties") public class AppConfig {.
Любые заполнители `${...}`, присутствующие в местоположении ресурса `@PropertySource`, являются разрешено в отношении набора источников собственности, уже зарегистрированных в отношении среде, как показано в следующем примере:
Java
@Configuration @PropertySource("classpath:/com/myco/app.properties") public class AppConfig {. @Configuration @PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties") public class AppConfig {
	   @Autowired
	   Environment env;
	   @Bean
	   public TestBean testBean() {
		   TestBean testBean = new TestBean();
		   testBean.setName(env.getProperty("testbean.name"));

return testBean;
	@Configuration
	@PropertySource("classpath:/com/\${my.placeholder:default/path}/app.properties")
	class AppConfig {
@Configuration @PropertySource("classpath:/com/myco/app.properties") public class AppConfig {.
Предполагая, что my.placeholder уже присутствует в одном из источников свойств. зарегистрированы (например, системные свойства или переменные среды), заполнитель решено до соответствующего значения.
Если нет, то используется `default/path`. по умолчанию.
Если значение по умолчанию не указано и свойство не может быть разрешено, Выдается `IllegalArgumentException`.
@Configuration @PropertySource("classpath:/com/myco/app.properties") public class AppConfig {.
ПРИМЕЧАНИЕ. @PropertySource можно использовать как повторяющуюся аннотацию. `@PropertySource` также может использоваться в качестве метааннотации для создания пользовательских аннотаций с помощью переопределение атрибутов.
Разрешение заполнителя в заявлениях.
Исторически значение заполнителей в элементах можно было определить только по Свойства системы JVM или переменные среды.
Это уже не так.
Потому что абстракция «Среда» интегрирована во весь контейнер, ее легко маршрутизировать разрешение заполнителей через него.
Это означает, что вы можете настроить процесс разрешения любым удобным для вас способом.
Вы можете изменить приоритет поиска по системные свойства и переменные среды или полностью удалите их.

Вы также можете добавить свой собственные источники собственности, если это необходимо.
Разрешение заполнителя в заявлениях.
Конкретно, следующее утверждение работает независимо от того, где находится «клиент». свойство определено, если оно доступно в `Среде`:
	<beans>
		<import resource="com/bank/service/${customer}-config.xml"/>
	</beans>

Преобразование кодов ошибок в сообщения об ошибках.
Мы рассмотрели привязку и проверку данных.
В этом разделе описывается вывод сообщений, соответствующих к ошибкам проверки.
В примере, показанном в предшествующий раздел, мы отклонили поля «имя» и «возраст».
Если мы хотим вывести сообщения об ошибках, используя `MessageSource`, мы можем сделать это, используя код ошибки, который мы указываем при отклонении поля. («имя» и «возраст» в данном случае).
Когда вы вызываете (прямо или косвенно, используя например, класс ValidationUtils), rejectValue или один из других методов reject. из интерфейса `Errors`, базовая реализация не только регистрирует код, который вы передается, но также регистрирует ряд дополнительных кодов ошибок. `MessageCodesResolver` определяет, какие коды ошибок регистрирует интерфейс `Errors`.
По умолчанию Используется `DefaultMessageCodesResolver`, который (например) не только регистрирует сообщение с кодом, который вы указали, но также регистрирует сообщения, содержащие переданное вами имя поля. к методу отклонения.
Итак, если вы отклоните поле, используя `rejectValue("age", "too.darn.old")`, помимо кода «too.darn.old», Spring также регистрирует «too.darn.old.age» и `too.darn.old.age.int` (первое включает имя поля, а второе — тип поля).

Это сделано для удобства разработчиков при работе с сообщениями об ошибках.
Преобразование кодов ошибок в сообщения об ошибках.
Дополнительную информацию о MessageCodesResolver и стратегии по умолчанию можно найти. в Javadoc {spring-framework-api}/validation/MessageCodesResolver.html[`MessageCodesResolver`] и {spring-framework-api}/validation/DefaultMessageCodesResolver.html[`DefaultMessageCodesResolver`], соответственно.

Оценка.
В этом разделе описывается программное использование интерфейсов SpEL и его языка выражений.
Полный справочник по языку можно найти в
Оценка.
Следующий код демонстрирует, как использовать API SpEL для оценки буквальной строки. выражение «Привет, мир».
Java
	ExpressionParser parser = new SpelExpressionParser();
	Expression exp = parser.parseExpression("'Hello World'"); // <1>
	String message = (String) exp.getValue();
Оценка. <1> Значение переменной сообщения — «Hello World».
Оценка.
Классы и интерфейсы SpEL, которые вы, скорее всего, будете использовать, расположены в папке Пакет `org.springframework.expression` и его подпакеты, такие как `spel.support`.
Оценка.
Интерфейс ExpressionParser отвечает за анализ строки выражения.
В В предыдущем примере строка выражения представляет собой строковый литерал, обозначаемый окружающим одинарные кавычки.
Интерфейс `Expression` отвечает за оценку определенная строка выражения.
Два типа исключений, которые могут быть выброшены при вызове `parser.parseExpression(...)` и `exp.getValue(...)` являются `ParseException` и `EvaluationException` соответственно.
Оценка.
SpEL поддерживает широкий спектр функций, таких как вызов методов, доступ к свойствам, и вызов конструкторов.
Оценка.
В следующем примере вызова метода мы вызываем метод concat для строки буквально «Привет, мир».
Java

ExpressionParser parser = new SpelExpressionParser();
	Expression exp = parser.parseExpression("'Hello World'.concat('!')"); // <1>
	String message = (String) exp.getValue();
Оценка. <1> Значение `message` теперь равно `"Hello World!"`.
Оценка.
В следующем примере показано, как получить доступ к свойству JavaBean `Bytes` объекта строковый литерал `Hello World`.
Java
	ExpressionParser parser = new SpelExpressionParser();
	// вызывает 'getBytes()'
	Expression exp = parser.parseExpression("'Hello World'.bytes"); // <1>
	byte[] bytes = (byte[]) exp.getValue();
Оценка. <1> Эта строка преобразует литерал в массив байтов.
Оценка.
SpEL также поддерживает вложенные свойства, используя стандартную запись через точку (например, `prop1.prop2.prop3`), а также соответствующую настройку значений свойств.
Доступ к публичным полям также возможен.
Оценка.
В следующем примере показано, как использовать запись через точку для получения длины строкового литерала.
Java
	ExpressionParser parser = new SpelExpressionParser();
	// вызывает 'getBytes().length'
	Expression exp = parser.parseExpression("'Hello World'.bytes.length"); // <1>

int length = (Integer) exp.getValue();
Оценка. <1> `'Hello World'.bytes.length` дает длину литерала.
Оценка.
Конструктор String можно вызвать вместо использования строкового литерала, как показано ниже. пример показывает.
Java
	ExpressionParser parser = new SpelExpressionParser();
	Expression exp = parser.parseExpression("new String('hello world').toUpperCase()"); // <1>
	String message = exp.getValue(String.class);
Оценка. <1> Создайте новую строку из литерала и преобразуйте ее в верхний регистр.
Оценка.
Обратите внимание на использование общего метода: `public <T> T getValue(Class<T> желаемыйResultType)`.
Использование этого метода избавляет от необходимости приводить значение выражения к желаемому значению. тип результата. `EvaluationException` выдается, если значение не может быть приведено к введите `T` или преобразуйте его с помощью зарегистрированного преобразователя типов.
Оценка.
Более распространенное использование SpEL — предоставление строки выражения, которая вычисляется против конкретного экземпляра объекта (называемого корневым объектом).
Следующий пример показывает как получить свойство name из экземпляра класса Inventor и как его ссылайтесь на свойство `name` в логическом выражении.
Java
	// Создайте и настройте календарь
	GregorianCalendar c = new GregorianCalendar();
	c.set(1856, 7, 9);

// Аргументами конструктора являются имя, день рождения и национальность.
	Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");
	ExpressionParser parser = new SpelExpressionParser();
	Expression exp = parser.parseExpression("name"); // Parse name as an expression
	String name = (String) exp.getValue(tesla);
	// name == "Никола Тесла"
	exp = parser.parseExpression("name == 'Nikola Tesla'");
	boolean result = exp.getValue(tesla, Boolean.class);
	// результат == правда
Понимание `EvaluationContext`.
API EvaluationContext используется при оценке выражения для разрешения свойств. методы или поля и помочь выполнить преобразование типов.
Spring предоставляет два реализации.
Понимание `EvaluationContext`. `SimpleEvaluationContext` Предоставляет подмножество основных функций языка SpEL и параметров конфигурации, например категории выражений, которые не требуют полного использования языка SpEL синтаксис и должен быть существенно ограничен.
Примеры включают, помимо прочего, выражения привязки данных и фильтры на основе свойств.
Понимание `EvaluationContext`. `StandardEvaluationContext` Предоставляет полный набор функций языка SpEL и параметров конфигурации.
Вы можете использовать он позволяет указать корневой объект по умолчанию и настроить все доступные, связанные с оценкой. стратегия.
Понимание `EvaluationContext`. `SimpleEvaluationContext` предназначен для поддержки только подмножества языка SpEL. синтаксис.

Например, он исключает ссылки на типы Java, конструкторы и ссылки на компоненты.
Также требуется явно выбрать уровень поддержки свойств и методов. в выражениях.
При создании SimpleEvaluationContext вам необходимо выбрать уровень поддержка, необходимая для привязки данных в выражениях SpEL:
* Привязка данных для доступа только для чтения.
* Привязка данных для доступа на чтение и запись.
* Пользовательский PropertyAccessor (обычно не основанный на отражении), потенциально в сочетании с
`DataBindingPropertyAccessor`.
Удобно, что SimpleEvaluationContext.forReadOnlyDataBinding() обеспечивает доступ только для чтения. к свойствам через DataBindingPropertyAccessor.
Аналогично, `SimpleEvaluationContext.forReadWriteDataBinding()` обеспечивает доступ для чтения и записи к свойства.
Альтернативно, настройте пользовательские средства доступа через `SimpleEvaluationContext.forPropertyAccessors(...)`, потенциально отключить назначение и при необходимости активируйте разрешение метода и/или преобразователь типов через построитель.
Преобразование типа.
По умолчанию SpEL использует службу преобразования, доступную в ядре Spring. (`org.springframework.core.convert.ConversionService`).
Эта услуга конвертации поставляется со множеством встроенных конвертеров для обычных преобразований, но при этом полностью расширяема, поэтому что вы можете добавлять собственные преобразования между типами.
Кроме того, он поддерживает дженерики.
Это означает, что при работе с универсальными типами в выражениях SpEL пытается преобразования для поддержания корректности типов любых объектов, с которыми он сталкивается.
Преобразование типа.
Что это означает на практике?

Предположим, что используется присвоение с использованием `setValue()`. чтобы установить свойство List.
Тип свойства на самом деле — List<Boolean>.
SpEL распознает, что элементы списка необходимо преобразовать в логические значения перед помещается в него.
В следующем примере показано, как это сделать.
Java
	class Simple {
		public List<Boolean> booleanList = new ArrayList<>();
	Simple simple = new Simple();
	simple.booleanList.add(true);
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	// «false» передается здесь как строка. SpEL и служба конвертации
	// распознает, что это должно быть логическое значение, и преобразует его соответствующим образом.
	parser.parseExpression("booleanList[0]").setValue(context, simple, "false");
	// б неверно
	Boolean b = simple.booleanList.get(0);
	// «false» передается здесь как строка. SpEL и служба конвертации
	// распознает, что это должно быть логическое значение, и преобразует его соответствующим образом.
	parser.parseExpression("booleanList[0]").setValue(context, simple, "false")
Конфигурация парсера.
Анализатор выражений SpEL можно настроить с помощью конфигурации анализатора. объект (`org.springframework.expression.spel.SpelParserConfiguration`).

Конфигурация объект управляет поведением некоторых компонентов выражения.
Например, если вы индекс в коллекцию и элемент по указанному индексу имеет значение null, SpEL может автоматически создать элемент.
Это полезно при использовании выражений, состоящих из цепочка ссылок на свойства.
Аналогично, если вы индексируете коллекцию и указываете индекс, превышающий текущий размер коллекции, SpEL может автоматически увеличить коллекцию, чтобы она соответствовала этому индексу.
Чтобы добавить элемент в указанный индекс, SpEL попытается создать элемент, используя значение по умолчанию для этого типа элемента. конструктор перед установкой указанного значения.
Если тип элемента не имеет конструктор по умолчанию, в коллекцию будет добавлен `null`.
Если нет встроенного конвертере или пользовательском конвертере, который знает, как установить значение, `null` останется в коллекция по указанному индексу.
Следующий пример демонстрирует, как автоматически увеличивать «Список».
Java
	class Demo {
		public List<String> list;
	// Включать:
	// - автоматическая инициализация нулевой ссылки
	// - рост автоколлекции
	SpelParserConfiguration config = new SpelParserConfiguration(true, true);
	ExpressionParser parser = new SpelExpressionParser(config);
	Expression expression = parser.parseExpression("list[3]");
	Demo demo = new Demo();
	Object o = expression.getValue(demo);
	// demo.list теперь будет настоящей коллекцией из 4 записей
	// Каждая запись представляет собой новую пустую строку.

// demo.list теперь будет настоящей коллекцией из 4 записей
	// Каждая запись представляет собой новую пустую строку.
Конфигурация парсера.
По умолчанию выражение SpEL не может содержать более 10 000 символов; однако, `maxExpressionLength` можно настроить.
Если вы создадите `SpelExpressionParser` программно вы можете указать собственный maxExpressionLength при создании `SpelParserConfiguration`, которую вы предоставляете `SpelExpressionParser`.
Если вы хотите установите `maxExpressionLength`, используемый для анализа выражений SpEL внутри `ApplicationContext` — например, в определениях XML-компонентов, `@Value` и т. д. — вы можете установите системное свойство JVM или свойство Spring с именем `spring.context.expression.maxLength` до максимальной длины выражения, необходимой вашему приложению (см.
Сборник SpEL.
Spring предоставляет базовый компилятор для выражений SpEL.
Выражения, как правило, интерпретируется, что обеспечивает большую динамическую гибкость во время оценки, но не обеспечить оптимальную производительность.
Для периодического использования выражений это нормально, но когда используемые другими компонентами, такими как Spring Integration, производительность может быть очень важна, и нет никакой реальной необходимости в динамизме.
Сборник SpEL.
Компилятор SpEL призван удовлетворить эту потребность.
Во время оценки компилятор генерирует класс Java, который воплощает поведение выражения во время выполнения, и использует его класс, чтобы добиться гораздо более быстрого вычисления выражения.

Из-за отсутствия набора текста выражения, компилятор использует информацию, собранную во время интерпретируемых вычислений выражения при выполнении компиляции.
Например, он не знает тип ссылки на свойство исключительно из выражения, но во время первой интерпретации оценка, он выясняет, что это такое.
Конечно, основываясь на таких производных информация может вызвать проблемы позже, если типы различных элементов выражения меняться со временем.
По этой причине компиляция лучше всего подходит для выражений, Информация о типе не изменится при повторных оценках.
Сборник SpEL.
Рассмотрим следующее основное выражение.
	someArray[0].someProperty.someOtherProperty < 0.1
Сборник SpEL.
Поскольку предыдущее выражение включает доступ к массиву, разыменование некоторых свойств и числовых операций, прирост производительности может быть очень заметным.
В примере микро тестовый прогон из 50 000 итераций, оценка с использованием интерпретатора и всего 3 мс при использовании скомпилированной версии выражения.
Конфигурация компилятора.
По умолчанию компилятор не включен, но его можно включить одним из двух способов. разные способы.
Вы можете включить его, используя процесс настройки парсера. (обсуждается ранее) или с помощью свойства Spring, когда использование SpEL встроено в другой компонент.
В этом разделе обсуждаются оба этих варианта.
Конфигурация компилятора.
Компилятор может работать в одном из трех режимов, которые зафиксированы в `org.springframework.expression.spel.SpelCompilerMode` перечисление.
Режимы следующие.

Конфигурация компилятора. `ВЫКЛ` Компилятор выключен, и все выражения будут оцениваться в _interpreted_ режим.
Это режим по умолчанию. `НЕМЕДЛЕННО` В немедленном режиме выражения компилируются как можно скорее, обычно после первая интерпретированная оценка.
Если вычисление скомпилированного выражения не удалось (для например, из-за изменения типа, как описано ранее), вызывающий выражение оценка получает исключение.
Если изменяются типы различных элементов выражения со временем рассмотрите возможность перехода в режим «MIXED» или отключения компилятора. `СМЕШАННЫЙ` В смешанном режиме вычисление выражения автоматически переключается между _интерпретируемым_ и _скомпилировано_ с течением времени.
После некоторого количества успешных интерпретаций выражение компилируется.
Если вычисление скомпилированного выражения завершается неудачей (например, из-за изменение типа), этот сбой будет обнаружен внутри системы, и система переключится обратно. в режим интерпретации для данного выражения.
По сути, исключение, что вызывающий абонент получает в режиме «НЕМЕДЛЕННО» вместо этого обрабатывается внутри.
Некоторое время спустя, компилятор может сгенерировать другую скомпилированную форму и переключиться на нее.
Этот цикл переключения между интерпретируемым и скомпилированным режимом будет продолжаться до тех пор, пока система не определит, что это нет смысла продолжать попытки — например, при достижении определенного порога неудачи достигнуто — в этот момент система навсегда переключится на интерпретируемый режим для данного выражения.
Конфигурация компилятора.
Режим `IMMEDIATE` существует, поскольку режим `MIXED` может вызвать проблемы с выражениями, которые имеют побочные эффекты.

Если скомпилированное выражение терпит неудачу после частичного успеха, оно возможно, уже сделал что-то, что повлияло на состояние системы.
Если это произошло, вызывающая сторона может не захотеть, чтобы она автоматически перезапускалась в интерпретируемом режиме, поскольку часть выражения может быть запущена дважды.
Конфигурация компилятора.
После выбора режима используйте SpelParserConfiguration для настройки парсера.
В следующем примере показано, как это сделать.
Java
	SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
			this.getClass().getClassLoader());
	SpelExpressionParser parser = new SpelExpressionParser(config);
	Expression expr = parser.parseExpression("payload");
	MyMessage message = new MyMessage();
	Object payload = expr.getValue(message);
Конфигурация компилятора.
Когда вы указываете режим компилятора, вы также можете указать ClassLoader (передавая null). разрешено).
Скомпилированные выражения определяются в дочернем файле ClassLoader, созданном под любым именем. что поставляется.
Важно убедиться, что если указан ClassLoader, он может просмотреть все типы, участвующие в процессе оценки выражений.
Если вы не укажете ClassLoader, используется ClassLoader по умолчанию (обычно контекст ClassLoader для поток, который выполняется во время вычисления выражения).
Конфигурация компилятора.
Второй способ настройки компилятора предназначен для использования, когда SpEL встроен в какой-либо файл. другой компонент, и его невозможно настроить через конфигурацию объект.

В таких случаях можно установить `spring.expression.compiler.mode` свойство через системное свойство JVM (или через Значения перечисления SpelCompilerMode («выключено», «немедленно» или «смешанно»).
Ограничения компилятора.
Spring не поддерживает компиляцию всех видов выражений.
Основное внимание уделяется общие выражения, которые, вероятно, будут использоваться в контекстах, критичных к производительности. следующие типы выражений не могут быть скомпилированы.
* Выражения, связанные с присвоением
* Выражения, зависящие от службы преобразования
* Выражения с использованием пользовательских преобразователей.
* Выражения с использованием перегруженных операторов.
* Выражения с использованием синтаксиса построения массива.
* Выражения с использованием выделения или проекции
* Выражения с использованием ссылок на компоненты
Ограничения компилятора.
В будущем может поддерживаться компиляция дополнительных видов выражений.

События, связанные с транзакцией.
Начиная с Spring 4.2, прослушиватель события может быть привязан к фазе транзакции.
Типичным примером является обработка события при успешном завершении транзакции.
Это позволяет использовать события с большей гибкостью, когда результат текущего транзакция действительно имеет значение для слушателя.
События, связанные с транзакцией.
Вы можете зарегистрировать обычный прослушиватель событий, используя аннотацию @EventListener.
Если вам нужно привязать его к транзакции, используйте @TransactionalEventListener.
При этом прослушиватель по умолчанию привязывается к фазе фиксации транзакции.
События, связанные с транзакцией.
Следующий пример демонстрирует эту концепцию.
Предположим, что компонент публикует созданный заказом событие и что мы хотим определить прослушиватель, который должен обрабатывать это событие только после транзакция, в которой он был опубликован, успешно зафиксирована.
Следующие пример устанавливает такой прослушиватель событий:
Java
	@Component
	public class MyComponent {
		@TransactionalEventListener
		public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) {
	@Component
	class MyComponent {
События, связанные с транзакцией.
Аннотация `@TransactionalEventListener` предоставляет атрибут `phase`, который позволяет вам настроить фазу транзакции, к которой должен быть привязан прослушиватель.
Допустимые фазы: BEFORE_COMMIT, AFTER_COMMIT (по умолчанию), AFTER_ROLLBACK, а также `AFTER_COMPLETION`, который агрегирует завершение транзакции (будь то фиксация или откат).
События, связанные с транзакцией.
Если ни одна транзакция не выполняется, прослушиватель вообще не вызывается, поскольку мы не можем соблюдать необходимая семантика.

Однако вы можете переопределить это поведение, установив `fallbackExecution` атрибут аннотации имеет значение true.
События, связанные с транзакцией. [ПРИМЕЧАНИЕ] = Начиная с версии 6.1, `@TransactionalEventListener` может работать с транзакциями, связанными с потоками, управляемыми «PlatformTransactionManager», а также реактивные транзакции, управляемые «ReactiveTransactionManager».
В первом случае слушатели гарантированно увидят текущую транзакцию, связанную с потоком.
Поскольку последний использует контекст Reactor вместо локальных переменных потока, транзакция контекст должен быть включен в опубликованный экземпляр события в качестве источника события.
См. {spring-framework-api}/transaction/reactive/TransactionalEventPublisher.html[`TransactionalEventPublisher`] javadoc для получения подробной информации.

Классы, используемые в примерах.
В этом разделе перечислены классы, используемые в примерах этой главы.
Java
	package org.spring.samples.spel.inventor;
	import java.util.Date;
	import java.util.GregorianCalendar;
	public class Inventor {
		private String name;
		private String nationality;
		private String[] inventions;
		private Date birthdate;
		private PlaceOfBirth placeOfBirth;
		public Inventor(String name, String nationality) {
			GregorianCalendar c= new GregorianCalendar();
			this.name = name;
			this.nationality = nationality;
			this.birthdate = c.getTime();
		public Inventor(String name, Date birthdate, String nationality) {
			this.name = name;
			this.nationality = nationality;
			this.birthdate = birthdate;
		public Inventor() {
		public String getName() {
			return name;
		public void setName(String name) {
			this.name = name;
		public String getNationality() {
			return nationality;
		public void setNationality(String nationality) {
			this.nationality = nationality;
		public Date getBirthdate() {
			return birthdate;
		public void setBirthdate(Date birthdate) {
			this.birthdate = birthdate;
		public PlaceOfBirth getPlaceOfBirth() {
			return placeOfBirth;
		public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {
			this.placeOfBirth = placeOfBirth;
		public void setInventions(String[] inventions) {
			this.inventions = inventions;

public String[] getInventions() {
			return inventions;
	package org.spring.samples.spel.inventor
Java
	package org.spring.samples.spel.inventor;
	public class PlaceOfBirth {
		private String city;
		private String country;
		public PlaceOfBirth(String city) {
			this.city=city;
		public PlaceOfBirth(String city, String country) {
			this(city);
			this.country = country;
		public String getCity() {
			return city;
		public void setCity(String s) {
			this.city = s;
		public String getCountry() {
			return country;
		public void setCountry(String country) {
			this.country = country;
	package org.spring.samples.spel.inventor
Java
	package org.spring.samples.spel.inventor;
	import java.util.*;
	public class Society {
		private String name;
		public static String Advisors = "advisors";
		public static String President = "president";
		private List<Inventor> members = new ArrayList<>();
		private Map officers = new HashMap();
		public List getMembers() {
			return members;
		public Map getOfficers() {
			return officers;
		public String getName() {
			return name;
		public void setName(String name) {
			this.name = name;
		public boolean isMember(String name) {
			for (Inventor inventor : members) {

if (inventor.getName().equals(name)) {
					return true;
			return false;
	package org.spring.samples.spel.inventor
	class Society {

Пример АОП.
Теперь, когда вы увидели, как работают все составные части, мы можем собрать их вместе, чтобы сделать что-то полезное.
Пример АОП.
Выполнение бизнес-сервисов иногда может завершаться сбоем из-за проблем параллелизма (например, например, проигравший в тупике).
Если операцию повторить, она, скорее всего, завершится успешно. при следующей попытке.
Для бизнес-услуг, где уместно повторить попытку в таком условия (идемпотентные операции, которым не нужно возвращаться к пользователю в случае конфликта разрешение), мы хотим прозрачно повторить операцию, чтобы клиент не увидел `PessimisticLockingFailureException`.
Это требование, которое явно затрагивает несколько сервисов на уровне сервисов и, следовательно, идеально подходит для реализации через аспект.
Пример АОП.
Поскольку мы хотим повторить операцию, нам нужно воспользоваться советом, чтобы мы могли вызовите `proceed` несколько раз.
В следующем листинге показана реализация основного аспекта: См. пример кода в исходном документе.
Пример АОП. `@Around("com.xyz.CommonPointcuts.businessService()")` ссылается на `businessService` с именем pointcut, определенный в
Пример АОП.
Обратите внимание, что этот аспект реализует интерфейс Ordered, поэтому мы можем установить приоритет аспект выше, чем совет по транзакции (мы хотим новую транзакцию каждый раз, когда мы повторите попытку).
Свойства maxRetries и order настраиваются Spring.
Основное действие происходит в doConcurrentOperation вокруг совета.

Обратите внимание, что для В этот момент мы применяем логику повтора к каждому «businessService».
Мы пытаемся продолжить, и если мы потерпим неудачу с PessimisticLockingFailureException, мы попробуем еще раз, если только мы исчерпали все наши повторные попытки.
Пример АОП.
Соответствующая конфигурация Spring следующая: См. пример кода в исходном документе.
Пример АОП.
Чтобы уточнить этот аспект, чтобы он повторял только идемпотентные операции, мы могли бы определить следующее `Идемпотентная` аннотация: См. пример кода в исходном документе.
Пример АОП.
Затем мы можем использовать аннотацию для аннотирования реализации сервисных операций.
Изменение аспект, позволяющий повторять только идемпотентные операции, требует уточнения pointcut выражение, чтобы совпадали только операции `@Idempotent`, как показано ниже: См. пример кода в исходном документе.

Язык выражений Spring (SpEL).
Язык выражений Spring (сокращенно SpEL) — это мощный язык выражений, который поддерживает запросы и манипулирование графом объектов во время выполнения.
Синтаксис языка аналогично https://jakarta.ee/specifications/expression-language/[Jakarta Expression Language], но предлагает дополнительные функции, в первую очередь вызов метода и базовую строку. функциональность шаблонов.
Язык выражений Spring (SpEL).
Хотя существует несколько других языков выражений Java — OGNL, MVEL и JBoss EL, и это лишь некоторые из них: язык выражений Spring был создан для обеспечения Сообщество Spring с единым хорошо поддерживаемым языком выражений, который можно использовать повсюду. все продукты из портфолио Spring.
Его языковые особенности обусловлены требования проектов в портфолио Spring, включая требования к инструментам для завершение кода в рамках поддержки IDE {spring-site-tools}[Spring Tools].
Тем не менее, SpEL основан на независимом от технологии API, который позволяет другим реализациям языка выражений интегрироваться, если возникнет такая необходимость.
Язык выражений Spring (SpEL).
Хотя SpEL служит основой для оценки выражений в Spring портфолио, он не привязан напрямую к Spring и может использоваться независимо.
Чтобы быть самодостаточным, во многих примерах в этой главе используется SpEL, как если бы это был самостоятельный язык выражения.
Это требует создания нескольких начальных настроек классы инфраструктуры, такие как синтаксический анализатор.

Большинству пользователей Spring не нужно иметь дело с эту инфраструктуру и вместо этого может создавать только строки выражений для оценки.
Примером такого типичного использования является интеграция SpEL в создание XML или определения bean-компонентов на основе аннотаций, как показано на рисунке
Язык выражений Spring (SpEL).
В этой главе рассматриваются особенности языка выражений, его API и языка. синтаксис.
В нескольких местах в качестве целевых используются классы Inventor и Society. объекты для оценки выражений.
Эти объявления классов и данные, используемые для для их заполнения перечислены в конце главы.
* Буквальные выражения
* Доступ к свойствам, массивам, спискам и картам.
* Встроенные списки
* Встроенные карты
* Построение массива
* Реляционные операторы
* Регулярные выражения
* Логические операторы
* Строковые операторы
* Математические операторы
* Назначение
* Введите выражения
* Вызов метода
* Вызов конструктора
* Переменные
* Пользовательские функции
* Ссылки на бобы
* Тернарный оператор, Элвис и операторы безопасной навигации.
* Проекция коллекции
* Выбор коллекции
* Шаблонные выражения

Определение новых типов советов.
Spring AOP спроектирован так, чтобы его можно было расширять.
Хотя стратегия реализации перехвата в настоящее время используется внутри компании, можно поддерживать произвольные типы советов в помимо перехвата вокруг советов, раньше кидает советы, и после возвращения совета.
Определение новых типов советов.
Пакет `org.springframework.aop.framework.adapter` — это пакет SPI, который позволяет поддержка новых типов пользовательских советов может быть добавлена без изменения базовой структуры.
Единственное ограничение для пользовательского типа Advice заключается в том, что он должен реализовывать Интерфейс маркера `org.aopalliance.aop.Advice`.
Определение новых типов советов.
См. {spring-framework-api}/aop/framework/adapter/package-summary.html[`org.springframework.aop.framework.adapter`] javadoc для получения дополнительной информации.

Соавторы автопроводки.
Контейнер Spring может автоматически связывать отношения между взаимодействующими компонентами.
Вы можете пусть Spring автоматически разрешает соавторов (другие bean-компоненты) для вашего bean-компонента проверка содержимого `ApplicationContext`.
Автопроводка имеет следующее преимущества:
* Автосвязывание может значительно снизить необходимость указания свойств или конструктора.
* Автосвязывание может обновлять конфигурацию по мере развития ваших объектов. Например, если вам нужно
аргументы. (Другие механизмы, такие как шаблон компонента в этом отношении.). чтобы добавить зависимость к классу, эта зависимость может быть удовлетворена автоматически без вам нужно изменить конфигурацию.
Таким образом, автоматическое подключение может быть особенно полезным. во время разработки, не отрицая возможности перехода на явную проводку при база кода становится более стабильной.
аргументы. (Другие механизмы, такие как шаблон компонента в этом отношении.).
При использовании метаданных конфигурации на основе XML (см. можно указать режим автоматического подключения для определения компонента с помощью атрибута `autowire` Элемент `<bean/>`.
Функция автоматического подключения имеет четыре режима.
Вы указываете автопроводку для каждого компонента и, таким образом, может выбирать, какие из них автоматически подключать.
В следующей таблице описаны четыре режима автоматического подключения:
.Режимы автоподключения [cols="20%,80%"] |=== | Режим| Объяснение. | `нет` | (По умолчанию) Без автоматического подключения.

Ссылки на компоненты должны определяться элементами `ref`.
Изменение настройку по умолчанию не рекомендуется использовать для более крупных развертываний, поскольку указание Соавторы явно обеспечивают больший контроль и ясность.
В какой-то степени это документирует структуру системы.
.Режимы автоподключения [cols="20%,80%"] |=== | Режим| Объяснение. | `поИмени` | Автоподключение по имени свойства.
Spring ищет компонент с тем же именем, что и свойство, которое необходимо автоматически подключить.
Например, если для определения компонента установлено значение autowire по имени и содержит свойство master (т. е. имеет свойство `setMaster(..)`), Spring ищет определение компонента с именем `master` и использует это для установки свойства.
.Режимы автоподключения [cols="20%,80%"] |=== | Режим| Объяснение. | `потипу` | Позволяет автосвязывать свойство, если в нем существует ровно один компонент типа свойства. контейнер.
Если существует более одного, выдается фатальное исключение, которое указывает что вы не можете использовать автоподключение по типу для этого компонента.
Если нет совпадений beans, ничего не происходит (свойство не установлено).
.Режимы автоподключения [cols="20%,80%"] |=== | Режим| Объяснение. | `конструктор` | Аналогично `byType`, но применяется к аргументам конструктора.

Если нет точно одного bean-компонента с типом аргумента конструктора в контейнере, возникает фатальная ошибка. |===
.Режимы автоподключения [cols="20%,80%"] |=== | Режим| Объяснение.
В режиме автоматического связывания по типу или конструктору вы можете связывать массивы и типизированные коллекции.
В таких случаях все кандидаты на автоподключение внутри контейнера, который соответствующие ожидаемому типу, предоставляются для удовлетворения зависимости.
Вы можете выполнить автоматическое подключение строго типизированные экземпляры Map, если ожидаемый тип ключа — String.
Автоматически подключенная «Карта» значения экземпляра состоят из всех экземпляров компонента, соответствующих ожидаемому типу, а Ключи экземпляра Map содержат соответствующие имена компонентов.
Ограничения и недостатки автоматического подключения.
Автоматическое связывание работает лучше всего, когда оно используется последовательно во всем проекте.
Если автопроводка не используется вообще, разработчикам может быть сложно использовать его для подключения только одного или два определения bean-компонентов.
* Явные зависимости в настройках `property` и `constructor-arg` всегда переопределяют.
Рассмотрим ограничения и недостатки автопроводки:. автопроводка.
Вы не можете автоматически связывать простые свойства, такие как примитивы, `Строки` и `Классы` (и массивы таких простых свойств).
Это ограничение по дизайну.
* Автоматическое связывание менее точное, чем явное связывание. Хотя, как отмечалось в предыдущей таблице,
Рассмотрим ограничения и недостатки автопроводки:.

Spring старается избегать догадок в случае двусмысленности, которая может иметь неожиданные последствия. результаты.
Отношения между объектами, управляемыми Spring, больше не являются документировано явно.
* Информация о проводке может быть недоступна для инструментов, которые могут создавать документацию из
Рассмотрим ограничения и недостатки автопроводки:. контейнер Spring.
* Несколько определений bean-компонентов в контейнере могут соответствовать типу, указанному в
Рассмотрим ограничения и недостатки автопроводки:. метод установки или аргумент конструктора для автоматического подключения.
Для массивов, коллекций или `Map` экземпляры, это не обязательно проблема.
Однако для зависимостей, которые ожидать единственного значения, эта двусмысленность не разрешается произвольно.
Если нет уникального компонента определение доступно, выдается исключение.
* Отказ от автоматического подключения в пользу явного подключения.
* Избегайте автоматического связывания для определения компонента, устанавливая его атрибуты autowire-candidate.
* Назначьте одно определение компонента в качестве основного кандидата, установив
на «ложь», как описано в.
Для атрибута `primary` элемента `<bean/>` установлено значение `true`.
* Реализуйте более детальный контроль, доступный в конфигурации на основе аннотаций,
на «ложь», как описано в. как описано в Конфигурация контейнера на основе аннотаций.
Исключение компонента из автоматического подключения.
Для каждого компонента вы можете исключить компонент из автоматического подключения.

В формате Spring XML установите атрибут `autowire-candidate` элемента `<bean/>` имеет значение `false`; с `@Bean` аннотации, атрибут называется autowireCandidate.
Контейнер делает это особенным определение bean-компонента недоступно для инфраструктуры автоматического подключения, включая основанное на аннотациях точки внедрения, такие как `@Autowired`.
Исключение компонента из автоматического подключения.
ПРИМЕЧАНИЕ.
Атрибут autowire-candidate предназначен только для автоматического связывания на основе типа.
Это не влияет на явные ссылки по имени, которые разрешаются, даже если указанный компонент не помечен как кандидат для автоматического подключения.
Как следствие, автопроводка по имени, тем не менее, внедряет компонент, если имя совпадает.
Исключение компонента из автоматического подключения.
Вы также можете ограничить кандидатов для автоматического подключения на основе сопоставления шаблонов с именами компонентов.
Элемент верхнего уровня `<beans/>` принимает один или несколько шаблонов внутри своего Атрибут `default-autowire-candidates`.
Например, чтобы ограничить статус кандидата на автоматическое подключение. для любого компонента, имя которого заканчивается на `Repository`, укажите значение `*Repository`.
Чтобы предоставить несколько шаблонов, определить их в списке, разделенном запятыми.
Явное значение `true` или `false` для атрибута `autowire-candidate` определения компонента всегда принимает значение приоритет.
Для таких bean-компонентов правила сопоставления с образцом не применяются.
Исключение компонента из автоматического подключения.

Эти методы полезны для компонентов, которые вы никогда не хотите внедрять в другие компоненты. путем автопроводки.
Это не означает, что исключенный компонент не может быть настроен самостоятельно. с использованием автопроводки.
Скорее, сам компонент не является кандидатом на автоматическое подключение других компонентов.
Исключение компонента из автоматического подключения. [ПРИМЕЧАНИЕ] = Начиная с версии 6.2, методы `@Bean` поддерживают два варианта флага-кандидата автоматического подключения: `autowireCandidate` и `defaultCandidate`.
Исключение компонента из автоматического подключения.
При использовании квалификаторы компонент, отмеченный `defaultCandidate=false`, доступен только для точек внедрения. где присутствует дополнительное указание квалификатора.
Это полезно для ограниченных делегаты, которые должны быть инъекционными в определенных областях, но не предназначены для мешаться бобам того же типа в других местах.
Такой боб никогда не будет вводится только по простому объявленному типу, а не по типу плюс конкретный квалификатор.
Исключение компонента из автоматического подключения.
Напротив, autowireCandidate=false ведет себя точно так же, как autowire-candidate. атрибут, как описано выше: такой компонент вообще никогда не будет внедрен по типу.

Внедрение зависимостей (DI) — это процесс, при котором объекты определяют свои зависимости. (то есть другие объекты, с которыми они работают) только через аргументы конструктора, аргументы фабричного метода или свойства, которые установлены в экземпляре объекта после он создается или возвращается из фабричного метода.
Затем контейнер вводит эти зависимости при создании компонента.
Этот процесс по сути является обратным (следовательно, имя Inversion of Control) самого компонента, управляющего созданием экземпляра. или расположение его зависимостей самостоятельно, используя прямую конструкцию классов или шаблон локатора службы.
Внедрение зависимостей.
Код становится чище благодаря принципу DI, а развязка более эффективна, когда объекты снабжены их зависимостями.
Объект не ищет свои зависимости и не выполняет не знать расположение или класс зависимостей.
В результате ваши занятия станут проще. для тестирования, особенно когда зависимости связаны с интерфейсами или абстрактными базовыми классами, которые позволяют использовать заглушки или макетные реализации в модульных тестах.
Внедрение зависимостей.
DI существует в двух основных вариантах: и внедрение зависимостей на основе сеттера.
Внедрение зависимостей на основе конструктора.
DI на основе конструктора выполняется контейнером, вызывающим конструктор с помощью количество аргументов, каждый из которых представляет зависимость.
Вызов статического фабричного метода с конкретными аргументами для создания компонента почти эквивалентно, и это обсуждение обрабатывает аргументы конструктора и статического фабричного метода одинаково.
В следующем примере показан класс, который может быть внедрен только с помощью конструктора инъекция:
Java
	public class SimpleMovieLister {
		// SimpleMovieLister зависит от MovieFinder

private final MovieFinder movieFinder;
		// конструктор, чтобы контейнер Spring мог внедрить MovieFinder
		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		// которая бизнес-логика, фактически использует внедрение MovieFinder, опущена...
Внедрение зависимостей на основе конструктора.
Обратите внимание, что в этом классе нет ничего особенного.
Это POJO, который не зависит от конкретных интерфейсов контейнера, базовых классов или аннотаций.
Разрешение аргументов конструктора.
Сопоставление разрешения аргументов конструктора происходит с использованием типа аргумента.
Если нет потенциальная двусмысленность существует в аргументах конструктора определения компонента, Порядок, в котором аргументы конструктора определяются в определении компонента, — это порядок в котором эти аргументы передаются соответствующему конструктору, когда компонент создается экземпляр.
Рассмотрим следующий класс:
Java
	package x.y;
	public class ThingOne {
		public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
	package x.y
	class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)
Разрешение аргументов конструктора.
Предполагая, что классы ThingTwo и ThingThree не связаны наследованием, нет существует потенциальная двусмысленность.
Таким образом, следующая конфигурация работает нормально, и вы не необходимо явно указать индексы или типы аргументов конструктора в Элемент `<constructor-arg/>`.
	<beans>
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg ref="beanTwo"/>
			<constructor-arg ref="beanThree"/>

</bean>
		<bean id="beanTwo" class="x.y.ThingTwo"/>
		<bean id="beanThree" class="x.y.ThingThree"/>
	</beans>
Разрешение аргументов конструктора.
При ссылке на другой компонент тип известен и может произойти сопоставление (как это было в случае с случай с предыдущим примером).
При использовании простого типа, например `<value>true</value>`, Spring не может определить тип значения и поэтому не может сопоставить его по типу без помощи.
Рассмотрим следующий класс:
Java
	package examples;
	public class ExampleBean {
		// Количество лет для расчета окончательного ответа
		private final int years;
		// Ответ на вопрос о жизни, Вселенной и всем остальном
		private final String ultimateAnswer;
		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
	package examples
[дискретный] Соответствие типов аргументов конструктора.
В предыдущем сценарии контейнер может использовать сопоставление типов с простыми типами, если вы явно указываете тип аргумента конструктора через атрибут type, как показано в следующем примере:
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg type="int" value="7500000"/>
		<constructor-arg type="java.lang.String" value="42"/>

</bean>
[дискретный] Индекс аргумента конструктора.
Вы можете использовать атрибут index, чтобы явно указать индекс аргументов конструктора. как показано в следующем примере:
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg index="0" value="7500000"/>
		<constructor-arg index="1" value="42"/>
	</bean>
[дискретный] Индекс аргумента конструктора.
Помимо разрешения неоднозначности нескольких простых значений, указание индекса устраняет неоднозначность, когда конструктор имеет два аргумента одного типа.
[дискретный] Индекс аргумента конструктора.
ПРИМЕЧАНИЕ.
Индекс начинается с 0.
[дискретный] Имя аргумента конструктора.
Вы также можете использовать имя параметра конструктора для устранения неоднозначности значения, как показано ниже. пример показывает:
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg name="years" value="7500000"/>
		<constructor-arg name="ultimateAnswer" value="42"/>
	</bean>
[дискретный] Имя аргумента конструктора.
Имейте в виду, что для того, чтобы эта работа работала «из коробки», ваш код должен быть скомпилирован с использованием Флаг `-parameters` включен, чтобы Spring мог искать имя параметра в конструкторе.

Если вы не можете или не хотите компилировать свой код с флагом «-parameters», вы можете использовать команду https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html[@ConstructorProperties] Аннотация JDK для явного указания аргументов конструктора.
Пример класса будет тогда надо выглядеть следующим образом:
Java
	package examples;
	public class ExampleBean {
		// Поля опущены
		@ConstructorProperties({"years", "ultimateAnswer"})
		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
	package examples
Внедрение зависимостей на основе сеттера.
Внедрение на основе сеттера осуществляется контейнером, вызывающим методы сеттера на вашем компьютере. bean-компоненты после вызова конструктора без аргументов или «статического» фабричного метода без аргументов для создайте экземпляр вашего bean-компонента.
Внедрение зависимостей на основе сеттера.
В следующем примере показан класс, в который можно внедрить зависимости только с помощью чистого инъекция сеттера.
Этот класс представляет собой обычный Java.
Это POJO, у которого нет зависимостей. в интерфейсах, специфичных для контейнера, базовых классах или аннотациях.
Java
	public class SimpleMovieLister {
		// SimpleMovieLister зависит от MovieFinder
		private MovieFinder movieFinder;
		// метод установки в контейнер Spring можно внедрить MovieFinder
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;

// которая бизнес-логика, фактически использует внедрение MovieFinder, опущена...
	// которая бизнес-логика, фактически использует внедрение MovieFinder, опущена...
class SimpleMovieLister {. `ApplicationContext` поддерживает DI на основе конструктора и установщика для bean-компонентов, которые он использует. управляет.
Он также поддерживает DI на основе установщика после того, как некоторые зависимости уже были установлены. вводится с помощью конструктора.
Вы настраиваете зависимости в виде `BeanDefinition`, который вы используете вместе с экземплярами `PropertyEditor` для конвертировать свойства из одного формата в другой.
Однако у большинства пользователей Spring не работает с этими классами напрямую (то есть программно), а скорее с XML-компонентом определения, аннотированные компоненты (то есть классы, аннотированные `@Component`, `@Controller` и т. д.) или методы `@Bean` в Java-классах `@Configuration`.
Эти источники затем внутренне конвертируются в экземпляры BeanDefinition и используются для загрузить весь экземпляр контейнера Spring IoC.
class SimpleMovieLister {.
DI на основе конструктора или установщика? **** Поскольку вы можете смешивать DI на основе конструктора и установщика, хорошим практическим правилом является используйте конструкторы для обязательных зависимостей и методов установки или методов конфигурации. для необязательных зависимостей.

Обратите внимание, что использование файла @Autowired аннотацию к методу установки можно использовать, чтобы сделать свойство обязательной зависимостью; однако внедрение конструктора с программной проверкой аргументов предпочтительнее.
class SimpleMovieLister {.
Команда Spring обычно выступает за внедрение конструктора, поскольку оно позволяет реализовать компоненты приложения как неизменяемые объекты и гарантируют, что необходимые зависимости не являются «нулевыми».
Более того, компоненты, внедренные конструктором, всегда возвращаются клиенту. (вызывающий) код в полностью инициализированном состоянии.
В качестве примечания: большое количество конструкторов аргументы — это неприятный запах кода, подразумевающий, что в классе, вероятно, слишком много аргументов. обязанности и должны быть переработаны для более эффективного разделения задач.
class SimpleMovieLister {.
Внедрение сеттера в первую очередь следует использовать только для необязательных зависимостей, которые могут быть присвоены разумные значения по умолчанию внутри класса.
В противном случае должны быть выполнены ненулевые проверки. выполняется везде, где код использует зависимость.
Одним из преимуществ внедрения сеттеров является то, что методы установки делают объекты этого класса доступными для реконфигурации или повторного внедрения. позже.
Таким образом, управление посредством JMX MBeans является привлекательным вариант использования для инъекции сеттера.
class SimpleMovieLister {.
Используйте стиль DI, который наиболее подходит для конкретного класса.
Иногда при общении со сторонними классами, для которых у вас нет исходников, выбор делается за вами.

Например, если сторонний класс не предоставляет никаких методов установки, тогда конструктор инъекции могут быть единственной доступной формой DI. ****
* ApplicationContext создается и инициализируется метаданными конфигурации, которые
Контейнер выполняет разрешение зависимостей компонентов следующим образом:. описывает все бобы.
Метаданные конфигурации могут быть заданы с помощью XML, кода Java или аннотации.
* Для каждого bean-компонента его зависимости выражаются в виде свойств, конструктора
Контейнер выполняет разрешение зависимостей компонентов следующим образом:. аргументы или аргументы метода статической фабрики (если вы используете их вместо обычный конструктор).
Эти зависимости предоставляются компоненту, когда компонент фактически создан.
* Каждое свойство или аргумент конструктора представляет собой фактическое определение устанавливаемого значения или
Контейнер выполняет разрешение зависимостей компонентов следующим образом:. ссылка на другой компонент в контейнере.
* Каждое свойство или аргумент конструктора, являющееся значением, преобразуется из указанного значения.
Контейнер выполняет разрешение зависимостей компонентов следующим образом:. форматировать фактический тип этого свойства или аргумента конструктора.
По умолчанию весна может преобразовать значение, предоставленное в строковом формате, во все встроенные типы, такие как `int`, `long`, `String`, `boolean` и т. д.
Контейнер выполняет разрешение зависимостей компонентов следующим образом:.
Контейнер Spring проверяет конфигурацию каждого компонента при создании контейнера.
Однако сами свойства компонента не устанавливаются до тех пор, пока компонент не будет фактически создан.

Создаются bean-компоненты с одноэлементной областью действия и настроенные на предварительное создание экземпляров (по умолчанию). при создании контейнера.
Области действия определены в файле Области компонентов.
В противном случае компонент создается только тогда, когда он запрошен.
Создание bean-компонента потенциально приводит к граф создаваемых bean-компонентов, а также зависимости bean-компонента и его зависимости зависимости (и т. д.) создаются и назначаются.
Обратите внимание, что разрешение не совпадает между эти зависимости могут проявиться поздно, то есть при первом создании затронутого компонента.
Контейнер выполняет разрешение зависимостей компонентов следующим образом:. .Циркулярные зависимости **** Если вы используете преимущественно внедрение конструктора, можно создать неразрешимую задачу.
Сценарий циклической зависимости.
Контейнер выполняет разрешение зависимостей компонентов следующим образом:.
Например: классу A требуется экземпляр класса B посредством внедрения конструктора, и классу B требуется экземпляр класса A посредством внедрения конструктора.
Если вы настроите bean-компоненты для классов A и B, которые будут внедряться друг в друга, контейнер Spring IoC обнаруживает эту циклическую ссылку во время выполнения и выдает `BeanCurrentlyInCreationException`.
Контейнер выполняет разрешение зависимостей компонентов следующим образом:.
Одним из возможных решений является редактирование исходного кода некоторых классов, которые будут настроены с помощью сеттеры, а не конструкторы.
В качестве альтернативы избегайте внедрения конструктора и используйте только инъекция сеттера.
Другими словами, хотя это и не рекомендуется, вы можете настроить циклические зависимости с внедрением сеттера.

Контейнер выполняет разрешение зависимостей компонентов следующим образом:.
В отличие от типичного случая (без циклических зависимостей), циклическая зависимость между бобами А и бобами Б заставляет один из бобов впрыскиваться в другой до того, как быть полностью инициализированным (классический сценарий «курица и яйцо»). ****
Контейнер выполняет разрешение зависимостей компонентов следующим образом:.
В целом вы можете быть уверены, что Spring поступит правильно.
Он обнаруживает проблемы конфигурации, такие как ссылки на несуществующие bean-компоненты и циклические зависимости в контейнере время загрузки.
Spring устанавливает свойства и разрешает зависимости как можно позже, когда бин фактически создан.
Это означает, что контейнер Spring, который загрузил правильно может позже сгенерировать исключение при запросе объекта, если есть проблема с созданием этого объекта или одной из его зависимостей - например, компонент выдает исключение в результате отсутствия или недопустимого свойства.
Это потенциально задерживает видимость некоторых проблем с конфигурацией — вот почему реализации `ApplicationContext` одноэлементные bean-компоненты по умолчанию перед созданием экземпляра.
Ценой некоторого предварительного времени и памяти, чтобы создайте эти bean-компоненты до того, как они действительно понадобятся, вы обнаружите проблемы с конфигурацией при создании `ApplicationContext`, не позже.
Вы все равно можете переопределить это значение по умолчанию. поведение, чтобы одноэлементные компоненты инициализировались лениво, а не с нетерпением. предварительно созданный.
Контейнер выполняет разрешение зависимостей компонентов следующим образом:.

Если циклических зависимостей не существует, когда один или несколько взаимодействующих компонентов впрыскивается в зависимый компонент, каждый сотрудничающий компонент предварительно полностью конфигурируется. для внедрения в зависимый компонент.
Это означает, что если компонент A зависит от bean B, контейнер Spring IoC полностью настраивает bean B перед вызовом метод установки для bean-компонента A.
Другими словами, создается экземпляр bean-компонента (если он не является предварительно созданный синглтон), его зависимости установлены и соответствующий жизненный цикл методы (например, bean [настроенный метод инициализации]) или метод обратного вызова InitializingBean) вызываются.
Примеры внедрения зависимостей.
В следующем примере используются метаданные конфигурации на основе XML для DI на основе установщика.
Маленький часть файла конфигурации Spring XML определяет некоторые определения bean-компонентов следующим образом:
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- setter injection using the nested ref element -->
		<property name="beanOne">
			<ref bean="anotherExampleBean"/>
		</property>
		<!-- setter injection using the neater ref attribute -->
		<property name="beanTwo" ref="yetAnotherBean"/>
		<property name="integerProperty" value="1"/>
	</bean>
	<bean id="anotherExampleBean" class="examples.AnotherBean"/>

<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
Java
	public class ExampleBean {
		private AnotherBean beanOne;
		private YetAnotherBean beanTwo;
		private int i;
		public void setBeanOne(AnotherBean beanOne) {
			this.beanOne = beanOne;
		public void setBeanTwo(YetAnotherBean beanTwo) {
			this.beanTwo = beanTwo;
		public void setIntegerProperty(int i) {
			this.i = i;
В следующем примере показан соответствующий класс ExampleBean:.
В предыдущем примере объявлены сеттеры, соответствующие указанным свойствам. в XML-файле.
В следующем примере используется внедрение зависимостей на основе конструктора:
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- constructor injection using the nested ref element -->
		<constructor-arg>
			<ref bean="anotherExampleBean"/>
		</constructor-arg>
		<!-- constructor injection using the neater ref attribute -->
		<constructor-arg ref="yetAnotherBean"/>
		<constructor-arg type="int" value="1"/>
	</bean>
	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
Java
	public class ExampleBean {
		private AnotherBean beanOne;
		private YetAnotherBean beanTwo;
		private int i;
		public ExampleBean(

AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
			this.beanOne = anotherBean;
			this.beanTwo = yetAnotherBean;
			this.i = i;
В следующем примере показан соответствующий класс ExampleBean:.
Аргументы конструктора, указанные в определении компонента, используются в качестве аргументов для конструктор `ExampleBean`.
В следующем примере показан соответствующий класс ExampleBean:.
Теперь рассмотрим вариант этого примера, где вместо использования конструктора Spring сказано вызвать `статический` фабричный метод для возврата экземпляра объекта:
	<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
		<constructor-arg ref="anotherExampleBean"/>
		<constructor-arg ref="yetAnotherBean"/>
		<constructor-arg value="1"/>
	</bean>
	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
Java
	public class ExampleBean {
		// частный конструктор
		private ExampleBean(...) {
		// статический фабричный метод; аргументы этого метода могут быть
		// учитываем зависимости возвращаемого компонента,
		// независимо от того, как на самом деле используются эти аргументы.
		public static ExampleBean createInstance (
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
			ExampleBean eb = new ExampleBean (...);

// еще какие-то операции...
			return eb;
В следующем примере показан соответствующий класс ExampleBean:.
Аргументы фабричного метода static предоставляются элементами <constructor-arg/>`, точно так же, как если бы конструктор действительно использовался.
Тип класса, который является возвращаемый фабричным методом, не обязательно должен быть того же типа, что и класс, который содержит `статический` фабричный метод (хотя в этом примере он есть).
Экземпляр (нестатический) фабричный метод может использоваться практически идентичным образом (кроме из-за использования атрибута Factory-Bean вместо атрибута Class), поэтому мы не обсуждайте эти детали здесь.

Использование `зависит от`.
Если компонент является зависимостью другого компонента, это обычно означает, что один компонент установлен как собственность другого.
Обычно это достигается с помощью в метаданных на основе XML или через autowiring.
Использование `зависит от`.
Однако иногда зависимости между компонентами менее прямые.
Пример: статический инициализатор в классе должен быть запущен, например, для регистрации драйвера базы данных.
Атрибут «зависит от» или аннотация «@DependsOn» могут явно принудительно принудительно использовать один или несколько компонентов. должен быть инициализирован до инициализации компонента, использующего этот элемент.
Следующий пример использует атрибут «зависит от» для выражения зависимости от одного компонента:
	<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
	<bean id="manager" class="ManagerBean" />
Использование `зависит от`.
Чтобы выразить зависимость от нескольких компонентов, укажите список имен компонентов в качестве значения атрибут «зависит от» (запятые, пробелы и точки с запятой допустимы) разделители):
	<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
		<property name="manager" ref="manager" />
	</bean>
	<bean id="manager" class="ManagerBean" />

<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
Использование `зависит от`.
ПРИМЕЧАНИЕ.
Атрибут «зависит от» может указывать как зависимость времени инициализации, так и в случае с singleton только beans, соответствующая зависимость от времени разрушения.
Зависимые bean-компоненты, которые определяют Отношения «зависит от» с данным компонентом уничтожаются первыми, до данного компонента. сам разрушается.
Таким образом, «зависит от» также может управлять порядком завершения работы.

Точки расширения контейнера.
Обычно разработчику приложения не требуется создавать подкласс ApplicationContext. классы реализации.
Вместо этого контейнер Spring IoC можно расширить, подключив реализации специальных интерфейсов интеграции.
Следующие несколько разделов описывают эти интерфейсы интеграции.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Интерфейс `BeanPostProcessor` определяет методы обратного вызова, которые вы можете реализовать для предоставить собственную логику создания экземпляров (или переопределить стандартную для контейнера), зависимость логика разрешения и так далее.
Если вы хотите реализовать некоторую пользовательскую логику после Контейнер Spring завершает создание экземпляра, настройку и инициализацию компонента, вы можете подключите одну или несколько пользовательских реализаций BeanPostProcessor.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Вы можете настроить несколько экземпляров BeanPostProcessor и контролировать их порядок. в котором эти экземпляры BeanPostProcessor запускаются путем установки свойства order.
Вы можете установить это свойство, только если BeanPostProcessor реализует Ordered. интерфейс.
Если вы пишете свой собственный BeanPostProcessor, вам следует рассмотреть возможность реализации интерфейс Ordered тоже.
Для получения более подробной информации см.
Javadoc {spring-framework-api}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`] и интерфейсы {spring-framework-api}/core/Ordered.html[`Ordered`].
См. также примечание о
Настройка Bean-компонентов с помощью BeanPostProcessor. [ПРИМЕЧАНИЕ] = Экземпляры `BeanPostProcessor` работают с экземплярами bean-компонентов (или объектов).

То есть, контейнер Spring IoC создает экземпляр экземпляра bean-компонента, а затем `BeanPostProcessor` экземпляры делают свою работу.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Экземпляры BeanPostProcessor имеют область действия для каждого контейнера.
Это актуально только в том случае, если вы использовать иерархии контейнеров.
Если вы определите BeanPostProcessor в одном контейнере, он обрабатывает только bean-компоненты в этом контейнере.
Другими словами, бобы, которые определенные в одном контейнере, не подвергаются постобработке с помощью BeanPostProcessor, определенного в другой контейнер, даже если оба контейнера являются частью одной и той же иерархии.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Чтобы изменить фактическое определение компонента (то есть схему, определяющую компонент), вместо этого вам нужно использовать BeanFactoryPostProcessor, как описано в =
Настройка Bean-компонентов с помощью BeanPostProcessor.
Интерфейс `org.springframework.beans.factory.config.BeanPostProcessor` состоит из ровно два метода обратного вызова.
Когда такой класс регистрируется как постпроцессор с контейнер, для каждого экземпляра компонента, созданного контейнером, постпроцессор получает обратный вызов из контейнера перед контейнером методы инициализации (такие как `InitializingBean.afterPropertiesSet()` или любой другой объявленный метод `init`), и после инициализации любого компонента выполняются обратные вызовы.
Постпроцессор может выполнять любые действия с экземпляром компонента, включая игнорирование обратный вызов полностью.
Постпроцессор компонента обычно проверяет интерфейсы обратного вызова, или он может обернуть компонент прокси.

Некоторые классы инфраструктуры Spring AOP реализованы как постпроцессоры bean-компонентов для обеспечения логики прокси-обертывания.
Настройка Bean-компонентов с помощью BeanPostProcessor. `ApplicationContext` автоматически обнаруживает любые bean-компоненты, определенные в метаданные конфигурации, реализующие интерфейс BeanPostProcessor. `ApplicationContext` регистрирует эти bean-компоненты как постпроцессоры, чтобы их можно было вызывать позже, при создании компонента.
Постпроцессоры Bean могут быть развернуты в контейнере в так же, как и любые другие бобы.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Обратите внимание, что при объявлении BeanPostProcessor с использованием фабричного метода @Bean на класс конфигурации, тип возвращаемого значения фабричного метода должен быть реализацией сам класс или, по крайней мере, `org.springframework.beans.factory.config.BeanPostProcessor` интерфейс, четко указывающий на постпроцессорную природу этого компонента.
В противном случае `ApplicationContext` не может автоматически определить его по типу до его полного создания.
Поскольку экземпляр BeanPostProcessor должен быть создан заранее, чтобы примениться к инициализации других bean-компонентов в контексте, это раннее обнаружение типов имеет решающее значение.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Программная регистрация экземпляров BeanPostProcessor.
ПРИМЕЧАНИЕ.
Хотя рекомендуемый подход к регистрации BeanPostProcessor заключается в Автоопределение `ApplicationContext` (как описано ранее), их можно зарегистрировать программно против `ConfigurableBeanFactory` с помощью `addBeanPostProcessor` метод.

Это может быть полезно, когда вам нужно оценить условную логику перед регистрации или даже для копирования постпроцессоров компонентов между контекстами иерархии.
Однако обратите внимание, что экземпляры BeanPostProcessor, добавленные программно, не учитывают `Упорядоченный` интерфейс.
Здесь порядок регистрации диктует порядок исполнения.
Также обратите внимание, что экземпляры BeanPostProcessor регистрируются программно. всегда обрабатываются раньше тех, которые регистрируются посредством автоматического обнаружения, независимо от каких-либо явный порядок.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Экземпляры.`BeanPostProcessor` и автоматическое проксирование AOP [ПРИМЕЧАНИЕ] = Классы, реализующие интерфейс BeanPostProcessor, являются специальными и обрабатываются по-разному в зависимости от контейнера.
Все экземпляры BeanPostProcessor и bean-компоненты, которые они прямая ссылка создается при запуске, как часть специальной фазы запуска из `ApplicationContext`.
Далее регистрируются все экземпляры BeanPostProcessor. отсортированным образом и применяется ко всем остальным бобам в контейнере.
Потому что АОП автоматическое проксирование реализовано как сам BeanPostProcessor, а не как BeanPostProcessor. ни экземпляры, ни bean-компоненты, на которые они напрямую ссылаются, не подлежат автоматическому проксированию и, таким образом, в них не вплетены аспекты.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Для любого такого bean-компонента вы должны увидеть информационное сообщение журнала: `Bean someBean is not имеет право на обработку всеми интерфейсами BeanPostProcessor (например: не имеет право на автоматическое проксирование)`.
Настройка Bean-компонентов с помощью BeanPostProcessor.

Если у вас есть bean-компоненты, подключенные к вашему `BeanPostProcessor` с помощью автоматического подключения или `@Resource` (который может вернуться к автоподключению), Spring может получить доступ к неожиданным bean-компонентам при поиске кандидатов зависимостей, соответствующих типу, и, следовательно, сделать их не подходит для автоматического проксирования или других видов постобработки компонентов.
Например, если вы иметь зависимость, помеченную `@Resource`, где имя поля или установщика не указано напрямую соответствуют объявленному имени компонента и атрибут имени не используется, Spring обращается к другим компонентам для сопоставления их по типу.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Следующие примеры показывают, как писать, регистрировать и использовать экземпляры BeanPostProcessor. в `ApplicationContext`.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Пример: Hello World, стиль BeanPostProcessor.
Настройка Bean-компонентов с помощью BeanPostProcessor.
Этот первый пример иллюстрирует базовое использование.
В примере показан пользовательский Реализация `BeanPostProcessor`, которая вызывает метод `toString()` каждого bean-компонента как он создается контейнером и выводит полученную строку на системную консоль.
Java
	package scripting;
	import org.springframework.beans.factory.config.BeanPostProcessor;
	public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {
		// просто верните созданный компонент как есть
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean; // we could potentially return any object reference here...

public Object postProcessAfterInitialization(Object bean, String beanName) {
			System.out.println("Bean '" + beanName + "' created : " + bean.toString());
			return bean;
	package scripting
	class InstantiationTracingBeanPostProcessor : BeanPostProcessor {
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:lang="http://www.springframework.org/schema/lang"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/lang
			https://www.springframework.org/schema/lang/spring-lang.xsd">
		<lang:groovy id="messenger"
				script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
			<lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
		</lang:groovy>

когда создается экземпляр вышеуказанного bean-компонента (мессенджера), этот заказ
		Реализация BeanPostProcessor выведет этот факт на системную консоль.
		<bean class="scripting.InstantiationTracingBeanPostProcessor"/>
	</beans>
Следующий элемент beans использует InstantiationTracingBeanPostProcessor:.
Обратите внимание, что InstantiationTracingBeanPostProcessor просто определен.
Это не даже иметь имя, и, поскольку это bean-компонент, в него можно внедрить зависимости, как и в любой другой компонент. другой боб. (Предыдущая конфигурация также определяет компонент, поддерживаемый Groovy. сценарий.)
Java
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.scripting.Messenger;
	public final class Boot {
		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
			Messenger messenger = ctx.getBean("messenger", Messenger.class);
			System.out.println(messenger);
[literal,subs="дословно,цитаты"].
Компонент 'messenger' создан: org.springframework.scripting.groovy.GroovyMessenger org.springframework.scripting.groovy.GroovyMessenger@272961
[literal,subs="дословно,цитаты"].
Пример: AutowiredAnnotationBeanPostProcessor.
[literal,subs="дословно,цитаты"].

Использование интерфейсов обратного вызова или аннотаций в сочетании с пользовательским BeanPostProcessor. реализация — это распространенное средство расширения контейнера Spring IoC.
Примером является Spring `AutowiredAnnotationBeanPostProcessor` — реализация BeanPostProcessor` который поставляется с дистрибутивом Spring и автоматически подключает аннотированные поля, методы установки, и произвольные методы конфигурации.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Следующая точка расширения, которую мы рассмотрим, — это `org.springframework.beans.factory.config.BeanFactoryPostProcessor`.
Семантика этот интерфейс аналогичен интерфейсам BeanPostProcessor, с одним основным разница: `BeanFactoryPostProcessor` работает с метаданными конфигурации компонента.
То есть контейнер Spring IoC позволяет BeanFactoryPostProcessor читать метаданные конфигурации и, возможно, изменить их _до_ создания экземпляра контейнера любые bean-компоненты, кроме экземпляров BeanFactoryPostProcessor.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Вы можете настроить несколько экземпляров BeanFactoryPostProcessor и контролировать их порядок. который эти экземпляры `BeanFactoryPostProcessor` запускают, устанавливая свойство `order`.
Однако вы можете установить это свойство, только если BeanFactoryPostProcessor реализует `Упорядоченный` интерфейс.
Если вы пишете свой собственный BeanFactoryPostProcessor, вам следует рассмотрите возможность реализации интерфейса Ordered.
См. javadoc {spring-framework-api}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`] и интерфейсы {spring-framework-api}/core/Ordered.html[`Ordered`] для получения более подробной информации.

Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor. [ПРИМЕЧАНИЕ] = Если вы хотите изменить фактические экземпляры bean-компонента (то есть объекты, созданные из метаданных конфигурации), то вместо этого вам нужно использовать BeanPostProcessor. (описано ранее в Хотя технически возможно работать с экземплярами bean-компонентов внутри BeanFactoryPostProcessor. (например, используя `BeanFactory.getBean()`), это приводит к преждевременному созданию экземпляра bean-компонента, нарушение стандартного жизненного цикла контейнера.
Это может вызвать негативные побочные эффекты, такие как минуя постобработку bean-компонента.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Кроме того, экземпляры BeanFactoryPostProcessor ограничены для каждого контейнера.
Это актуально только если вы используете иерархии контейнеров.
Если вы определяете `BeanFactoryPostProcessor` в одном контейнере, он применяется только к определениям компонентов в этом контейнере.
Определения компонентов в одном контейнере не обрабатываются экземплярами BeanFactoryPostProcessor в другом контейнер, даже если оба контейнера являются частью одной и той же иерархии.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Постпроцессор фабрики компонентов запускается автоматически, когда он объявляется внутри `ApplicationContext`, чтобы применить изменения к метаданным конфигурации, которые определить контейнер.
Spring включает в себя ряд предопределенных фабрик компонентов. постпроцессоры, такие как PropertyOverrideConfigurer и `PropertySourcesPlaceholderConfigurer`.
Вы также можете использовать собственный BeanFactoryPostProcessor. -- например, для регистрации редакторов пользовательских свойств.

Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor. `ApplicationContext` автоматически обнаруживает любые развернутые в нем bean-компоненты, которые реализовать интерфейс BeanFactoryPostProcessor.
Он использует эти бобы в качестве фабрики по производству бобов. постпроцессоры в нужное время.
Вы можете развернуть эти bean-компоненты постпроцессора как вы бы выбрали любой другой боб.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
ПРИМЕЧАНИЕ.
Как и в случае с BeanPostProcessor, вы обычно не хотите настраивать ``BeanFactoryPostProcessor`` для отложенной инициализации.
Если ни один другой компонент не ссылается на `Bean(Factory)PostProcessor`, этот постпроцессор вообще не будет создан.
Таким образом, пометка его для отложенной инициализации будет проигнорирована, и `Bean(Factory)PostProcessor` будет быстро создан, даже если вы установите Атрибуту `default-lazy-init` присвоено значение `true` в объявлении вашего элемента `<beans />`.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Пример: замена заполнителя свойства с помощью PropertySourcesPlaceholderConfigurer.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Вы можете использовать PropertySourcesPlaceholderConfigurer для экстернализации значений свойств. из определения компонента в отдельном файле, используя стандартный формат Java «Свойства».
Это позволяет человеку, развертывающему приложение, настраивать его с учетом специфики среды. свойства, такие как URL-адреса баз данных и пароли, без сложностей и рисков изменение основного файла или файлов определения XML для контейнера.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.

Рассмотрим следующий фрагмент метаданных конфигурации на основе XML, где DataSource со значениями заполнителей определяется:
	<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<property name="locations" value="classpath:com/something/jdbc.properties"/>
	</bean>
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
В примере показаны свойства, настроенные из внешнего файла Properties.
Во время выполнения, к метаданным применяется PropertySourcesPlaceholderConfigurer, который заменяет некоторые свойства `DataSource`.
Заменяемые значения указываются как заполнители form pass:q[`${property-name}`], который соответствует стилю Ant, log4j и JSP EL.
Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor.
Фактические значения берутся из другого файла в стандартном формате Java «Свойства»:

[literal,subs="дословно,цитаты"]. jdbc.driverClassName=org.hsqldb.jdbcDriver jdbc.url=jdbc:hsqldb:hsql://production:9002 jdbc.username=sa jdbc.password=root
[literal,subs="дословно,цитаты"].
Таким образом, строка `${jdbc.username}` заменяется во время выполнения значением 'sa' и то же самое относится и к другим значениям-заполнителям, которые соответствуют ключам в файле свойств.
PropertySourcesPlaceholderConfigurer проверяет наличие заполнителей в большинстве свойств и атрибуты определения компонента.
Кроме того, вы можете настроить префикс заполнителя, суффикс, разделитель значений по умолчанию и escape-символ.
Кроме того, экранирование по умолчанию персонажа можно изменить или отключить глобально, установив параметр `spring.placeholder.escapeCharacter.default` через системное свойство JVM (или через механизм SpringProperties[`SpringProperties`]).
[literal,subs="дословно,цитаты"].
С помощью пространства имен context вы можете настроить заполнители свойств. со специальным элементом конфигурации.
Вы можете указать одно или несколько местоположений в качестве список, разделенный запятыми, в атрибуте location, как показано в следующем примере:
	<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
[literal,subs="дословно,цитаты"].

PropertySourcesPlaceholderConfigurer не только ищет свойства в свойстве. файл, который вы указываете.
По умолчанию, если не удается найти свойство в указанных файлах свойств, он проверяет свойства Spring `Environment` и обычные свойства Java `System`.
[literal,subs="дословно,цитаты"]. [ВНИМАНИЕ] = Для данного приложения должен быть определен только один такой элемент со свойствами что это нужно.
Можно настроить несколько заполнителей свойств, если они имеют отдельные синтаксис заполнителя (`${...}`).
[literal,subs="дословно,цитаты"].
Если вам необходимо модулировать источник свойств, используемых для замены, вам следует не создавать несколько заполнителей свойств.
Скорее, вам следует создать свой собственный Компонент `PropertySourcesPlaceholderConfigurer`, который собирает используемые свойства.
[literal,subs="дословно,цитаты"]. [СОВЕТ] = Вы можете использовать PropertySourcesPlaceholderConfigurer для замены имен классов, которые иногда полезно, когда вам нужно выбрать конкретный класс реализации во время выполнения.
В следующем примере показано, как это сделать:
	<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
		<property name="locations">
			<value>classpath:com/something/strategy.properties</value>
		</property>
		<property name="properties">

<value>custom.strategy.class=com.something.DefaultStrategy</value>
		</property>
	</bean>
	<bean id="serviceStrategy" class="${custom.strategy.class}"/>
[literal,subs="дословно,цитаты"].
Если класс не может быть разрешен во время выполнения в допустимый класс, разрешение компонента происходит сбой, когда он вот-вот будет создан, что происходит во время `preInstantiateSingletons()` фаза `ApplicationContext` для bean-компонента без ленивой инициализации.
[literal,subs="дословно,цитаты"].
Пример: PropertyOverrideConfigurer.
[literal,subs="дословно,цитаты"].
PropertyOverrideConfigurer, еще один постпроцессор фабрики компонентов, напоминает `PropertySourcesPlaceholderConfigurer`, но в отличие от последнего, исходные определения может иметь значения по умолчанию или вообще не иметь значений для свойств компонента.
Если переопределение В файле `Properties` нет записи для определенного свойства компонента, значение по умолчанию используется определение контекста.
[literal,subs="дословно,цитаты"].
Обратите внимание, что определение компонента не знает о переопределении, поэтому оно не из файла определения XML сразу становится очевидным, что используется конфигуратор переопределения. использован.
В случае нескольких экземпляров PropertyOverrideConfigurer, которые определяют разные значения для одного и того же свойства компонента, последний из них выигрывает из-за механизма переопределения.

dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql:mydb.
Этот пример файла можно использовать с определением контейнера, который содержит компонент с именем dataSource, который имеет свойства driverClassName и url.
dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql:mydb.
Также поддерживаются составные имена свойств, если каждый компонент пути за исключением того, что последнее переопределяемое свойство уже не равно нулю (предположительно инициализировано конструкторами).
В следующем примере свойство Sammy объекта Bob свойству `fred` bean-компонента `tom` присвоено скалярное значение `123`:
tom.fred.bob.sammy=123.
ПРИМЕЧАНИЕ.
Указанные значения переопределения всегда являются буквальными значениями.
Они не переведены на ссылки на бобы.
Это соглашение также применяется, когда исходное значение в XML-компоненте определение указывает ссылку на компонент.
tom.fred.bob.sammy=123.
Благодаря пространству имен context, представленному в Spring 2.5, можно настроить переопределение свойства с помощью специального элемента конфигурации, как показано в следующем примере:
Настройка логики создания экземпляров с помощью FactoryBean.
Вы можете реализовать интерфейс `org.springframework.beans.factory.FactoryBean` для объектов, которые сами являются фабриками.
Настройка логики создания экземпляров с помощью FactoryBean.
Интерфейс FactoryBean — это точка подключения к контейнеру Spring IoC. логика создания экземпляров.

Если у вас сложный код инициализации, который лучше выразить в Java, в отличие от (потенциально) подробного объема XML, вы можете создать свой собственный `FactoryBean`, напишите сложную инициализацию внутри этого класса, а затем подключите свой пользовательский FactoryBean в контейнер.
* `T getObject()`: Возвращает экземпляр объекта, созданного этой фабрикой.
Интерфейс FactoryBean<T> предоставляет три метода:. экземпляр может быть общим, в зависимости от того, возвращает ли эта фабрика синглтоны или прототипы.
* `boolean isSingleton()`: возвращает `true`, если этот `FactoryBean` возвращает одиночные элементы или
Интерфейс FactoryBean<T> предоставляет три метода:. «ложь» в противном случае.
Реализация этого метода по умолчанию возвращает true.
* `Class<?> getObjectType()`: возвращает тип объекта, возвращаемый методом `getObject()`.
Интерфейс FactoryBean<T> предоставляет три метода:. или `null`, если тип заранее не известен.
Интерфейс FactoryBean<T> предоставляет три метода:.
Концепция и интерфейс FactoryBean используются во многих местах Spring.
Рамки.
В состав Spring входит более 50 реализаций интерфейса FactoryBean. сам.
Интерфейс FactoryBean<T> предоставляет три метода:.

Когда вам нужно запросить у контейнера сам экземпляр FactoryBean вместо bean-компонент, который он производит, префикс `id` bean-компонента с символом амперсанда (`&`), когда вызов метода getBean() класса ApplicationContext.
Итак, для данного FactoryBean с идентификатором `myBean`, вызов `getBean("myBean")` в контейнере возвращает продукт FactoryBean, тогда как вызов getBean("&myBean") возвращает Сам экземпляр FactoryBean.

Лениво инициализированные компоненты.
По умолчанию реализации ApplicationContext охотно создают и настраивают все процесс.
Как правило, такая предварительная реализация желательна, поскольку ошибки в конфигурация или окружающая среда обнаруживаются немедленно, а не часами или даже несколько дней спустя.
Если такое поведение нежелательно, вы можете предотвратить предварительное создание экземпляра одноэлементного компонента путем маркировки определения компонента как ленивая инициализация.
Компонент с ленивой инициализацией сообщает контейнеру IoC создать компонент. экземпляре при первом запросе, а не при запуске.
Лениво инициализированные компоненты.
Это поведение контролируется аннотацией `@Lazy` или в XML атрибутом `lazy-init` элемента `<bean/>`, как следующий пример показывает: См. пример кода в исходном документе.
Лениво инициализированные компоненты.
Когда предыдущая конфигурация используется ApplicationContext, ленивый bean-компонент не создается заранее при запуске `ApplicationContext`, тогда как `notLazy` тщательно создается заранее.
Лениво инициализированные компоненты.
Однако, когда лениво инициализированный bean-компонент является зависимостью одноэлементного bean-компонента, который не инициализированный с отложенной инициализацией, `ApplicationContext` создает bean-компонент с ленивой инициализацией по адресу start, потому что он должен удовлетворять зависимостям синглтона.
Компонент с ленивой инициализацией вводится в одноэлементный компонент в другом месте, где не выполняется ленивая инициализация.
Лениво инициализированные компоненты.

Вы также можете управлять отложенной инициализацией набора bean-компонентов, используя аннотацию @Lazy в файле @Configuration. аннотированный класс или в XML, используя атрибут `default-lazy-init` в элементе `<beans/>`, как показано в следующем примере. показывает: См. пример кода в исходном документе.

Внедрение метода.
В большинстве сценариев приложений большинство компонентов в контейнере Singleton Bean должен взаимодействовать с другим Singleton Bean или не-Singleton Bean необходимо сотрудничать с другим компонентом, не являющимся одноэлементным, вы обычно обрабатываете зависимость определяя один компонент как свойство другого.
Проблема возникает, когда жизненный цикл компонента разные.
Предположим, что одноэлементный компонент A должен использовать неодноэлементный (прототипный) компонент B, возможно, при каждом вызове метода на A.
Контейнер создает только одноэлементный компонент A. один раз и, таким образом, получает только одну возможность установить свойства.
Контейнер не может предоставлять bean-компоненту A новый экземпляр bean-компонента B каждый раз, когда он необходим.
Внедрение метода.
Решение состоит в том, чтобы отказаться от некоторой инверсии контроля.
Вы можете реализуя интерфейс ApplicationContextAware, и посредством вызова `getBean("B")` к контейнеру] запросить (обычно новый) экземпляр bean B каждый раз, когда bean A нуждается в этом.
Следующий пример показывает этот подход:
Java
	package fiona.apple;
	// Импорт Spring-API
	import org.springframework.beans.BeansException;
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.ApplicationContextAware;
	 * A class that uses a stateful Command-style class to perform
	 * some processing.
	public class CommandManager implements ApplicationContextAware {
		private ApplicationContext applicationContext;
		public Object process(Map commandState) {
			// возьмите новый экземпляр соответствующей команды

Command command = createCommand();
			// установить состояние экземпляра команды (надеюсь, нового)
			command.setState(commandState);
			return command.execute();
		protected Command createCommand() {
			// обратите внимание на зависимость Spring API!
			return this.applicationContext.getBean("command", Command.class);
		public void setApplicationContext(
				ApplicationContext applicationContext) throws BeansException {
			this.applicationContext = applicationContext;
	package fiona.apple
	// Импорт Spring-API
	// Класс, который использует класс в стиле Command с сохранением состояния для выполнения
	// некоторая обработка.
	class CommandManager : ApplicationContextAware {
Внедрение метода.
Предыдущее нежелательно, поскольку бизнес-код знает и связан с Весенний фреймворк.
Внедрение метода, несколько продвинутая функция Spring IoC. контейнер, позволяет вам аккуратно обработать этот вариант использования.
Внедрение метода. **** Вы можете прочитать больше о мотивации внедрения метода в {spring-site-blog}/2004/08/06/method-injection/[эта запись в блоге]. ****
Внедрение метода поиска — это способность контейнера переопределять методы bean-компоненты, управляемые контейнером, и вернуть результат поиска для другого именованного bean-компонента в контейнер.
Поиск обычно включает прототип bean-компонента, как в описанном сценарии. в предыдущий раздел.

Spring Framework реализует этот метод внедрения, используя генерацию байт-кода из библиотеки CGLIB для динамически генерировать подкласс, который переопределяет метод.
* Чтобы это динамическое подклассирование работало, класс, который находится в контейнере bean-компонентов Spring,
[ПРИМЕЧАНИЕ]. подклассы не могут быть «финальными», и переопределяемый метод также не может быть «финальным».
* Модульное тестирование класса, имеющего `абстрактный` метод, требует создания подкласса класса.
[ПРИМЕЧАНИЕ]. самостоятельно и предоставить заглушку реализации `абстрактного` метода.
* Еще одним ключевым ограничением является то, что методы поиска не работают с фабричными методами и
[ПРИМЕЧАНИЕ]. в частности, не с методами `@Bean` в классах конфигурации, поскольку в этом случае контейнер не отвечает за создание экземпляра и поэтому не может создавать подкласс, создаваемый во время выполнения на лету.
[ПРИМЕЧАНИЕ].
В случае с классом CommandManager в предыдущем фрагменте кода Контейнер Spring динамически переопределяет реализацию createCommand(). метод.
Класс CommandManager не имеет каких-либо зависимостей Spring, так как переработанный пример показывает:
Java
	package fiona.apple;
	// больше никакого весеннего импорта!
	public abstract class CommandManager {
		public Object process(Object commandState) {
			// возьмите новый экземпляр соответствующего командного интерфейса
			Command command = createCommand();
			// установить состояние экземпляра команды (надеюсь, нового)
			command.setState(commandState);
			return command.execute();

// окей... но где реализация этого метода?
		protected abstract Command createCommand();
	package fiona.apple
	// больше никакого весеннего импорта!
	abstract class CommandManager {
[ПРИМЕЧАНИЕ].
В клиентском классе, содержащем внедряемый метод (CommandManager в этом примере случае), метод, который будет внедрен, требует подписи следующего вида:
	<public|protected> [abstract] <return-type> theMethodName(no-arguments);
[ПРИМЕЧАНИЕ].
Если метод является «абстрактным», динамически создаваемый подкласс реализует этот метод.
В противном случае динамически созданный подкласс переопределяет конкретный метод, определенный в оригинальный класс.
Рассмотрим следующий пример:
	<!-- a stateful bean deployed as a prototype (non-singleton) -->
	<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
		<!-- inject dependencies here as required -->
	</bean>
	<!-- commandManager uses myCommand prototype bean -->
	<bean id="commandManager" class="fiona.apple.CommandManager">
		<lookup-method name="createCommand" bean="myCommand"/>
	</bean>
[ПРИМЕЧАНИЕ].

Компонент, идентифицированный как `commandManager`, вызывает собственный метод `createCommand()`. всякий раз, когда ему нужен новый экземпляр bean-компонента `myCommand`.
Вы должны быть осторожны при развертывании компонент `myCommand` в качестве прототипа, если это действительно то, что нужно.
Если это a singleton, тот же экземпляр `myCommand` bean возвращается каждый раз.
[ПРИМЕЧАНИЕ].
Альтернативно, в модели компонента на основе аннотаций вы можете объявить поиск через аннотацию `@Lookup`, как показано в следующем примере:
Java
	public abstract class CommandManager {
		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		@Lookup("myCommand")
		protected abstract Command createCommand();
	abstract class CommandManager {
[ПРИМЕЧАНИЕ].
Или, более идиоматично, вы можете рассчитывать на то, что целевой компонент будет разрешен против объявленный тип возвращаемого значения метода поиска:
Java
	public abstract class CommandManager {
		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		@Lookup
		protected abstract Command createCommand();
	abstract class CommandManager {
[ПРИМЕЧАНИЕ]. [СОВЕТ] = Другой способ доступа к целевым компонентам с разной областью действия — это `ObjectFactory`/.
Точка внедрения `Provider`.

См.
[ПРИМЕЧАНИЕ].
Вы также можете найти `ServiceLocatorFactoryBean` (в `org.springframework.beans.factory.config`), чтобы быть полезным.
Произвольная замена метода.
Менее полезная форма внедрения метода, чем внедрение метода поиска, — это возможность замените произвольные методы в управляемом компоненте другой реализацией метода. ты можете спокойно пропустить остальную часть этого раздела, пока эта функция вам действительно не понадобится.
Произвольная замена метода.
С метаданными конфигурации на основе XML вы можете использовать элемент replaced-method для замените существующую реализацию метода другой для развернутого компонента.
Рассмотрим следующий класс, у которого есть метод ComputeValue, который мы хотим переопределить:
Java
	public class MyValueCalculator {
		public String computeValue(String input) {
			// какой-то реальный код...
		// еще какие-то методы...
	class MyValueCalculator {
		// еще какие-то методы...
Произвольная замена метода.
Класс, реализующий `org.springframework.beans.factory.support.MethodReplacer` Интерфейс предоставляет новое определение метода, как показано в следующем примере:
Java
		public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
			// получить входное значение, работать с ним и вернуть вычисленный результат
			String input = (String) args[0];
			return ...;
Произвольная замена метода.

Определение компонента для развертывания исходного класса и указания переопределения метода будет напоминают следующий пример:
	<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
		<!-- arbitrary method replacement -->
		<replaced-method name="computeValue" replacer="replacementComputeValue">
			<arg-type>String</arg-type>
		</replaced-method>
	</bean>
	<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
Произвольная замена метода.
Вы можете использовать один или несколько элементов `<arg-type/>` внутри `<replaced-method/>` элемент, указывающий сигнатуру переопределяемого метода.
Подпись для аргументов необходим только если метод перегружен и имеется несколько вариантов существуют внутри класса.
Для удобства строка типа аргумента может быть подстрока полного имени типа.
Например, все следующее соответствует `java.lang.String`:
	java.lang.String
	String
	Str
Произвольная замена метода.
Поскольку количества аргументов часто достаточно, чтобы различать все возможные варианты. выбор, этот ярлык может сэкономить много времени на вводе текста, позволяя вводить только кратчайшая строка, соответствующая типу аргумента.

Настройка природы компонента.
Spring Framework предоставляет ряд интерфейсов, которые вы можете использовать для настройки характера боба.
В этом разделе они группируются следующим образом:
* Обратные вызовы жизненного цикла
* `ApplicationContextAware` и `BeanNameAware`
* Другие `Aware` интерфейсы
Обратные вызовы жизненного цикла.
Для взаимодействия с контейнером, управляющим жизненным циклом компонента, вы можете реализовать интерфейсы Spring `InitializingBean` и `DisposableBean`.
Контейнер вызывает `afterPropertiesSet()` для первого и `destroy()` для второго, чтобы позволить компоненту выполнить определенные действия при инициализации и уничтожении ваших bean-компонентов.
Обратные вызовы жизненного цикла. [СОВЕТ] = Аннотации JSR-250 `@PostConstruct` и `@PreDestroy` обычно считаются лучшими. практика получения обратных вызовов жизненного цикла в современном приложении Spring.
Используя эти аннотации означают, что ваши bean-компоненты не связаны с интерфейсами, специфичными для Spring.
Подробности см. в с использованием `@PostConstruct` и `@PreDestroy`.
Обратные вызовы жизненного цикла.
Если вы не хотите использовать аннотации JSR-250, но все равно хотите удалить рассмотрите метаданные определения bean-компонентов `init-method` и`destroy-method`.
Обратные вызовы жизненного цикла.
Внутри Spring Framework использует реализации BeanPostProcessor для обработки любых интерфейсы обратного вызова, которые он может найти и вызвать соответствующие методы.

Если вам нужен индивидуальный функции или другое поведение жизненного цикла Spring по умолчанию не предлагает, вы можете реализуйте `BeanPostProcessor` самостоятельно.
Для получения дополнительной информации см.
Обратные вызовы жизненного цикла.
В дополнение к обратным вызовам инициализации и уничтожения объекты, управляемые Spring, могут также реализовать интерфейс «Жизненный цикл», чтобы эти объекты могли участвовать в процесс запуска и завершения работы, определяемый собственным жизненным циклом контейнера.
Обратные вызовы жизненного цикла.
В этом разделе описаны интерфейсы обратного вызова жизненного цикла.
Обратные вызовы инициализации.
Интерфейс `org.springframework.beans.factory.InitializingBean` позволяет bean-компоненту выполнить работу по инициализации после того, как контейнер установил все необходимые свойства на боб.
Интерфейс InitializingBean определяет один метод:
	void afterPropertiesSet() throws Exception;
Обратные вызовы инициализации.
Мы рекомендуем вам не использовать интерфейс `InitializingBean`, поскольку он излишне связывает код с Spring.
В качестве альтернативы мы предлагаем использовать аннотацию `@PostConstruct` или указание метода инициализации POJO.
В случае метаданных конфигурации на основе XML: вы можете использовать атрибут init-method, чтобы указать имя метода, который имеет void подпись без аргументов.
В конфигурации Java вы можете использовать атрибут initMethod `@Бин`.
См.
Получение обратных вызовов жизненного цикла.
Рассмотрим следующий пример:
	<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
Java
	public class ExampleBean {

public void init() {
			// сделать некоторую работу по инициализации
	class ExampleBean {
Обратные вызовы инициализации.
Предыдущий пример имеет почти тот же эффект, что и следующий пример. (который состоит из двух списков):
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
Java
	public class AnotherExampleBean implements InitializingBean {
		@Override
		public void afterPropertiesSet() {
			// сделать некоторую работу по инициализации
	class AnotherExampleBean : InitializingBean {
Обратные вызовы инициализации.
Однако первый из двух предыдущих примеров не связывает код с Spring.
Обратные вызовы инициализации. [ПРИМЕЧАНИЕ] = Имейте в виду, что `@PostConstruct` и методы инициализации в целом выполняются внутри блокировки создания синглтона контейнера.
Экземпляр компонента рассматривается только как полностью инициализированный и готовый к публикации для других после возвращения из Метод `@PostConstruct`.
Такие отдельные методы инициализации предназначены только для проверки состояния конфигурации и, возможно, подготовки некоторых структур данных на основе заданной конфигурации, но без дальнейших действий с доступом к внешнему компоненту.
В противном случае существует риск тупиковой ситуации при инициализации.
Обратные вызовы инициализации.
Для сценария, в котором должны быть запущены дорогостоящие действия после инициализации, например, этапы асинхронной подготовки базы данных, ваш компонент должен либо реализовать `SmartInitializingSingleton.afterSingletonsInstantiated()` или полагаться на контекст событие обновления: реализация `ApplicationListener<ContextRefreshedEvent>` или объявляя эквивалент аннотации `@EventListener(ContextRefreshedEvent.class)`.

Эти варианты появляются после обычной одноэлементной инициализации и, следовательно, вне любой блокировки создания синглтона.
Обратные вызовы инициализации.
В качестве альтернативы вы можете реализовать интерфейс «(Smart)Lifecycle» и интегрироваться с ним. общее управление жизненным циклом контейнера, включая механизм автозапуска, шаг остановки перед уничтожением и потенциальные обратные вызовы остановки/перезапуска (см. ниже).
Обратные вызовы разрушения.
Реализация интерфейса org.springframework.beans.factory.DisposableBean позволяет bean-компонент получает обратный вызов, когда контейнер, содержащий его, уничтожается.
Интерфейс DisposableBean определяет один метод:
	void destroy() throws Exception;
Обратные вызовы разрушения.
Мы рекомендуем вам не использовать интерфейс обратного вызова DisposableBean, поскольку он излишне связывает код с Spring.
В качестве альтернативы мы предлагаем использовать аннотацию `@PreDestroy` или указание общего метода, который поддерживается определениями компонентов.
С помощью XML метаданные конфигурации, вы можете использовать атрибут `destroy-method` в `<bean/>`.
В конфигурации Java вы можете использовать атрибут `destroyMethod` @Bean`.
Видеть
	<bean id="exampleDestructionBean" class="examples.ExampleBean" destroy-method="cleanup"/>
Java
	public class ExampleBean {
		public void cleanup() {
			// выполнить некоторую работу по уничтожению (например, освободить соединения из пула)
	class ExampleBean {
Обратные вызовы разрушения.
Предыдущее определение имеет почти тот же эффект, что и следующее определение:

<bean id="exampleDestructionBean" class="examples.AnotherExampleBean"/>
Java
	public class AnotherExampleBean implements DisposableBean {
		@Override
		public void destroy() {
			// выполнить некоторую работу по уничтожению (например, освободить соединения из пула)
	class AnotherExampleBean : DisposableBean {
Обратные вызовы разрушения.
Однако первое из двух предыдущих определений не связывает код со Spring.
Обратные вызовы разрушения.
Обратите внимание, что Spring также поддерживает вывод методов уничтожения, обнаруживая общедоступное «закрытие» или метод «выключения».
Это поведение по умолчанию для методов `@Bean` в конфигурации Java. классы и автоматически соответствует `java.lang.AutoCloseable` или `java.io.Closeable` реализации, не связывая логику разрушения с Spring.
Обратные вызовы разрушения.
СОВЕТ: Для вывода метода уничтожения с помощью XML вы можете назначить атрибут `destroy-method`. элемента `<bean>` специальное значение `(inferred)`, которое инструктирует Spring автоматически обнаружить общедоступный метод закрытия или завершения работы в классе компонента для конкретного определения компонента.
Вы также можете установить это специальное значение `(inferred)` для атрибута `default-destroy-method`. элемента `<beans>`, чтобы применить это поведение ко всему набору определений bean-компонентов (см.

Обратные вызовы разрушения. [ПРИМЕЧАНИЕ] = Для расширенных фаз выключения вы можете реализовать интерфейс «Жизненный цикл» и получать ранний сигнал остановки перед вызовом методов уничтожения любого одноэлементного bean-компонента.
Вы также можете реализовать SmartLifecycle для шага остановки с привязкой по времени, когда контейнер будет ждать завершения всей такой обработки остановки, прежде чем переходить к уничтожению методов.
Методы инициализации и уничтожения по умолчанию.
Когда вы пишете инициализацию и уничтожаете обратные вызовы методов, которые не используют Интерфейсы обратного вызова InitializingBean и DisposableBean, специфичные для Spring, позволяют обычно пишут методы с такими именами, как `init()`, `initialize()`, `dispose()`, и так далее.
В идеале имена таких методов обратного вызова жизненного цикла стандартизированы для всех систем. проект, чтобы все разработчики использовали одни и те же имена методов и обеспечивали согласованность.
Методы инициализации и уничтожения по умолчанию.
Вы можете настроить контейнер Spring на «поиск» именованной инициализации и уничтожение. имена методов обратного вызова для каждого компонента.
Это означает, что вы, как разработчик приложений, можете написать классы вашего приложения и использовать обратный вызов инициализации под названием `init()`, без необходимости настройки атрибута `init-method="init"` для каждого определения компонента.
Контейнер Spring IoC вызывает этот метод при создании компонента (и в соответствии со стандартным контрактом обратного вызова жизненного цикла (описано ранее).

Эта функция также обеспечивает согласованное соглашение об именах для инициализации и уничтожить обратные вызовы методов.
Методы инициализации и уничтожения по умолчанию.
Предположим, что ваши методы обратного вызова инициализации называются `init()`, а метод уничтожения методы обратного вызова называются `destroy()`.
Тогда ваш класс будет похож на класс в следующий пример:
Java
	public class DefaultBlogService implements BlogService {
		private BlogDao blogDao;
		public void setBlogDao(BlogDao blogDao) {
			this.blogDao = blogDao;
		// это (неудивительно) метод обратного вызова инициализации
		public void init() {
			if (this.blogDao == null) {
				throw new IllegalStateException("The [blogDao] property must be set.");
	class DefaultBlogService : BlogService {
	<beans default-init-method="init">
		<bean id="blogService" class="com.something.DefaultBlogService">
			<property name="blogDao" ref="blogDao" />
		</bean>
	</beans>
Затем вы можете использовать этот класс в компоненте, напоминающем следующий:.
Наличие атрибута default-init-method в элементе верхнего уровня `<beans/>`. атрибут заставляет контейнер Spring IoC распознавать метод init в bean-компоненте class в качестве обратного вызова метода инициализации.
Когда компонент создается и собирается, если В классе bean есть такой метод, он вызывается в подходящее время.

Затем вы можете использовать этот класс в компоненте, напоминающем следующий:.
Вы можете настроить обратные вызовы метода уничтожения аналогичным образом (то есть в XML), используя метод Атрибут `default-destroy-method` в элементе `<beans/>` верхнего уровня.
Затем вы можете использовать этот класс в компоненте, напоминающем следующий:.
Если существующие классы компонентов уже имеют методы обратного вызова, имена которых различаются. согласно соглашению, вы можете переопределить значение по умолчанию, указав (то есть в XML) имя метода, используя атрибуты `init-method` и `destroy-method` `<bean/>` сам.
Затем вы можете использовать этот класс в компоненте, напоминающем следующий:.
Контейнер Spring гарантирует, что будет вызван настроенный обратный вызов инициализации. сразу после того, как компонент поставляется со всеми зависимостями.
Таким образом, инициализация обратный вызов вызывается по ссылке на необработанный компонент, что означает, что перехватчики AOP и т. д. вперед еще не применяются к компоненту.
Целевой компонент сначала полностью создается и затем применяется прокси-сервер AOP (например) со своей цепочкой перехватчиков.
Если цель bean-компонент и прокси-сервер определяются отдельно, ваш код может даже взаимодействовать с необработанным целевой компонент в обход прокси.

Следовательно, было бы непоследовательно применять перехватчиков с методом init, поскольку это приведет к объединению жизненного цикла нацеливайте bean-компонент на его прокси-сервер или перехватчики и оставляйте странную семантику, когда ваш код взаимодействует напрямую с необработанным целевым компонентом.
Объединение механизмов жизненного цикла.
Начиная с Spring 2.5, у вас есть три варианта управления поведением жизненного цикла компонента:
* Xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[`InitializingBean`] и
* Пользовательские методы `init()` и `destroy()`
* Xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc [`@PostConstruct` и `@PreDestroy` аннотации]
Объединение механизмов жизненного цикла. .
Вы можете комбинировать эти механизмы для управления данным компонентом.
Объединение механизмов жизненного цикла.
ПРИМЕЧАНИЕ.
Если для компонента настроено несколько механизмов жизненного цикла и каждый механизм настроено с другим именем метода, то каждый настроенный метод запускается в порядок, указанный после этого примечания.
Однако если настроено то же имя метода, например `init()` для метода инициализации - для более чем одного из этих механизмов жизненного цикла, этот метод запускается один раз, как описано в
Объединение механизмов жизненного цикла.
Несколько механизмов жизненного цикла, настроенных для одного и того же компонента, с разными методы инициализации называются следующим образом:

Объединение механизмов жизненного цикла. .
Методы, аннотированные `@PostConstruct`. `afterPropertiesSet()`, как определено интерфейсом обратного вызова `InitializingBean`.
Пользовательский настроенный метод `init()`
Методы уничтожения вызываются в том же порядке:. .
Методы, помеченные `@PreDestroy`. `destroy()`, как определено интерфейсом обратного вызова `DisposableBean`.
Специально настроенный метод `destroy()`
Обратные вызовы при запуске и завершении работы.
Интерфейс «Жизненный цикл» определяет основные методы для любого объекта, имеющего свои собственные требования жизненного цикла (например, запуск и остановка какого-либо фонового процесса):
	public interface Lifecycle {
		void start();
		void stop();
		boolean isRunning();
Обратные вызовы при запуске и завершении работы.
Любой объект, управляемый Spring, может реализовать интерфейс Lifecycle.
Затем, когда `ApplicationContext` сам получает сигналы запуска и остановки (например, для остановки/перезапуска). сценарий во время выполнения), он каскадирует эти вызовы ко всем реализациям жизненного цикла. определены в этом контексте.
Это делается путем делегирования полномочий «LifecycleProcessor», как показано ниже. в следующем листинге:
	public interface LifecycleProcessor extends Lifecycle {
		void onRefresh();
		void onClose();
Обратные вызовы при запуске и завершении работы.
Обратите внимание, что «LifecycleProcessor» сам по себе является расширением «Lifecycle». интерфейс.

Он также добавляет два других метода для реагирования на обновляемый контекст. и закрылся.
Обратные вызовы при запуске и завершении работы. [СОВЕТ] = Обратите внимание, что обычный интерфейс org.springframework.context.Lifecycle представляет собой простой интерфейс. контракт на явные уведомления о запуске и остановке и не подразумевает автозапуск во время обновления контекста.
Для детального контроля над автозапуском и плавного остановку конкретного компонента (включая фазы запуска и остановки), рассмотрите возможность реализации вместо этого используется расширенный интерфейс org.springframework.context.SmartLifecycle.
Обратные вызовы при запуске и завершении работы.
Также обратите внимание, что уведомления об остановке не гарантированно приходят до уничтожения.
При обычном завершении работы все bean-компоненты Lifecycle сначала получают уведомление об остановке, а затем распространяются обратные вызовы общего разрушения.
Однако при горячем обновлении во время в течение времени жизни контекста или при остановленных попытках обновления вызываются только методы уничтожения.
Обратные вызовы при запуске и завершении работы.
Порядок вызовов запуска и завершения работы может иметь важное значение.
Если «зависит от» Между любыми двумя объектами существует связь, зависимая сторона начинается после ее зависимости, и он останавливается перед своей зависимостью.
Однако иногда прямое зависимости неизвестны.
Вы можете знать только, что должны запускаться объекты определенного типа. перед объектами другого типа.
В таких случаях интерфейс SmartLifecycle определяет другой вариант, а именно метод getPhase(), определенный в его суперинтерфейсе, `Поэтапно`.

В следующем листинге показано определение поэтапного интерфейса:
	public interface Phased {
		int getPhase();
	public interface SmartLifecycle extends Lifecycle, Phased {
		boolean isAutoStartup();
		void stop(Runnable callback);
В следующем листинге показано определение интерфейса SmartLifecycle:.
При запуске первыми запускаются объекты с наименьшей фазой.
При остановке, соблюдается обратный порядок.
Таким образом, объект, реализующий SmartLifecycle и чей метод getPhase() возвращает Integer.MIN_VALUE, будет запущен одним из первых и последний, кто остановился.
На другом конце спектра находится фазовое значение `Integer.MAX_VALUE` будет указывать, что объект должен быть запущен последним и остановлен. сначала (вероятно, потому, что это зависит от запуска других процессов).
При рассмотрении значение фазы, также важно знать, что фаза по умолчанию для любого «нормального» Объект «Жизненный цикл», который не реализует «SmartLifecycle», имеет значение «0».
Следовательно, любой отрицательное значение фазы указывает на то, что объект должен начаться раньше этих стандартных компоненты (и останавливаемся после них).
Обратное справедливо для любого положительного значения фазы.
В следующем листинге показано определение интерфейса SmartLifecycle:.
Метод остановки, определенный SmartLifecycle, принимает обратный вызов.
Любой реализация должна вызвать метод обратного вызова `run()` после того, как эта реализация процесс выключения завершен.

Это позволяет при необходимости асинхронное завершение работы, поскольку реализация по умолчанию интерфейса LifecycleProcessor, `DefaultLifecycleProcessor` ожидает достижения значения тайм-аута для группы объектов. внутри каждой фазы, чтобы вызвать этот обратный вызов.
Тайм-аут для каждой фазы по умолчанию составляет 30 секунд.
Вы можете переопределить экземпляр процессора жизненного цикла по умолчанию, определив компонент с именем `lifecycleProcessor` в контексте.
Если вы хотите только изменить тайм-аут, достаточно определить следующее:
	<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
		<!-- timeout value in milliseconds -->
		<property name="timeoutPerShutdownPhase" value="10000"/>
	</bean>
В следующем листинге показано определение интерфейса SmartLifecycle:.
Как упоминалось ранее, интерфейс LifecycleProcessor определяет методы обратного вызова для обновление и закрытие контекста.
Последний вызывает отключение процесс, как если бы `stop()` был вызван явно, но это происходит, когда контекст закрытие.
С другой стороны, обратный вызов «обновить» обеспечивает еще одну функцию Компоненты `SmartLifecycle`.
Когда контекст обновляется (после того, как все объекты были создан и инициализирован), вызывается этот обратный вызов.
В этот момент процессор жизненного цикла по умолчанию проверяет логическое значение, возвращаемое каждым Метод isAutoStartup() объекта SmartLifecycle.

Если `true`, этот объект начать с этого момента, а не ждать явного вызова контекста или собственный метод `start()` (в отличие от обновления контекста, старт контекста не происходит) автоматически для стандартной реализации контекста).
Значение `фазы` и любое Отношения «зависит от» определяют порядок запуска, как описано ранее.
Грамотное завершение работы контейнера Spring IoC в не-веб-приложениях. [ПРИМЕЧАНИЕ] = Этот раздел относится только к не-веб-приложениям.
Spring веб-интерфейс Реализации ApplicationContext уже имеют код для корректного завершения работы. контейнер Spring IoC, когда соответствующее веб-приложение закрывается.
Грамотное завершение работы контейнера Spring IoC в не-веб-приложениях.
Если вы используете IoC-контейнер Spring в среде, отличной от веб-приложения (для например, в среде рабочего стола богатого клиента), зарегистрируйте перехватчик завершения работы с помощью JVM.
Это обеспечит плавное завершение работы и вызов соответствующих методов уничтожения на вашем компьютере.
Singleton beans, чтобы освободить все ресурсы.
Вам все равно придется настроить и правильно реализовать эти обратные вызовы уничтожения.
Грамотное завершение работы контейнера Spring IoC в не-веб-приложениях.
Чтобы зарегистрировать перехватчик завершения работы, вызовите метод `registerShutdownHook()`, который объявленный в интерфейсе ConfigurationApplicationContext, как показано в следующем примере:
Java
	import org.springframework.context.ConfigurableApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {
		public static void main(final String[] args) throws Exception {
			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
			// добавляем перехватчик завершения работы для приведенного выше контекста...
			ctx.registerShutdownHook();
			// приложение запускается здесь...
			// выход из основного метода, хук вызывается перед закрытием приложения...
		// добавляем перехватчик завершения работы для приведенного выше контекста...
		ctx.registerShutdownHook()
		// приложение запускается здесь...
		// выход из основного метода, хук вызывается перед закрытием приложения...
Безопасность резьбы и видимость.
Основной контейнер Spring публикует созданные одноэлементные экземпляры в потокобезопасном режиме. защита доступа с помощью одноэлементной блокировки и гарантия видимости в других потоках.
Безопасность резьбы и видимость.
Как следствие, классам компонентов, предоставляемым приложением, не нужно беспокоиться о видимость их состояния инициализации.
Обычные поля конфигурации не обязательно должны быть помечены как «изменчивые», если они мутируют только на этапе инициализации, предоставление гарантий видимости, аналогичных «final», даже для конфигурации на основе установщика состояние, которое является изменчивым на этом начальном этапе.
Если такие поля изменяются после этапе создания компонента и его последующей первоначальной публикации, их необходимо объявить как «летучий» или охраняется общей блокировкой при каждом доступе.
Безопасность резьбы и видимость.

Обратите внимание, что одновременный доступ к такому состоянию конфигурации в экземплярах одноэлементного компонента, например, для экземпляров контроллера или экземпляров репозитория, полностью потокобезопасен после такая безопасная первоначальная публикация со стороны контейнера.
Это включает в себя общий синглтон Экземпляры FactoryBean, которые также обрабатываются в рамках общей одноэлементной блокировки.
Безопасность резьбы и видимость.
Для обратных вызовов уничтожения состояние конфигурации остается потокобезопасным, но любая среда выполнения состояние, накопленное между инициализацией и уничтожением, должно храниться в потокобезопасном режиме. структуры (или в «изменчивых» полях для простых случаев) в соответствии с общими рекомендациями Java.
Безопасность резьбы и видимость.
Более глубокая интеграция жизненного цикла, как показано выше, включает изменяемое во время выполнения состояние, такое как «исполняемое» поле, которое необходимо объявить как «изменчивое».
В то время как общий обратные вызовы жизненного цикла следуют определенному порядку, например, обратный вызов начала гарантированно происходит только после полной инициализации и обратного вызова остановки только после первоначального запуска, есть особый случай с общей остановкой перед уничтожением: это строго рекомендовал, чтобы внутреннее состояние любого такого компонента также допускало немедленную уничтожить обратный вызов без предшествующей остановки, поскольку это может произойти во время чрезвычайной ситуации. завершение работы после отмены начальной загрузки или в случае тайм-аута остановки, вызванного другим компонентом.
`ApplicationContextAware` и `BeanNameAware`.

Когда `ApplicationContext` создает экземпляр объекта, реализующий Интерфейс `org.springframework.context.ApplicationContextAware`, предоставляется экземпляр со ссылкой на этот `ApplicationContext`.
В следующем листинге показано определение интерфейса ApplicationContextAware:
	public interface ApplicationContextAware {
		void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
`ApplicationContextAware` и `BeanNameAware`.
Таким образом, bean-компоненты могут программно манипулировать создавшим их ApplicationContext. через интерфейс ApplicationContext или путем приведения ссылки к известному подкласс этого интерфейса (например, «ConfigurableApplicationContext», который предоставляет дополнительный функционал).
Одним из вариантов использования может быть программный поиск других компонентов.
Иногда эта возможность бывает полезна.
Однако в целом вам следует избегать этого, потому что он связывает код со Spring и не следует стилю инверсии управления, где соавторы предоставляются компонентам в качестве свойств.
Другие методы `ApplicationContext` обеспечивает доступ к файловым ресурсам, публикацию событий приложения, и доступ к «MessageSource».
Эти дополнительные возможности описаны в
`ApplicationContextAware` и `BeanNameAware`.
Автопроводка — еще одна альтернатива для получения ссылки на `Контекст приложения`.
Традиционные_ режимы автосвязывания `constructor` и`byType`. (как описано в Соавторы автоматического подключения) может предоставить зависимость типа `ApplicationContext` для аргумента конструктора или параметра метода установки, соответственно.
Для большей гибкости, включая возможность автоматического связывания полей и методы с несколькими параметрами, используйте функции автоматического связывания на основе аннотаций.

Если да, `ApplicationContext` автоматически подключается к полю, аргументу конструктора или методу. параметр, который ожидает тип ApplicationContext, если поле, конструктор или рассматриваемый метод содержит аннотацию @Autowired.
Для получения дополнительной информации см.
`ApplicationContextAware` и `BeanNameAware`.
Когда `ApplicationContext` создает класс, реализующий `org.springframework.beans.factory.BeanNameAware`, классу предоставляется ссылка на имя, определенное в определении связанного с ним объекта.
Следующий список показывает определение интерфейса BeanNameAware:
	public interface BeanNameAware {
		void setBeanName(String name) throws BeansException;
`ApplicationContextAware` и `BeanNameAware`.
Обратный вызов вызывается после заполнения обычных свойств компонента, но до обратный вызов инициализации, такой как `InitializingBean.afterPropertiesSet()` или собственный init-метод.
Другие `Aware` интерфейсы.
Помимо `ApplicationContextAware` и `BeanNameAware` (обсуждалось ранее), Spring предлагает широкий спектр интерфейсов обратного вызова «Aware», которые позволяют bean-компонентам указывать контейнеру. что они требуют определенной зависимости от инфраструктуры.
Как правило, название указывает на тип зависимости.
В следующей таблице приведены наиболее важные интерфейсы «Aware»:
Другие `Aware` интерфейсы. .Поддерживаемые интерфейсы |=== | Имя| Внедренная зависимость | Объяснено в...
Другие `Aware` интерфейсы. | `ApplicationContextAware` | Объявление `ApplicationContext`. | `ApplicationContextAware` и `BeanNameAware`

Другие `Aware` интерфейсы. | `ApplicationEventPublisherAware` | Издатель событий включающего в себя ApplicationContext. | Дополнительные возможности ApplicationContext
Другие `Aware` интерфейсы. | `BeanClassLoaderAware` | Загрузчик классов, используемый для загрузки классов компонентов. | Создание экземпляров Beans
| `BeanNameAware` | Имя объявляющего компонента. | `ApplicationContextAware` и `BeanNameAware`. | `LoadTimeWeaverAware` | Определен Weaver для обработки определения класса во время загрузки. | Переплетение во время загрузки с AspectJ в Spring Framework
| `BeanNameAware` | Имя объявляющего компонента. | `ApplicationContextAware` и `BeanNameAware`. | `MessageSourceAware` | Настроенная стратегия разрешения сообщений (с поддержкой параметризации и интернационализация). | Дополнительные возможности ApplicationContext
| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления. | `ResourceLoaderAware` | Настроен загрузчик для низкоуровневого доступа к ресурсам. | Ресурсы
| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления. | `ServletConfigAware` | Текущая `ServletConfig`, в которой работает контейнер.
Действует только в веб-версии Spring. `Контекст приложения`. | Spring MVC
| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления. | `ServletContextAware` | Текущий `ServletContext`, в котором работает контейнер.
Действует только в веб-версии Spring. `Контекст приложения`. | Spring MVC |===

| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления.
Еще раз обратите внимание, что использование этих интерфейсов привязывает ваш код к Spring API и не следуйте стилю «Инверсия управления».
В результате мы рекомендуем их для инфраструктуры. bean-компоненты, которым требуется программный доступ к контейнеру.

Зависимости и конфигурация в деталях.
Как упоминалось в предыдущий раздел, вы можете определить свойства bean-компонента и аргументы конструктора как ссылки на другие управляемые bean-компоненты. (соавторы) или как значения, определенные в строке.
Метаданные конфигурации Spring на основе XML поддерживают для этой цели типы подэлементов внутри его элементов `<property/>` и `<constructor-arg/>`.
Прямые значения (примитивы, строки и т. д.).
Атрибут `value` элемента `<property/>` указывает свойство или конструктор. аргумент как удобочитаемое строковое представление.
Весна значения от String до фактического типа свойства или аргумента.
В следующем примере показаны различные устанавливаемые значения:
	<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- results in a setDriverClassName(String) call -->
		<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		<property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
		<property name="username" value="root"/>
		<property name="password" value="misterkaoli"/>
	</bean>
Прямые значения (примитивы, строки и т. д.).

В следующем примере используется ссылка:core/beans/dependents/factory-properties-detailed.adoc#beans-p-namespace[p-namespace] для еще большей краткости.
XML-конфигурация:
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
			destroy-method="close"
			p:driverClassName="com.mysql.jdbc.Driver"
			p:url="jdbc:mysql://localhost:3306/mydb"
			p:username="root"
			p:password="misterkaoli"/>
	</beans>
Прямые значения (примитивы, строки и т. д.).
Предыдущий XML более краток.

Однако опечатки обнаруживаются во время выполнения, а не время разработки, если вы не используете IDE (например, https://www.jetbrains.com/idea/[IntelliJ IDEA] или {spring-site-tools}[Spring Tools]), который поддерживает автоматическое свойство. завершение при создании определений компонентов.
Такая помощь IDE настоятельно рекомендуется.
	<bean id="mappings"
		class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<!-- typed as a java.util.Properties -->
		<property name="properties">
			<value>
				jdbc.driver.className=com.mysql.jdbc.Driver
				jdbc.url=jdbc:mysql://localhost:3306/mydb
			</value>
		</property>
	</bean>
Вы также можете настроить экземпляр java.util.Properties следующим образом:.
Контейнер Spring преобразует текст внутри элемента `<value/>` в экземпляр `java.util.Properties` с использованием механизма JavaBeans `PropertyEditor`.
Это это хороший ярлык и одно из немногих мест, где команда Spring предпочитает использовать вложенный элемент `<value/>` в стиле атрибута `value`.

Элемент `idref` — это просто защищенный от ошибок способ передать `id` (строковое значение, а не ссылка) другого компонента в контейнере на `<constructor-arg/>` или `<property/>` элемент.
В следующем примере показано, как его использовать:
	<bean id="collaborator" class="..." />
	<bean id="client" class="...">
		<property name="targetName">
			<idref bean="collaborator" />
		</property>
	</bean>
Элемент `idref`.
Предыдущий фрагмент определения компонента точно эквивалентен (во время выполнения) следующий фрагмент:
	<bean id="collaborator" class="..." />
	<bean id="client" class="...">
		<property name="targetName" value="collaborator" />
	</bean>
Элемент `idref`.
Первая форма предпочтительнее второй, поскольку использование тега idref позволяет контейнер проверяет во время развертывания, что указанный именованный компонент действительно существует.
В во втором варианте проверка значения, передаваемого в метод, не выполняется.
Свойство targetName компонента client.
Таким образом, опечатки обнаруживаются только вероятные фатальные результаты), когда фактически создается экземпляр `client` bean.

Если «клиент» bean-компонент — это bean-компонент prototype, эта опечатка и полученный результат исключение может быть обнаружено только спустя много времени после развертывания контейнера.
Элемент `idref`.
ПРИМЕЧАНИЕ.
Обычное место (по крайней мере, в версиях до Spring 2.0), где `<idref/>` элемент приносит значение находится в конфигурации перехватчики AOP в определении bean-компонента ProxyFactoryBean.
Использование элементов `<idref/>` при указании имена перехватчиков не позволяют вам ошибиться в написании идентификатора перехватчика.
Ссылки на другие компоненты (соавторы).
Элемент `ref` является последним элементом внутри `<constructor-arg/>` или `<property/>`. элемент определения.
Здесь вы устанавливаете значение указанного свойства компонента как ссылка на другой компонент (соавтор), управляемый контейнером.
Ссылочный компонент — это зависимость bean-компонента, свойство которого должно быть установлено, и оно инициализируется по требованию. по мере необходимости, прежде чем свойство будет установлено. (Если соавтор является одноэлементным компонентом, он может уже инициализирован контейнером.) Все ссылки в конечном итоге являются ссылками на другой объект.
Область действия и проверка зависят от того, указываете ли вы идентификатор или имя другой объект через атрибут bean или parent.
Ссылки на другие компоненты (соавторы).

Указание целевого компонента через атрибут bean тега <ref/> является наиболее простым. общую форму и позволяет создавать ссылку на любой компонент в том же контейнере или родительский контейнер, независимо от того, находится ли он в том же XML-файле.
Ценность Атрибут `bean` может совпадать с атрибутом `id` целевого bean-компонента или совпадать с ним. как одно из значений атрибута `name` целевого bean-компонента.
Следующий пример показывает, как использовать элемент `ref`:
	<ref bean="someBean"/>
Ссылки на другие компоненты (соавторы).
Указание целевого компонента через атрибут «parent» создает ссылку на компонент. это находится в родительском контейнере текущего контейнера.
Значение «родителя» Атрибут может совпадать либо с атрибутом `id` целевого bean-компонента, либо с одним из значения в атрибуте `name` целевого bean-компонента.
Целевой компонент должен находиться в родительский контейнер текущего.
В основном вам следует использовать этот эталонный вариант компонента. когда у вас есть иерархия контейнеров и вы хотите обернуть существующий компонент в родительский компонент контейнер с прокси-сервером, имеющим то же имя, что и родительский компонент.
Следующая пара листинги показывают, как использовать атрибут «parent»:
	<!-- in the parent context -->
	<bean id="accountService" class="com.something.SimpleAccountService">

<!-- insert dependencies as required here -->
	</bean>
	<!-- in the child (descendant) context, bean name is the same as the parent bean -->
	<bean id="accountService"
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target">
			<ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
		</property>
		<!-- insert other configuration and dependencies as required here -->
	</bean>
Ссылки на другие компоненты (соавторы).
ПРИМЕЧАНИЕ.
Атрибут local элемента ref больше не поддерживается в bean-компонентах версии 4.0.
XSD, поскольку он больше не предоставляет значения по обычной ссылке на компонент.
Изменить ваши существующие `ref local` ссылаются на `ref bean` при обновлении до схемы 4.0.
Внутренние бобы.
Элемент `<bean/>` внутри элементов `<property/>` или `<constructor-arg/>` определяет внутренний компонент, как показано в следующем примере:
	<bean id="outer" class="...">
		<!-- instead of using a reference to a target bean, simply define the target bean inline -->
		<property name="target">

<bean class="com.example.Person"> <!-- this is the inner bean -->
				<property name="name" value="Fiona Apple"/>
				<property name="age" value="25"/>
			</bean>
		</property>
	</bean>
Внутренние бобы.
Определение внутреннего компонента не требует определенного идентификатора или имени.
Если указано, контейнер не использует такое значение в качестве идентификатора.
Контейнер также игнорирует флаг «scope» создание, поскольку внутренние компоненты всегда анонимны и всегда создаются вместе с внешними боб.
Невозможно получить доступ к внутренним компонентам независимо или внедрить их в сотрудничающие bean-компоненты, отличные от включающего bean-компонента.
Внутренние бобы.
В крайнем случае, можно получать обратные вызовы уничтожения из пользовательской области — например, для внутреннего bean-компонента с областью запроса, содержащегося в одноэлементном bean-компоненте.
Создание экземпляра внутреннего компонента привязан к содержащему его компоненту, но обратные вызовы разрушения позволяют ему участвовать в жизненном цикле области запроса.
Это не распространенный сценарий.
Внутренние бобы обычно просто делятся областью действия содержащего их компонента.
Коллекции.

Элементы `<list/>`, `<set/>`, `<map/>` и `<props/>` устанавливают свойства и аргументы типов Java `Collection` List`, `Set`, `Map` и `Properties`, соответственно.
В следующем примере показано, как их использовать:
	<bean id="moreComplexObject" class="example.ComplexObject">
		<!-- results in a setAdminEmails(java.util.Properties) call -->
		<property name="adminEmails">
			<props>
				<prop key="administrator">administrator@example.org</prop>
				<prop key="support">support@example.org</prop>
				<prop key="development">development@example.org</prop>
			</props>
		</property>
		<!-- results in a setSomeList(java.util.List) call -->
		<property name="someList">
			<list>
				<value>a list element followed by a reference</value>
				<ref bean="myDataSource" />
			</list>
		</property>
		<!-- results in a setSomeMap(java.util.Map) call -->
		<property name="someMap">
			<map>

<entry key="an entry" value="just some string"/>
				<entry key="a ref" value-ref="myDataSource"/>
			</map>
		</property>
		<!-- results in a setSomeSet(java.util.Set) call -->
		<property name="someSet">
			<set>
				<value>just some string</value>
				<ref bean="myDataSource" />
			</set>
		</property>
	</bean>
Коллекции.
Значение ключа или значения карты или заданное значение также может быть любым из следующие элементы:
	фасоль | ссылка | идеф | список | набор | карта | реквизит | ценность | нулевой
Объединение коллекций.
Контейнер Spring также поддерживает объединение коллекций.
Приложение разработчик может определить родительский элемент `<list/>`, `<map/>`, `<set/>` или `<props/>` и иметь дочерние элементы `<list/>`, `<map/>`, `<set/>` или `<props/>`, наследующие и переопределить значения из родительской коллекции.
То есть значения дочерней коллекции результат слияния элементов родительской и дочерней коллекций с дочерней коллекцией элементы коллекции, переопределяющие значения, указанные в родительской коллекции.
Объединение коллекций.

В этом разделе, посвященном слиянию, обсуждается механизм родительско-дочерних компонентов.
Читатели незнакомы с определениями родительских и дочерних компонентов, возможно, захочется прочитать
	<beans>
		<bean id="parent" abstract="true" class="example.ComplexObject">
			<property name="adminEmails">
				<props>
					<prop key="administrator">administrator@example.com</prop>
					<prop key="support">support@example.com</prop>
				</props>
			</property>
		</bean>
		<bean id="child" parent="parent">
			<property name="adminEmails">
				<!-- the merge is specified on the child collection definition -->
				<props merge="true">
					<prop key="sales">sales@example.com</prop>
					<prop key="support">support@example.co.uk</prop>
				</props>
			</property>
		</bean>
	<beans>
Следующий пример демонстрирует слияние коллекций:.
Обратите внимание на использование атрибута `merge=true` в элементе `<props/>` Свойство `adminEmails` определения `дочернего` компонента.

Когда `дочерний` компонент разрешен и создается контейнером, полученный экземпляр имеет `adminEmails` Коллекция `Properties`, содержащая результат слияния дочерних элементов.
Коллекция `adminEmails` с родительской коллекцией `adminEmails`.
Следующий список показывает результат:
administrator=administrator@example.com sales=sales@example.com support=support@example.co.uk.
Набор значений дочерней коллекции Properties наследует все элементы свойств из родительский `<props/>`, а дочернее значение для значения `support` переопределяет значение в родительская коллекция.
administrator=administrator@example.com sales=sales@example.com support=support@example.co.uk.
Такое поведение слияния применяется аналогично `<list/>`, `<map/>` и `<set/>`. типы коллекций.
В конкретном случае элемента `<list/>` семантика связанный с типом коллекции List (то есть с понятием упорядоченной коллекции). коллекция значений) сохраняется.
Значения родительского элемента предшествуют всем значениям дочернего списка. ценности.
В случае типов коллекций Map, Set и Properties порядок не упорядочивается. существует.
Следовательно, семантика упорядочения не действует для типов коллекций, лежащих в основе связанные типы реализации Map, Set и Properties, которые контейнер использует внутренне.
Ограничения слияния коллекций.
Вы не можете объединить разные типы коллекций (например, «Карта» и «Список»).

Если ты попытайтесь это сделать, будет выдано соответствующее исключение.
Атрибут `merge` должен быть указанный в нижнем, унаследованном, дочернем определении.
Указание атрибута merge на определение родительской коллекции является избыточным и не приводит к желаемому слиянию.
Строго типизированная коллекция.
Благодаря поддержке Java универсальных типов вы можете использовать строго типизированные коллекции.
То есть можно объявить тип «Коллекция» так, чтобы он мог содержать только (например) элементы String.
Если вы используете Spring для внедрения зависимостей строго типизированную `Collection` в bean-компонент, вы можете воспользоваться преимуществами Spring поддержка преобразования типов, так что элементы вашей строго типизированной коллекции экземпляры преобразуются в соответствующий тип перед добавлением в «Коллекцию».
Следующий класс Java и определение компонента показывают, как это сделать:
Java
	public class SomeClass {
		private Map<String, Float> accounts;
		public void setAccounts(Map<String, Float> accounts) {
			this.accounts = accounts;
	<beans>
		<bean id="something" class="x.y.SomeClass">
			<property name="accounts">
				<map>
					<entry key="one" value="9.99"/>
					<entry key="two" value="2.75"/>
					<entry key="six" value="3.99"/>
				</map>
			</property>
		</bean>

</beans>
Строго типизированная коллекция.
Когда свойство account компонента Something готовится к внедрению, дженерики информация о типе элемента строго типизированного `Map<String, Float>` доступны посредством отражения.
Таким образом, инфраструктура преобразования типов Spring распознает различные элементы значений имеют тип Float, а строковые значения (9.99, 2.75 и `3.99`) преобразуются в фактический тип `Float`.
Значения пустых и пустых строк.
Spring рассматривает пустые аргументы для свойств и т.п. как пустые «строки».
Следующий фрагмент метаданных конфигурации на основе XML устанавливает для свойства `email` пустое значение. `Строковое` значение ("").
	<bean class="ExampleBean">
		<property name="email" value=""/>
	</bean>
Java
	exampleBean.setEmail("");
	exampleBean.email = ""
	<bean class="ExampleBean">
		<property name="email">
			<null/>
		</property>
	</bean>
Java
	exampleBean.setEmail(null);
	exampleBean.email = null
Ярлык XML с пространством имен p.
Пространство имен p позволяет использовать атрибуты элемента bean (вместо вложенных элементы `<property/>`) для описания значений свойств взаимодействующих bean-компонентов или того и другого.
Ярлык XML с пространством имен p.

Spring поддерживает расширяемые форматы конфигурации. которые основаны на определении XML-схемы.
Формат конфигурации `beans`, обсуждаемый в эта глава определена в документе XML-схемы.
Однако пространство имен p не определено. в файле XSD и существует только в ядре Spring.
Ярлык XML с пространством имен p.
В следующем примере показаны два фрагмента XML (первый использует стандартный формат XML, а второй использует пространство имен p), которые приводят к одному и тому же результату:
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean name="classic" class="com.example.ExampleBean">
			<property name="email" value="someone@somewhere.com"/>
		</bean>
		<bean name="p-namespace" class="com.example.ExampleBean"
			p:email="someone@somewhere.com"/>
	</beans>

Ярлык XML с пространством имен p.
В примере показан атрибут в пространстве имен p, называемый электронной почтой в определении компонента.
Это говорит Spring о необходимости включить объявление свойства.
Как упоминалось ранее, p-namespace не имеет определения схемы, поэтому вы можете установить имя атрибута к имени свойства.
Ярлык XML с пространством имен p.
Следующий пример включает в себя еще два определения bean-компонентов, оба из которых имеют ссылку на еще один боб:
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean name="john-classic" class="com.example.Person">
			<property name="name" value="John Doe"/>
			<property name="spouse" ref="jane"/>
		</bean>
		<bean name="john-modern"
			class="com.example.Person"
			p:name="John Doe"

p:spouse-ref="jane"/>
		<bean name="jane" class="com.example.Person">
			<property name="name" value="Jane Doe"/>
		</bean>
	</beans>
Ярлык XML с пространством имен p.
Этот пример включает не только значение свойства, использующее пространство имен p. но также использует специальный формат для объявления ссылок на свойства.
В то время как первый боб определение использует `<property name="spouse" ref="jane"/>` для создания ссылки из bean-компонента `john` на bean `jane`, второе определение bean-компонента использует `p:spouse-ref="jane"` в качестве атрибут, чтобы сделать то же самое.
В данном случае «супруга» — это имя объекта недвижимости, тогда как часть `-ref` указывает, что это не прямое значение, а скорее ссылка на другой компонент.
Ярлык XML с пространством имен p.
ПРИМЕЧАНИЕ.
Пространство имен p не такое гибкое, как стандартный формат XML.
Например, формат для объявления ссылок на свойства, конфликтующих со свойствами, оканчивающимися на Ref, тогда как стандартный формат XML этого не делает.
Мы рекомендуем вам тщательно выбирать подход и сообщите об этом членам вашей команды, чтобы избежать создания XML-документов, в которых используются все три подхода одновременно.

Ярлык XML с пространством имен c.
Подобно пространство имен c, представленное в Spring 3.1, позволяет использовать встроенные атрибуты для настройки аргументы конструктора, а не вложенные элементы constructor-arg.
Ярлык XML с пространством имен c.
В следующем примере пространство имен `c:` используется для того же самого, что и from.
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:c="http://www.springframework.org/schema/c"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean id="beanTwo" class="x.y.ThingTwo"/>
		<bean id="beanThree" class="x.y.ThingThree"/>
		<!-- traditional declaration with optional argument names -->
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg name="thingTwo" ref="beanTwo"/>
			<constructor-arg name="thingThree" ref="beanThree"/>

<constructor-arg name="email" value="something@somewhere.com"/>
		</bean>
		<!-- c-namespace declaration with argument names -->
		<bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
			c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>
	</beans>
Ярлык XML с пространством имен c.
Пространство имен `c:` использует те же соглашения, что и `p:` (завершающий `-ref` для ссылки на компоненты) для установки аргументов конструктора по их именам.
Аналогично, его необходимо объявить в файле XML, даже если он не определен в схеме XSD. (он существует внутри ядра Spring).
Ярлык XML с пространством имен c.
В редких случаях, когда имена аргументов конструктора недоступны (обычно, если байт-код был скомпилирован без флага `-parameters`), вы можете вернуться к индексы аргументов, а именно:
	<!-- c-namespace index declaration -->
	<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
		c:_2="something@somewhere.com"/>

Ярлык XML с пространством имен c.
ПРИМЕЧАНИЕ.
Из-за грамматики XML индексная запись требует присутствия ведущего `_`, поскольку имена атрибутов XML не могут начинаться с цифры (хотя некоторые IDE это допускают).
Соответствующее индексное обозначение также доступно для элементов `<constructor-arg>`, но обычно не используется, поскольку там обычно достаточно простого порядка объявления.
Ярлык XML с пространством имен c.
На практике разрешение конструктора довольно эффективен при сопоставлении аргументов, поэтому, если вам это действительно не нужно, мы рекомендуем используя обозначение имени во всей вашей конфигурации.
Составные имена свойств.
Вы можете использовать составные или вложенные имена свойств при установке свойств компонента, если все компоненты пути, кроме имени конечного свойства, не имеют значения null.
Рассмотрим следующее определение компонента:
	<bean id="something" class="things.ThingOne">
		<property name="fred.bob.sammy" value="123" />
	</bean>
Составные имена свойств.
Компонент `something` имеет свойство `fred`, свойство `bob`, которое имеет `sammy`. свойство, и этому окончательному свойству Sammy присваивается значение 123.
Для того, чтобы чтобы это работало, свойство `fred` объекта `something` и свойство `bob` объекта `fred` не должны быть нулевым после создания компонента.
В противном случае выдается исключение NullPointerException.

Области применения компонентов.
Когда вы создаете определение компонента, вы создаете рецепт для создания реальных экземпляров. класса, определенного этим определением компонента.
Идея о том, что определение компонента является Рецепт важен, потому что он означает, что, как и в случае с классом, вы можете создать множество объектов. экземпляры из одного рецепта.
Области применения компонентов.
Вы можете контролировать не только различные зависимости и значения конфигурации, которые необходимо быть подключен к объекту, созданному на основе определенного определения компонента, но также управлять область действия объектов, созданных на основе определенного определения компонента.
Этот подход мощный и гибкий, поскольку вы можете выбирать объем создаваемых объектов через конфигурацию вместо необходимости запекать в области объекта на Java уровень класса.
Компоненты могут быть определены для развертывания в одной из нескольких областей.
Spring Framework поддерживает шесть областей действия, четыре из которых доступны только в том случае, если вы используете веб-ориентированный `ApplicationContext`.
Вы также можете создать
.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание. | singleton | (По умолчанию) Охватывает одно определение bean-компонента одним экземпляром объекта для каждого Spring IoC. контейнер.
.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание. | прототип | Охватывает одно определение компонента любым количеством экземпляров объекта.

.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание. | запрос | Охватывает одно определение bean-компонента жизненным циклом одного HTTP-запроса.
То есть, каждый HTTP-запрос имеет свой собственный экземпляр компонента, созданный на основе одного компонента. определение.
Действует только в контексте Spring `ApplicationContext`, поддерживающего веб-интерфейс.
.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание. | сессия | Охватывает одно определение bean-компонента жизненным циклом HTTP-сеанса.
Действует только в контекст веб-приложения Spring `ApplicationContext`.
.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание. | приложение | Охватывает одно определение bean-компонента жизненным циклом ServletContext.
Действует только в контекст веб-приложения Spring `ApplicationContext`.
.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание. | websocket | Охватывает одно определение bean-компонента жизненным циклом WebSocket.
Действует только в контекст веб-приложения Spring `ApplicationContext`. |===
.Области применения бинов [cols="20%,80%"] |=== | Область применения| Описание.
ПРИМЕЧАНИЕ.

Область потока доступна, но по умолчанию не зарегистрирована.
Для получения дополнительной информации см. документацию для {spring-framework-api}/context/support/SimpleThreadScope.html[`SimpleThreadScope`].
Инструкции о том, как зарегистрировать эту или любую другую пользовательскую область, см.
Синглтон-область.
Управляется только один общий экземпляр одноэлементного компонента, и все запросы к компонентам с идентификатором или идентификаторами, которые соответствуют определению этого компонента, в результате получается один конкретный компонент экземпляр, возвращаемый контейнером Spring.
Синглтон-область.
Другими словами, когда вы определяете определение компонента, и его область действия ограничена Singleton, контейнер Spring IoC создает ровно один экземпляр объекта определяется этим определением компонента.
Этот единственный экземпляр хранится в кеше такого одиночные bean-компоненты и все последующие запросы и ссылки на этот именованный bean-компонент. вернуть кэшированный объект.
На следующем изображении показано, как работает область действия Singleton:
изображение::singleton.png[].
Концепция Singleton bean-компонента Spring отличается от шаблона Singleton, определенного в книга шаблонов Gang of Four (GoF).
Синглтон GoF жестко задает область действия объект такой, что для каждого создается один и только один экземпляр определенного класса.
КлассЗагрузчик.
Объем синглтона Spring лучше всего можно описать как охват каждого контейнера. и для каждого компонента.

Это означает, что если вы определите один компонент для определенного класса в один контейнер Spring, контейнер Spring создает один и только один экземпляр класса, определенного этим определением компонента.
Область синглтона является областью действия по умолчанию.
Spring.
Чтобы определить компонент как синглтон в XML, вы можете определить компонент, как показано в следующий пример:
	<bean id="accountService" class="com.something.DefaultAccountService"/>
	<!-- the following is equivalent, though redundant (singleton scope is the default) -->
	<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
Область применения прототипа.
Область развертывания bean-компонента, не являющаяся одноэлементным прототипом, приводит к созданию нового bean-компонента каждый раз, когда делается запрос на этот конкретный bean-компонент.
То есть боб вводится в другой компонент или вы запрашиваете его через вызов метода getBean() в контейнер.
Как правило, вы должны использовать область прототипа для всех bean-компонентов с состоянием и Singleton область действия для bean-компонентов без сохранения состояния.
изображение::prototype.png[]. (Объект доступа к данным (DAO) обычно не конфигурируется как прототип, поскольку типичный DAO не поддерживает любое разговорное состояние.
Нам было проще повторно использовать ядро синглтон-диаграмма.)

<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
В следующем примере компонент определяется как прототип в XML:.
В отличие от других областей видимости, Spring не управляет полным жизненным циклом объекта. прототип компонента.
Контейнер создает экземпляр, настраивает и иным образом собирает объект-прототип и передает его клиенту без дальнейшей записи этого прототипа. экземпляр.
Таким образом, хотя методы обратного вызова жизненного цикла инициализации вызываются на всех объекты независимо от области применения, в случае прототипов настраивается уничтожение обратные вызовы жизненного цикла не вызываются.
Клиентский код должен очистить область действия прототипа. объекты и освободить дорогостоящие ресурсы, которые хранятся в прототипах bean-компонентов.
Чтобы получить контейнер Spring для освобождения ресурсов, хранящихся в компонентах прототипа, попробуйте использовать пользовательская ссылка:core/beans/factory-extension.adoc#beans-factory-extension-bpp[постпроцессор bean] который содержит ссылку на bean-компоненты, которые необходимо очистить.
В следующем примере компонент определяется как прототип в XML:.
В некотором смысле, роль контейнера Spring по отношению к bean-компоненту в области прототипа является замена оператора Java `new`.
Все управление жизненным циклом после этого момента должно обрабатываться клиентом. (Подробнее о жизненном цикле bean-компонента Spring контейнер, см.
Обратные вызовы жизненного цикла.)
Singleton Beans с зависимостями от прототипа bean-компонента.

Когда вы используете одноэлементные bean-компоненты с зависимостями от прототипных bean-компонентов, имейте в виду, что зависимости разрешаются во время создания экземпляра.
Таким образом, если вы внедрите зависимость bean-компонент с областью прототипа в bean-компонент с областью действия Singleton, создается новый компонент-прототип а затем внедряется зависимость в одноэлементный компонент.
Экземпляр прототипа является единственным экземпляр, который когда-либо предоставляется bean-компоненту с одиночной областью видимости.
Singleton Beans с зависимостями от прототипа bean-компонента.
Однако предположим, что вы хотите, чтобы одноэлементный компонент получил новый экземпляр Компонент с областью действия прототипа неоднократно во время выполнения.
Вы не можете внедрить зависимость bean-компонент в области прототипа в ваш синглтон-компонент, потому что эта инъекция происходит только один раз, когда контейнер Spring создает экземпляр одноэлементного компонента и разрешает и внедряет свои зависимости.
Если вам нужен новый экземпляр прототипа bean-компонента по адресу во время выполнения более одного раза, см.
Внедрение метода.
Области запросов, сеансов, приложений и WebSocket.
Области запроса, сеанса, приложения и веб-сокета доступны только если вы используете веб-реализацию Spring `ApplicationContext` (например, `XmlWebApplicationContext`).
Если вы используете эти области с обычными контейнерами Spring IoC, такие как ClassPathXmlApplicationContext, IllegalStateException, которое жалуется о неизвестной области bean-компонента.
Первоначальная веб-конфигурация.

Для поддержки области видимости bean-компонентов по запросу, сеансу, приложению и уровни `websocket` (компоненты веб-области), некоторая незначительная начальная конфигурация требуется, прежде чем вы определите свои bean-компоненты. (Эта первоначальная настройка не требуется для стандартных областей: «singleton» и «prototype».)
Первоначальная веб-конфигурация.
То, как вы выполните эту первоначальную настройку, зависит от вашей конкретной среды сервлетов.
Первоначальная веб-конфигурация.
Если вы получаете доступ к bean-компонентам с ограниченной областью действия в Spring Web MVC, по сути, в рамках запроса, который обрабатывается Spring `DispatcherServlet`, никакой специальной настройки не требуется. `DispatcherServlet` уже предоставляет все соответствующее состояние.
Первоначальная веб-конфигурация.
Если вы используете веб-контейнер сервлетов, запросы которого обрабатываются вне Spring `DispatcherServlet` (например, при использовании JSF) необходимо зарегистрировать `org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`.
Это можно сделать программно, используя интерфейс WebApplicationInitializer.
Альтернативно добавьте следующее объявление в файл web.xml вашего веб-приложения:
	<web-app>
		<listener>
			<listener-class>
				org.springframework.web.context.request.RequestContextListener
			</listener-class>
		</listener>
	</web-app>
Первоначальная веб-конфигурация.

В качестве альтернативы, если есть проблемы с настройкой вашего прослушивателя, рассмотрите возможность использования Spring `RequestContextFilter`.
Сопоставление фильтров зависит от окружающей сети. конфигурацию приложения, поэтому вам придется изменить ее соответствующим образом.
Следующий список показывает фильтрующую часть веб-приложения:
	<web-app>
		<filter>
			<filter-name>requestContextFilter</filter-name>
			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>requestContextFilter</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
	</web-app>
Первоначальная веб-конфигурация.
DispatcherServlet, RequestContextListener и RequestContextFilter работают точно то же самое, а именно привязать объект HTTP-запроса к «Потоку», который обслуживает этот запрос.
Это делает bean-компоненты, доступные в области запроса и сеанса. по цепочке вызовов.
	<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
Рассмотрим следующую конфигурацию XML для определения компонента:.
Контейнер Spring создает новый экземпляр компонента LoginAction, используя метод Определение bean-компонента `loginAction` для каждого HTTP-запроса.
То есть Область действия компонента `loginAction` находится на уровне HTTP-запроса.

Вы можете изменить внутреннюю состояние экземпляра, который создается столько, сколько вы хотите, потому что другие экземпляры созданный на основе того же определения bean-компонента `loginAction`, не видит этих изменений в состоянии.
Они специфичны для индивидуального запроса.
Когда запрос завершает обработку, Компонент, ограниченный запросом, отбрасывается.
Рассмотрим следующую конфигурацию XML для определения компонента:.
При использовании компонентов, управляемых аннотациями, или конфигурации Java, аннотация `@RequestScope` может использоваться для назначения компонента области запроса.
Следующий пример показывает, как чтобы сделать это:
Java
	@RequestScope
	@Component
	public class LoginAction {
	@RequestScope
	@Component
	class LoginAction {
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
Рассмотрим следующую конфигурацию XML для определения компонента:.
Контейнер Spring создает новый экземпляр bean-компонента UserPreferences, используя метод Определение bean-компонента userPreferences на время существования одного HTTP-сеанса.
В другом Другими словами, bean-компонент `userPreferences` фактически ограничен уровнем HTTP-сеанса.
Как с помощью bean-компонентов области запроса вы можете изменить внутреннее состояние экземпляра, который создается столько, сколько вы хотите, зная, что другие экземпляры HTTP `Session`, которые также используя экземпляры, созданные на основе того же определения bean-компонента `userPreferences`, они не видятся изменения состояния, поскольку они специфичны для отдельного HTTP-сеанса.

Когда HTTP `Session` в конечном итоге отбрасывается, bean-компонент, ограниченный этим конкретным HTTP. «Сессия» также отбрасывается.
Рассмотрим следующую конфигурацию XML для определения компонента:.
При использовании компонентов, управляемых аннотациями, или конфигурации Java, вы можете использовать Аннотация `@SessionScope` для назначения компонента области `session`.
Java
	@SessionScope
	@Component
	public class UserPreferences {
	@SessionScope
	@Component
	class UserPreferences {
	<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
Рассмотрим следующую конфигурацию XML для определения компонента:.
Контейнер Spring создает новый экземпляр bean-компонента AppPreferences, используя метод Определение bean-компонента appPreferences один раз для всего веб-приложения.
То есть Компонент `appPreferences` имеет область действия на уровне `ServletContext` и хранится как обычный Атрибут `ServletContext`.
Это чем-то похоже на одноэлементный компонент Spring, но отличается двумя важными способами: это синглтон для ServletContext, а не для Spring. `ApplicationContext` (которых в любом веб-приложении может быть несколько), и он фактически предоставляется и, следовательно, виден как атрибут ServletContext.
Рассмотрим следующую конфигурацию XML для определения компонента:.
При использовании компонентов, управляемых аннотациями, или конфигурации Java, вы можете использовать Аннотация `@ApplicationScope` для назначения компонента области `application`. следующий пример показывает, как это сделать:
Java
	@ApplicationScope
	@Component

public class AppPreferences {
	@ApplicationScope
	@Component
	class AppPreferences {
Область веб-сокета.
Область WebSocket связана с жизненным циклом сеанса WebSocket и применяется к STOMP для приложений WebSocket, см.
Bean-компоненты с областью действия как зависимости.
Контейнер Spring IoC управляет не только созданием экземпляров ваших объектов (компонентов), но также и подключение соавторов (или зависимостей).
Если вы хотите ввести (для пример) bean-компонент с областью HTTP-запроса в другой bean-компонент с более продолжительной областью действия, вы можете выберите внедрение прокси-сервера AOP вместо ограниченного компонента.
То есть вам нужно ввести прокси-объект, который предоставляет тот же общедоступный интерфейс, что и объект с заданной областью, но который может также получить реальный целевой объект из соответствующей области (например, HTTP-запрос) и делегировать вызовы метода на реальный объект.
Bean-компоненты с областью действия как зависимости. [ПРИМЕЧАНИЕ] = Вы также можете использовать `<aop:scoped-proxy/>` между bean-компонентами, областью действия которых является `singleton`, при этом ссылка затем проходит через промежуточный прокси, который можно сериализовать и, следовательно, может повторно получить целевой одноэлементный компонент при десериализации.
Bean-компоненты с областью действия как зависимости.

При объявлении `<aop:scoped-proxy/>` для bean-компонента с областью `prototype` каждый метод вызов общего прокси-сервера приводит к созданию нового целевого экземпляра, к которому вызов затем переадресовывается.
Bean-компоненты с областью действия как зависимости.
Кроме того, прокси с ограниченной областью действия — не единственный способ доступа к компонентам из более коротких областей действия в мода, безопасная для жизненного цикла.
Вы также можете указать свою точку инъекции (т. аргумент конструктора или установщика или поле с автоматическим связыванием) как `ObjectFactory<MyTargetBean>`, позволяющий вызывать getObject() для получения текущего экземпляра по требованию каждый раз. время, когда это необходимо, не удерживая экземпляр и не сохраняя его отдельно.
Bean-компоненты с областью действия как зависимости.
В качестве расширенного варианта вы можете объявить `ObjectProvider<MyTargetBean>`, который доставляет несколько дополнительных вариантов доступа, включая getIfAvailable и getIfUnique.
Bean-компоненты с областью действия как зависимости.
Вариант JSR-330 называется Provider и используется с Provider<MyTargetBean>. объявление и соответствующий вызов get() для каждой попытки получения.
Дополнительную информацию о JSR-330 в целом см. в здесь.
Bean-компоненты с областью действия как зависимости.
Конфигурация в следующем примере состоит только из одной строки, но важно понять «почему», а также «как», стоящее за этим:

<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<!-- an HTTP Session-scoped bean exposed as a proxy -->
		<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
			<!-- instructs the container to proxy the surrounding bean -->
			<aop:scoped-proxy/> <1>
		</bean>
		<!-- a singleton-scoped bean injected with a proxy to the above bean -->
		<bean id="userService" class="com.something.SimpleUserService">

<!-- a reference to the proxied userPreferences bean -->
			<property name="userPreferences" ref="userPreferences"/>
		</bean>
	</beans>
Bean-компоненты с областью действия как зависимости. <1> Строка, определяющая прокси.
Bean-компоненты с областью действия как зависимости.
Чтобы создать такой прокси, вы вставляете дочерний элемент `<aop:scoped-proxy/>` в определение bean-компонента с ограниченной областью действия (см. и конфигурация на основе XML-схемы).
Bean-компоненты с областью действия как зависимости.
Почему определения bean-компонентов ограничены областью запроса, сеанса и пользовательской области? уровни требуют элемента `<aop:scoped-proxy/>` в распространенных сценариях?
Рассмотрим следующее определение одноэлементного компонента и сравним его с что вам нужно определить для вышеупомянутых областей (обратите внимание, что следующие Определение bean-компонента `userPreferences` в его нынешнем виде является неполным):
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
Bean-компоненты с областью действия как зависимости.

В предыдущем примере в одноэлементный компонент (`userManager`) вводится ссылка к HTTP-компоненту с областью действия `Session` (`userPreferences`).
Существенным моментом здесь является то, что Компонент `userManager` является одноэлементным: его экземпляр создается ровно один раз в контейнер и его зависимости (в данном случае только одна, bean-компонент `userPreferences`) тоже вводили только один раз.
Это означает, что компонент `userManager` работает только на точно такой же объект `userPreferences` (то есть тот, с которым он был первоначально внедрен).
Bean-компоненты с областью действия как зависимости.
Это не то поведение, которое вам нужно при внедрении компонента с более короткой областью действия в долгоживущий bean-компонент с областью действия (например, внедрение HTTP-компонента с областью действия «Session») bean как зависимость от одноэлементного bean-компонента).
Скорее, вам нужен один `userManager` объект, и на время существования HTTP-сеанса вам понадобится объект userPreferences. это специфично для HTTP-сеанса.
Таким образом, контейнер создает объект, который предоставляет тот же общедоступный интерфейс, что и класс UserPreferences (в идеале объект, который является экземпляром UserPreferences), который может получить реальную Объект UserPreferences из механизма определения области (HTTP-запрос, сеанс и т. д.). далее).

Контейнер внедряет этот прокси-объект в компонент `userManager`, который не зная, что эта ссылка UserPreferences является прокси.
В этом примере, когда Экземпляр UserManager вызывает метод для внедренного зависимости UserPreferences. объект, он фактически вызывает метод на прокси.
Затем прокси извлекает реальный Объект UserPreferences из (в данном случае) HTTP-сеанса и делегирует вызов метода для полученного реального объекта UserPreferences.
Bean-компоненты с областью действия как зависимости.
Таким образом, при внедрении вам потребуется следующая (правильная и полная) конфигурация: bean-компоненты `request-` и `session-scoped` в взаимодействующие объекты, как показано в следующем примере. показывает:
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<aop:scoped-proxy/>
	</bean>
	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
Выбор типа прокси для создания.
По умолчанию, когда контейнер Spring создает прокси для компонента, помеченного знаком элемента `<aop:scoped-proxy/>` создается прокси класса на основе CGLIB.
Выбор типа прокси для создания. [ПРИМЕЧАНИЕ] = Прокси-серверы CGLIB не перехватывают частные методы.

Попытка вызвать частный метод на таком прокси-сервере не будет делегироваться фактическому целевому объекту с заданной областью.
Выбор типа прокси для создания.
Альтернативно вы можете настроить контейнер Spring для создания стандартного JDK. прокси на основе интерфейса для таких bean-компонентов с ограниченной областью действия, указав `false` для значения атрибут proxy-target-class элемента `<aop:scoped-proxy/>`.
Использование JDK прокси на основе интерфейса означает, что вам не нужны дополнительные библиотеки в вашем путь к классам приложения, чтобы повлиять на такое проксирование.
Однако это также означает, что класс bean-компонент с областью действия должен реализовывать хотя бы один интерфейс и чтобы все участники в который вводится ограниченный bean-компонент, должен ссылаться на bean-компонент через один из его интерфейсы.
В следующем примере показан прокси-сервер на основе интерфейса:
	<!-- DefaultUserPreferences implements the UserPreferences interface -->
	<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
		<aop:scoped-proxy proxy-target-class="false"/>
	</bean>
	<bean id="userManager" class="com.stuff.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
Выбор типа прокси для создания.

Для получения более подробной информации о выборе проксирования на основе классов или интерфейсов см. см.
Механизмы проксирования.
Непосредственное внедрение ссылок на запрос/сеанс.
В качестве альтернативы заводским областям видимости Spring WebApplicationContext также поддерживает внедрение HttpServletRequest, HttpServletResponse, HttpSession, `WebRequest` и (если JSF присутствует) `FacesContext` и `ExternalContext` в Компоненты, управляемые Spring, просто посредством автоматического подключения на основе типов рядом с обычным внедрением. баллы за другие бобы.
Spring обычно вводит прокси для такого запроса и сеанса. объекты, преимущество которых заключается в работе с одноэлементными и сериализуемыми компонентами. а также аналогично прокси-серверам с областью действия для компонентов с заводской областью действия.
Пользовательские области.
Механизм области видимости компонента является расширяемым.
Вы можете определить свой собственный области действия или даже переопределить существующие области действия, хотя последнее считается плохой практикой. и вы не можете переопределить встроенные области действия «singleton» и «prototype».
Создание пользовательской области.
Чтобы интегрировать ваши пользовательские области видимости в контейнер Spring, вам необходимо реализовать Интерфейс `org.springframework.beans.factory.config.Scope`, который описан в этом раздел.

Информацию о том, как реализовать свои собственные области видимости, см. в разделе «Область действия». реализации, поставляемые вместе с самим Spring Framework и {spring-framework-api}/beans/factory/config/Scope.html[`Scope`] javadoc, где более подробно объясняются методы, которые необходимо реализовать.
Создание пользовательской области.
Интерфейс `Scope` имеет четыре метода для получения объектов из области видимости и удаления их из области видимости. прицел, и пусть они будут уничтожены.
Создание пользовательской области.
Например, реализация области сеанса возвращает bean-компонент области сеанса (если он не существует, метод возвращает новый экземпляр компонента после привязки его к сеанс для дальнейшего использования).
Следующий метод возвращает объект из базовая область действия:
Java
	Object get(String name, ObjectFactory<?> objectFactory)
Создание пользовательской области.
Например, реализация области сеанса удаляет bean-компонент области сеанса из базовый сеанс.
Объект должен быть возвращен, но вы можете вернуть `null`, если объект с указанным именем не найден.
Следующий метод удаляет объект из базовая область действия:
Java
	Object remove(String name)
Создание пользовательской области.
Следующий метод регистрирует обратный вызов, который область должна вызывать, когда она уничтожено или когда указанный объект в области уничтожен:
Java
	void RegisterDestructionCallback (имя строки, Runnable DestructionCallback)
Создание пользовательской области.

См. {spring-framework-api}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc] или реализацию Spring для получения дополнительной информации об обратных вызовах уничтожения.
Java
	String getConversationId()
Следующий метод получает идентификатор диалога для базовой области:.
Этот идентификатор различен для каждой области.
Для реализации в области сеанса это идентификатор может быть идентификатором сеанса.
Использование пользовательской области.
После того, как вы напишете и протестируете одну или несколько пользовательских реализаций Scope, вам необходимо сделать контейнер Spring знает о ваших новых областях.
Следующий метод является центральным. метод для регистрации новой области видимости в контейнере Spring:
Java
	void registerScope(String scopeName, Scope scope);
Использование пользовательской области.
Этот метод объявлен в интерфейсе ConfigurationBeanFactory, который доступен через свойство BeanFactory в большей части конкретного ApplicationContext. реализации, поставляемые вместе со Spring.
Использование пользовательской области.
Первым аргументом метода `registerScope(..)` является уникальное имя, связанное с область применения.
Примерами таких имен в самом контейнере Spring являются `singleton` и `прототип`.
Вторым аргументом метода `registerScope(..)` является фактический экземпляр. пользовательской реализации Scope, которую вы хотите зарегистрировать и использовать.
Использование пользовательской области.
Предположим, вы пишете свою собственную реализацию Scope, а затем регистрируете ее, как показано. в следующем примере.
Использование пользовательской области.
ПРИМЕЧАНИЕ.

В следующем примере используется SimpleThreadScope, который включен в Spring, но не является зарегистрирован по умолчанию.
Инструкции будут такими же для вашего собственного «Области применения». реализации.
Java
	Scope threadScope = new SimpleThreadScope();
	beanFactory.registerScope("thread", threadScope);
Использование пользовательской области.
Затем вы можете создать определения bean-компонентов, которые соответствуют правилам области действия вашего пользовательского интерфейса. `Объем`, а именно:
	<bean id="..." class="..." scope="thread">
Использование пользовательской области.
Благодаря специальной реализации «Области» вы не ограничены программной регистрацией. области применения.
Вы также можете выполнить регистрацию Scope декларативно, используя команду Класс CustomScopeConfigurer, как показано в следующем примере:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd

http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
			<property name="scopes">
				<map>
					<entry key="thread">
						<bean class="org.springframework.context.support.SimpleThreadScope"/>
					</entry>
				</map>
			</property>
		</bean>
		<bean id="thing2" class="x.y.Thing2" scope="thread">
			<property name="name" value="Rick"/>
			<aop:scoped-proxy/>
		</bean>
		<bean id="thing1" class="x.y.Thing1">
			<property name="thing2" ref="thing2"/>
		</bean>
	</beans>
Использование пользовательской области.
ПРИМЕЧАНИЕ.
Когда вы помещаете `<aop:scoped-proxy/>` в объявление `<bean>` для Реализация FactoryBean, областью действия является сам фабричный компонент, а не объект. возвращается из `getObject()`.

Резервный вариант SockJS.
В общедоступном Интернете ограничительные прокси-серверы, находящиеся вне вашего контроля, могут препятствовать использованию WebSocket. взаимодействия, либо потому, что они не настроены на передачу заголовка «Upgrade», либо потому что они закрывают долгоживущие соединения, которые кажутся простаивающими.
Резервный вариант SockJS.
Решением этой проблемы является эмуляция WebSocket, то есть попытка использовать WebSocket. сначала, а затем вернуться к методам на основе HTTP, которые эмулируют WebSocket взаимодействие и предоставлять один и тот же API уровня приложения.
Резервный вариант SockJS.
В стеке сервлетов Spring Framework обеспечивает поддержку как сервера, так и клиента. для протокола SockJS.
Обзор.
Цель SockJS — позволить приложениям использовать API WebSocket, но при этом вернуться к альтернативы, отличные от WebSocket, когда это необходимо во время выполнения, без необходимости изменить код приложения.
* {sockjs-protocol}[протокол SockJS]
SockJS состоит из:. определяется в виде исполняемого файла {sockjs-protocol-site}/sockjs-protocol-0.3.3.html[озвученные тесты].
* {sockjs-client}[SockJS JavaScript-клиент] — клиентская библиотека для использования в браузерах.
* Реализации сервера SockJS, включая одну в модуле Spring-websocket Spring Framework.
* Java-клиент SockJS в модуле Spring-websocket (начиная с версии 4.1).
SockJS состоит из:.
SockJS предназначен для использования в браузерах.

Он использует различные техники для поддержки широкого спектра версий браузера.
Полный список типов транспорта и браузеров SockJS см.
Страница {sockjs-client}[SockJS-клиент].
Транспорт делятся на три основные категории: WebSocket, потоковая передача HTTP и длинный опрос HTTP.
Обзор этих категорий см. {spring-site-blog}/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[это сообщение в блоге].
SockJS состоит из:.
Клиент SockJS начинает с отправки `GET /info` в получить основную информацию с сервера.
После этого он должен решить, какой транспорт использовать.
Если возможно, используется WebSocket.
Если нет, то в большинстве браузеров существует хотя бы один вариант потоковой передачи HTTP.
Если нет, то HTTP (длинный) используется опрос.
* pass:q[`{server-id}`] полезен для маршрутизации запросов в кластере, но в других случаях не используется.
* pass:q[`{session-id}`] соотносит HTTP-запросы, принадлежащие сеансу SockJS.
* pass:q[`{transport}`] указывает тип транспорта (например, `websocket`, `xhr-streaming` и другие).
где:.
Транспорту WebSocket требуется только один HTTP-запрос для выполнения подтверждения WebSocket.

Все последующие сообщения обмениваются через этот сокет.
где:.
HTTP-транспорт требует большего количества запросов.
Например, потоковая передача Ajax/XHR основана на один длительный запрос для сообщений между сервером и клиентом и дополнительный HTTP POST запросы сообщений клиент-сервер.
Длинный опрос аналогичен, за исключением того, что он завершает текущий запрос после каждой отправки от сервера к клиенту.
где:.
SockJS добавляет минимальное кадрирование сообщений.
Например, сервер отправляет букву `o` («открытый» кадр) изначально сообщения отправляются как `a["message1","message2"]` (массив в кодировке JSON), буква `h` (кадр `heartbeat`), если сообщения не передаются. на 25 секунд (по умолчанию) и букву «c» («рамка «закрыть»)» для закрытия сеанса.
где:.
Чтобы узнать больше, запустите пример в браузере и посмотрите HTTP-запросы.
Клиент SockJS позволяет фиксировать список транспортов, поэтому можно видеть каждый транспорт по одному.
Клиент SockJS также предоставляет флаг отладки. что позволяет отображать полезные сообщения в консоли браузера.
На стороне сервера вы можете включить Журнал TRACE для org.springframework.web.socket.
Более подробную информацию см. в протоколе SockJS. https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html [озвученный тест].

Включение SockJS.
Вы можете включить SockJS через конфигурацию, как показано в следующем примере: См. пример кода в исходном документе.
Включение SockJS.
Предыдущий пример предназначен для использования в приложениях Spring MVC и должен быть включен в пакет конфигурация файла `DispatcherServlet`.
Однако Spring WebSocket и поддержка SockJS не зависит от Spring MVC.
Относительно просто интегрироваться в другие среды HTTP-обслуживания с помощью {spring-framework-api}/web/socket/sockjs/support/SockJsHttpRequestHandler.html[`SockJsHttpRequestHandler`].
Включение SockJS.
На стороне браузера приложения могут использовать {sockjs-client}[`sockjs-client`] (версия 1.0.x).
Это эмулирует W3C WebSocket API и взаимодействует с сервером, чтобы выбрать лучший вариант транспорта, в зависимости от браузера, в котором он работает.
См.
Страница {sockjs-client}[sockjs-client] и список типы транспорта, поддерживаемые браузером.
Клиент также предоставляет несколько параметры конфигурации — например, чтобы указать, какие транспорты включать.
ИЕ 8 и 9.
Internet Explorer 8 и 9 продолжают использоваться.
Они ключевая причина использования SockJS.
В этом разделе рассматриваются важные соображения по поводу работы в этих браузерах.
ИЕ 8 и 9.

Клиент SockJS поддерживает потоковую передачу Ajax/XHR в IE 8 и 9 с помощью Microsoft. https://web.archive.org/web/20160219230343/https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx[`XDomainRequest`].
Это работает во всех доменах, но не поддерживает отправку файлов cookie.
Файлы cookie часто необходимы для приложений Java.
Однако, поскольку клиент SockJS можно использовать со многими серверами типов (не только Java), ему необходимо знать, имеют ли значение файлы cookie.
Если да, то клиент SockJS предпочитает Ajax/XHR для потоковой передачи.
В противном случае это опирается на технику на основе iframe.
ИЕ 8 и 9.
Первый запрос `/info` от клиента SockJS — это запрос информация, которая может повлиять на выбор клиентом транспорта.
Одна из этих деталей заключается в том, использует ли серверное приложение файлы cookie. (например, для целей аутентификации или кластеризации с помощью закрепленных сеансов).
Поддержка SockJS в Spring включает свойство sessionCookieNeeded.
Он включен по умолчанию, поскольку большинство приложений Java используют JSESSIONID. печенье.
Если вашему приложению это не нужно, вы можете отключить эту опцию, и клиент SockJS затем должен выбрать «xdr-streaming» в IE 8 и 9.
ИЕ 8 и 9.

Если вы используете транспорт на основе iframe, имейте в виду что браузерам можно дать указание блокировать использование IFrames на данной странице с помощью установка заголовка ответа HTTP `X-Frame-Options` в `DENY`, `SAMEORIGIN` или `ALLOW-FROM <origin>`.
Это используется для предотвращения https://www.owasp.org/index.php/Clickjacking[кликджекинг].
ИЕ 8 и 9. [ПРИМЕЧАНИЕ] = Spring Security 3.2+ обеспечивает поддержку установки X-Frame-Options на каждом ответ.
По умолчанию в конфигурации Spring Security Java для него установлено значение DENY.
В версии 3.2 пространство имен Spring Security XML не устанавливает этот заголовок по умолчанию. но его можно настроить для этого.
В будущем он может установить его по умолчанию.
ИЕ 8 и 9.
См. {docs-spring-security}/features/exploits/headers.html#headers-default [Заголовки безопасности по умолчанию]. документации Spring Security для получения подробной информации о том, как настроить настройка заголовка X-Frame-Options.
Вы также можете увидеть {spring-github-org}/spring-security/issues/2718[gh-2718] для дополнительного фона.
ИЕ 8 и 9.

Если ваше приложение добавляет заголовок ответа `X-Frame-Options` (как и должно!) и полагается на транспорт на основе iframe, вам необходимо установить значение заголовка `SAMEORIGIN` или `ALLOW-FROM <origin>`.
Весенний SockJS поддержке также необходимо знать расположение клиента SockJS, поскольку он загружен из iframe.
По умолчанию iframe настроен на загрузку клиента SockJS. из местоположения CDN.
Рекомендуется настроить эту опцию для использования URL-адрес из того же источника, что и приложение.
ИЕ 8 и 9.
В следующем примере показано, как его настроить: См. пример кода в исходном документе.
ИЕ 8 и 9.
ПРИМЕЧАНИЕ.
Во время первоначальной разработки включите режим разработки клиента SockJS, который предотвращает браузер от кэширования запросов SockJS (например, iframe), которые в противном случае кэшироваться.
Подробности о том, как его включить, см.
Страница {sockjs-client}[SockJS-клиент].
Сердцебиение.
Протокол SockJS требует, чтобы серверы отправляли периодические сообщения, чтобы запретить прокси-серверы. от заключения, что соединение зависло.
Конфигурация Spring SockJS имеет свойство называется «heartbeatTime», который вы можете использовать для настройки частоты.
По умолчанию Heartbeat отправляется через 25 секунд, при условии, что на этом этапе не было отправлено никаких других сообщений. соединение.

Это 25-секундное значение соответствует следующему {rfc-site}/rfc6202[рекомендация IETF] для общедоступных интернет-приложений.
Сердцебиение.
ПРИМЕЧАНИЕ.
При использовании STOMP через WebSocket и SockJS, если клиент STOMP и сервер согласовывают Heartbeats для обмена, Heartbeats SockJS отключены.
Сердцебиение.
Поддержка Spring SockJS также позволяет вам настроить TaskScheduler для планировать задачи Heartbeats.
Планировщик задач поддерживается пулом потоков, с настройками по умолчанию, основанными на количестве доступных процессоров. ты следует рассмотреть возможность настройки параметров в соответствии с вашими конкретными потребностями.
Клиент отключается.
Потоковая передача HTTP и длинный опрос HTTP Транспорты SockJS требуют, чтобы соединение оставалось открыты дольше обычного.
Обзор этих методов см. {spring-site-blog}/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[это сообщение в блоге].
Клиент отключается.
В контейнерах сервлетов это осуществляется посредством асинхронной поддержки сервлета 3, которая позволяет выйти из потока контейнера сервлетов, обработать запрос и продолжить написать ответ из другой ветки.
Клиент отключается.
Конкретная проблема заключается в том, что API сервлетов не предоставляет уведомления клиенту. это ушло.
См. https://github.com/eclipse-ee4j/servlet-api/issues/44[eclipse-ee4j/servlet-api#44].
Однако контейнеры сервлетов вызывают исключение при последующих попытках записи. к ответу.

Поскольку служба SockJS Spring поддерживает контрольные сигналы, отправляемые сервером (каждый по умолчанию 25 секунд), это означает, что в течение этого времени обычно обнаруживается отключение клиента. период времени (или раньше, если сообщения отправляются чаще).
Клиент отключается.
ПРИМЕЧАНИЕ.
В результате могут возникнуть сбои сетевого ввода-вывода из-за отключения клиента, что приводит к сбою сетевого ввода-вывода. может заполнить журнал ненужными трассировками стека.
Spring делает все возможное, чтобы идентифицировать такие сетевые сбои, которые представляют собой отключение клиента (специфическое для каждого сервера) и регистрируют минимальное сообщение с использованием специальной категории журнала `DISCONNECTED_CLIENT_LOG_CATEGORY` (определено в «AbstractSockJsSession»).
Если вам нужно увидеть трассировку стека, вы можете установить это категорию журнала в TRACE.
SockJS и CORS.
Если вы разрешаете запросы из разных источников (см.
Протокол использует CORS для междоменной поддержки в потоковой передаче XHR и транспорте опроса.
Таким образом, заголовки CORS добавляются автоматически, за исключением случаев, когда заголовки CORS присутствуют в файле. обнаружен ответ.
Итак, если приложение уже настроено для поддержки CORS (например, через фильтр сервлетов), Spring SockJsService пропускает эту часть.
SockJS и CORS.
Также можно отключить добавление этих заголовков CORS, установив параметр Свойство SuppressCors в Spring SockJsService.
* `Access-Control-Allow-Origin`: инициализируется значением заголовка запроса `Origin`.

* `Access-Control-Allow-Credentials`: всегда установлено значение `true`.
* `Access-Control-Request-Headers`: инициализируется значениями из эквивалентного заголовка запроса.
* `Access-Control-Allow-Methods`: методы HTTP, поддерживаемые транспортом (см. перечисление `TransportType`).
* «Access-Control-Max-Age»: установлено значение 31536000 (1 год).
SockJS ожидает следующие заголовки и значения:.
Точную реализацию см. в `addCorsHeaders` в `AbstractSockJsService` и перечисление TransportType в исходном коде.
SockJS ожидает следующие заголовки и значения:.
В качестве альтернативы, если конфигурация CORS это позволяет, рассмотрите возможность исключения URL-адресов с Префикс конечной точки SockJS, что позволяет Spring SockJsService обрабатывать его.
`SockJsClient`.
Spring предоставляет Java-клиент SockJS для подключения к удаленным конечным точкам SockJS без с помощью браузера.
Это может быть особенно полезно, когда есть необходимость в двунаправленной передаче данных. связь между двумя серверами через общедоступную сеть (то есть, где сетевые прокси могут исключить использование протокола WebSocket).
Java-клиент SockJS также очень полезен. в целях тестирования (например, для имитации большого количества одновременных пользователей).
`SockJsClient`.
Java-клиент SockJS поддерживает `websocket`, `xhr-streaming` и `xhr-polling`. транспорты.
Остальные имеют смысл использовать только в браузере.

* StandardWebSocketClient во время выполнения JSR-356.
* JettyWebSocketClient с использованием встроенного API WebSocket Jetty 9+.
* Любая реализация Spring WebSocketClient.
Вы можете настроить WebSocketTransport с помощью:.
XhrTransport по определению поддерживает как потоковую передачу xhr, так и опрос xhr, поскольку: с точки зрения клиента нет никакой разницы, кроме URL-адреса, используемого для подключения. на сервер.
На данный момент существует две реализации:
* RestTemplateXhrTransport использует Spring RestTemplate для HTTP-запросов.
* JettyXhrTransport использует Jetty HttpClient для HTTP-запросов.
Вы можете настроить WebSocketTransport с помощью:.
В следующем примере показано, как создать клиент SockJS и подключиться к конечной точке SockJS:
Вы можете настроить WebSocketTransport с помощью:.
List<Transport> transports = new ArrayList<>(2); transports.add(new WebSocketTransport(new StandardWebSocketClient())); transports.add(new RestTemplateXhrTransport());
Вы можете настроить WebSocketTransport с помощью:.
SockJsClient sockJsClient = new SockJsClient(transports); sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
Вы можете настроить WebSocketTransport с помощью:.
ПРИМЕЧАНИЕ.
SockJS использует для сообщений массивы в формате JSON.
По умолчанию используется Jackson 2, и ему требуется быть на пути к классу.
Альтернативно вы можете настроить собственную реализацию `SockJsMessageCodec` и настройте его в `SockJsClient`.

Вы можете настроить WebSocketTransport с помощью:.
Чтобы использовать SockJsClient для имитации большого количества одновременных пользователей, вы необходимо настроить базовый HTTP-клиент (для транспорта XHR), чтобы обеспечить достаточный количество соединений и нитей.
В следующем примере показано, как это сделать с помощью Jetty:
Вы можете настроить WebSocketTransport с помощью:.
HttpClient jettyHttpClient = new HttpClient(); jettyHttpClient.setMaxConnectionsPerDestination(1000); jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
Вы можете настроить WebSocketTransport с помощью:.
В следующем примере показаны свойства, связанные с SockJS на стороне сервера (подробности см. в javadoc). что вам также следует рассмотреть возможность настройки: См. пример кода в исходном документе.

Фильтры.
В API сервлетов вы можете добавить `jakarta.servlet.Filter` для применения логики в стиле перехвата. до и после остальной части цепочки обработки фильтров и целевого «сервлета».
* Данные формы
* Пересылаемые заголовки
* Shallow ETag
* CORS
* Обработчик URL
* `GenericFilterBean` — базовый класс для `Filter`, настроенного как bean-компонент Spring;
Существуют также реализации базового класса для использования в приложениях Spring:. интегрируется с жизненным циклом Spring `ApplicationContext`.
* `OncePerRequestFilter` — расширение `GenericFilterBean`, которое поддерживает одиночный
Существуют также реализации базового класса для использования в приложениях Spring:. вызов в начале запроса, т.е. во время фазы отправки REQUEST, и игнорируя дальнейшую обработку через отправку FORWARD.
Фильтр также обеспечивает контроль относительно того, участвует ли «Фильтр» в отправках «ASYNC» и «ERROR».
Существуют также реализации базового класса для использования в приложениях Spring:.
Фильтры сервлетов можно настроить в `web.xml` или с помощью аннотаций сервлетов.
В приложении Spring Boot вы можете {spring-boot-docs}/how-to/webserver.html#howto.webserver.add-servlet-filter-listener.spring-bean [объявить фильтры как bean-компоненты] и Boot настроит их.
Данные формы.

Браузеры могут отправлять данные формы только через HTTP GET или HTTP POST, но клиенты, не являющиеся браузерами, также могут используйте HTTP PUT, PATCH и DELETE.
API сервлетов требует `ServletRequest.getParameter{asterisk}()` методы для поддержки доступа к полям формы только для HTTP POST.
Данные формы.
Модуль Spring-Web обеспечивает FormContentFilter для перехвата HTTP PUT, PATCH и DELETE. запросы с типом контента «application/x-www-form-urlencoded», прочитайте данные формы из тело запроса и оберните `ServletRequest`, чтобы сделать данные формы доступен через семейство методов `ServletRequest.getParameter{asterisk}()`.
Фильтр перенаправленного заголовка. `ForwardedHeaderFilter` — это фильтр сервлетов, который изменяет запрос, чтобы а) изменить хост, порт и схему на основе заголовков «Перенаправлено» и б) удалить их. заголовки для устранения дальнейшего воздействия.
Фильтр основан на упаковке запроса и поэтому его необходимо упорядочивать перед другими фильтрами, такими как RequestContextFilter, который должен работать с измененным, а не с исходным запросом.
Вопросы безопасности.
Существуют соображения безопасности для пересылаемых заголовков, поскольку приложение не может знать если заголовки были добавлены прокси-сервером, как предполагалось, или вредоносным клиентом.
Вот почему прокси-сервер на границе доверия должен быть настроен на удаление ненадежных «Перенаправленных» заголовки, которые приходят извне.

Вы также можете настроить ForwardedHeaderFilter. с `removeOnly=true`, и в этом случае заголовки удаляются, но не используются.
Типы диспетчеров.
Чтобы поддерживать асинхронные запросы и отправлять ошибки, это Фильтр должен быть сопоставлен с DispatcherType.ASYNC, а также с DispatcherType.ERROR.
При использовании AbstractAnnotationConfigDispatcherServletInitializer Spring Framework (см.
Servlet Config) все фильтры автоматически регистрируются для всей отправки. типы.
Однако при регистрации фильтра через web.xml или в Spring Boot через `FilterRegistrationBean` обязательно включите `DispatcherType.ASYNC` и DispatcherType.ERROR в дополнение к DispatcherType.REQUEST.
Мелкий ETag.
Фильтр ShallowEtagHeaderFilter создает «мелкий» ETag путем кэширования содержимого. записывается в ответ и вычисляется из него хэш MD5.
В следующий раз, когда клиент отправит, он делает то же самое, но также сравнивает вычисленное значение с `If-None-Match` заголовок запроса и, если они равны, возвращает 304 (NOT_MODIFIED).
Мелкий ETag.
Эта стратегия экономит пропускную способность сети, но не ЦП, поскольку для каждого запроса необходимо вычислять полный ответ.
Методы HTTP, изменяющие состояние, и другие заголовки условных запросов HTTP, такие как If-Match и `If-Unmodified-Since` выходят за рамки этого фильтра.
Другие стратегии на уровне контроллера может избежать вычислений и иметь более широкую поддержку условных запросов HTTP.

См. ссылку:web/webmvc/mvc-caching.adoc [HTTP-кэширование].
Мелкий ETag.
Этот фильтр имеет параметр writeWeakETag, который настраивает фильтр для записи слабых ETag. аналогично следующему: `W/"02a2d595e6ed9a0b24f027f2b63b134d6"` (как определено в {rfc-сайт}/rfc7232#section-2.3[RFC 7232, раздел 2.3]).
Мелкий ETag.
Для поддержки асинхронных запросов этот фильтр должен быть сопоставлен. с DispatcherType.ASYNC, чтобы фильтр мог задерживать и успешно генерировать ETag в конец последней асинхронной отправки.
Если вы используете Spring Framework `AbstractAnnotationConfigDispatcherServletInitializer` (см. ссылку:web/webmvc/mvc-servlet/container-config.adoc [Servlet Config]) все фильтры автоматически регистрируются для всех типов рассылок.
Однако если зарегистрироваться фильтр через `web.xml` или в Spring Boot через `FilterRegistrationBean` обязательно включите `Тип Диспетчера.ASYNC`.
КОРС.
Spring MVC обеспечивает детальную поддержку конфигурации CORS посредством аннотаций на контроллеры.
Однако при использовании Spring Security мы советуем полагаться на встроенный `CorsFilter`, который необходимо заказывать перед цепочкой фильтров Spring Security.
КОРС.
Дополнительные сведения см. в разделах CORS и CORS Filter.
Обработчик URL-адресов.
Возможно, вы захотите, чтобы конечные точки вашего контроллера соответствовали маршрутам с косой чертой в конце URL-пути или без нее.

Например, и «GET /home», и «GET /home/» должны обрабатываться методом контроллера, аннотированным `@GetMapping("/home")`.
Обработчик URL-адресов.
Spring предоставляет UrlHandlerFilter, который удаляет конечную косую черту из URL-путей, чтобы обеспечить согласованное представление путей с конечной косой чертой или без нее.
Это важно, чтобы избежать несоответствия между решениями об авторизации на основе URL-адресов и сопоставлениями запросов веб-платформы.
Фильтр может удалить косую черту одним из нескольких способов:
* ответить статусом перенаправления HTTP, который отправляет клиентов по одному и тому же пути без косой черты в конце.
* обернуть запрос на удаление косой черты в конце.
Обработчик URL-адресов.
ПРИМЕЧАНИЕ.
Исторически Spring MVC поддерживал сопоставление конечных косых черт URL-путей.
Эта возможность устарела в версии 6.0 по соображениям безопасности и удалена в версии 7.0 с UrlHandlerFilter предоставляет более безопасную альтернативу.
Обработчик URL-адресов.
Вот как вы можете создать и настроить UrlHandlerFilter для приложения блога: См. пример кода в исходном документе.
- корневой путь `"/"` исключен из обработки косой черты.
- `@RequestMapping("/")` добавляет конечную косую черту к сопоставлению уровня типа и, следовательно, будет

Имейте в виду следующее:. не отображать, когда применяется обработка косой черты; вместо этого используйте `@RequestMapping` (без атрибута пути).

Пример реализации декларативной транзакции.
Рассмотрим следующий интерфейс и сопутствующую ему реализацию.
В этом примере используется Классы `Foo` и `Bar` в качестве заполнителей, чтобы вы могли сосредоточиться на транзакции. использование без фокусировки на конкретной модели предметной области.
Для целей этого примера тот факт, что класс DefaultFooService выдает исключение UnsupportedOperationException. экземпляры в теле каждого реализованного метода — это хорошо.
Такое поведение позволяет вам видеть транзакции создаются, а затем откатываются в ответ на Экземпляр UnsupportedOperationException.
В следующем листинге показан FooService. интерфейс:
Java
	// интерфейс сервиса, который мы хотим сделать транзакционным
	package x.y.service;
	public interface FooService {
		Foo getFoo(String fooName);
		Foo getFoo(String fooName, String barName);
		void insertFoo(Foo foo);
		void updateFoo(Foo foo);
	// интерфейс сервиса, который мы хотим сделать транзакционным
	package x.y.service
	interface FooService {
Java
	package x.y.service;
	public class DefaultFooService implements FooService {
		@Override
		public Foo getFoo(String fooName) {
		@Override
		public Foo getFoo(String fooName, String barName) {
		@Override
		public void insertFoo(Foo foo) {
		@Override
		public void updateFoo(Foo foo) {
	package x.y.service
	class DefaultFooService : FooService {
В следующем примере показана реализация предыдущего интерфейса:.

Предположим, что первые два метода интерфейса FooService: getFoo(String) и `getFoo(String, String)` должен выполняться в контексте транзакции с доступом только для чтения. семантику и что другие методы, `insertFoo(Foo)` и `updateFoo(Foo)`, должны запускаться в контексте транзакции с семантикой чтения и записи.
Следующие Конфигурация подробно описана в следующих нескольких параграфах:
	<!-- from the file 'context.xml' -->
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd

http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">
		<!-- this is the service object that we want to make transactional -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>
		<!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->
		<tx:advice id="txAdvice" transaction-manager="txManager">
			<!-- the transactional semantics... -->
			<tx:attributes>
				<!-- all methods starting with 'get' are read-only -->
				<tx:method name="get*" read-only="true"/>
				<!-- other methods use the default transaction settings (see below) -->
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>
		<!-- ensure that the above transactional advice runs for any execution
			of an operation defined by the FooService interface -->
		<aop:config>

<aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
		</aop:config>
		<!-- don't forget the DataSource -->
		<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
			<property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
			<property name="username" value="scott"/>
			<property name="password" value="tiger"/>
		</bean>
		<!-- similarly, don't forget the TransactionManager -->
		<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>
		<!-- other <bean/> definitions here -->
	</beans>
В следующем примере показана реализация предыдущего интерфейса:.

Изучите предыдущую конфигурацию.
Предполагается, что вы хотите создать объект службы, компонент `fooService`, транзакционный.
Применяемая семантика транзакции инкапсулирована. в определении `<tx:advice/>`.
Определение `<tx:advice/>` читается как «все методы начинающиеся с `get`, выполняются в контексте транзакции только для чтения, и все другие методы должны работать с семантикой транзакции по умолчанию».
Атрибуту `transaction-manager` тега `<tx:advice/>` присвоено имя Компонент TransactionManager, который будет управлять транзакциями (в данном случае компонент `txManager`).
В следующем примере показана реализация предыдущего интерфейса:.
СОВЕТ: Вы можете опустить атрибут `transaction-manager` в рекомендациях по транзакциям. (`<tx:advice/>`), если имя компонента `TransactionManager`, который вы хотите провод имеет имя «transactionManager».
Если компонент TransactionManager к которому вы хотите подключиться, имеет любое другое имя, вы должны использовать «менеджер транзакций» атрибут явно, как в предыдущем примере.
В следующем примере показана реализация предыдущего интерфейса:.
Определение `<aop:config/>` гарантирует, что рекомендации по транзакциям, определенные Компонент `txAdvice` запускается в соответствующих точках программы.
Сначала вы определяете pointcut, соответствующий выполнению любой операции, определенной в интерфейсе FooService. («fooServiceOperation»).
Затем вы связываете pointcut с txAdvice, используя советник.

Результат показывает, что при выполнении `fooServiceOperation` запускается совет, определенный `txAdvice`.
В следующем примере показана реализация предыдущего интерфейса:.
Выражение, определенное в элементе `<aop:pointcut/>`, представляет собой pointcut AspectJ. выражение.
См. раздел AOP для получения более подробной информации о pointcut. выражения Spring.
В следующем примере показана реализация предыдущего интерфейса:.
Общее требование — сделать весь уровень обслуживания транзакционным.
Лучший способ сделать это, чтобы изменить выражение pointcut, чтобы оно соответствовало любой операции в вашем сервисный уровень.
В следующем примере показано, как это сделать:
	<aop:config>
		<aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
		<aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
	</aop:config>
В следующем примере показана реализация предыдущего интерфейса:.
ПРИМЕЧАНИЕ.
В предыдущем примере предполагается, что все ваши сервисные интерфейсы определены в пакете `x.y.service`.
Дополнительную информацию см. в раздел АОП.
В следующем примере показана реализация предыдущего интерфейса:.
Теперь, когда мы проанализировали конфигурацию, вы можете спросить себя: «Что на самом деле делает вся эта конфигурация?»
В следующем примере показана реализация предыдущего интерфейса:.

Показанная ранее конфигурация используется для создания транзакционного прокси вокруг объекта. который создается на основе определения bean-компонента `fooService`.
Прокси настроен с транзакционный совет, чтобы при вызове соответствующего метода на прокси-сервере транзакция запускается, приостанавливается, помечается как доступная только для чтения и т. д., в зависимости от конфигурация транзакции, связанная с этим методом.
Рассмотрим следующую программу этот тест запускает конфигурацию, показанную ранее:
Java
	public final class Boot {
		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");
			FooService fooService = ctx.getBean(FooService.class);
			fooService.insertFoo(new Foo());
В следующем примере показана реализация предыдущего интерфейса:.
Результат запуска предыдущей программы должен выглядеть следующим образом (файл Log4J вывод и трассировка стека из UnsupportedOperationException, выданного Метод `insertFoo(..)` класса `DefaultFooService` был усечен для ясности):
	<!-- the Spring container is starting up... -->
	[AspectJInvoctionContextExposeAdvisorAutoProxyCreator] — создание неявного прокси для bean-компонента «fooService» с 0 общими перехватчиками и 1 конкретным перехватчиком.
	<!-- the DefaultFooService is actually proxied -->
	[JdkDynamicAopProxy] — создание динамического прокси JDK для [x.y.service.DefaultFooService]

<!-- ... the insertFoo(..) method is now being invoked on the proxy -->
	[TransactionInterceptor] — Получение транзакции для x.y.service.FooService.insertFoo
	<!-- the transactional advice kicks in here... -->
	[DataSourceTransactionManager] — Создание новой транзакции с именем [x.y.service.FooService.insertFoo]
	[DataSourceTransactionManager] — полученное соединение [org.apache.commons.dbcp.PoolableConnection@a53de4] для транзакции JDBC
	<!-- the insertFoo(..) method from DefaultFooService throws an exception... -->
	[RuleBasedTransactionAttribute] — применение правил для определения того, следует ли откатить транзакцию в java.lang.UnsupportedOperationException.
	[TransactionInterceptor] — вызов отката транзакции на x.y.service.FooService.insertFoo из-за исключения исключения [java.lang.UnsupportedOperationException]
	<!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) -->
	[DataSourceTransactionManager] — откат транзакции JDBC при подключении [org.apache.commons.dbcp.PoolableConnection@a53de4]
	[DataSourceTransactionManager] — освобождение соединения JDBC после транзакции
	[DataSourceUtils] — Возврат соединения JDBC к источнику данных

Исключение в потоке «основной» java.lang.UnsupportedOperationException в x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
	<!-- AOP infrastructure stack trace elements removed for clarity -->
	at $Proxy0.insertFoo(Unknown Source)
	at Boot.main(Boot.java:11)
В следующем примере показана реализация предыдущего интерфейса:.
Чтобы использовать реактивное управление транзакциями, код должен использовать реактивные типы.
В следующем примере показана реализация предыдущего интерфейса:.
ПРИМЕЧАНИЕ.
Spring Framework использует ReactiveAdapterRegistry, чтобы определить, является ли метод тип возвращаемого значения — реактивный.
В следующем примере показана реализация предыдущего интерфейса:.
В следующем листинге показана модифицированная версия ранее использовавшегося `FooService`, но на этот раз код использует реактивные типы:
Java
	// интерфейс реактивного сервиса, который мы хотим сделать транзакционным
	package x.y.service;
	public interface FooService {
		Flux<Foo> getFoo(String fooName);
		Publisher<Foo> getFoo(String fooName, String barName);
		Mono<Void> insertFoo(Foo foo);
		Mono<Void> updateFoo(Foo foo);
	// интерфейс реактивного сервиса, который мы хотим сделать транзакционным
	package x.y.service
	interface FooService {
Java
	package x.y.service;
	public class DefaultFooService implements FooService {
		@Override
		public Flux<Foo> getFoo(String fooName) {
		@Override

public Publisher<Foo> getFoo(String fooName, String barName) {
		@Override
		public Mono<Void> insertFoo(Foo foo) {
		@Override
		public Mono<Void> updateFoo(Foo foo) {
	package x.y.service
	class DefaultFooService : FooService {
В следующем примере показана реализация предыдущего интерфейса:.
Императивное и реактивное управление транзакциями имеют одну и ту же семантику для транзакций. определения границ и атрибутов транзакции.
Основное отличие императивного и реактивных транзакций – это отложенный характер последних. `Перехватчик транзакций` украшает возвращаемый реактивный тип транзакционным оператором для начала и очистки транзакция.
Следовательно, вызов транзакционно-реактивного метода откладывает фактическое выполнение. управление транзакциями на тип подписки, который активирует обработку реактивных тип.
В следующем примере показана реализация предыдущего интерфейса:.
Другой аспект реактивного управления транзакциями связан с экранированием данных, которое является естественное следствие модели программирования.
В следующем примере показана реализация предыдущего интерфейса:.
Возвращаемые значения метода императивных транзакций возвращаются из транзакционных методов. при успешном завершении метода, чтобы частично вычисленные результаты не ускользнули закрытие метода.
В следующем примере показана реализация предыдущего интерфейса:.
Методы реактивной транзакции возвращают тип реактивной оболочки, который представляет собой последовательность вычислений вместе с обещанием начать и завершить вычисление.
В следующем примере показана реализация предыдущего интерфейса:. «Издатель» может отправлять данные во время транзакции, но не обязательно завершенной.

Поэтому методы, которые зависят от успешного завершения всей транзакции, нуждаются в для обеспечения завершения и буферизации результатов в вызывающем коде.

Настройка глобального формата даты и времени.
По умолчанию поля даты и времени, не помеченные @DateTimeFormat, преобразуются из строки, используя стиль DateFormat.SHORT.
Если хотите, вы можете изменить это, определение вашего собственного глобального формата.
Настройка глобального формата даты и времени.
Для этого убедитесь, что Spring не регистрирует средства форматирования по умолчанию.
Вместо этого зарегистрируйтесь форматтеры вручную с помощью:
* `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`
* `org.springframework.format.datetime.DateFormatterRegistrar`
Настройка глобального формата даты и времени.
Например, следующая конфигурация регистрирует глобальный формат «ггггММдд»: См. пример кода в исходном документе.
Настройка глобального формата даты и времени.
Обратите внимание, что при настройке форматов даты и времени в Интернете необходимо учитывать дополнительные моменты. приложения.
Пожалуйста, посмотрите

Весеннее форматирование полей.
Как обсуждалось в предыдущем разделе, `core.convert` — это универсальная система преобразования типов.
Он предоставляет унифицированный API ConversionService как а также строго типизированный SPI Converter для реализации логики преобразования из одного типа. другому.
Контейнер Spring использует эту систему для привязки значений свойств компонента.
В Кроме того, и Spring Expression Language (SpEL), и DataBinder используют эту систему для привязать значения полей.
Например, когда SpEL необходимо преобразовать «Short» в «Long», чтобы завершите попытку `expression.setValue(Object bean, Object value)`, `core.convert` система выполняет принуждение.
Весеннее форматирование полей.
Теперь рассмотрим требования к преобразованию типов типичной клиентской среды, например веб-приложение или настольное приложение.
В таких средах вы обычно конвертируете из `String` для поддержки процесса обратной передачи клиента, а также обратно в String для поддержки просмотреть процесс рендеринга.
Кроме того, вам часто требуется локализовать строковые значения.
Чем больше общий `core.convert` `Converter` SPI не учитывает такие требования к форматированию. напрямую.
Чтобы напрямую обращаться к ним, Spring предоставляет удобный SPI Formatter, который предоставляет простую и надежную альтернативу реализациям PropertyEditor для клиента. среды.
Весеннее форматирование полей.

В общем, вы можете использовать SPI «Конвертер», когда вам нужно реализовать тип общего назначения. логика преобразования — например, для преобразования между `java.util.Date` и `Long`.
Вы можете использовать SPI `Formatter`, когда работаете в клиентской среде (например, в веб-интерфейсе). приложение) и необходимо проанализировать и распечатать локализованные значения полей. `Конверсионная служба` предоставляет унифицированный API преобразования типов для обоих SPI.
SPI форматтера.
SPI `Formatter` для реализации логики форматирования полей прост и строго типизирован.
Следующий листинг показывает определение интерфейса Formatter:
	package org.springframework.format;
	public interface Formatter<T> extends Printer<T>, Parser<T> {
SPI форматтера. «Форматтер» является продолжением интерфейсов строительных блоков «Принтер» и «Парсер».
Следующий листинг показывает определения этих двух интерфейсов:
	public interface Printer<T> {
		String print(T fieldValue, Locale locale);
	import java.text.ParseException;
	public interface Parser<T> {
		T parse(String clientValue, Locale locale) throws ParseException;
SPI форматтера.
Чтобы создать свой собственный «Форматтер», реализуйте интерфейс «Форматтер», показанный ранее.
Параметризируйте `T` как тип объекта, который вы хотите отформатировать, например: `java.util.Date`.

Реализуйте операцию print() для печати экземпляра T для отображение в локали клиента.
Реализуйте операцию `parse()` для анализа экземпляра `T` из форматированного представления, возвращенного из локали клиента.
Ваш «Форматёр» должен выдавать исключение ParseException или IllegalArgumentException, если попытка синтаксического анализа не удалась.
Возьми позаботьтесь о том, чтобы ваша реализация `Formatter` была потокобезопасной.
SPI форматтера.
Подпакеты `format` для удобства предоставляют несколько реализаций `Formatter`.
Пакет `number` предоставляет `NumberStyleFormatter`, `CurrencyStyleFormatter` и PercentStyleFormatter для форматирования объектов Number, использующих java.text.NumberFormat.
Пакет datetime предоставляет DateFormatter для форматирования объектов java.util.Date с помощью java.text.DateFormat, а также DurationFormatter для форматирования объектов Duration. в разных стилях, определенных в перечислении `@DurationFormat.Style` (см. <<format-annotations-api>>).
Java
	package org.springframework.format.datetime;
	public final class DateFormatter implements Formatter<Date> {
		private String pattern;
		public DateFormatter(String pattern) {
			this.pattern = pattern;
		public String print(Date date, Locale locale) {
			if (date == null) {
				return "";
			return getDateFormat(locale).format(date);
		public Date parse(String formatted, Locale locale) throws ParseException {

if (formatted.length() == 0) {
				return null;
			return getDateFormat(locale).parse(formatted);
		protected DateFormat getDateFormat(Locale locale) {
			DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
			dateFormat.setLenient(false);
			return dateFormat;
Следующий DateFormatter представляет собой пример реализации Formatter:.
Команда Spring приветствует вклад сообщества в программу Formatter.
См. {spring-framework-issues}[Проблемы GitHub] могут внести свой вклад.
Форматирование на основе аннотаций.
Форматирование поля можно настроить по типу поля или аннотации.
Связать аннотацию к форматтеру, реализуйте AnnotationFormatterFactory.
Следующие В листинге показано определение интерфейса AnnotationFormatterFactory:
	package org.springframework.format;
	public interface AnnotationFormatterFactory<A extends Annotation> {
		Set<Class<?>> getFieldTypes();
		Printer<?> getPrinter(A annotation, Class<?> fieldType);
		Parser<?> getParser(A annotation, Class<?> fieldType);
Чтобы создать реализацию:. .
Параметризируйте `A` как поле `annotationType`, с которым вы хотите связать логика форматирования — например, `org.springframework.format.annotation.DateTimeFormat`..
Попросите getFieldTypes() вернуть типы полей, в которых можно использовать аннотацию..
Пусть getPrinter() вернет принтер для печати значения аннотированного поля..

Пусть getParser() вернет Parser для анализа clientValue для аннотированного поля.
Чтобы создать реализацию:.
Следующий пример реализации AnnotationFormatterFactory привязывает @NumberFormat. аннотация к средству форматирования, позволяющая указать стиль или шаблон числа:
Java
	public final class NumberFormatAnnotationFormatterFactory
			implements AnnotationFormatterFactory<NumberFormat> {
		private static final Set<Class<?>> FIELD_TYPES = Set.of(Short.class,
				Целочисленный.класс, Длинный.класс, Плавающий.класс, Двойной.класс,
				BigDecimal.class, BigInteger.class);
		public Set<Class<?>> getFieldTypes() {
			return FIELD_TYPES;
		public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {
			return configureFormatterFrom(annotation, fieldType);
		public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {
			return configureFormatterFrom(annotation, fieldType);
		private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) {
			if (!annotation.pattern().isEmpty()) {
				return new NumberStyleFormatter(annotation.pattern());
			// еще
			return switch(annotation.style()) {
				case Style.PERCENT -> new PercentStyleFormatter();
				case Style.CURRENCY -> new CurrencyStyleFormatter();
				default -> new NumberStyleFormatter();
	class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory<NumberFormat> {
Чтобы создать реализацию:.

Чтобы запустить форматирование, вы можете аннотировать поля с помощью @NumberFormat, как показано ниже. пример показывает:
Java
	public class MyModel {
		@NumberFormat(style=Style.CURRENCY)
		private BigDecimal decimal;
API форматирования аннотаций.
API аннотаций переносимого формата существует в файле `org.springframework.format.annotation`. пакет.
Вы можете использовать @NumberFormat для форматирования числовых полей, таких как Double и `Long`, `@DurationFormat` для форматирования полей `Duration` в ISO-8601 и упрощенных стилях, и `@DateTimeFormat` для форматирования таких полей, как `java.util.Date`, `java.util.Calendar`, и «Long» (для миллисекундных меток времени), а также типы JSR-310 «java.time».
API форматирования аннотаций.
В следующем примере используется @DateTimeFormat для форматирования java.util.Date как даты ISO. (гггг-ММ-дд):
Java
	public class MyModel {
		@DateTimeFormat(iso=ISO.DATE)
		private Date date;
API форматирования аннотаций.

Более подробную информацию см. в javadoc для {spring-framework-api}/format/annotation/DateTimeFormat.html[`@DateTimeFormat`], {spring-framework-api}/format/annotation/DurationFormat.html[`@DurationFormat`] и {spring-framework-api}/format/annotation/NumberFormat.html[`@NumberFormat`].
API форматирования аннотаций. [ВНИМАНИЕ] = Форматирование и синтаксический анализ на основе стилей основаны на шаблонах, чувствительных к локали, которые могут измениться. в зависимости от среды выполнения Java.
В частности, приложения, которые полагаются на дату, время или синтаксический анализ и форматирование чисел могут столкнуться с несовместимыми изменениями в поведении при запуске на JDK 20 или выше.
API форматирования аннотаций.
Использование стандартизированного формата ISO или конкретного шаблона, которым вы управляете, позволяет надежный системно-независимый и независимый от локали анализ и форматирование даты, времени, и числовые значения.
API форматирования аннотаций.
Для `@DateTimeFormat` использование резервных шаблонов также может помочь решить проблему. проблемы совместимости.
API форматирования аннотаций.

Более подробную информацию см. https://github.com/spring-projects/spring-framework/wiki/Date-and-Time-Formatting-with-JDK-20-and-higher [Форматирование даты и времени с помощью JDK 20 и более поздних версий] страница в вики Spring Framework.
SPI `FormatterRegistry`. «FormatterRegistry» — это SPI для регистрации форматтеров и конвертеров. «FormattingConversionService» — это реализация «FormatterRegistry», подходящая для большинство сред.
Вы можете программно или декларативно настроить этот вариант. в качестве bean-компонента Spring, например, с помощью FormattingConversionServiceFactoryBean.
Потому что это реализация также реализует ConversionService, вы можете настроить ее напрямую для использования с Spring DataBinder и языком выражений Spring (SpEL).
	package org.springframework.format;
	public interface FormatterRegistry extends ConverterRegistry {
		void addPrinter(Printer<?> printer);
		void addParser(Parser<?> parser);
		void addFormatter(Formatter<?> formatter);
		void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);
		void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);
		void addFormatterForFieldAnnotation(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory);
В следующем листинге показан SPI FormatterRegistry:.
Как показано в предыдущем листинге, вы можете зарегистрировать средства форматирования по типу поля или по аннотации.

В следующем листинге показан SPI FormatterRegistry:.
SPI FormatterRegistry позволяет централизованно настраивать правила форматирования, а не дублирование такой конфигурации на ваших контроллерах.
Например, вы можете захотеть обеспечить, чтобы все поля даты были отформатированы определенным образом или чтобы поля имели определенный формат. аннотации форматируются определенным образом.
С помощью общего «FormatterRegistry» вы определяете эти правила применяются один раз, и они применяются всякий раз, когда требуется форматирование.
SPI `FormatterRegistrar`. «FormatterRegistrar» — это SPI для регистрации форматтеров и конвертеров через Реестр форматтера.
В следующем листинге показано определение его интерфейса:
	package org.springframework.format;
	public interface FormatterRegistrar {
		void registerFormatters(FormatterRegistry registry);
SPI `FormatterRegistrar`. «FormatterRegistrar» полезен при регистрации нескольких связанных конвертеров и средства форматирования для данной категории форматирования, например форматирования даты.
Это также может быть полезно там, где декларативная регистрация недостаточна — например, когда форматтер необходимо индексировать по определенному типу поля, отличному от его собственного `<T>`, или когда регистрация пары «Принтер»/«Парсер».
В следующем разделе представлена дополнительная информация о регистрация конвертера и форматтера.
Настройка форматирования в Spring MVC.
См.
Преобразование и форматирование в главе Spring MVC.

Функции.
Вы можете расширить SpEL, зарегистрировав определяемые пользователем функции, которые можно вызывать внутри выражения с использованием синтаксиса `#functionName(...)` и аналогично стандартному методу. вызовы, также поддерживаются varargs для вызовов функций.
Функции могут быть зарегистрированы как _переменные_ в реализациях `EvaluationContext` через Метод `setVariable()`.
Функции. [СОВЕТ] = `StandardEvaluationContext` также определяет методы `registerFunction(...)`, которые предоставляют удобный способ зарегистрировать функцию как `java.lang.reflect.Method` или `java.lang.invoke.MethodHandle`.
Функции. [ВНИМАНИЕ] = Поскольку функции имеют общее пространство имен с необходимо следить за тем, чтобы имена функций и имена переменных не перекрывались.
Функции.
В следующем примере показано, как зарегистрировать определяемую пользователем функцию для вызова через отражение с использованием `java.lang.reflect.Method`:
Java
	Method method = ...;
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	context.setVariable("myFunction", method);
Java
	public abstract class StringUtils {
		public static String reverseString(String input) {
			return new StringBuilder(input).reverse().toString();
Например, рассмотрим следующий служебный метод, который переворачивает строку:.
Вы можете зарегистрировать и использовать предыдущий метод, как показано в следующем примере:
Java

ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	context.setVariable("reverseString",
			StringUtils.class.getMethod("reverseString", String.class));
	// оценивается как «оллех»
	String helloWorldReversed = parser.parseExpression(
			"#reverseString('hello')").getValue(context, String.class);
Например, рассмотрим следующий служебный метод, который переворачивает строку:.
Функцию также можно зарегистрировать как java.lang.invoke.MethodHandle.
Это позволяет потенциально более эффективные варианты использования, если цель и параметры `MethodHandle` имеют были полностью связаны до регистрации; однако частично связанные дескрипторы также поддерживается.
Например, рассмотрим следующий служебный метод, который переворачивает строку:.
Рассмотрим метод экземпляра `String#formatted(Object...)`, который создает сообщение по шаблону и переменному количеству аргументов (varargs).
Например, рассмотрим следующий служебный метод, который переворачивает строку:.
Вы можете зарегистрировать и использовать метод «formatted» как «MethodHandle», как показано ниже. пример показывает:
Java
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	MethodHandle mh = MethodHandles.lookup().findVirtual(String.class, "formatted",

MethodType.methodType(String.class, Object[].class));
	context.setVariable("message", mh);
	// оценивается как «Простое сообщение: <Hello World>»
	String message = parser.parseExpression("#message('Simple message: <%s>', 'Hello World', 'ignored')")
			.getValue(context, String.class);
Например, рассмотрим следующий служебный метод, который переворачивает строку:.
Как упоминалось выше, привязка MethodHandle и регистрация привязанного MethodHandle также поддерживается.
Вероятно, это будет более эффективно, если и цель, и все аргументы связаны.
В этом случае в выражении SpEL аргументы не требуются, так как следующий пример показывает:
Java
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	String template = "This is a %s message with %s words: <%s>";
	Object varargs = new Object[] { "prerecorded", 3, "Oh Hello World!", "ignored" };
	MethodHandle mh = MethodHandles.lookup().findVirtual(String.class, "formatted",
		MethodType.methodType(String.class, Object[].class))
			.bindTo(template)
			// Здесь мы должны предоставить аргументы в одной привязке массива:

.bindTo(varargs);
	context.setVariable("message", mh);
	// оценивается как «Это заранее записанное сообщение из трех слов: <Oh Hello World!>»
	String message = parser.parseExpression("#message()")
			.getValue(context, String.class);

Общие соображения по интеграции ORM.
В этом разделе освещены соображения, применимые ко всем технологиям ORM.
В разделе Hibernate представлена более подробная информация, а также показаны эти функции и конфигурации в конкретном контексте.
Общие соображения по интеграции ORM.
Основная цель интеграции ORM в Spring — четкое многоуровневое представление приложений (с любыми данными). технологии доступа и транзакций), а для слабой связи объектов приложения - нет больше зависимостей бизнес-сервисов от доступа к данным или стратегии транзакций, не более жестко запрограммированные поиски ресурсов, больше нет труднозаменяемых одиночных элементов, больше нет настраиваемых сервисов реестры.
Цель состоит в том, чтобы иметь один простой и последовательный подход к подключению объектов приложения, сохраняя они максимально пригодны для повторного использования и свободны от контейнерных зависимостей.
Все индивидуально функции доступа к данным можно использовать сами по себе, но они прекрасно интегрируются с Spring. концепция контекста приложения, обеспечивающая конфигурацию на основе XML и перекрестные ссылки на простые экземпляры JavaBean, которые не обязательно поддерживают Spring.
В типичном приложении Spring многие важные объекты являются JavaBeans: шаблоны доступа к данным, объекты доступа к данным, менеджеры транзакций, бизнес-сервисы, использующие объекты доступа к данным и транзакции менеджеры, преобразователи веб-представлений, веб-контроллеры, использующие бизнес-сервисы, и т. д.
Управление ресурсами и транзакциями.
Типичные бизнес-приложения перегружены повторяющимся кодом управления ресурсами.

Многие проекты пытаются изобрести собственные решения, иногда жертвуя правильным обращением. отказов для удобства программирования.
Spring выступает за простые решения для правильного обработка ресурсов, а именно IoC посредством шаблонов в случае JDBC и применения AOP перехватчики для технологий ОРМ.
Управление ресурсами и транзакциями.
Инфраструктура обеспечивает правильную обработку ресурсов и соответствующее преобразование определенные исключения API в непроверяемой иерархии исключений инфраструктуры.
Весна представляет иерархию исключений DAO, применимую к любой стратегии доступа к данным.
Для прямого JDBC, класс JdbcTemplate, упомянутый в файле предыдущий раздел обеспечивает обработку соединений и правильное преобразование `SQLException` в Иерархия DataAccessException, включая перевод ошибок SQL, специфичных для базы данных. коды для значимых классов исключений.
Информацию о технологиях ORM см. преимущества перевода.
Управление ресурсами и транзакциями.
Когда дело доходит до управления транзакциями, класс JdbcTemplate подключается к Spring. поддержка транзакций и поддерживает транзакции JTA и JDBC через соответствующие Spring менеджеры транзакций.
Для поддерживаемых технологий ORM Spring предлагает Hibernate. и поддержка JPA через менеджеры транзакций Hibernate и JPA, а также поддержку JTA.
Подробную информацию о поддержке транзакций см. в главе «Управление транзакциями».
Перевод исключений.
Когда вы используете Hibernate или JPA в DAO, вы должны решить, как обрабатывать постоянство. собственные классы исключений технологии.
DAO выдает подкласс HibernateException. или PersistenceException, в зависимости от технологии.
Все эти исключения относятся к среде выполнения. исключения и не должны быть объявлены или перехвачены.

Возможно, вам также придется иметь дело с IllegalArgumentException и IllegalStateException.
Это означает, что вызывающие абоненты могут только рассматривать исключения как фатальные, если только они не хотят зависеть от устойчивости собственная структура исключений технологии.
Выявление конкретных причин (таких как оптимистичный настрой) сбой блокировки) невозможен без привязки вызывающего объекта к стратегии реализации.
Этот компромисс может быть приемлемым для приложений, которые сильно основаны на ORM или не требуют какой-либо специальной обработки исключений (или того и другого).
Однако Spring допускает исключение перевод может применяться прозрачно через аннотацию `@Repository`.
Следующие примеры (один для конфигурации Java и один для конфигурации XML) показывают, как это сделать:
Java
	@Repository
	public class ProductDaoImpl implements ProductDao {
		// классное тело здесь...
	@Repository
	class ProductDaoImpl : ProductDao {
		// классное тело здесь...
	<beans>
		<!-- Exception translation bean post processor -->
		<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
		<bean id="myProductDao" class="product.ProductDaoImpl"/>
	</beans>
Перевод исключений.
Постпроцессор автоматически ищет все трансляторы исключений (реализации интерфейс PersistenceExceptionTranslator) и сообщает всем bean-компонентам, отмеченным значком аннотацию `@Repository`, чтобы обнаруженные переводчики могли перехватить и применить соответствующий перевод по выброшенным исключениям.
Перевод исключений.

Таким образом, вы можете реализовать DAO на основе API простой технологии персистентности и аннотации, сохраняя при этом преимущества транзакций, управляемых Spring, зависимости внедрение и прозрачное преобразование исключений (при желании) в пользовательские Spring иерархии исключений.

Использование дженериков в качестве квалификаторов автоподключения.
В дополнение к аннотации `@Qualifier` вы можете использовать универсальные типы Java. как неявная форма квалификации.
Например, предположим, что у вас есть следующее конфигурация:
Java
	@Configuration
	public class MyConfiguration {
		@Bean
		public StringStore stringStore() {
			return new StringStore();
		@Bean
		public IntegerStore integerStore() {
			return new IntegerStore();
	@Configuration
	class MyConfiguration {
Использование дженериков в качестве квалификаторов автоподключения.
Предполагая, что предыдущие bean-компоненты реализуют общий интерфейс (то есть Store<String>` и `Store<Integer>`), вы можете `@Autowire` использовать интерфейс `Store`, и его общий вид используется в качестве квалификатора, как показано в следующем примере:
Java
	@Autowired
	private Store<String> s1; // <String> qualifier, injects the stringStore bean
	@Autowired
	private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
Использование дженериков в качестве квалификаторов автоподключения.
Общие квалификаторы также применяются при автоматическом связывании списков, экземпляров Map и массивов.
В следующем примере автоматически подключается общий `List`:
Java
	// Внедрить все bean-компоненты Store, если они имеют общий <Integer>
	// Компоненты Store<String> не будут отображаться в этом списке.
	@Autowired
	private List<Store<Integer>> s;

Спящий режим.
Мы начнем с описания https://hibernate.org/[Hibernate] в среде Spring. используя его для демонстрации подхода Spring к интеграции преобразователей OR.
В этом разделе подробно рассматриваются многие проблемы и показаны различные варианты DAO. реализации и разграничение транзакций.
Большинство из этих шаблонов могут быть непосредственно переведен на все другие поддерживаемые инструменты ORM.
Последующие разделы этой главы затем осветите другие технологии ORM и покажите краткие примеры.
Спящий режим. [ПРИМЕЧАНИЕ] = Учитывая Spring Framework 7.0, Spring требует Hibernate ORM 7.x для Spring. `HibernateJpaVendorAdapter`.
Спящий режим.
Пакет `org.springframework.orm.jpa.hibernate` заменяет прежний `orm.hibernate5`: теперь для использования с Hibernate ORM 7.x, тесно интегрированным с HibernateJpaVendorAdapter а также поддержка собственного стиля Hibernate `SessionFactory.getCurrentSession()`.
Настройка SessionFactory в контейнере Spring.
Чтобы избежать привязки объектов приложения к жестко запрограммированному поиску ресурсов, вы можете определить ресурсы (такие как DataSource JDBC или SessionFactory Hibernate) в виде bean-компонентов в Пружинный контейнер.
Объекты приложения, которым необходим доступ к ресурсам, получают ссылки. к таким предопределенным экземплярам через ссылки на компоненты, как показано в DAO. определение в файле следующий раздел.
Настройка SessionFactory в контейнере Spring.
В следующем отрывке из определения контекста приложения XML показано, как настроить JDBC DataSource и Hibernate SessionFactory поверх него:
	<beans>

<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
			<property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
			<property name="username" value="sa"/>
			<property name="password" value=""/>
		</bean>
		<bean id="mySessionFactory" class="org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean">
			<property name="dataSource" ref="myDataSource"/>
			<property name="mappingResources">
				<list>
					<value>product.hbm.xml</value>
				</list>
			</property>
			<property name="hibernateProperties">
				<value>
					hibernate.dialect=org.hibernate.dialect.HSQLDialect
				</value>
			</property>
		</bean>
	</beans>
Настройка SessionFactory в контейнере Spring.
Переключение с локального источника базовых данных Jakarta Commons DBCP на источник, расположенный в JNDI. `DataSource` (обычно управляемый сервером приложений) — это всего лишь вопрос конфигурации, как показано в следующем примере:
	<beans>

<jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/>
	</beans>
Настройка SessionFactory в контейнере Spring.
Вы также можете получить доступ к расположенной в JNDI `SessionFactory`, используя Spring `JndiObjectFactoryBean` / `<jee:jndi-lookup>`, чтобы получить и предоставить его.
Однако это обычно не распространено вне контекста EJB.
Настройка SessionFactory в контейнере Spring. [ПРИМЕЧАНИЕ] = Spring также предоставляет вариант LocalSessionFactoryBuilder, легко интегрирующий с конфигурацией в стиле `@Bean` и программной настройкой (без использования `FactoryBean`).
Настройка SessionFactory в контейнере Spring.
И LocalSessionFactoryBean, и LocalSessionFactoryBuilder поддерживают фон. загрузка, при этом инициализация Hibernate выполняется параллельно с приложением поток начальной загрузки для данного исполнителя начальной загрузки (например, SimpleAsyncTaskExecutor).
В LocalSessionFactoryBean это доступно через bootstrapExecutor. собственность.
В программном файле LocalSessionFactoryBuilder имеется перегруженный Метод buildSessionFactory, который принимает аргумент исполнителя начальной загрузки.
Настройка SessionFactory в контейнере Spring.
Такая собственная настройка Hibernate также может предоставлять JPA `EntityManagerFactory` для стандартных Взаимодействие JPA рядом с собственным доступом к Hibernate.
Подробности см. в Встроенная настройка Hibernate для JPA.
Реализация DAO на основе Plain Hibernate API.
В Hibernate есть функция, называемая контекстными сеансами, при которой Hibernate сам управляет одна текущая «сессия» на транзакцию.

Это примерно эквивалентно Spring синхронизация одного сеанса Hibernate на транзакцию.
Соответствующий DAO реализация напоминает следующий пример, основанный на простом API Hibernate:
Java
	public class ProductDaoImpl implements ProductDao {
		private SessionFactory sessionFactory;
		public void setSessionFactory(SessionFactory sessionFactory) {
			this.sessionFactory = sessionFactory;
		public Collection loadProductsByCategory(String category) {
			return this.sessionFactory.getCurrentSession()
					.createQuery("from test.Product product where product.category=?")
					.setParameter(0, category)
					.list();
Реализация DAO на основе Plain Hibernate API.
Этот стиль похож на стиль справочной документации и примеров Hibernate. за исключением хранения SessionFactory в переменной экземпляра.
Мы настоятельно рекомендуем такая настройка на основе экземпляра поверх старого статического класса HibernateUtil из Пример приложения CaveatEmptor от Hibernate. (Как правило, не храните какие-либо ресурсы в `статические` переменные, кроме случаев крайней необходимости.)
Реализация DAO на основе Plain Hibernate API.
Предыдущий пример DAO соответствует шаблону внедрения зависимостей.
Он прекрасно вписывается в Spring IoC. контейнер, как если бы он был закодирован с помощью Spring HibernateTemplate.
Вы также можете настроить такой DAO на простой Java (например, в модульных тестах).
Для этого создайте его экземпляр и вызовите `setSessionFactory(..)` с желаемой ссылкой на фабрику.
Как Определение компонента Spring, DAO будет выглядеть следующим образом:
	<beans>

<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="sessionFactory" ref="mySessionFactory"/>
		</bean>
	</beans>
Реализация DAO на основе Plain Hibernate API.
Основное преимущество этого стиля DAO заключается в том, что он зависит только от Hibernate API.
Нет импорта любого класса Spring требуется.
Это привлекательно из-за неинвазивности перспективу и может показаться более естественным разработчикам Hibernate.
Реализация DAO на основе Plain Hibernate API.
Однако DAO выдает простое исключение HibernateException (которое не отмечено, поэтому у него нет быть объявлены или перехвачены), что означает, что вызывающая сторона может рассматривать исключения только как обычно фатально - если только они не хотят зависеть от собственной иерархии исключений Hibernate.
Выявить конкретные причины (например, оптимистичный сбой блокировки) невозможно без привязка вызывающего абонента к стратегии реализации.
Этот компромисс может быть приемлемым для приложения, основанные на Hibernate, не нуждаются в каких-либо специальных исключениях. лечение, или и то, и другое.
Реализация DAO на основе Plain Hibernate API.
К счастью, Spring LocalSessionFactoryBean поддерживает Hibernate.
Метод SessionFactory.getCurrentSession() для любой стратегии транзакций Spring, возврат текущего транзакционного сеанса, управляемого Spring, даже при `HibernateTransactionManager`.
Стандартное поведение этого метода остается для возврата текущего сеанса, связанного с текущей транзакцией JTA, если таковая имеется.

Такое поведение применяется независимо от того, используете ли вы Spring `JtaTransactionManager`, транзакции, управляемые контейнером EJB (CMT), или JTA.
Реализация DAO на основе Plain Hibernate API.
Таким образом, вы можете реализовать DAO на основе простого API Hibernate, оставаясь при этом возможность участвовать в транзакциях, управляемых Spring.
Декларативная демаркация транзакций.
Мы рекомендуем вам использовать поддержку декларативных транзакций Spring, которая позволяет вам замените вызовы API явного разграничения транзакций в вашем коде Java на AOP перехватчик транзакций.
Вы можете настроить этот перехватчик транзакций в Spring контейнер с помощью аннотаций Java или XML.
Эта возможность декларативной транзакции позволяет избавить бизнес-сервисы от кода разграничения повторяющихся транзакций и сосредоточьтесь на добавлении бизнес-логики, которая и является реальной ценностью вашего приложения.
Декларативная демаркация транзакций.
ПРИМЕЧАНИЕ.
Прежде чем продолжить, мы настоятельно рекомендуем вам прочитать Декларативное управление транзакциями. если вы еще этого не сделали.
Декларативная демаркация транзакций.
Вы можете аннотировать уровень сервиса аннотациями `@Transactional` и указать Spring-контейнер для поиска этих аннотаций и предоставления транзакционной семантики для эти аннотированные методы.
В следующем примере показано, как это сделать:
Java
	public class ProductServiceImpl implements ProductService {
		private ProductDao productDao;
		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		@Transactional
		public void increasePriceOfAllProductsInCategory(final String category) {
			List productsToChange = this.productDao.loadProductsByCategory(category);
		@Transactional(readOnly = true)

public List<Product> findAllProducts() {
			return this.productDao.findAllProducts();
Декларативная демаркация транзакций.
В контейнере вам необходимо настроить реализацию PlatformTransactionManager. (как bean-компонент) и запись `<tx:annotation-driven/>`, выбрав `@Transactional` обработка во время выполнения.
В следующем примере показано, как это сделать:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop

https://www.springframework.org/schema/aop/spring-aop.xsd">
		<!-- SessionFactory, DataSource, etc. omitted -->
		<bean id="transactionManager"
				class="org.springframework.orm.jpa.hibernate.HibernateTransactionManager">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>
		<tx:annotation-driven/>
		<bean id="myProductService" class="product.SimpleProductService">
			<property name="productDao" ref="myProductDao"/>
		</bean>
	</beans>
Программное разграничение транзакций.
Вы можете разграничить транзакции на более высоком уровне приложения, поверх услуги доступа к данным нижнего уровня, охватывающие любое количество операций.
Также нет ограничений существуют на реализацию окружающих бизнес-услуг.
Нужна только весна `Менеджер ПлатформыТранзакций`.
Опять же, последнее может прийти откуда угодно, но желательно в качестве ссылки на компонент через метод setTransactionManager(..)`.
Кроме того, `productDAO` должен быть установлен методом `setProductDao(..)`.
Следующая пара фрагментов показывает менеджер транзакций и определение бизнес-сервиса в контексте приложения Spring и пример реализации бизнес-метода:
	<beans>
		<bean id="myTxManager" class="org.springframework.orm.jpa.hibernate.HibernateTransactionManager">

<property name="sessionFactory" ref="mySessionFactory"/>
		</bean>
		<bean id="myProductService" class="product.ProductServiceImpl">
			<property name="transactionManager" ref="myTxManager"/>
			<property name="productDao" ref="myProductDao"/>
		</bean>
	</beans>
Java
	public class ProductServiceImpl implements ProductService {
		private TransactionTemplate transactionTemplate;
		private ProductDao productDao;
		public void setTransactionManager(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);
		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		public void increasePriceOfAllProductsInCategory(final String category) {
			this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
				public void doInTransactionWithoutResult(TransactionStatus status) {
					List productsToChange = this.productDao.loadProductsByCategory(category);
					// поднимите цену...
Программное разграничение транзакций.
Spring TransactionInterceptor позволяет выдавать любое проверенное исключение приложения. с кодом обратного вызова, а `TransactionTemplate` ограничен непроверенным исключения в обратном вызове. `TransactionTemplate` запускает откат в случае непроверенное исключение приложения или если транзакция помечена как «только откат» приложение (установив TransactionStatus).
По умолчанию TransactionInterceptor. ведет себя так же, но позволяет настраивать политику отката для каждого метода.
Стратегии управления транзакциями.

И TransactionTemplate, и TransactionInterceptor делегируют фактическую транзакцию. обработка экземпляра PlatformTransactionManager (который может быть HibernateTransactionManager (для одной Hibernate SessionFactory) с помощью `ThreadLocal` `Session` под капотом) или `JtaTransactionManager` (делегирование JTA-подсистема контейнера) для приложений Hibernate.
Вы даже можете использовать собственный Реализация PlatformTransactionManager.
Переключение с собственной транзакции Hibernate управление JTA (например, при возникновении требований к распределенным транзакциям для определенных развертывания вашего приложения) — это только вопрос конфигурации.
Вы можете заменить менеджер транзакций Hibernate с реализацией транзакций Spring JTA. оба код разграничения транзакций и код доступа к данным работают без изменений, поскольку они используйте общие API-интерфейсы управления транзакциями.
Стратегии управления транзакциями.
Для распределенных транзакций между несколькими фабриками сеансов Hibernate вы можете комбинировать `JtaTransactionManager` как стратегия транзакций с несколькими Определения LocalSessionFactoryBean.
Затем каждый DAO получает одну конкретную SessionFactory. ссылка передается в соответствующее свойство компонента.
Если все базовые данные JDBC источники являются транзакционными контейнерами, бизнес-сервис может разграничивать транзакции через любое количество DAO и любое количество фабрик сеансов без особого внимания, поскольку пока он использует JtaTransactionManager в качестве стратегии.
Стратегии управления транзакциями.
И HibernateTransactionManager, и JtaTransactionManager позволяют правильно Обработка кэша на уровне JVM с помощью Hibernate без диспетчера транзакций для конкретного контейнера. поиск или соединитель JCA (если вы не используете EJB для инициации транзакций).
Стратегии управления транзакциями.

HibernateTransactionManager может экспортировать соединение Hibernate JDBC в обычный JDBC. код доступа для определенного `DataSource`.
Эта способность позволяет достичь высокого уровня. разграничение транзакций со смешанным доступом к данным Hibernate и JDBC полностью без JTA, при условии доступа только к одной базе данных. `HibernateTransactionManager` автоматически предоставляет транзакцию Hibernate как транзакцию JDBC, если вы настроили переданную `SessionFactory` с `DataSource` через свойство `dataSource` Класс LocalSessionFactoryBean.
Альтернативно, вы можете явно указать `DataSource`, для которого транзакции должны быть доступны через Свойство dataSource класса HibernateTransactionManager.
Стратегии управления транзакциями.
Для отложенного получения фактических подключений к ресурсам в стиле JTA Spring предоставляет соответствующий прокси-класс `DataSource` для целевого пула соединений: см. {spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].
Это особенно полезно для транзакций Hibernate, доступных только для чтения, которые часто могут обрабатываться из локального кэша, а не обращаться к базе данных.
Сравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.
Вы можете переключаться между управляемым контейнером JNDI SessionFactory и локально определенным без необходимости изменения ни одной строки кода приложения.
Стоит ли сохранять определения ресурсов в контейнере или локально внутри приложения — это в основном Вопрос в стратегии транзакции, которую вы используете.
По сравнению с локалом, определенным Spring `SessionFactory`, зарегистрированная вручную JNDI `SessionFactory`, не предоставляет никаких преимущества.

Развертывание SessionFactory через JCA-коннектор Hibernate обеспечивает дополнительная выгода от участия в инфраструктуре управления сервера Jakarta EE, но не добавляйте фактической ценности сверх этого.
Сравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.
Поддержка транзакций Spring не привязана к контейнеру.
При настройке любой стратегии Помимо JTA, поддержка транзакций также работает в автономной или тестовой среде.
Особенно в типичном случае транзакций с одной базой данных Spring с одним ресурсом Поддержка локальных транзакций — это легкая и мощная альтернатива JTA.
Когда вы используете локальные сессионные компоненты EJB без сохранения состояния для управления транзакциями, вы зависите как от EJB, так и от EJB. контейнере и на JTA, даже если вы обращаетесь только к одной базе данных и используете только без сохранения состояния сессионные компоненты для обеспечения декларативных транзакций посредством управляемых контейнером транзакции.
Для прямого программного использования JTA также требуется среда Jakarta EE.
Сравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.
Транзакции, управляемые Spring, также могут работать с локально определенным Hibernate. «SessionFactory», как и в случае с локальным источником данных JDBC, при условии, что они имеют доступ к единая база данных.
Таким образом, вам нужно использовать стратегию транзакций Spring JTA только тогда, когда вы имеют распределенные требования к транзакциям.
Для соединителя JCA требуется специфичный для контейнера этапы развертывания и (очевидно) поддержка JCA в первую очередь.

Эта конфигурация требует больше работы, чем развертывание простого веб-приложения с локальным ресурсом определения и транзакции, управляемые Spring.
Сравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.
Учитывая все обстоятельства, если вы не используете EJB, придерживайтесь локальной настройки SessionFactory. и Spring HibernateTransactionManager или JtaTransactionManager.
Вы получаете все преимущества, включая правильное транзакционное кэширование на уровне JVM и распределенную транзакции без неудобств, связанных с развертыванием контейнера.
Регистрация JNDI Hibernate `SessionFactory` через соединитель JCA добавляет ценность только при использовании в сочетании с EJB.
Ложные предупреждения сервера приложений в режиме Hibernate.
В некоторых средах JTA с очень строгой реализацией XADataSource (в настоящее время некоторые версии WebLogic Server и WebSphere), когда Hibernate настроен без относительно менеджера транзакций JTA для этой среды, ложных предупреждений или исключения могут отображаться в журнале сервера приложений.
Эти предупреждения или исключения указывают, что соединение, к которому осуществляется доступ, больше не действительно или доступ JDBC невозможен. больше действителен, возможно, потому, что транзакция больше не активна.
В качестве примера: вот фактическое исключение из WebLogic:
[буквальный] [subs="дословно,цитаты"]. java.sql.SQLException: транзакция больше не активна — статус: «Зафиксировано».
Нет в рамках этой транзакции разрешен дальнейший доступ JDBC.
[буквальный] [subs="дословно,цитаты"].

Другая распространенная проблема — утечка соединения после транзакций JTA в Hibernate. сеансы (и, возможно, лежащие в основе соединения JDBC) не закрываются должным образом.
[буквальный] [subs="дословно,цитаты"].
Вы можете решить такие проблемы, сообщив Hibernate о менеджере транзакций JTA. с которым он синхронизируется (вместе со Spring).
У вас есть два варианта сделать это:
* Передайте bean-компонент Spring `JtaTransactionManager` в настройки Hibernate. Самый простой
[буквальный] [subs="дословно,цитаты"]. way — это ссылка на компонент в свойстве jtaTransactionManager для вашего Компонент LocalSessionFactoryBean (см. ссылку:data-access/transaction/strategies.adoc#transaction-strategies-hibernate [Настройка транзакции Hibernate]).
Затем Spring делает соответствующие стратегии JTA доступными для Hibernate.
* Вы также можете явно настроить свойства Hibernate, связанные с JTA, в частности
[буквальный] [subs="дословно,цитаты"]. "hibernate.transaction.coordinator_class", "hibernate.connection.handling_mode" и, возможно, «hibernate.transaction.jta.platform» в ваших «hibernateProperties». в `LocalSessionFactoryBean` (подробную информацию об этих свойствах см. в руководстве Hibernate).
[буквальный] [subs="дословно,цитаты"].

Оставшаяся часть этого раздела описывает последовательность событий, которые происходят с и без ведома Hibernate о JTA PlatformTransactionManager.
[буквальный] [subs="дословно,цитаты"].
Когда Hibernate не настроен с учетом диспетчера транзакций JTA, при фиксации транзакции JTA происходят следующие события:
* Транзакция JTA фиксируется.
* Spring `JtaTransactionManager` синхронизируется с транзакцией JTA, поэтому
[буквальный] [subs="дословно,цитаты"]. вызывается через обратный вызов afterCompletion менеджером транзакций JTA.
* Помимо прочего, эта синхронизация может вызвать обратный вызов Spring для
[буквальный] [subs="дословно,цитаты"].
Hibernate через обратный вызов Hibernate afterTransactionCompletion (используется для очистки кэш Hibernate), за которым следует явный вызов close() в сеансе Hibernate, что заставляет Hibernate попытаться закрыть() соединение JDBC.
* В некоторых средах вызов Connection.close() вызывает предупреждение или
[буквальный] [subs="дословно,цитаты"]. ошибка, поскольку сервер приложений больше не считает «Соединение» пригодным для использования, поскольку транзакция уже зафиксирована.
[буквальный] [subs="дословно,цитаты"].
Когда Hibernate настроен с учетом диспетчера транзакций JTA, при фиксации транзакции JTA происходят следующие события:
* Транзакция JTA готова к фиксации.
* Spring `JtaTransactionManager` синхронизируется с транзакцией JTA, поэтому

[буквальный] [subs="дословно,цитаты"]. транзакция вызывается обратно через обратный вызов «beforeCompletion» со стороны JTA менеджер транзакций.
* Spring знает, что Hibernate сам синхронизируется с транзакцией JTA и
[буквальный] [subs="дословно,цитаты"]. ведет себя иначе, чем в предыдущем сценарии.
В частности, это соответствует Управление транзакционными ресурсами Hibernate.
* Транзакция JTA фиксируется.
* Hibernate синхронизируется с транзакцией JTA, поэтому транзакция вызывается обратно.
[буквальный] [subs="дословно,цитаты"]. через обратный вызов afterCompletion менеджера транзакций JTA и может правильно очистите его кеш.

HTTP/2-соединения Reactor Netty, Tomcat и Jetty.
Однако существуют соображения, связанные с конфигурацией сервера.
Более подробную информацию см. {spring-framework-wiki}/HTTP-2-support[вики-страница HTTP/2].

`HttpEntity` более или менее идентичен использованию `@RequestBody`, но основан на объект-контейнер, который предоставляет заголовки и тело запроса.
В следующем примере используется `HttpEntity`:
Java
	@PostMapping("/accounts")
	public void handle(HttpEntity<Account> entity) {

Инициализация источника данных.
Пакет `org.springframework.jdbc.datasource.init` обеспечивает поддержку инициализации существующий «Источник данных».
Поддержка встроенной базы данных предоставляет один из вариантов создания и инициализация источника данных для приложения.
Однако иногда вам может потребоваться инициализировать экземпляр, который работает где-то на сервере.
Инициализация базы данных с использованием Spring XML.
Если вы хотите инициализировать базу данных и можете предоставить ссылку на DataSource bean, вы можете использовать тег `initialize-database` в пространстве имен `spring-jdbc`:
	<jdbc:initialize-database data-source="dataSource">
		<jdbc:script location="classpath:com/foo/sql/db-schema.sql"/>
		<jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/>
	</jdbc:initialize-database>
Инициализация базы данных с использованием Spring XML.
В предыдущем примере выполняются два указанных сценария для базы данных.
Первый скрипт создает схему, а второй заполняет таблицы тестовым набором данных.
Сценарий местоположения также могут быть шаблонами с подстановочными знаками в обычном стиле Ant, используемом для ресурсов.
Spring (например, `classpath{asterisk}:/com/foo/{asterisk}{asterisk}/sql/{asterisk}-data.sql`).

Если вы используете шаблон, сценарии выполняются в лексическом порядке их URL-адресов или имен файлов.
Инициализация базы данных с использованием Spring XML.
Поведение инициализатора базы данных по умолчанию — безоговорочный запуск предоставленного сценарии.
Это не всегда может быть тем, что вам нужно — например, если вы запустите сценарии для базы данных, в которой уже есть тестовые данные.
Вероятность вероятность случайного удаления данных снижается за счет следования общей схеме (показанной ранее) сначала создавать таблицы, а затем вставлять данные.
Первый шаг не удался, если таблицы уже существуют.
Инициализация базы данных с использованием Spring XML.
Однако, чтобы получить больший контроль над созданием и удалением существующих данных, XML пространство имен предоставляет несколько дополнительных опций.
Первый — это флаг переключения инициализация включается и выключается.
Вы можете установить это в соответствии с окружающей средой (например, при извлечении логическое значение из свойств системы или из компонента среды).
В следующем примере получается значение из системного свойства:
	<jdbc:initialize-database data-source="dataSource"
		enabled="#{systemProperties.INITIALIZE_DATABASE}"> <1>
		<jdbc:script location="..."/>
	</jdbc:initialize-database>
Инициализация базы данных с использованием Spring XML. <1> Получите значение «включено» из системного свойства с именем «INITIALIZE_DATABASE».
Инициализация базы данных с использованием Spring XML.

Второй вариант контроля над тем, что происходит с существующими данными, — это быть более терпимыми к неудачи.
С этой целью вы можете контролировать возможность инициализатора игнорировать определенные ошибки в SQL-коде, который он запускает из сценариев, как показано в следующем примере:
	<jdbc:initialize-database data-source="dataSource" ignore-failures="DROPS">
		<jdbc:script location="..."/>
	</jdbc:initialize-database>
Инициализация базы данных с использованием Spring XML.
В предыдущем примере мы говорим, что ожидаем, что иногда сценарии будут запускаться против пустой базы данных, и в сценариях есть несколько операторов `DROP`, которые следовательно, потерпит неудачу.
Таким образом, неудачные операторы SQL `DROP` будут игнорироваться, но другие ошибки вызовет исключение.
Это полезно, если ваш диалект SQL не поддерживает `DROP...
IF EXISTS` (или аналогичный), но вы хотите безоговорочно удалить все тестовые данные перед воссоздавая его заново.
В этом случае первый сценарий обычно представляет собой набор операторов DROP. за которым следует набор операторов CREATE.
Инициализация базы данных с использованием Spring XML.
Опция `ignore-failures` может быть установлена на `NONE` (по умолчанию), `DROPS` (игнорировать сбой). падений) или «ВСЕ» (игнорировать все сбои).
Инициализация базы данных с использованием Spring XML.

Каждый оператор должен быть разделен символом `;` или новой строкой, если символ `;` не указан. вообще присутствует в сценарии.
Вы можете контролировать это глобально или сценарий за сценарием, как следующий пример показывает:
	<jdbc:initialize-database data-source="dataSource" separator="@@"> <1>
		<jdbc:script location="classpath:com/myapp/sql/db-schema.sql" separator=";"/> <2>
		<jdbc:script location="classpath:com/myapp/sql/db-test-data-1.sql"/>
		<jdbc:script location="classpath:com/myapp/sql/db-test-data-2.sql"/>
	</jdbc:initialize-database>
Инициализация базы данных с использованием Spring XML. <1> Установите в качестве скриптов-разделителей значение `@@`. <2> Установите разделитель для `db-schema.sql` на `;`.
Инициализация базы данных с использованием Spring XML.
В этом примере два сценария `test-data` используют `@@` в качестве разделителя операторов и только `db-schema.sql` использует `;`.

Эта конфигурация указывает, что разделитель по умолчанию имеет значение `@@` и переопределяет значение по умолчанию для сценария `db-schema`.
Инициализация базы данных с использованием Spring XML.
Если вам нужно больше контроля, чем вы получаете от пространства имен XML, вы можете использовать DataSourceInitializer напрямую и определите его как компонент вашего приложения.
Инициализация других компонентов, зависящих от базы данных.
Большой класс приложений (тех, которые не используют базу данных до тех пор, пока не будет создан контекст Spring). запущен) может использовать инициализатор базы данных без каких-либо дальнейших действий. осложнения.
Если ваше приложение не входит в их число, возможно, вам придется прочитать остальное. этого раздела.
Инициализация других компонентов, зависящих от базы данных.
Инициализатор базы данных зависит от экземпляра DataSource и запускает сценарии. предоставленный в обратном вызове инициализации (аналог `init-method` в XML bean определение, метод `@PostConstruct` в компоненте или `afterPropertiesSet()` метод в компоненте, реализующем `InitializingBean`).
Если другие компоненты зависят от тот же источник данных и использовать источник данных в обратном вызове инициализации, там может быть проблемой, поскольку данные еще не инициализированы.
Типичный пример это кеш, который быстро инициализируется и загружает данные из базы данных в приложении запуск.
Инициализация других компонентов, зависящих от базы данных.

Чтобы обойти эту проблему, у вас есть два варианта: изменить стратегию инициализации кэша. на более поздний этап или убедитесь, что инициализатор базы данных инициализирован первым.
Инициализация других компонентов, зависящих от базы данных.
Изменить стратегию инициализации кэша может быть легко, если приложение находится под вашим контролем, а не иначе.
Некоторые предложения по реализации этого включают в себя:
* Сделайте кеш ленивой инициализацией при первом использовании, что улучшает запуск приложений.
Инициализация других компонентов, зависящих от базы данных. время.
* Имейте свой кеш или отдельный компонент, который инициализирует реализацию кеша.
Инициализация других компонентов, зависящих от базы данных. «Жизненный цикл» или «SmartLifecycle».
Когда контекст приложения запускается, вы можете автоматически запустить `SmartLifecycle`, установив его флаг `autoStartup`, и вы можете вручную запустите «Жизненный цикл», вызвав «ConfigurableApplicationContext.start()» на включающем контексте.
* Используйте Spring `ApplicationEvent` или аналогичный механизм пользовательского наблюдателя для запуска
Инициализация других компонентов, зависящих от базы данных. инициализация кэша. `ContextRefreshedEvent` всегда публикуется контекстом, когда он готов к использованию (после того, как все компоненты были инициализированы), так что это часто бывает полезно. хук (именно так работает SmartLifecycle по умолчанию).
Инициализация других компонентов, зависящих от базы данных.
Гарантировать, что инициализатор базы данных инициализируется первым, также может быть легко.

Некоторые предложения о том, как это реализовать, включают в себя:
* Полагайтесь на поведение Spring `BeanFactory` по умолчанию, которое заключается в том, что bean-компоненты
Инициализация других компонентов, зависящих от базы данных. инициализируется в порядке регистрации.
Вы можете легко это организовать, приняв общие практика набора элементов `<import/>` в конфигурации XML, которые упорядочивают ваши прикладные модули и обеспечение того, чтобы база данных и ее инициализация были указан первым.
* Разделите источник данных и бизнес-компоненты, которые его используют, и контролируйте их.
Инициализация других компонентов, зависящих от базы данных. порядок запуска, поместив их в отдельные экземпляры ApplicationContext (например, родительский контекст содержит DataSource, а дочерний контекст содержит бизнес-контекст. компоненты).
Эта структура распространена в веб-приложениях Spring, но может быть и более обычно применяется.

Встроенные списки.
Вы можете напрямую выражать списки в выражении, используя нотацию `{}`.
Java
	// вернуть список Java, состоящее из четырех чисел
	List numbers = (List) parser.parseExpression("{1,2,3,4}").getValue(context);
	List listOfLists = (List) parser.parseExpression("{{'a','b'},{'x','y'}}").getValue(context);
Встроенные списки. `{}` сам по себе означает пустой список.
По соображениям производительности, если список сам по себе полностью состоящий из фиксированных литералов, создается постоянный список для представления выражение (вместо того, чтобы создавать новый список для каждой оценки).

Встроенные карты.
Вы также можете напрямую выразить карты в выражении, используя нотацию `{key:value}`. следующий пример показывает, как это сделать:
Java
	// выпишите карту Java, содержащую две записи
	Map inventorInfo = (Map) parser.parseExpression("{name:'Nikola',dob:'10-July-1856'}").getValue(context);
	Map mapOfMaps = (Map) parser.parseExpression("{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}").getValue(context);
Встроенные карты. `{:}` сам по себе означает пустую карту.
Из соображений производительности, если карта сама по себе состоит из фиксированных литералов или других вложенных константных структур (списков или карт), постоянная карта создается для представления выражения (вместо построения новой карты на основе каждая оценка).
Заключение ключей карты в кавычки не является обязательным (если ключ не содержит точку (`.`)).
В приведенных выше примерах не используются ключи в кавычках.

Создание экземпляра контейнера Spring с помощью AnnotationConfigApplicationContext.
В следующих разделах документируется Spring AnnotationConfigApplicationContext, представленный в Spring.
3.0.
Эта универсальная реализация ApplicationContext способна принимать не только Классы `@Configuration` в качестве входных данных, а также простые классы и классы `@Component` аннотированный метаданными JSR-330.
Когда в качестве входных данных предоставляются классы `@Configuration`, сам класс `@Configuration` регистрируется как определение компонента и все объявленные методы `@Bean` внутри класса также регистрируются как определения bean-компонентов.
Когда предоставляются классы `@Component` и JSR-330, они регистрируются как bean-компонент. определения, и предполагается, что метаданные DI, такие как `@Autowired` или `@Inject`, используется внутри этих классов там, где это необходимо.
Простая конструкция.
Во многом так же, как XML-файлы Spring используются в качестве входных данных при создании экземпляра `ClassPathXmlApplicationContext`, вы можете использовать классы `@Configuration` в качестве входных данных, когда создание экземпляра AnnotationConfigApplicationContext.
Это позволяет полностью Использование контейнера Spring без XML, как показано в следующем примере:
Java
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
Простая конструкция.

Как упоминалось ранее, AnnotationConfigApplicationContext не ограничивается работой только с классами `@Configuration`.
Любой аннотированный класс `@Component` или JSR-330 может быть предоставлен. в качестве входных данных для конструктора, как показано в следующем примере:
Java
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
Простая конструкция.
В предыдущем примере предполагается, что MyServiceImpl, Dependency1 и Dependency2 используют Spring. аннотации внедрения зависимостей, такие как `@Autowired`.
Программное построение контейнера с помощью `register(Class<?>...)`.
Вы можете создать экземпляр AnnotationConfigApplicationContext, используя конструктор без аргументов. а затем настройте его с помощью метода Register().
Этот подход особенно полезен при программном создании AnnotationConfigApplicationContext.
Следующие пример показывает, как это сделать:
Java
	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.register(AppConfig.class, OtherConfig.class);
		ctx.register(AdditionalConfig.class);
		ctx.refresh();
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
Включение сканирования компонентов с помощью `scan(String...)`.

Чтобы включить сканирование компонентов, вы можете аннотировать свой класс @Configuration следующим образом:
Java
	@Configuration
	@ComponentScan(basePackages = "com.acme") // <1>
	public class AppConfig  {
Включение сканирования компонентов с помощью `scan(String...)`. <1> Эта аннотация включает сканирование компонентов.
	@Configuration
	@ComponentScan(basePackages = ["com.acme"]) // <1>
	class AppConfig  {
Включение сканирования компонентов с помощью `scan(String...)`. <1> Эта аннотация включает сканирование компонентов.
Включение сканирования компонентов с помощью `scan(String...)`. [СОВЕТ] = Опытные пользователи Spring могут быть знакомы с эквивалентом объявления XML из Пространство имен Spring `context:`, показанное в следующем примере:
	<beans>
		<context:component-scan base-package="com.acme"/>
	</beans>
Включение сканирования компонентов с помощью `scan(String...)`.
В предыдущем примере пакет com.acme сканируется на наличие каких-либо Классы, аннотированные `@Component`, и эти классы регистрируются как Spring bean определения внутри контейнера. `AnnotationConfigApplicationContext` предоставляет `scan(String...)`, чтобы обеспечить ту же функциональность сканирования компонентов, что и метод следующий пример показывает:
Java

public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.scan("com.acme");
		ctx.refresh();
		MyService myService = ctx.getBean(MyService.class);
Включение сканирования компонентов с помощью `scan(String...)`.
ПРИМЕЧАНИЕ.
Помните, что классы `@Configuration` с `@Component`, поэтому они являются кандидатами на сканирование компонентов.
В предыдущем примере предполагая, что AppConfig объявлен в пакете com.acme (или в любом пакете внизу), он считывается во время вызова Scan().
При `refresh()` все его `@Bean` методы обрабатываются и регистрируются как определения компонентов внутри контейнера.
Включение сканирования компонентов с помощью `scan(String...)`.
Поддержка веб-приложений с помощью AnnotationConfigWebApplicationContext.
Включение сканирования компонентов с помощью `scan(String...)`.
Доступен вариант WebApplicationContext для AnnotationConfigApplicationContext. с AnnotationConfigWebApplicationContext.
Вы можете использовать эту реализацию, когда настройка прослушивателя сервлетов Spring `ContextLoaderListener`, Spring MVC «DispatcherServlet» и так далее.
Следующий фрагмент `web.xml` настраивает типичный Веб-приложение Spring MVC (обратите внимание на использование контекстного параметра contextClass и инициализирующий параметр):
	<web-app>
		<!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
			instead of the default XmlWebApplicationContext -->

<context-param>
			<param-name>contextClass</param-name>
			<param-value>
				org.springframework.web.context.support.AnnotationConfigWebApplicationContext
			</param-value>
		</context-param>
		<!-- Configuration locations must consist of one or more comma- or space-delimited
			полноценные классы @Configuration. Полноценные пакеты также могут быть
			specified for component-scanning -->
		<context-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>com.acme.AppConfig</param-value>
		</context-param>
		<!-- Bootstrap the root application context as usual using ContextLoaderListener -->
		<listener>
			<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
		</listener>
		<!-- Declare a Spring MVC DispatcherServlet as usual -->
		<servlet>
			<servlet-name>dispatcher</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
				instead of the default XmlWebApplicationContext -->
			<init-param>
				<param-name>contextClass</param-name>
				<param-value>

org.springframework.web.context.support.AnnotationConfigWebApplicationContext
				</param-value>
			</init-param>
			<!-- Again, config locations must consist of one or more comma- or space-delimited
				and fully-qualified @Configuration classes -->
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>com.acme.web.MvcConfig</param-value>
			</init-param>
		</servlet>
		<!-- map all requests for /app/* to the dispatcher servlet -->
		<servlet-mapping>
			<servlet-name>dispatcher</servlet-name>
			<url-pattern>/app/*</url-pattern>
		</servlet-mapping>
	</web-app>
Включение сканирования компонентов с помощью `scan(String...)`.
ПРИМЕЧАНИЕ.
В случаях программного использования GenericWebApplicationContext можно использовать в качестве альтернатива AnnotationConfigWebApplicationContext.
См. {spring-framework-api}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`] javadoc для получения подробной информации.

Модели реализации аспектов.
ПРИМЕЧАНИЕ.
Это сложная тема.
Если вы только начинаете работать с АОП, вы можете спокойно пропустить это на потом.
Модели реализации аспектов.
По умолчанию в приложении существует один экземпляр каждого аспекта. контекст.
AspectJ называет это моделью создания одноэлементного экземпляра.
Можно определить аспекты с альтернативными жизненными циклами.
Spring поддерживает `perthis`, `pertarget` и модели реализации `pertypewithin`; `percflow` и `percflowbelow` в настоящее время не поддерживаются. поддерживается.
Модели реализации аспектов.
Вы можете объявить аспект Perthis, указав предложение Perthis в параметре @Aspect. аннотация.
Рассмотрим следующий пример:
Java
	@Aspect("perthis(execution(* com.xyz..service.*.*(..)))")
	public class MyAspect {
		private int someState;
		@Before("execution(* com.xyz..service.*.*(..))")
		public void recordServiceUsage() {
	@Aspect("perthis(execution(* com.xyz..service.*.*(..)))")
	class MyAspect {
Модели реализации аспектов.
В предыдущем примере эффект предложения perthis заключается в том, что один экземпляр аспекта создается для каждого уникального объекта службы, выполняющего бизнес-услугу (каждый уникальный объект, привязанный к `this` в точках соединения, соответствующих выражению pointcut).

Аспект Экземпляр создается при первом вызове метода объекта службы. аспект выходит за рамки, когда объект службы выходит за рамки.
Перед аспектом экземпляр создан, ни один из советов, содержащихся в нем, не выполняется.
Как только экземпляр аспекта создан, объявленный в нем совет выполняется в соответствующих точках соединения, но только когда объект службы является тем, с которым связан этот аспект.
См. аспектJ Руководство по программированию для получения дополнительной информации о предложениях per.
Модели реализации аспектов.
Модель реализации `pertarget` работает точно так же, как `perthis`, но она создает один экземпляр аспекта для каждого уникального целевого объекта в совпадающих точках соединения.

Перехватчики.
Вы можете зарегистрировать перехватчики для применения к входящим запросам, как показано в следующем примере: См. пример кода в исходном документе.
Перехватчики.
ВНИМАНИЕ: перехватчики не идеально подходят в качестве уровня безопасности из-за возможности несоответствие аннотированному пути контроллера.
Как правило, мы рекомендуем использовать Spring Безопасность или, альтернативно, аналогичный подход, интегрированный с цепочкой фильтров сервлетов, и применять как можно раньше.
Перехватчики.
ПРИМЕЧАНИЕ.
В конфигурации XML перехватчики объявляются как bean-компоненты MappedInterceptor, и они находятся в Turn обнаруживается любым bean-компонентом HandlerMapping, в том числе из других фреймворков.
Напротив, конфигурация Java передает перехватчики только bean-компонентам HandlerMapping, которыми она управляет.
Чтобы повторно использовать одни и те же перехватчики в Spring MVC и других платформах HandlerMapping. bean-компоненты с конфигурацией Java MVC, либо объявите bean-компоненты MappedInterceptor (и не вручную добавьте их в конфиг Java) или настройте одни и те же перехватчики в обоих конфигурация Java и другие bean-компоненты HandlerMapping.

Концепции АОП.
Давайте начнем с определения некоторых основных концепций и терминологии АОП.
Эти условия не Специально для весны.
К сожалению, терминология АОП не совсем интуитивно понятна.
Однако было бы еще больше путаницы, если бы Spring использовал собственную терминологию.
* Аспект: модульность проблемы, охватывающая несколько классов.
Концепции АОП.
Управление транзакциями является хорошим примером сквозной проблемы в корпоративной Java. приложения.
В Spring AOP аспекты реализуются с помощью обычных классов. (подход на основе схемы) или обычные классы, помеченные Аннотация `@Aspect` (стиль @AspectJ).
* Точка соединения: точка во время выполнения программы, например, выполнение
Концепции АОП. метод или обработка исключения.
В Spring AOP точка соединения всегда представляет выполнение метода.
* Совет: действие, выполняемое аспектом в определенной точке соединения. Различные типы
Концепции АОП.
Советы включают советы «вокруг», «до» и «после». (Виды советов обсуждаются позже.) Многие АОП-фреймворки, включая Spring, моделируют совет как перехватчик и поддерживать цепочку перехватчиков вокруг точки соединения.
* Pointcut: предикат, соответствующий точкам соединения. Совет связан с
Концепции АОП. выражение pointcut и выполняется в любой точке соединения, соответствующей pointcut (например, выполнение метода с определенным именем).
Концепция точек соединения как совпадающих с помощью выражений pointcut является центральным элементом АОП, а Spring использует pointcut AspectJ. язык выражений по умолчанию.

* Введение: объявление дополнительных методов или полей от имени типа. Весна
Концепции АОП.
АОП позволяет вам добавлять новые интерфейсы (и соответствующую реализацию) к любому посоветовал объект.
Например, вы можете использовать введение, чтобы заставить компонент реализовать Интерфейс IsModified для упрощения кэширования. (Введение известно как межтиповое объявление в сообществе AspectJ.)
* Целевой объект: Объект, которому сообщается один или несколько аспектов. Также упоминается как
Концепции АОП. «советуемый объект».
Поскольку Spring AOP реализован с использованием прокси-серверов времени выполнения, это объект всегда является прокси-объектом.
* Прокси-сервер AOP: объект, созданный средой AOP для реализации аспекта
Концепции АОП. контракты (исполнение методов рекомендаций и т. д.).
В Spring Framework прокси-сервер AOP является динамическим прокси-сервером JDK или прокси-сервером CGLIB.
* Переплетение: связывание аспектов с другими типами приложений или объектами для создания
Концепции АОП. посоветовал объект.
Это можно сделать во время компиляции (используя компилятор AspectJ, например например), во время загрузки или во время выполнения.
Spring AOP, как и другие среды AOP на чистом Java, выполняет переплетение во время выполнения.
* Совет перед: совет, который выполняется перед точкой соединения, но не имеет
Spring AOP включает следующие типы советов:. возможность предотвратить движение потока выполнения к точке соединения (если только он не выдает исключение).

* После возврата совета: совет будет запущен после завершения точки соединения.
Spring AOP включает следующие типы советов:. обычно (например, если метод возвращает значение, не выдавая исключения).
* После выдачи совета: совет будет выполняться, если метод завершается путем выдачи
Spring AOP включает следующие типы советов:. исключение.
* После (наконец) совета: совет следует выполнять независимо от того, с помощью чего
Spring AOP включает следующие типы советов:. выходы из точки соединения (нормальный или исключительный возврат).
* Вокруг совета: совет, окружающий точку соединения, например вызов метода.
Spring AOP включает следующие типы советов:.
Это самый действенный совет.
Вокруг совета можно выполнять индивидуальное поведение. до и после вызова метода.
Он также отвечает за выбор того, следует ли перейти к точке соединения или сократить выполнение рекомендованного метода, вернув его собственное возвращаемое значение или выдача исключения.
Spring AOP включает следующие типы советов:.
Вокруг совета – это самый общий вид совета.
Поскольку Spring AOP, как и AspectJ, предоставляет полный набор типов советов, мы рекомендуем использовать наименее мощные тип совета, который может реализовать требуемое поведение.
Например, если вам нужно только обновить кеш возвращаемым значением метода, вам лучше реализовать после ответа на совет, чем обходной совет, хотя обходной совет может принести пользу то же самое.
Использование наиболее конкретного типа рекомендаций обеспечивает более простую модель программирования. с меньшей вероятностью ошибок.

Например, вам не нужно вызывать `proceed()` метод в «JoinPoint», используемый для получения рекомендаций, и, следовательно, вы не можете не вызвать его.
Spring AOP включает следующие типы советов:.
Все параметры рекомендаций статически типизированы, поэтому вы можете работать с параметрами рекомендаций соответствующий тип (например, тип возвращаемого значения при выполнении метода), а не чем массивы `Object`.
Spring AOP включает следующие типы советов:.
Концепция точек соединения, соответствующих точечным разрезам, является ключом к АОП, который отличает это из старых технологий, предлагающих только перехват.
Pointcuts позволяют давать советы нацелены независимо от объектно-ориентированной иерархии.
Например, вы можете применить вокруг рекомендаций, обеспечивающих декларативное управление транзакциями для набора методов, охватывающих несколько объектов (например, все бизнес-операции на уровне обслуживания).

АОП-прокси.
Spring AOP по умолчанию использует стандартные динамические прокси JDK для прокси AOP.
Это позволяет проксировать любой интерфейс (или набор интерфейсов).
АОП-прокси.
Spring AOP также может использовать прокси-серверы CGLIB.
Это необходимо для прокси-классов, а не интерфейсы.
По умолчанию CGLIB используется, если бизнес-объект не реализует интерфейс.
Поскольку хорошей практикой является программирование для интерфейсов, а не для классов, бизнес классы обычно реализуют один или несколько бизнес-интерфейсов.
Это возможно нужно посоветовать метод, который не объявлен на интерфейсе или где нужно передать прокси-объект методу как конкретный тип.
АОП-прокси.
Важно понимать тот факт, что Spring AOP основан на прокси-сервере.
См. для тщательного изучения того, что именно означает эта деталь реализации.

Возможности и цели Spring AOP.
Spring AOP реализован на чистой Java.
Нет необходимости в специальной компиляции процесс.
Spring AOP не нуждается в управлении иерархией загрузчика классов и поэтому подходит для использования в контейнере сервлетов или сервере приложений.
Возможности и цели Spring AOP.
Spring AOP в настоящее время поддерживает только точки соединения выполнения метода (рекомендуя выполнение методов на компонентах Spring).
Перехват полей не реализован, хотя поддержка перехват полей можно добавить, не нарушая основные API Spring AOP.
Если вам нужно чтобы рекомендовать доступ к полям и обновлять точки соединения, рассмотрите такой язык, как AspectJ.
Возможности и цели Spring AOP.
Подход Spring AOP к АОП отличается от подхода большинства других инфраструктур АОП.
Цель состоит в том, не для обеспечения наиболее полной реализации АОП (хотя Spring AOP вполне способен).
Скорее, цель состоит в том, чтобы обеспечить тесную интеграцию между реализацией АОП и Spring IoC для решения распространенных проблем в корпоративных приложениях.
Возможности и цели Spring AOP.
Так, например, функциональность AOP Spring Framework обычно используется в сочетании с контейнером Spring IoC.
Аспекты настраиваются с использованием обычного bean-компонента. синтаксис определения (хотя это обеспечивает мощные возможности «автоматического проксирования»).
Это существенное отличие от других реализаций АОП.
Вы не можете делать некоторые вещи легко и эффективно с помощью Spring AOP, например, советовать очень мелкозернистые объекты (обычно объекты домена).
AspectJ — лучший выбор в таких случаях.

Однако наш опыт показывает, что Spring AOP обеспечивает отличное решение большинства проблем в корпоративные Java-приложения, совместимые с АОП.
Возможности и цели Spring AOP.
Spring AOP никогда не стремится конкурировать с AspectJ в предоставлении комплексного АОП. решение.
Мы считаем, что как прокси-фреймворки, такие как Spring AOP, так и полноценные такие фреймворки, как AspectJ, ценны и дополняют друг друга, а не конкуренция.
Spring легко интегрирует Spring AOP и IoC с AspectJ, чтобы обеспечить все виды использования АОП в едином приложении на основе Spring архитектура.
Эта интеграция не влияет на Spring AOP API или AOP Alliance.
API.
Spring AOP остается обратно совместимым.
См. следующую главу для обсуждения API Spring AOP.
Возможности и цели Spring AOP. [ПРИМЕЧАНИЕ] = Одним из центральных принципов Spring Framework является принцип неинвазивности.
Это заключается в том, что вас не следует заставлять вводить классы, специфичные для платформы, и интерфейсы с вашей бизнес-моделью или моделью домена.
Однако в некоторых местах Spring Framework дает вам возможность ввести зависимости, специфичные для Spring Framework, в ваш кодовая база.
Обоснование предоставления вам таких вариантов заключается в том, что в определенных сценариях это может быть просто проще читать или кодировать какую-то конкретную часть функциональности в таком путь.

Однако Spring Framework (почти) всегда предлагает вам выбор: у вас есть свобода принятия обоснованного решения относительно того, какой вариант лучше всего подходит для вашего конкретного использования случай или сценарий.
Возможности и цели Spring AOP.
Одним из таких вариантов, имеющих отношение к этой главе, является выбор того, какая структура АОП (и какой стиль АОП) выбрать.
У вас есть выбор: AspectJ, Spring AOP или оба. ты также есть выбор либо подхода в стиле аннотаций @AspectJ, либо Spring XML. подход в стиле конфигурации.
Тот факт, что в этой главе решено представить Подход в стиле @AspectJ не следует воспринимать как признак того, что команда Spring предпочитает подход в стиле аннотации @AspectJ стилю конфигурации Spring XML.
Возможности и цели Spring AOP.
Дополнительную информацию см. в Выбор стиля объявления АОП. полное обсуждение преимуществ и недостатков каждого стиля.

Введение в ORM с помощью Spring.
Spring Framework поддерживает интеграцию с Java Persistence API (JPA) и поддерживает встроенный Hibernate для управления ресурсами, реализации объектов доступа к данным (DAO), и стратегии транзакций.
Например, для Hibernate имеется первоклассная поддержка с несколько удобных функций IoC, которые решают многие типичные проблемы интеграции Hibernate.
Вы можете настроить все поддерживаемые функции для сопоставления OR (реляционного объекта). инструменты посредством внедрения зависимостей.
Они могут участвовать в ресурсе Spring и управление транзакциями и соответствуют общим транзакциям Spring и DAO. иерархии исключений.
Рекомендуемый стиль интеграции — кодировать DAO вместо простых API-интерфейсы Hibernate или JPA.
Введение в ORM с помощью Spring.
Spring добавляет значительные улучшения к выбранному вами слою ORM при создании приложения доступа к данным.
Вы можете использовать столько поддержки интеграции, сколько захотите. желанию, и вам следует сравнить эти усилия по интеграции со стоимостью и риском создания аналогичная инфраструктура внутри компании.
Вы можете использовать большую часть поддержки ORM так же, как и библиотека, вне зависимости от технологии, ведь все спроектировано как набор многоразовых JavaBeans.
ORM в контейнере Spring IoC упрощает настройку и развертывание.
Таким образом, большинство примеров в этом разделе показывают конфигурацию внутри контейнера Spring.
Введение в ORM с помощью Spring.
Преимущества использования Spring Framework для создания ORM DAO включают в себя:
* *Упрощенное тестирование.* Подход Spring IoC позволяет легко менять реализации.

Введение в ORM с помощью Spring. и расположение конфигурации экземпляров Hibernate `SessionFactory`, JDBC `DataSource` экземпляры, менеджеры транзакций и реализации сопоставленных объектов (при необходимости).
Это в свою очередь, значительно упрощает тестирование каждого фрагмента кода, связанного с персистентностью, в изоляция.
* *Общие исключения доступа к данным.* Spring может обертывать исключения из вашего инструмента ORM,
Введение в ORM с помощью Spring. преобразование их из проприетарных (потенциально проверяемых) исключений в общую среду выполнения Иерархия DataAccessException.
Эта функция позволяет вам обрабатывать большую часть настойчивости исключения, которые не подлежат восстановлению, только в соответствующих слоях, без надоедливые шаблонные перехваты, выдачи и объявления исключений.
Вы все еще можете поймать и обрабатывать исключения по мере необходимости.
Помните, что исключения JDBC (включая Диалекты, специфичные для БД), также преобразуются в ту же иерархию, что означает, что вы можете выполнять некоторые операции с JDBC в рамках согласованной модели программирования.
* *Общее управление ресурсами.* Контексты приложений Spring могут обрабатывать местоположение.
Введение в ORM с помощью Spring. и настройка экземпляров Hibernate SessionFactory, JPA EntityManagerFactory. экземпляры, экземпляры JDBC `DataSource` и другие связанные ресурсы.
Это делает эти ценности, которыми легко управлять и изменять.
Spring предлагает эффективное, простое и безопасное обращение с ресурсы персистентности.

Например, связанный код, использующий Hibernate, обычно требует используйте тот же сеанс Hibernate, чтобы обеспечить эффективность и правильную обработку транзакций.
Spring позволяет легко создавать и прозрачно привязывать сеанс к текущему потоку. путем предоставления текущего сеанса через Hibernate SessionFactory.
Таким образом, весна решает многие хронические проблемы типичного использования Hibernate для любого локального или JTA-сервера. среда транзакций.
* *Интегрированное управление транзакциями.* Вы можете обернуть свой код ORM декларативным,
Введение в ORM с помощью Spring. перехватчик метода аспектно-ориентированного программирования (АОП) либо через аннотацию `@Transactional` или явно настроив рекомендации AOP транзакции в XML-файл конфигурации.
В обоих случаях семантика транзакций и обработка исключений (откат и т. д.) обрабатываются за вас.
Как обсуждалось в вы также можете поменять местами различные менеджеры транзакций, не затрагивая код, связанный с ORM.
Например, вы можете переключаться между локальными транзакциями и JTA с тем же полным набором услуг. (например, декларативные транзакции), доступные в обоих сценариях.
Кроме того, Код, связанный с JDBC, может полностью интегрироваться транзакционно с кодом, который вы используете для ORM.
Это полезно для доступа к данным, который не подходит для ORM (например, пакетная обработка и потоковая передача BLOB), но для этого все равно необходимо использовать общие транзакции с операциями ORM.
Введение в ORM с помощью Spring.

СОВЕТ: Для более полной поддержки ORM, включая поддержку альтернативной базы данных таких технологий, как MongoDB, вы можете ознакомиться с Набор проектов {spring-site-projects}/spring-data/[Spring Data].
Если вы пользователь JPA, {spring-site-guides}/gs/accessing-data-jpa/[Начало работы с доступом Руководство «Данные с JPA» с https://spring.io представляет собой отличное введение.

Введение.
Введения (известные как объявления между типами в AspectJ) позволяют аспекту объявлять что рекомендуемые объекты реализуют заданный интерфейс и обеспечивают реализацию этот интерфейс от имени этих объектов.
Введение.
Вы можете представиться, используя аннотацию @DeclareParents.
Эта аннотация используется для объявления того, что соответствующие типы имеют нового родителя (отсюда и название).
Например, учитывая интерфейс с именем UsageTracked и реализацию этого интерфейса с именем `DefaultUsageTracked`, следующий аспект заявляет, что все разработчики службы интерфейсы также реализуют интерфейс UsageTracked (например, для статистики через JMX):
Java
	@Aspect
	public class UsageTracking {
		@DeclareParents(value="com.xyz.service.*+", defaultImpl=DefaultUsageTracked.class)
		public static UsageTracked mixin;
		@Before("execution(* com.xyz..service.*.*(..)) && this(usageTracked)")
		public void recordUsage(UsageTracked usageTracked) {
			usageTracked.incrementUseCount();
	@Aspect
	class UsageTracking {
Введение.
Реализуемый интерфейс определяется типом аннотируемого поля.
Атрибут value в аннотации @DeclareParents представляет собой шаблон типа AspectJ.
Любой Компонент соответствующего типа реализует интерфейс UsageTracked.
Обратите внимание, что в Перед советом предыдущего примера служебные bean-компоненты можно напрямую использовать как реализации интерфейса UsageTracked.
Если доступ к компоненту осуществляется программно, вы бы написали следующее:
Java

UsageTracked usageTracked = context.getBean("myService", UsageTracked.class);

Джексон JSON.
Spring предлагает поддержку библиотеки Jackson JSON.
Просмотры JSON.
Spring WebFlux предоставляет встроенную поддержку {baeldung-blog}/jackson-json-view-annotation [Представления сериализации Джексона], который позволяет отображать только подмножество всех полей в объекте.
Чтобы использовать его с Методы контроллера `@ResponseBody` или `ResponseEntity`, вы можете использовать методы Джексона.
Аннотация `@JsonView` для активации класса представления сериализации, как показано в следующем примере:
Java
	@RestController
	public class UserController {
		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView.class)
		public User getUser() {
			return new User("eric", "7!jd#h23");
	public class User {
		public interface WithoutPasswordView {};
		public interface WithPasswordView extends WithoutPasswordView {};
		private String username;
		private String password;
		public User() {
		public User(String username, String password) {
			this.username = username;
			this.password = password;
		@JsonView(WithoutPasswordView.class)
		public String getUsername() {
			return this.username;
		@JsonView(WithPasswordView.class)
		public String getPassword() {
			return this.password;
	@RestController
	class UserController {
Просмотры JSON.
ПРИМЕЧАНИЕ. `@JsonView` допускает использование массива классов представлений, но вы можете указать только один для каждого. метод контроллера.

Используйте составной интерфейс, если вам нужно активировать несколько представлений.

Конфигурация контейнера на основе Java.
В этом разделе описано, как использовать аннотации в коде Java для настройки Spring. контейнер.

Доступ к данным с помощью JDBC.
Ценность, предоставляемая абстракцией JDBC Spring Framework, возможно, лучше всего демонстрируется Последовательность действий изложена в следующей таблице.
В таблице показано, какие действия Spring о чем заботится и за какие действия вы несете ответственность.
Доступ к данным с помощью JDBC. .Spring JDBC – кто что делает? |=== | Действие| Весна| ты
| Подготовьте и запустите заявление. | Х |. | Настройте цикл для перебора результатов (если таковые имеются). | Х |
| Обрабатывать транзакции. | Х |. | Закройте соединение, оператор и набор результатов. | Х | |===
| Обрабатывать транзакции. | Х |.
Spring Framework заботится обо всех деталях низкого уровня, которые могут сделать JDBC таким утомительный API.

Spring JPA, доступный в пакете org.springframework.orm.jpa, предлагает всесторонняя поддержка https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html[Постоянство Java API] аналогично интеграции с Hibernate, но с учетом базовую реализацию, чтобы предоставить дополнительные функции.
Три варианта настройки JPA в среде Spring.
Поддержка Spring JPA предлагает три способа настройки JPA `EntityManagerFactory`. который используется приложением для получения менеджера объектов.
* с использованием `LocalEntityManagerFactoryBean`
* Получение EntityManagerFactory из JNDI
* с использованием `LocalContainerEntityManagerFactoryBean`
Использование LocalEntityManagerFactoryBean.
Эту опцию можно использовать только в простых средах развертывания, например в изолированных средах. приложения и интеграционные тесты.
Использование LocalEntityManagerFactoryBean.
LocalEntityManagerFactoryBean создает EntityManagerFactory, подходящий для простые среды развертывания, в которых приложение использует только JPA для доступа к данным.
Фабричный компонент использует механизм автоматического обнаружения JPA PersistenceProvider (согласно к начальной загрузке Java SE JPA) и в большинстве случаев требует указания только имя единицы персистентности.
Следующий пример XML настраивает такой bean-компонент:
	<beans>
		<bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
			<property name="persistenceUnitName" value="myPersistenceUnit"/>
		</bean>
	</beans>
Использование LocalEntityManagerFactoryBean.
Эта форма развертывания JPA является самой простой и наиболее ограниченной.

Вы не можете ссылаться на существующее определение bean-компонента JDBC `DataSource` и отсутствие поддержки глобальных транзакций существует.
Кроме того, плетение (преобразование байт-кода) постоянных классов зависит от поставщика, часто требует указания конкретного агента JVM при запуске.
Это вариант достаточен только для автономных приложений и тестовых сред, для которых разработана спецификация JPA.
Получение EntityManagerFactory из JNDI.
Эту опцию можно использовать при развертывании на сервере Jakarta EE.
Проверьте документацию вашего сервера о том, как развернуть на вашем сервере собственный поставщик JPA, позволяющий использовать разные провайдера, чем сервер по умолчанию.
Получение EntityManagerFactory из JNDI (например, в среде Jakarta EE), является вопросом изменения конфигурации XML, как показано в следующем примере:
	<beans>
		<jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/>
	</beans>
Получение EntityManagerFactory из JNDI.
Это действие предполагает стандартную загрузку Jakarta EE.
Сервер Jakarta EE автоматически обнаруживает единицы персистентности (по сути, файлы META-INF/persistence.xml в jar-файлах приложения) и записи `persistence-unit-ref` в дескрипторе развертывания Jakarta EE (например, `web.xml`) и определяет расположение контекста именования среды для этих единиц персистентности.
Получение EntityManagerFactory из JNDI.
В таком сценарии все развертывание модуля сохраняемости, включая переплетение (преобразование байт-кода) постоянных классов зависит от сервера Jakarta EE.

JDBC DataSource определяется через местоположение JNDI в файле META-INF/persistence.xml.
Транзакции EntityManager интегрированы с подсистемой JTA сервера.
Весна просто использует полученную EntityManagerFactory, передавая ее объектам приложения через внедрение зависимостей и управление транзакциями для модуля персистентности (обычно через `JtaTransactionManager`).
Получение EntityManagerFactory из JNDI.
Если вы используете несколько модулей персистентности в одном приложении, имена компонентов таких Единицы персистентности, полученные с помощью JNDI, должны соответствовать именам единиц персистентности, которые приложение использует для ссылки на них (например, в `@PersistenceUnit` и аннотации `@PersistenceContext`).
Использование LocalContainerEntityManagerFactoryBean.
Вы можете использовать эту опцию для получения всех возможностей JPA в среде приложений на основе Spring.
Сюда входят веб-контейнеры, такие как Tomcat, автономные приложения и интеграционные тесты со сложными требованиями к устойчивости.
Использование LocalContainerEntityManagerFactoryBean.
LocalContainerEntityManagerFactoryBean дает полный контроль над Конфигурация `EntityManagerFactory` подходит для сред, где требуется тонкая настройка. `LocalContainerEntityManagerFactoryBean` создает экземпляр PersistenceUnitInfo на основе файлаpersistence.xml, предоставил стратегию dataSourceLookup и указанный loadTimeWeaver.
Таким образом, это можно работать с пользовательскими источниками данных вне JNDI и контролировать переплетение процесс.
В следующем примере показано типичное определение компонента для `LocalContainerEntityManagerFactoryBean`:
	<beans>
		<bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
			<property name="dataSource" ref="someDataSource"/>

<property name="loadTimeWeaver">
				<bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>
			</property>
		</bean>
	</beans>
	<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
		<persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL">
			<mapping-file>META-INF/orm.xml</mapping-file>
			<exclude-unlisted-classes/>
		</persistence-unit>
	</persistence>
В следующем примере показан типичный файл persistence.xml:.
ПРИМЕЧАНИЕ.
Ярлык `<exclude-unlisted-classes/>` указывает, что сканирование на наличие предполагается, что будут аннотированные классы сущностей.
Явное «истинное» значение (`<exclude-unlisted-classes>true</exclude-unlisted-classes/>`) также означает отсутствие сканирования. `<exclude-unlisted-classes>false</exclude-unlisted-classes/>` запускает сканирование.
Однако мы рекомендуем опустить элемент «exclude-unlisted-classes». если вы хотите, чтобы происходило сканирование классов сущностей.
В следующем примере показан типичный файл persistence.xml:.
Использование LocalContainerEntityManagerFactoryBean — самая мощная настройка JPA. опция, позволяющая гибко локально настраивать приложение.

Он поддерживает ссылки на существующий источник данных JDBC, поддерживают как локальные, так и глобальные транзакции и так далее.
Однако это также накладывает требования на среду выполнения, например наличие загрузчика классов с возможностью переплетения, если этого требует поставщик персистентности преобразование байт-кода.
В следующем примере показан типичный файл persistence.xml:.
Этот параметр может конфликтовать со встроенными возможностями JPA сервера Jakarta EE.
В полной среды Jakarta EE, рассмотрите возможность получения EntityManagerFactory от JNDI.
Альтернативно, укажите пользовательское значение «persistenceXmlLocation» в вашем Определение `LocalContainerEntityManagerFactoryBean` (например, META-INF/my-persistence.xml) и включать в свой файл только дескриптор с таким именем. jar-файлы приложения.
Поскольку сервер Jakarta EE ищет только значения по умолчанию `META-INF/persistence.xml`, он игнорирует такие пользовательские единицы персистентности и, следовательно, позволяет избежать конфликтов с предварительной настройкой JPA, управляемой Spring.
В следующем примере показан типичный файл persistence.xml:. .Когда требуется ткачество во время загрузки? **** Не всем поставщикам JPA требуется агент JVM.
Hibernate — пример того, чего нет.
Если вашему провайдеру не требуется агент или у вас есть другие альтернативы, например применяя улучшения во время сборки с помощью специального компилятора или задачи Ant, вам не следует использовать время загрузки ткача. ****
В следующем примере показан типичный файл persistence.xml:.

Интерфейс LoadTimeWeaver — это класс, предоставленный Spring, который позволяет JPA Экземпляры ClassTransformer подключаются определенным образом, в зависимости от того, среда — это веб-контейнер или сервер приложений.
Перехват `ClassTransformers` через {java-api}/java.instrument/java/lang/instrument/package-summary.html[агент] обычно неэффективен.
Агенты работают на всей виртуальной машине и проверять каждый загружаемый класс, что обычно нежелательно в рабочей среде. серверная среда.
В следующем примере показан типичный файл persistence.xml:.
Spring предоставляет ряд реализаций LoadTimeWeaver для различных сред. позволяя экземплярам ClassTransformer применяться только для каждого загрузчика классов, а не для каждой виртуальной машины.
В следующем примере показан типичный файл persistence.xml:.
См. конфигурация Spring в главе АОП. более подробная информация о реализациях LoadTimeWeaver и их настройке, либо универсальный или адаптированный для различных платформ (таких как Tomcat, JBoss и WebSphere).
В следующем примере показан типичный файл persistence.xml:.
Как описано в конфигурация Spring, вы можете настроить контекстный `LoadTimeWeaver`, используя аннотацию `@EnableLoadTimeWeaving` или XML-элемент `context:load-time-weaver`.
Такой глобальный вивер автоматически подхватывается всеми экземплярами JPA LocalContainerEntityManagerFactoryBean.

Следующий пример показывает предпочтительный способ настройки Weaver во время загрузки, обеспечивая автоматическое обнаружение платформы (например, загрузчик классов Tomcat с поддержкой переплетения или агент JVM Spring) и автоматическое распространение ткача на все bean-компоненты, поддерживающие ткач:
	<context:load-time-weaver/>
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
	</bean>
В следующем примере показан типичный файл persistence.xml:.
Однако при необходимости вы можете вручную указать выделенного ткача через loadTimeWeaver, как показано в следующем примере:
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="loadTimeWeaver">
			<bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/>
		</property>
	</bean>
В следующем примере показан типичный файл persistence.xml:.
Независимо от того, как настроен LTW, при использовании этого метода приложения JPA, использующие Инструментарий может работать на целевой платформе (например, Tomcat) без использования агента.
Это особенно важно, когда хостинговые приложения используют разные JPA. реализации, поскольку преобразователи JPA применяются только на уровне загрузчика классов и таким образом, изолированы друг от друга.
Работа с несколькими единицами персистентности.

Для приложений, которые полагаются на несколько расположений единиц персистентности (хранящихся в различных JARS в пути к классам), Spring предлагает PersistenceUnitManager действовать как центральный репозиторий и избежать процесса обнаружения единиц персистентности, который может быть дорого.
Реализация по умолчанию позволяет указать несколько местоположений.
Эти места анализируется и позже извлекается по имени единицы персистентности. (По умолчанию путь к классам ищет файлы `META-INF/persistence.xml`.) В следующем примере настраиваются несколько мест:
	<bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager">
		<property name="persistenceXmlLocations">
			<list>
				<value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>
				<value>classpath:/my/package/**/custom-persistence.xml</value>
				<value>classpath*:META-INF/persistence.xml</value>
			</list>
		</property>
		<property name="dataSources">
			<map>
				<entry key="localDataSource" value-ref="local-db"/>
				<entry key="remoteDataSource" value-ref="remote-db"/>
			</map>
		</property>
		<!-- if no datasource is specified, use this one -->

<property name="defaultDataSource" ref="remoteDataSource"/>
	</bean>
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="persistenceUnitManager" ref="pum"/>
		<property name="persistenceUnitName" value="myCustomUnit"/>
	</bean>
Работа с несколькими единицами персистентности.
Реализация по умолчанию позволяет настраивать экземпляры PersistenceUnitInfo. (до того, как они будут переданы провайдеру JPA) либо декларативно (через его свойства, которые влиять на все размещенные устройства) или программно (через `PersistenceUnitPostProcessor`, который позволяет выбирать единицы персистентности).
Если нет Указан `PersistenceUnitManager`, он создается и используется внутри `LocalContainerEntityManagerFactoryBean`.
Фоновая загрузка.
LocalContainerEntityManagerFactoryBean поддерживает фоновую загрузку через свойство bootstrapExecutor, как показано в следующем примере:
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="bootstrapExecutor">
			<bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/>
		</property>
	</bean>
Фоновая загрузка.
Фактическая загрузка поставщика JPA передается указанному исполнителю, а затем работает параллельно с потоком начальной загрузки приложения.
Открытая `EntityManagerFactory` прокси-сервер может быть внедрен в другие компоненты приложения и даже способен реагировать на Проверка конфигурации `EntityManagerFactoryInfo`.

Однако, как только фактический поставщик JPA к которому обращаются другие компоненты (например, вызов `createEntityManager`), эти вызовы блокируются до завершения фоновой загрузки.
В частности, когда вы используете Spring Data JPA, обязательно также настройте отложенную загрузку для своих репозиториев.
Фоновая загрузка.
Начиная с версии 6.2, инициализация JPA применяется до завершения обновления контекста, ожидая асинхронная загрузка должна завершиться к тому времени.
Это делает доступность полностью инициализированная инфраструктура базы данных предсказуема и позволяет настраивать пост-инициализацию логика в прослушивателях `ContextRefreshedEvent` и т. д.
Размещение такой базы данных уровня приложения инициализация методами `@PostConstruct` и т.п. не рекомендуется; это лучше разместить в Lifecycle.start (если применимо) или в прослушивателе ContextRefreshedEvent.
Фоновая загрузка.
Реализация DAO на основе JPA: EntityManagerFactory и EntityManager.
Фоновая загрузка.
ПРИМЕЧАНИЕ.
Хотя экземпляры EntityManagerFactory являются потокобезопасными, экземпляры EntityManager нет.
Внедренный JPA `EntityManager` ведет себя как `EntityManager`, полученный из среда JNDI сервера приложений, как определено спецификацией JPA.
Он делегирует все вызовы текущего транзакционного `EntityManager`, если таковые имеются.
В противном случае он откатится назад во вновь созданный `EntityManager` для каждой операции, что фактически делает его использование потокобезопасным.
Фоновая загрузка.
Можно написать код на простом JPA без каких-либо зависимостей Spring, используя внедренный EntityManagerFactory или EntityManager.

Весна может понять Аннотации `@PersistenceUnit` и `@PersistenceContext` как в поле, так и в методе. уровень, если включен PersistenceAnnotationBeanPostProcessor.
Следующий пример показана простая реализация JPA DAO, использующая аннотацию @PersistenceUnit:
Java
	public class ProductDaoImpl implements ProductDao {
		private EntityManagerFactory emf;
		@PersistenceUnit
		public void setEntityManagerFactory(EntityManagerFactory emf) {
			this.emf = emf;
		public Collection loadProductsByCategory(String category) {
			EntityManager em = this.emf.createEntityManager();
			try {
				Query query = em.createQuery("from Product as p where p.category = ?1");
				query.setParameter(1, category);
				return query.getResultList();
			finally {
				if (em != null) {
					em.close();
	class ProductDaoImpl : ProductDao {
Фоновая загрузка.
Предыдущий DAO не зависит от Spring и по-прежнему прекрасно вписывается в Spring. контекст приложения.
Более того, DAO использует аннотации, чтобы потребовать внедрение стандартного `EntityManagerFactory`, как показано в следующем примере определения bean-компонента:
	<beans>
		<!-- bean post-processor for JPA annotations -->
		<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>
		<bean id="myProductDao" class="product.ProductDaoImpl"/>
	</beans>
Фоновая загрузка.

В качестве альтернативы явному определению PersistenceAnnotationBeanPostProcessor: рассмотрите возможность использования XML-элемента Spring `context:annotation-config` в вашем приложении.
Конфигурация контекста.
При этом автоматически регистрируются все стандарты Spring. постпроцессоры для настройки на основе аннотаций, включая `CommonAnnotationBeanPostProcessor` и так далее.
	<beans>
		<!-- post-processors for all standard config annotations -->
		<context:annotation-config/>
		<bean id="myProductDao" class="product.ProductDaoImpl"/>
	</beans>
Рассмотрим следующий пример:.
Основная проблема такого DAO заключается в том, что он всегда создает новый EntityManager через завод.
Вы можете избежать этого, запросив транзакционный `EntityManager` (также называемый «shared EntityManager», потому что это общий потокобезопасный прокси-сервер для реальных транзакций.
EntityManager), который будет внедрен вместо фабрики.
В следующем примере показано, как это сделать:
Java
	public class ProductDaoImpl implements ProductDao {
		@PersistenceContext
		private EntityManager em;
		public Collection loadProductsByCategory(String category) {
			Query query = em.createQuery("from Product as p where p.category = :category");
			query.setParameter("category", category);
			return query.getResultList();
	class ProductDaoImpl : ProductDao {
Рассмотрим следующий пример:.
Аннотация `@PersistenceContext` имеет необязательный атрибут `type`, который по умолчанию в PersistenceContextType.TRANSACTION.

Вы можете использовать это значение по умолчанию для получения общего Прокси `EntityManager`.
Альтернатива PersistenceContextType.EXTENDED — это полностью другое дело.
В результате получается так называемый расширенный `EntityManager`, который не является потокобезопасен и, следовательно, не должен использоваться в компоненте с одновременным доступом, таком как Одноэлементный компонент, управляемый Spring.
Расширенные экземпляры EntityManager предназначены только для использования. в компонентах с состоянием, которые, например, находятся в сеансе, с жизненным циклом `EntityManager` не привязан к текущей транзакции, а полностью зависит от приложение.
Рассмотрим следующий пример:. .Внедрение на уровне метода и поля. **** Вы можете применять аннотации, обозначающие внедрение зависимостей (например, `@PersistenceUnit` и `@PersistenceContext`) для поля или методов внутри класса - отсюда и выражения «Внедрение на уровне метода» и «Внедрение на уровне поля».
Аннотации на уровне поля лаконичны и просты в использовании, а аннотации на уровне метода позволяют осуществлять дальнейшую обработку внедренная зависимость.
В обоих случаях видимость члена (общедоступная, защищенная или частная) не имеет значения.
Рассмотрим следующий пример:.
А как насчет аннотаций уровня класса?
Рассмотрим следующий пример:.
На платформе Jakarta EE они используются для объявления зависимостей, а не для описания ресурсов. инъекция. ****
Рассмотрим следующий пример:.
Внедренный `EntityManager` управляется Spring (с учетом текущей транзакции).

Несмотря на то, что новая реализация DAO использует внедрение EntityManager на уровне метода вместо EntityManagerFactory никаких изменений в определении компонента не требуется. из-за использования аннотаций.
Рассмотрим следующий пример:.
Основное преимущество этого стиля DAO заключается в том, что он зависит только от Java Persistence API.
Импорт какого-либо класса Spring не требуется.
Более того, как понимаются аннотации JPA, инъекции применяются автоматически контейнером Spring.
Это привлекательно от перспектива неинвазивности и может показаться более естественной для разработчиков JPA.
Рассмотрим следующий пример:.
Реализация DAO на основе @Autowired (обычно с внедрением на основе конструктора)
Рассмотрим следующий пример:. `@PersistenceUnit` и `@PersistenceContext` могут быть объявлены только для методов и полей.
А как насчет предоставления ресурсов JPA через конструкторы и другие точки внедрения @Autowired?
Рассмотрим следующий пример:. `EntityManagerFactory` можно легко внедрить через конструкторы и поля/методы `@Autowired`. до тех пор, пока цель определена как компонент, например, через LocalContainerEntityManagerFactoryBean.
Точка внедрения соответствует исходному определению EntityManagerFactory по типу как есть.
Рассмотрим следующий пример:.
Однако общая ссылка на EntityManager в стиле @PersistenceContext недоступна для регулярное внедрение зависимостей «из коробки».
Чтобы сделать его доступным для соответствия, как того требует `@Autowired`, рассмотрите возможность определения `SharedEntityManagerBean` как компаньон для вашего определения `EntityManagerFactory`:

<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
	</bean>
	<bean id="em" class="org.springframework.orm.jpa.support.SharedEntityManagerBean">
		<property name="entityManagerFactory" ref="emf"/>
	</bean>
	@Bean("em")
	public static EntityManager sharedEntityManager(EntityManagerFactory emf) {
		return SharedEntityManagerCreator.createSharedEntityManager(emf);
Альтернативно вы можете определить метод @Bean на основе SharedEntityManagerCreator:.
В случае нескольких единиц персистентности каждое определение EntityManagerFactory должно быть сопровождается соответствующим определением bean-компонента EntityManager, в идеале с квалификаторами которые соответствуют отдельному определению EntityManagerFactory, чтобы различать единицы персистентности через `@Autowired @Qualifier("...")`.
Spring-управляемые JPA-транзакции.
ПРИМЕЧАНИЕ.
Мы настоятельно рекомендуем вам прочитать Декларативное управление транзакциями. если вы еще этого не сделали, чтобы получить более подробное описание поддержки декларативных транзакций Spring.
Spring-управляемые JPA-транзакции.
Рекомендуемая стратегия для JPA — локальные транзакции через собственную транзакцию JPA. поддержка.
Spring `JpaTransactionManager` предоставляет множество возможностей, известных из локальных Транзакции JDBC (такие как уровни изоляции для конкретных транзакций и уровни изоляции на уровне ресурсов). оптимизация только для чтения) для любого обычного пула соединений JDBC, не требуя координатор транзакций JTA и ресурсы с поддержкой XA.

Spring-управляемые JPA-транзакции.
Spring JPA также позволяет настроенному JpaTransactionManager предоставлять транзакцию JPA. к коду доступа JDBC, который обращается к тому же источнику данных, при условии, что зарегистрированный `JpaDialect` поддерживает извлечение базового JDBC `Connection`.
Весна обеспечивает диалекты для реализаций EclipseLink и Hibernate JPA.
См.
Spring-управляемые JPA-транзакции.
Для отложенного получения фактических подключений к ресурсам в стиле JTA Spring предоставляет соответствующий прокси-класс `DataSource` для целевого пула соединений: см. {spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].
Это особенно полезно для транзакций JPA, доступных только для чтения, которые часто могут обрабатываться из локального кэша, а не обращаться к базе данных.
Понимание `JpaDialect` и `JpaVendorAdapter`.
В качестве расширенной функции JpaTransactionManager и его подклассы `AbstractEntityManagerFactoryBean` позволяет передавать пользовательский `JpaDialect` в Свойство компонента `jpaDialect`.
Реализация `JpaDialect` может включать следующие расширенные возможности: функции, поддерживаемые Spring, обычно в зависимости от поставщика:
* Применение определенной семантики транзакций (например, пользовательского уровня изоляции или
* Получение транзакционного соединения JDBC (для доступа к DAO на основе JDBC).
* Расширенный перевод PersistenceException в Spring DataAccessException.
тайм-аут).
Это особенно ценно для специальной семантики транзакций и для продвинутых перевод исключения.

Реализация по умолчанию («DefaultJpaDialect») делает не предоставляют никаких особых возможностей, и, если перечисленные ранее функции необходимы, у вас есть указать соответствующий диалект.
тайм-аут).
СОВЕТ: В качестве еще более широкого средства адаптации поставщика, прежде всего для полнофункциональной среды Spring.
Настройка LocalContainerEntityManagerFactoryBean, JpaVendorAdapter объединяет возможности `JpaDialect` с другими настройками по умолчанию, зависящими от поставщика.
Указание HibernateJpaVendorAdapter или EclipseLinkJpaVendorAdapter — наиболее удобный вариант. способ автоматической настройки установки EntityManagerFactory для Hibernate или EclipseLink, соответственно.
Обратите внимание, что эти адаптеры поставщиков в первую очередь предназначены для использования с Управление транзакциями на основе Spring (то есть для использования с JpaTransactionManager).
тайм-аут).
См. {spring-framework-api}/orm/jpa/JpaDialect.html[`JpaDialect`] и {spring-framework-api}/orm/jpa/JpaVendorAdapter.html[`JpaVendorAdapter`] javadoc для более подробную информацию о его операциях и о том, как они используются в рамках поддержки Spring JPA.
Настройка JPA с управлением транзакциями JTA.
В качестве альтернативы JpaTransactionManager Spring также позволяет использовать несколько ресурсов. координация транзакций через JTA либо в среде Jakarta EE, либо с помощью автономный координатор транзакций, например Atomikos.
Помимо выбора Spring's `JtaTransactionManager` вместо `JpaTransactionManager`, вам нужно сделать еще несколько шаги:
* Базовые пулы соединений JDBC должны поддерживать XA и быть интегрированы с

Настройка JPA с управлением транзакциями JTA. ваш координатор транзакций.
В среде Jakarta EE это обычно просто. предоставление доступа к другому типу DataSource через JNDI.
Посмотрите свой сервер приложений документация для получения подробной информации.
Аналогично, автономный координатор транзакций обычно поставляется со специальными вариантами DataSource, интегрированными с XA.
Еще раз проверьте его документацию.
* Настройка JPA `EntityManagerFactory` должна быть настроена для JTA. Это
Настройка JPA с управлением транзакциями JTA. зависит от поставщика, обычно через специальные свойства, которые указываются как `jpaProperties` в `LocalContainerEntityManagerFactoryBean`.
В случае Hibernate эти свойства даже зависят от версии.
Подробности смотрите в документации Hibernate.
* HibernateJpaVendorAdapter Spring применяет определенные настройки по умолчанию, ориентированные на Spring, такие как
Настройка JPA с управлением транзакциями JTA. в качестве режима освобождения соединения, `on-close`, который соответствует собственному умолчанию Hibernate в Hibernate 5.0, но не в Hibernate 5.1+.
Для настройки JTA обязательно объявите тип транзакции вашей единицы персистентности — «JTA».
Альтернативно установите Hibernate 5.2.
Свойство `hibernate.connection.handling_mode` для `DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT` для восстановления настроек Hibernate по умолчанию.
Соответствующие примечания см. в Предупреждения о ложных серверах приложений в Hibernate.
* В качестве альтернативы рассмотрите возможность получения EntityManagerFactory из вашего приложения.
Настройка JPA с управлением транзакциями JTA. сам сервер (то есть посредством поиска JNDI вместо локально объявленного `LocalContainerEntityManagerFactoryBean`).

Предоставляемый сервером EntityManagerFactory. могут потребоваться специальные определения в конфигурации вашего сервера (что делает развертывание менее портативен), но настроен для среды JTA сервера.
Собственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.
Собственная настройка LocalSessionFactoryBean в сочетании с HibernateTransactionManager. позволяет взаимодействовать с @PersistenceContext и другим кодом доступа JPA.
Спящий режим SessionFactory теперь изначально реализует интерфейс JPA EntityManagerFactory. а дескриптор сеанса Hibernate изначально является JPA `EntityManager`.
Средства поддержки JPA Spring автоматически обнаруживают собственные сеансы Hibernate.
Собственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.
Таким образом, такая собственная настройка Hibernate может служить заменой стандартного JPA.
Комбинация LocalContainerEntityManagerFactoryBean и JpaTransactionManager. во многих сценариях, позволяющих взаимодействовать с `SessionFactory.getCurrentSession()` (а также HibernateTemplate) рядом с @PersistenceContext EntityManager внутри та же локальная транзакция.
Такая настройка также обеспечивает более сильную интеграцию Hibernate. и большую гибкость конфигурации, поскольку она не ограничена контрактами начальной загрузки JPA.
Собственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.
В таком сценарии вам не нужна конфигурация HibernateJpaVendorAdapter. поскольку встроенная настройка Hibernate Spring предоставляет еще больше возможностей (например, пользовательская настройка Hibernate Integrator, интеграция контейнера компонентов Hibernate 5.3, и более сильная оптимизация для транзакций только для чтения).

И последнее, но не менее важное: вы также можете выразить встроенную настройку Hibernate через LocalSessionFactoryBuilder, плавно интегрируется с конфигурацией стиля `@Bean` (без использования `FactoryBean`).
Собственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA. [ПРИМЕЧАНИЕ] = LocalSessionFactoryBean и LocalSessionFactoryBuilder поддерживают фон. загрузка, так же, как это делает JPA `LocalContainerEntityManagerFactoryBean`.
Введение см. в Фоновая загрузка.
Собственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.
В LocalSessionFactoryBean это доступно через bootstrapExecutor. собственность.
В программном файле LocalSessionFactoryBuilder перегруженный Метод buildSessionFactory принимает аргумент исполнителя начальной загрузки.

1. Введение. `kafka` модуль предоставляет высокоуровневую интеграцию Lilipup Framework с Apache Kafka: продюсеры, консьюмеры, ретраи, backoff, DLQ и наблюдаемость.
- единый API публикации/чтения сообщений;
- встроенные гарантии доставки и управление ошибками;
- прозрачная интеграция с monitoring hooks.
```xml
```java
    private final LilipupKafkaTemplate<String, InvoiceCreatedEvent> kafkaTemplate;
    public BillingEventPublisher(LilipupKafkaTemplate<String, InvoiceCreatedEvent> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    public void publish(InvoiceCreatedEvent event) {
        SendResult result = kafkaTemplate.send("billing.invoice.created", event.invoiceId(), event);
        // Обязательная проверка: подтверждение брокера.
        if (!result.acknowledged()) {
            throw new IllegalStateException("Kafka send is not acknowledged");
```java
    @LilipupKafkaListener(
        topic = "billing.invoice.created",
        groupId = "billing-read-model",
        concurrency = 4,
        ackMode = AckMode.MANUAL
    public void onMessage(InvoiceCreatedEvent event, KafkaAck ack) {
        processEvent(event);
        // Явно подтверждаем обработку только после успешной бизнес-операции.
        ack.acknowledge();
    private void processEvent(InvoiceCreatedEvent event) {
        // Запись в read model.
```yaml
    bootstrap-servers: kafka-1:9092,kafka-2:9092

client-id: billing-service
    producer:
      acks: all
      retries: 5
      linger-ms: 10
      enable-idempotence: true
      compression: zstd
    consumer:
      auto-offset-reset: earliest
      max-poll-records: 500
      session-timeout-ms: 45000
      manual-ack: true
    serialization:
      key-serde: string
      value-serde: json
    retry:
      attempts: 4
      backoff-ms: 500
      multiplier: 2.0
    dlq:
      enabled: true
      topic-suffix: .dlq
- Всегда проверяйте `SendResult.acknowledged()` после отправки.
- Проверяйте, что ключ сообщения (`message key`) стабилен для корректного partition ordering.
- Всегда настраивайте `acks=all` для критичных бизнес-событий.
- Проверяйте сериализацию payload до отправки (особенно для nullable полей).
- Не отправляйте сообщения без версии схемы (`eventVersion`) при эволюции контракта.
```java
    .attempts(4)
    .initialBackoffMs(500)
    .multiplier(2.0)
    .maxBackoffMs(8000)
    .retryOn(TimeoutException.class, RetriableBrokerException.class)
    .build();
- не используйте бесконечный retry;
- отправляйте событие в DLQ после исчерпания попыток;
- логируйте correlation-id на каждой попытке.
- `KafkaSerializationException`: payload не сериализуется в выбранный формат.
- `KafkaDeliveryTimeoutException`: брокер не подтвердил отправку вовремя.

- `KafkaListenerProcessingException`: ошибка обработки в listener.
```java
    private final DeadLetterPublisher deadLetterPublisher;
    public FailedMessageHandler(DeadLetterPublisher deadLetterPublisher) {
        this.deadLetterPublisher = deadLetterPublisher;
    public void handle(String topic, String key, byte[] payload, Exception ex) {
        deadLetterPublisher.publish(topic + ".dlq", key, payload, ex.getMessage());
- Включайте `lilipup.kafka.metrics.enabled=true` для метрик latency/throughput.
- Используйте `trace-id` и `correlation-id` в headers.
- Проверяйте lag по consumer-group перед релизом.
- Делайте обработчики консьюмера идемпотентными.
- Ограничивайте размер сообщения и избегайте передачи бинарных blob без необходимости.
- Применяйте версионирование событий (`eventType`, `eventVersion`).
- Разделяйте топики команд и доменных событий.
- Периодически тестируйте сценарии «брокер недоступен» и «частичный outage».

Справочник по языкам.
В этом разделе описывается, как работает язык выражений Spring.

1. Введение. `lifecycle` управляет фазами жизни компонентов: создание, инициализация, готовность к трафику, graceful shutdown и очистка ресурсов.
- предсказуемый запуск сервиса;
- корректное завершение без потери данных;
- контроль готовности инфраструктурных зависимостей.
```xml
```java
    @OnStart(order = 10)
    public void initCaches() {
        // Выполняется до открытия внешнего трафика.
        System.out.println("Warming up cache...");
    @OnReady
    public void signalReady() {
        // Точка, когда компонент готов обслуживать запросы.
        System.out.println("Component is ready");
    @OnStop(timeoutMs = 5000)
    public void flushAndClose() {
        // Корректно закрываем ресурсы.
        System.out.println("Flushing and closing resources");
```yaml
    startup-timeout-ms: 30000
    shutdown-timeout-ms: 20000
    readiness:
      enabled: true
      require-all-components: true
    shutdown:
      graceful: true
      await-jobs: true
- Всегда ставьте таймауты на `@OnStart` и `@OnStop`, чтобы избежать зависания процесса.
- Проверяйте readiness внешних зависимостей (БД, Kafka, кэш) до `@OnReady`.
- Не публикуйте трафик, пока не завершились критичные `@OnStart` хуки.
- Всегда освобождайте сетевые/файловые ресурсы в `@OnStop`.

- Для background-задач проверяйте, что при shutdown они либо завершены, либо безопасно прерваны.
- `LifecycleTimeoutException`: хук превысил таймаут.
- `ReadinessCheckException`: не выполнена проверка готовности.
- `ShutdownInterruptedException`: процесс завершения был прерван.
```java
    @Override
    public ReadinessState check() {
        boolean dbReachable = pingDb();
        return dbReachable
            ? ReadinessState.ready("db_ok")
            : ReadinessState.notReady("db_unreachable");
    private boolean pingDb() {
        // Здесь реальная проверка соединения.
        return true;
- Разделяйте быстрые и тяжелые `@OnStart` действия по `order`.
- Делайте shutdown идемпотентным: повторный вызов не должен ломать состояние.
- Логируйте длительность каждого lifecycle-hook.
- Используйте readiness-пробы как контракт между сервисом и orchestrator.
- Тестируйте сценарий «kill во время старта» и «kill во время long-running job».

Буквальные выражения.
SpEL поддерживает следующие типы литеральных выражений.
Буквальные выражения.
Строка Строки могут быть разделены одинарными кавычками (`'`) или двойными кавычками. («`»`).
Чтобы включить одинарную кавычку в строковый литерал, заключенный в одинарные кавычки, используйте два соседних символа одинарных кавычек.
Аналогично, чтобы включать двойные кавычки в строковый литерал, заключенный в двойные кавычки знаки, используйте два соседних символа двойных кавычек.
Номер Числа поддерживают использование отрицательного знака, экспоненциальной записи и десятичных точек.
  * Целое число: `int` или `long`
  * Шестнадцатеричный: `int` или `long`
  * Настоящее: «плавающее» или «двойное».
Буквальные выражения. ** По умолчанию действительные числа анализируются с помощью Double.parseDouble(). логическое значение «правда» или «ложь» Ноль `ноль`
Буквальные выражения. [ПРИМЕЧАНИЕ] = Благодаря разработке и реализации языка выражений Spring, буквальные числа всегда хранятся внутри как положительные числа.
Буквальные выражения.
Например, `-2` сохраняется внутри как положительное `2`, которое затем инвертируется, пока оценка выражения (путем вычисления значения `0 - 2`).
Буквальные выражения.
Это означает, что невозможно представить отрицательное буквальное число, равное минимальное значение этого типа числа в Java.

Например, минимальное поддерживаемое значение для `int` в Java используется `Integer.MIN_VALUE`, который имеет значение `-2147483648`.
Однако, если вы включите `-2147483648` в выражение SpEL, будет выдано исключение, информирующее вы понимаете, что значение `2147483648` не может быть проанализировано как `int` (поскольку оно превышает значение `Integer.MAX_VALUE`, которое равно `2147483647`).
Буквальные выражения.
Если вам нужно использовать минимальное значение для определенного типа числа в SpEL выражение, вы можете либо ссылаться на константу `MIN_VALUE` для соответствующей оболочки введите (например, «Integer.MIN_VALUE», «Long.MIN_VALUE» и т. д.) или вычислите минимальное значение. ценность.
Например, чтобы использовать минимальное целое значение:
- `T(Integer).MIN_VALUE` -- требуется `StandardEvaluationContext`
- `-2^31` -- может использоваться с любым типом `EvaluationContext`
Буквальные выражения.
В следующем листинге показано простое использование литералов.
Как правило, они не используются в такая изоляция, а, скорее, как часть более сложного выражения — например, использование литерала на одной стороне оператора логического сравнения или в качестве аргумента метод.
Java
	ExpressionParser parser = new SpelExpressionParser();
	// оценивается как «Hello World»

String helloWorld = (String) parser.parseExpression("'Hello World'").getValue();
	// оценивается как «Пицца Тони».
	String pizzaParlor = (String) parser.parseExpression("'Tony''s Pizza'").getValue();
	double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue();
	// оценивается как 2147483647
	int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();
	boolean trueValue = (Boolean) parser.parseExpression("true").getValue();
	Object nullValue = parser.parseExpression("null").getValue();

Матричные переменные. {rfc-site}/rfc3986#section-3.3[RFC 3986] обсуждает пары имя-значение в сегменты пути.
В Spring WebFlux мы называем их «матричными переменными», основанными на https://www.w3.org/DesignIssues/MatrixURIs.html["`old post`"] Тима Бернерса-Ли, но они также могут называться параметрами пути URI.
Матричные переменные.
Переменные матрицы могут появляться в любом сегменте пути, при этом каждая переменная отделяется точкой с запятой и несколько значений, разделенных запятыми, например `"/cars;color=red,green;year=2012"`.
Несколько значения также могут быть указаны с помощью повторяющихся имен переменных, например, `"color=red;color=green;color=blue"`.
Матричные переменные.
В отличие от Spring MVC, в WebFlux наличие или отсутствие матричных переменных в URL-адресе не учитывается. не влияет на сопоставления запросов.
Другими словами, вам не обязательно использовать переменную URI. для маскировки содержимого переменной.
Тем не менее, если вы хотите получить доступ к матричным переменным из метод контроллера, вам необходимо добавить переменную URI в сегмент пути, где находится матрица ожидаются переменные.
В следующем примере показано, как это сделать:
Java
	// ПОЛУЧИТЬ /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
	public void findPet(@PathVariable String petId, @MatrixVariable int q) {
		// идентификатор питомца == 42
		// q == 11
	// ПОЛУЧИТЬ /pets/42;q=11;r=22
		// идентификатор питомца == 42
		// q == 11
Матричные переменные.
Учитывая, что все сегменты пути могут содержать матричные переменные, иногда вам может потребоваться устранить неоднозначность, в какой переменной пути должна находиться матричная переменная, как показано в следующем примере:
Java
	// ПОЛУЧИТЬ /owners/42;q=11/pets/21;q=22
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable(name="q", pathVar="ownerId") int q1,
			@MatrixVariable(name="q", pathVar="petId") int q2) {
		// q1 == 11
		// q2 == 22
		// q1 == 11
		// q2 == 22
Матричные переменные.
Вы можете определить матричную переменную как необязательную и указать значение по умолчанию. как показано в следующем примере:
Java
	// ПОЛУЧИТЬ /pets/42
	@GetMapping("/pets/{petId}")

public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {
		// q == 1
	// ПОЛУЧИТЬ /pets/42
		// q == 1
Матричные переменные.
Чтобы получить все переменные матрицы, используйте MultiValueMap, как показано в следующем примере:
Java
	// ПОЛУЧИТЬ /owners/42;q=11;r=12/pets/21;q=22;s=23
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable MultiValueMap<String, String> matrixVars,
			@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {
		// матрицаVars: ["q": [11,22], "r": 12, "s": 23]
		// petMatrixVars: ["q": 22, "s": 23]
	// ПОЛУЧИТЬ /owners/42;q=11;r=12/pets/21;q=22;s=23
		// матрицаVars: ["q": [11,22], "r": 12, "s": 23]
		// petMatrixVars: ["q": 22, "s": 23]

Конвертеры сообщений.
Вы можете настроить экземпляры HttpMessageConverter, переопределив {spring-framework-api}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters(org.springframework.http.converter.HttpMessageConverters.Builder)[`configureMessageConverters()`].
Конвертеры сообщений.
В следующем примере настраиваются пользовательские преобразователи Jackson JSON и XML с настроенными преобразователями вместо стандартных.
См. пример кода в исходном документе.

Методы.
Вы можете вызывать методы, используя типичный синтаксис программирования Java.
Вы также можете вызвать методы непосредственно для литералов, таких как строки или числа.
Методы.
В следующих примерах показано, как вызывать методы.
Java
	// строковый литерал, имеет значение «bc»
	String bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String.class);
	// оценивается как правда
	boolean isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(
			societyContext, Boolean.class);

Смешение типов аспектов.
Вполне возможно смешивать аспекты стиля @AspectJ, используя поддержку автоматического проксирования. определенные в схеме аспекты `<aop:aspect>`, `<aop:advisor>` объявленные советники и даже прокси и перехватчики других стилей в той же конфигурации.
Все это реализовано используя один и тот же базовый механизм поддержки, и могут без каких-либо затруднений сосуществовать.

`@ModelAttribute`.
Аннотация параметра метода `@ModelAttribute` связывает данные формы, параметры запроса, Переменные пути URI и заголовки запросов к объекту модели.
Например:
Java
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute Pet pet) { } // <1>
`@ModelAttribute`. <1> Привязка к экземпляру Pet.
`@ModelAttribute`.
Данные формы и параметры запроса имеют приоритет над переменными URI и заголовками, которые включаются только в том случае, если они не переопределяют параметры запроса с тем же именем.
Тире удалено из названий заголовков.
* Доступен из модели, где он мог быть добавлен с помощью
* Доступен из сеанса HTTP, если атрибут модели был указан в
Экземпляр `Pet` может быть:. ссылка на уровне класса:web/webflux/controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`].
* Создается с помощью конструктора по умолчанию.
* Создается с помощью «основного конструктора» с аргументами, соответствующими сервлету.
Экземпляр `Pet` может быть:. параметры запроса.
Имена аргументов определяются с помощью параметра, сохраняемого во время выполнения. имена в байт-коде.
Экземпляр `Pet` может быть:.

По умолчанию и конструктор, и свойство Проектирование модельного объекта требует тщательного рассмотрения, и по соображениям безопасности это рекомендуется рекомендуется либо использовать объект, специально предназначенный для веб-привязки, либо применить только привязка конструктора.
Если привязку свойств все еще необходимо использовать, тогда _allowedFields_ шаблоны должны быть установлены для ограничения того, какие свойства могут быть установлены.
Для получения более подробной информации об этом и пример конфигурации см.
Экземпляр `Pet` может быть:.
При использовании привязки конструктора вы можете настроить имена параметров запроса с помощью Аннотация `@BindParam`.
Например:
Java
	class Account {
		private final String firstName;
		public Account(@BindParam("first-name") String firstName) {
			this.firstName = firstName;
Экземпляр `Pet` может быть:.
ПРИМЕЧАНИЕ. `@BindParam` также может быть помещен в поля, соответствующие конструктору. параметры.
Хотя `@BindParam` поддерживается "из коробки", вы также можете использовать другую аннотацию, установив DataBinder.NameResolver в DataBinder.
Экземпляр `Pet` может быть:.
Привязка конструктора поддерживает аргументы List, Map и массива, преобразованные из одну строку, например список, разделенный запятыми, или на основе индексированных ключей, таких как `accounts[2].name` или `account[KEY].name`.
Экземпляр `Pet` может быть:.

WebFlux, в отличие от Spring MVC, поддерживает в модели реактивные типы, например Mono<Account>.
Вы можете объявить аргумент `@ModelAttribute` с оболочкой реактивного типа или без нее, и он будет решен в соответствии с фактическим значением.
Экземпляр `Pet` может быть:.
Если привязка данных приводит к ошибкам, по умолчанию возникает исключение WebExchangeBindException. но вы также можете добавить аргумент BindingResult непосредственно рядом с @ModelAttribute. для обработки таких ошибок в методе контроллера.
Например:
Java
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <1>
		if (result.hasErrors()) {
			return "petForm";
Экземпляр `Pet` может быть:. <1> Добавление BindingResult.
Экземпляр `Pet` может быть:.
Чтобы использовать аргумент BindingResult, вы должны объявить аргумент @ModelAttribute перед это без оболочки реактивного типа.
Если вы хотите использовать реактивность, вы можете обрабатывать ошибки прямо через него.
Например:
Java
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public Mono<String> processSubmit(@Valid @ModelAttribute("pet") Mono<Pet> petMono) {
		return petMono
			.flatMap(pet -> {

.onErrorResume(ex -> {
Экземпляр `Pet` может быть:.
Вы можете автоматически применить проверку после привязки данных, добавив аннотация `jakarta.validation.Valid` или аннотация Spring `@Validated` (см.
Java
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
		if (result.hasErrors()) {
			return "petForm";
Экземпляр `Pet` может быть:. <1> Использование `@Valid` для аргумента атрибута модели.
Экземпляр `Pet` может быть:.
Если проверка метода применяется, поскольку другие параметры имеют аннотации @Constraint, тогда вместо этого будет вызвано HandlerMethodValidationException.
См. раздел о метод контроллера Validation.
Экземпляр `Pet` может быть:.
СОВЕТ: Использование @ModelAttribute не является обязательным.
По умолчанию любой аргумент, который не является простым тип значения, определенный {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty] _AND_, который не разрешается каким-либо другим преобразователем аргументов, рассматривается как неявный `@ModelAttribute`.
Экземпляр `Pet` может быть:.

ВНИМАНИЕ: При компиляции собственного образа с помощью GraalVM неявный `@ModelAttribute` описанная выше поддержка не позволяет правильно сделать предварительный вывод связанных данных. подсказки по обязательному отражению.
Как следствие, рекомендуется явно аннотировать параметры метода с `@ModelAttribute` для использования в собственном образе GraalVM.

1. Введение. `monitoring` предоставляет единые хуки для метрик, структурированных логов и интеграции с Prometheus/Alerting.
- наблюдаемость производительности и надежности;
- быстрый root-cause анализ инцидентов;
- единый стандарт telemetry для всех модулей.
```xml
```java
    private final MetricsHook metrics;
    public PaymentService(MetricsHook metrics) {
        this.metrics = metrics;
    public void processPayment(String paymentId) {
        long startedAt = System.nanoTime();
        try {
            // Бизнес-операция.
            metrics.counter("payments_processed_total").increment();
        } catch (Exception ex) {
            metrics.counter("payments_failed_total").increment();
            throw ex;
        } finally {
            long durationMs = (System.nanoTime() - startedAt) / 1_000_000;
            metrics.timer("payments_duration_ms").record(durationMs);
```java
    private final LogHook log;
    public OrderLogger(LogHook log) {
        this.log = log;
    public void logOrderEvent(String orderId, String status) {
        log.info("order_event", Map.of(
            "orderId", orderId,
            "status", status,
            "component", "order-service"
```yaml
    metrics:
      enabled: true
      export:
        prometheus:
          enabled: true
          endpoint: /internal/metrics
    logging:
      format: json

include-trace-id: true
      redact-fields:
        - password
        - accessToken
        - cardNumber
    tracing:
      enabled: true
      sampler: 0.2
- Всегда проверяйте, что endpoint метрик защищен и недоступен публично.
- Не логируйте чувствительные поля: токены, пароли, PAN/PII.
- Проверяйте наличие `trace-id` в логах для распределенной трассировки.
- Для каждой критичной операции добавляйте минимум одну success и одну failure метрику.
- Убедитесь, что cardinality label-ов ограничена (не используйте userId как label).
- `MetricRegistryOverflowException`: слишком много уникальных label-комбинаций.
- `PrometheusExportException`: ошибка публикации метрик.
- `LogSerializationException`: проблема сериализации structured-log payload.
```java
    private final MetricsHook metrics;
    public SafeMetricPublisher(MetricsHook metrics) {
        this.metrics = metrics;
    public void publishRequestMetric(String endpoint, int statusCode) {
        String normalizedEndpoint = endpoint.replaceAll("/[0-9]+", "/{id}");
        metrics.counter("http_requests_total")
            .tag("endpoint", normalizedEndpoint)
            .tag("status", String.valueOf(statusCode))
            .increment();
- Стройте SLI/SLO на основе latency, error-rate и saturation.

- Используйте единый naming convention для метрик (`<domain>_<metric>_<unit>`).
- Сохраняйте баланс между детализацией логов и стоимостью хранения.
- Делайте алерты action-oriented, чтобы было понятно, что делать on-call инженеру.
- Регулярно проводите game-day с проверкой мониторинга и alert-routing.

Преимущества модели поддержки транзакций Spring Framework.
Традиционно у разработчиков приложений EE было два варианта управления транзакциями: глобальные или локальные транзакции, обе из которых имеют глубокие ограничения.
Глобальный и управление локальными транзакциями рассматривается в следующих двух разделах, за которыми следует обсуждение того, как поддержка управления транзакциями Spring Framework решает ограничения глобальных и локальных моделей транзакций.
Глобальные транзакции позволяют работать с несколькими транзакционными ресурсами, обычно реляционные базы данных и очереди сообщений.
Сервер приложений управляет глобальным транзакции через JTA, который представляет собой громоздкий API (частично из-за его модель исключения).
Кроме того, JTA `UserTransaction` обычно должен быть получен из JNDI, что означает, что вам также необходимо использовать JNDI, чтобы использовать JTA.
Использование глобальных транзакций ограничивает любое потенциальное повторное использование кода приложения, поскольку JTA обычно доступен только в среде сервера приложений.
Глобальные транзакции.
Раньше предпочтительным способом использования глобальных транзакций было использование EJB CMT. (Транзакция, управляемая контейнером).
CMT — это форма декларативной транзакции. управление (в отличие от программного управления транзакциями).
ЭЖБ СМТ устраняет необходимость поиска JNDI, связанного с транзакциями, хотя использование EJB сам по себе требует использования JNDI.
Это устраняет большую часть, но не всю необходимость писать Java-код для управления транзакциями.
Существенным недостатком является то, что CMT привязан к JTA. и среда сервера приложений.

Кроме того, это доступно только в том случае, если вы решите реализовать бизнес-логику в EJB (или, по крайней мере, за транзакционным фасадом EJB).
Недостатки EJB в целом настолько велики, что это непривлекательное предложение, особенно перед лицом убедительных альтернатив декларативному управлению транзакциями.
Локальные транзакции зависят от ресурса, например транзакция, связанная с JDBC. соединение.
Локальные транзакции могут быть проще в использовании, но имеют существенный недостаток: Они не могут работать с несколькими транзакционными ресурсами.
Например, код, который управляет транзакции с использованием соединения JDBC не могут выполняться в рамках глобальной транзакции JTA.
Потому что сервер приложений не участвует в управлении транзакциями, он не может гарантировать корректность на нескольких ресурсах. (Следует отметить, что большинство приложений используют единый ресурс транзакции.) Еще одним недостатком является то, что локальные транзакции являются инвазивными. к модели программирования.
Согласованная модель программирования Spring Framework.
Spring устраняет недостатки глобальных и локальных транзакций.
Это позволяет разработчики приложений используют единую модель программирования в любой среде.
Вы пишете свой код один раз, и он может получить выгоду от другого управления транзакциями. стратегии в различных средах.
Spring Framework предоставляет как декларативные, так и программное управление транзакциями.
Большинство пользователей предпочитают декларативные транзакции управление, которое мы рекомендуем в большинстве случаев.
Согласованная модель программирования Spring Framework.
Благодаря программному управлению транзакциями разработчики работают с Spring Framework. абстракция транзакции, которая может работать над любой базовой инфраструктурой транзакций.

При использовании предпочтительной декларативной модели разработчики обычно пишут мало кода или вообще его не пишут. связаны с управлением транзакциями и, следовательно, не зависят от Spring Framework API транзакций или любой другой API транзакций.
Согласованная модель программирования Spring Framework. .Нужен ли вам сервер приложений для управления транзакциями? **** Поддержка управления транзакциями Spring Framework меняет традиционные правила относительно когда корпоративному Java-приложению требуется сервер приложений.
Согласованная модель программирования Spring Framework.
В частности, вам не нужен сервер приложений исключительно для декларативных транзакций. через EJB.
Фактически, даже если ваш сервер приложений обладает мощными возможностями JTA, вы можете решить, что декларативные транзакции Spring Framework предлагают больше возможностей и более продуктивная модель программирования, чем EJB CMT.
Согласованная модель программирования Spring Framework.
Обычно возможности JTA сервера приложений требуются только в том случае, если вашему приложению требуется обрабатывать транзакции между несколькими ресурсами, что не является обязательным для многих приложения.
Многие высокопроизводительные приложения используют одну хорошо масштабируемую базу данных (например, вместо этого Oracle RAC).
Автономные менеджеры транзакций (например, https://www.atomikos.com/[Atomikos Transactions]) есть другие варианты.
Конечно, вам могут понадобиться и другие возможности сервера приложений, например Служба сообщений Java (JMS) и архитектура соединителя Jakarta EE (JCA).
Согласованная модель программирования Spring Framework.
Spring Framework дает вам выбор, когда масштабировать приложение до полной загруженный сервер приложений.

Прошли те времена, когда единственной альтернативой использованию EJB CMT или JTA должны были писать код с локальными транзакциями (например, в соединениях JDBC). и вам придется серьезно переработать, если вам нужно, чтобы этот код выполнялся в глобальных, управляемых контейнером транзакции.
При использовании Spring Framework только некоторые определения компонентов в вашем необходимо изменить файл конфигурации (а не ваш код). ****

Многочастный контент.
Как объяснено в Multipart Data, `ServerWebExchange` обеспечивает доступ к составным данным. содержание.
Лучший способ обработки формы загрузки файла (например, из браузера) в контроллере осуществляется посредством привязки данных к файлу командный объект, как показано в следующем примере:
Java
	class MyForm {
		private String name;
		private FilePart file;
	@Controller
	public class FileUploadController {
		@PostMapping("/form")
		public String handleFormUpload(MyForm form, BindingResult errors) {
	@Controller
	class FileUploadController {
Многочастный контент.
Вы также можете отправлять составные запросы от клиентов, не являющихся браузерами, в службе RESTful. сценарий.
В следующем примере файл используется вместе с JSON:
POST /someUrl Content-Type: multipart/mixed. --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name="meta-data" Content-Type: application/json; charset=UTF-8 Content-Transfer-Encoding: 8bit
	"name": "value"
POST /someUrl Content-Type: multipart/mixed. } --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name="file-data"; filename="file.properties" Content-Type: text/xml Content-Transfer-Encoding: 8bit...
Данные файла...
POST /someUrl Content-Type: multipart/mixed.

Вы можете получить доступ к отдельным частям с помощью `@RequestPart`, как показано в следующем примере:
Java
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") Part metadata, // <1>
			@RequestPart("file-data") FilePart file) { // <2>
POST /someUrl Content-Type: multipart/mixed. <1> Использование `@RequestPart` для получения метаданных. <2> Использование `@RequestPart` для получения файла.
POST /someUrl Content-Type: multipart/mixed.
Чтобы десериализовать необработанное содержимое части (например, в JSON — аналогично `@RequestBody`), вы можете объявить конкретную цель «Объект» вместо «Часть», как показано в следующем примере:
Java
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") MetaData metadata) { // <1>
POST /someUrl Content-Type: multipart/mixed. <1> Использование `@RequestPart` для получения метаданных.
POST /someUrl Content-Type: multipart/mixed.
Вы можете использовать @RequestPart в сочетании с jakarta.validation.Valid или Spring.
Аннотация `@Validated`, которая вызывает применение стандартной проверки компонента.
Валидация ошибки приводят к возникновению исключения WebExchangeBindException, которое приводит к ответу 400 (BAD_REQUEST).

Исключение содержит BindingResult с подробностями об ошибке и также может быть обработано. в методе контроллера, объявив аргумент с асинхронной оболочкой, а затем используя Операторы, связанные с ошибками:
Java
	@PostMapping("/")
	public String handle(@Valid @RequestPart("meta-data") Mono<MetaData> metadata) {
		// используйте один из операторов onError*...
POST /someUrl Content-Type: multipart/mixed.
Если проверка метода применяется, поскольку другие параметры имеют аннотации @Constraint, тогда вместо этого возникает HandlerMethodValidationException.
См. раздел о
POST /someUrl Content-Type: multipart/mixed.
Чтобы получить доступ ко всем составным данным как к MultiValueMap, вы можете использовать @RequestBody, как показано в следующем примере:
Java
	@PostMapping("/")
	public String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { // <1>
POST /someUrl Content-Type: multipart/mixed. <1> Использование `@RequestBody`.
- Поля формы будут создавать *один* `FormPartEvent`, содержащий значение поля.
- Загрузка файлов будет создавать *один или несколько* объектов FilePartEvent, содержащих используемое имя файла.
`PartEvent`. при загрузке.
Если файл достаточно велик, чтобы его можно было разделить на несколько буферов, первый За FilePartEvent последуют последующие события.
`PartEvent`.

Например: См. пример кода в исходном документе.
`PartEvent`.
Полученные события детали также можно передать в другую службу с помощью WebClient.
См. ссылку:web/webflux-webclient/client-body.adoc#webflux-client-body-multipart [Multipart Data].

Асинхронные запросы.
Spring MVC имеет обширную интеграцию с асинхронным запросом сервлета.
* `DeferredResult`,
Асинхронные запросы. в методах контроллера обеспечивается поддержка одного асинхронного возвращаемого значения.
* Контроллеры могут использовать несколько значений, включая
* Контроллеры могут использовать реактивные клиенты и возвращать
Асинхронные запросы.
Обзор того, чем это отличается от Spring WebFlux, см. в разделе ниже.
`Отложенный результат`.
Как только функция асинхронной обработки запросов станет доступной. в контейнере сервлетов методы контроллера могут обертывать любой поддерживаемый метод контроллера. возвращаемое значение с помощью `DeferredResult`, как показано в следующем примере:
Java
	@GetMapping("/quotes")
	@ResponseBody
	public DeferredResult<String> quotes() {
		DeferredResult<String> deferredResult = new DeferredResult<>();
		// Сохраните где-нибудь отложенный результат.
		return deferredResult;
	// Из какой-то другой темы...
	deferredResult.setResult(result);
	// Из какой-то другой темы...
	deferredResult.setResult(result)
`Отложенный результат`.
Контроллер может выдавать возвращаемое значение асинхронно из другого потока — для например, в ответ на внешнее событие (сообщение JMS), запланированное задание или другое событие.
`Вызывной`.
Контроллер может обернуть любое поддерживаемое возвращаемое значение в `java.util.concurrent.Callable`, как показано в следующем примере:
Java
	@PostMapping

public Callable<String> processUpload(final MultipartFile file) {
		return () -> "someView";
`WebAsyncTask` можно сравнить с использованием Callable но позволяет настраивать дополнительные параметры, такие как значение тайм-аута запроса и `AsyncTaskExecutor` для выполнения `java.util.concurrent.Callable` вместо этого из значений по умолчанию, установленных глобально для Spring MVC.
Ниже приведен пример использования WebAsyncTask:
Java
	@GetMapping("/callable")
	WebAsyncTask<String> handle() {
		return new WebAsyncTask<String>(20000L,()->{
			Thread.sleep(10000); //simulate long-running task
			return "asynchronous request completed";
* ServletRequest можно перевести в асинхронный режим, вызвав request.startAsync().
Вот очень краткий обзор асинхронной обработки запросов сервлета:.
Основной эффект от этого заключается в том, что сервлет (как и любые фильтры) может выйти, но ответ остается открытым, чтобы обработка могла завершиться позже.
* Вызов `request.startAsync()` возвращает `AsyncContext`, который вы можете использовать для
Вот очень краткий обзор асинхронной обработки запросов сервлета:. дальнейший контроль над асинхронной обработкой.
Например, он предоставляет метод `dispatch`, который аналогичен пересылке из API сервлетов, за исключением того, что он позволяет обработка запроса на возобновление приложения в потоке контейнера сервлетов.

* ServletRequest предоставляет доступ к текущему DispatcherType, который вы можете
Вот очень краткий обзор асинхронной обработки запросов сервлета:. используйте, чтобы различать обработку первоначального запроса, асинхронную диспетчеризация, пересылка и другие типы диспетчеров.
* Контроллер возвращает DeferredResult и сохраняет его в памяти.
Обработка `DeferredResult` работает следующим образом:. очередь или список, где к нему можно получить доступ.
* Spring MVC вызывает `request.startAsync()`.
* При этом `DispatcherServlet` и все настроенные фильтры завершают запрос.
Обработка `DeferredResult` работает следующим образом:. поток обработки, но ответ остается открытым.
* Приложение устанавливает DeferredResult из какого-то потока, а Spring MVC
Обработка `DeferredResult` работает следующим образом:. отправляет запрос обратно в контейнер сервлетов.
* DispatcherServlet вызывается снова, и обработка возобновляется с
Обработка `DeferredResult` работает следующим образом:. асинхронно созданное возвращаемое значение.
* Контроллер возвращает Callable.
* Spring MVC вызывает `request.startAsync()` и отправляет `Callable` в
Обработка `Callable` работает следующим образом:. `AsyncTaskExecutor` для обработки в отдельном потоке.
* Тем временем, DispatcherServlet и все фильтры выходят из потока контейнера сервлетов,
Обработка `Callable` работает следующим образом:. но ответ остается открытым.
* В конце концов Callable выдает результат, и Spring MVC отправляет запрос обратно.

Обработка `Callable` работает следующим образом:. в контейнер сервлетов для завершения обработки.
* DispatcherServlet вызывается снова, и обработка возобновляется с
Обработка `Callable` работает следующим образом:. асинхронно созданное возвращаемое значение из Callable.
Обработка `Callable` работает следующим образом:.
Для получения дополнительной информации и контекста вы также можете прочитать {spring-site-blog}/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[the сообщения в блоге], которые представили поддержку асинхронной обработки запросов в Spring MVC 3.2.
Обработка исключений.
Когда вы используете DeferredResult, вы можете выбрать, вызывать ли setResult или `setErrorResult` с исключением.
В обоих случаях Spring MVC отправляет запрос обратно. в контейнер сервлетов для завершения обработки.
Тогда это рассматривается либо так, как если бы Метод контроллера вернул заданное значение или как если бы он вызвал данное исключение.
Затем исключение проходит через обычный механизм обработки исключений (например, вызов методы `@ExceptionHandler`).
Обработка исключений.
Когда вы используете `Callable`, происходит аналогичная логика обработки, основное отличие состоит в том, что результат возвращается из Callable или им создается исключение.
Перехват.
Экземпляры HandlerInterceptor могут иметь тип AsyncHandlerInterceptor, чтобы получать Обратный вызов afterConcurrentHandlingStarted для первоначального запроса, который запускается асинхронно. обработка (вместо postHandle и afterCompletion).
Перехват.

Реализации HandlerInterceptor также могут зарегистрировать CallableProcessingInterceptor. или DeferredResultProcessingInterceptor для более глубокой интеграции с жизненный цикл асинхронного запроса (например, для обработки события тайм-аута).
См. {spring-framework-api}/web/servlet/AsyncHandlerInterceptor.html[`AsyncHandlerInterceptor`] для более подробной информации.
Перехват.
DeferredResult предоставляет обратные вызовы onTimeout(Runnable) и onCompletion(Runnable).
См. {spring-framework-api}/web/context/request/async/DeferredResult.html[javadoc of `DeferredResult`] для более подробной информации. `Callable` можно заменить на `WebAsyncTask`, который предоставляет дополнительные методы для таймаута и обратных вызовов завершения.
Async Spring MVC по сравнению с WebFlux.
API сервлетов изначально был создан для выполнения одного прохода через Filter-Servlet. цепь.
Асинхронная обработка запросов позволяет приложениям выйти из цепочки Фильтр-сервлет. но оставьте ответ открытым для дальнейшей обработки.
Асинхронная поддержка Spring MVC построен вокруг этого механизма.
Когда контроллер возвращает DeferredResult, Цепочка фильтр-сервлет завершается, и поток контейнера сервлетов освобождается.
Позже, когда установлен `DeferredResult`, выполняется `ASYNC` отправка (на тот же URL-адрес), во время которой контроллер снова отображается, но вместо его вызова используется значение DeferredResult. (как если бы контроллер вернул его), чтобы возобновить обработку.
Async Spring MVC по сравнению с WebFlux.

Напротив, Spring WebFlux не построен на API сервлетов и не нуждается в таком интерфейсе. функция асинхронной обработки запросов, поскольку она асинхронна по своей конструкции.
Асинхронный обработка встроена во все фреймворковые контракты и поддерживается всеми этапы обработки запроса.
Async Spring MVC по сравнению с WebFlux.
С точки зрения модели программирования, Spring MVC и Spring WebFlux поддерживают асинхронный и в качестве возвращаемых значений в методах контроллера.
Spring MVC даже поддерживает потоковую передачу, включая реактивное обратное давление.
Однако отдельные записи в ответ остаются блокирующими (и выполняются в отдельном потоке), в отличие от WebFlux, который опирается на неблокирующий ввод-вывод и не требует дополнительного потока для каждой записи.
Async Spring MVC по сравнению с WebFlux.
Еще одно фундаментальное отличие состоит в том, что Spring MVC не поддерживает асинхронный или реактивный режим. типы аргументов метода контроллера (например, `@RequestBody`, `@RequestPart` и другие), и при этом он не имеет явной поддержки асинхронных и реактивных типов в качестве атрибутов модели.
Spring WebFlux все это поддерживает.
Async Spring MVC по сравнению с WebFlux.
Наконец, с точки зрения конфигурации должна быть реализована функция асинхронной обработки запросов.
HTTP-потоковая передача.
Вы можете использовать DeferredResult и Callable для одного асинхронного возвращаемого значения.
Что делать, если вы хотите создать несколько асинхронных значений и записать их в ответ?
В этом разделе описывается, как это сделать.
Объекты.

Вы можете использовать возвращаемое значение ResponseBodyEmitter для создания потока объектов, где каждый объект сериализуется с помощью ответ, как показано в следующем примере:
Java
	@GetMapping("/events")
	public ResponseBodyEmitter handle() {
		ResponseBodyEmitter emitter = new ResponseBodyEmitter();
		// Сохраните эмиттер куда-нибудь.
		return emitter;
	// В какой-то другой теме
	emitter.send("Hello once");
	// и еще раз позже
	emitter.send("Hello again");
	// и сделано в какой-то момент
	emitter.complete();
	// В какой-то другой теме
	emitter.send("Hello once")
	// и еще раз позже
	emitter.send("Hello again")
	// и сделано в какой-то момент
	emitter.complete()
Объекты.
Вы также можете использовать ResponseBodyEmitter в качестве тела ResponseEntity, что позволит вам настроить статус и заголовки ответа.
Объекты.
Когда «эмиттер» выдает «IOException» (например, если удаленный клиент ушел), приложения не несут ответственности за очистку соединения и не должны вызывать `emitter.complete` или `emitter.completeWithError`.
Вместо этого контейнер сервлетов автоматически инициирует Уведомление об ошибке AsyncListener, в котором Spring MVC выполняет вызов CompleteWithError.

Этот вызов, в свою очередь, выполняет заключительную отправку ASYNC приложению, во время которой Spring MVC вызывает настроенные преобразователи исключений и завершает запрос.
Объекты.
SseEmitter (подкласс ResponseBodyEmitter) обеспечивает поддержку https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events], где события, отправленные с сервера. форматируются в соответствии со спецификацией W3C SSE.
Для создания SSE поток от контроллера, верните SseEmitter, как показано в следующем примере:
Java
	@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)
	public SseEmitter handle() {
		SseEmitter emitter = new SseEmitter();
		// Сохраните эмиттер куда-нибудь.
		return emitter;
	// В какой-то другой теме
	emitter.send("Hello once");
	// и еще раз позже
	emitter.send("Hello again");
	// и сделано в какой-то момент
	emitter.complete();
	// В какой-то другой теме
	emitter.send("Hello once")
	// и еще раз позже
	emitter.send("Hello again")
	// и сделано в какой-то момент
	emitter.complete()
Объекты.
Хотя SSE является основным вариантом потоковой передачи в браузеры, обратите внимание, что Internet Explorer не поддерживает события, отправленные сервером.

Рассмотрите возможность использования Spring широкий выбор браузеров.
Объекты.
См. также ссылку:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-objects[предыдущий раздел] для получения примечаний по обработке исключений.
Необработанные данные.
Иногда полезно обойти преобразование сообщения и передать его непосредственно в ответ. `OutputStream` (например, для загрузки файла).
Вы можете использовать `StreamingResponseBody` для этого введите тип возвращаемого значения, как показано в следующем примере:
Java
	@GetMapping("/download")
	public StreamingResponseBody handle() {
		return new StreamingResponseBody() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				// писать...
Необработанные данные.
Вы можете использовать StreamingResponseBody в качестве тела в ResponseEntity для настроить статус и заголовки ответа.
Реактивные типы.
Spring MVC поддерживает использование реактивных клиентских библиотек в контроллере (также читайте Сюда входит «WebClient» из «spring-webflux» и другие, такие как Spring Data. реактивные хранилища данных.
В таких случаях удобно иметь возможность вернуть реактивные типы из метода контроллера.
* Промис с одним значением адаптирован, аналогично использованию DeferredResult. Примеры
Реактивные возвращаемые значения обрабатываются следующим образом:. включают CompletionStage (JDK), Mono (Reactor) и Single (RxJava).
* Многозначный поток с типом потокового мультимедиа (например, `application/x-ndjson`

Реактивные возвращаемые значения обрабатываются следующим образом:. или `text/event-stream`), аналогично использованию `ResponseBodyEmitter` или `SseEmitter`.
Примеры включают Flux (Reactor) или Observable (RxJava).
Приложения также могут возвращать Flux<ServerSentEvent> или Observable<ServerSentEvent>.
* Адаптирован многозначный поток с любым другим типом мультимедиа (например, application/json).
Реактивные возвращаемые значения обрабатываются следующим образом:. to, аналогично использованию `DeferredResult<List<?>>`.
Реактивные возвращаемые значения обрабатываются следующим образом:.
СОВЕТ: Spring MVC поддерживает Reactor и RxJava через {spring-framework-api}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`] из `spring-core`, который позволяет ему адаптироваться из нескольких реактивных библиотек.
Реактивные возвращаемые значения обрабатываются следующим образом:.
Для потоковой передачи в ответ поддерживается реактивное обратное давление, но запись в ответ все еще блокируется и запускается в отдельном потоке через `AsyncTaskExecutor`, чтобы избежать блокировки восходящего источника, такого как возвращаемый `Flux`. из `Вебклиента`.
Распространение контекста.
Обычно контекст передается через `java.lang.ThreadLocal`.
Это работает прозрачно для обработки в одном потоке, но требует дополнительной работы для асинхронной обработки в нескольких потоках.

Микрометр https://github.com/micrometer-metrics/context-propagation#context-propagation-library [Распространение контекста] библиотека упрощает распространение контекста между потоками и механизмами контекста, такими как как значения ThreadLocal, Реактор {реактор-сайт}/docs/core/release/reference/#context[context], GraphQL Java https://www.graphql-java.com/documentation/concerns/#context-objects[контекст], и другие.
Распространение контекста.
Если распространение контекста микрометра присутствует в пути к классам, когда метод контроллера возвращает [реактивный тип], например Flux или Mono, все Значения `ThreadLocal`, для которых есть зарегистрированный `io.micrometer.ThreadLocalAccessor`, записываются в Reactor `Context` как пары ключ-значение с использованием ключа, назначенного `ThreadLocalAccessor`.
Распространение контекста.
Для других сценариев асинхронной обработки вы можете использовать библиотеку распространения контекста. напрямую.
Например:
	// Захват оценок ThreadLocal из основного потока...
	ContextSnapshot snapshot = ContextSnapshot.captureAll();
	// В другом потоке: восстанавливаем значения ThreadLocal
	try (ContextSnapshot.Scope scope = snapshot.setThreadLocals()) {
* `LocaleContextThreadLocalAccessor` — распространяет `LocaleContext` через `LocaleContextHolder`
* `RequestAttributesThreadLocalAccessor` — передает `RequestAttributes` через `RequestContextHolder`
Следующие реализации ThreadLocalAccessor предоставляются «из коробки»:.
Вышеуказанное не регистрируется автоматически.

Вам необходимо зарегистрировать их через `ContextRegistry.getInstance()` при запуске.
Следующие реализации ThreadLocalAccessor предоставляются «из коробки»:.
Более подробную информацию можно найти в {micrometer-context-propagation-docs}/[документации] Библиотека распространения контекста Micrometer.
Отключает.
API сервлетов не отправляет никаких уведомлений при выходе удаленного клиента.
Поэтому при потоковой передаче ответа, будь то через SseEmitter или реактивные типы, важно периодически отправлять данные, поскольку запись не удалась, если клиент отключился.
Отправка может принимать форму пустое (только для комментариев) событие SSE или любые другие данные, которые другая сторона должна будет интерпретировать как сердцебиение и игнорировать.
Отключает.
В качестве альтернативы рассмотрите возможность использования решений для обмена веб-сообщениями (например, которые имеют встроенный механизм сердцебиения.
Конфигурация.
Функция асинхронной обработки запросов должна быть включена на уровне контейнера сервлетов.
Конфигурация MVC также предоставляет несколько вариантов асинхронных запросов.
Контейнер сервлетов.
Объявления фильтров и сервлетов имеют флаг asyncSupported, для которого необходимо установить значение true. чтобы включить асинхронную обработку запросов.
Кроме того, сопоставления фильтров должны быть объявлен для обработки ASYNC `jakarta.servlet.DispatchType`.
Контейнер сервлетов.
В конфигурации Java, когда вы используете «AbstractAnnotationConfigDispatcherServletInitializer» для инициализации контейнера сервлетов это делается автоматически.
Контейнер сервлетов.

В конфигурации `web.xml` вы можете добавить `<async-supported>true</async-supported>` к `DispatcherServlet` и `Filter` для объявлений и добавить `<dispatcher>ASYNC</dispatcher>` для фильтрации сопоставлений.
* Конфигурация Java: используйте обратный вызов configureAsyncSupport в WebMvcConfigurer.
* Пространство имен XML: используйте элемент `<async-support>` в `<mvc:annotation-driven>`.
* Значение таймаута по умолчанию для асинхронных запросов зависит
Вы можете настроить следующее:. в базовом контейнере сервлетов, если это не задано явно.
* `AsyncTaskExecutor` для блокировки записи при потоковой передаче с помощью
Вы можете настроить следующее:. выполнение экземпляров Callable, возвращаемых методами контроллера.
Тот, который используется по умолчанию, не подходит для производства под нагрузкой.
* Реализации `DeferredResultProcessingInterceptor` и `CallableProcessingInterceptor`.
Вы можете настроить следующее:.
Обратите внимание, что вы также можете установить значение таймаута по умолчанию для DeferredResult, ResponseBodyEmitter и SseEmitter.
Для Callable вы можете использовать `WebAsyncTask`, чтобы указать значение тайм-аута.

Реакции на ошибки.
Общим требованием к службам REST является включение подробностей в текст ошибки. ответы.
Spring Framework поддерживает «Подробности проблем для HTTP API». спецификация, {rfc-сайт}/rfc9457[RFC 9457].
- `ProblemDetail` — представление подробностей проблемы RFC 9457; простой контейнер
Ниже приведены основные абстракции для этой поддержки:. как для стандартных полей, определенных в спецификации, так и для нестандартных.
- `ErrorResponse` — контракт для предоставления подробностей ответа об ошибке HTTP, включая HTTP.
Ниже приведены основные абстракции для этой поддержки:. статус, заголовки ответа и тело в формате RFC 9457; это позволяет исключениям инкапсулировать и раскрывать подробности того, как они сопоставляются с ответом HTTP.
Все весенние MVC исключения реализуют это.
- `ErrorResponseException` -- базовая реализация `ErrorResponse`, которую другие
Ниже приведены основные абстракции для этой поддержки:. можно использовать как удобный базовый класс.
- `ResponseEntityExceptionHandler` -- удобный базовый класс для
Ниже приведены основные абстракции для этой поддержки:. и любое `ErrorResponseException` и отображает ответ об ошибке с телом.
Рендеринг.
Вы можете вернуть «ProblemDetail» или «ErrorResponse» из любого «@ExceptionHandler» или из любой метод @RequestMapping для обработки ответа RFC 9457.
Это обрабатывается следующим образом:
- Свойство `status` `ProblemDetail` определяет статус HTTP.

- Свойство `instance` для `ProblemDetail` устанавливается на основе текущего URL-пути, если это не так.
Рендеринг. уже установлен.
- Кодеки Jackson JSON и XML используют «application/problem+json» или
Рендеринг. «application/problem+xml» соответственно в качестве типов воспроизводимых носителей для «ProblemDetail». чтобы гарантировать, что им будет отдано предпочтение при обсуждении содержания.
Рендеринг.
Чтобы включить ответы RFC 9457 для исключений Spring MVC и для любых `ErrorResponseException`, расширьте `ResponseEntityExceptionHandler` и объявите его как имеет метод @ExceptionHandler, который обрабатывает любое исключение ErrorResponse, которое включает все встроенные веб-исключения.
Вы можете добавить больше методов обработки исключений и используйте защищенный метод для сопоставления любого исключения с «ProblemDetail».
Рендеринг.
Вы можете зарегистрировать перехватчики `ErrorResponse` через любой ответ RFC 9457 и предпримите какие-либо действия.
Нестандартные поля.
Вы можете расширить ответ RFC 9457 нестандартными полями одним из двух способов.
Нестандартные поля.
Во-первых, вставьте в «свойства» «Карту» «ProblemDetail».
При использовании Джексона библиотека, Spring Framework регистрирует `ProblemDetailJacksonMixin`, который обеспечивает это «Свойства» `Карта` разворачивается и отображается как свойства JSON верхнего уровня в ответ, и аналогично любое неизвестное свойство во время десериализации вставляется в эта `Карта`.
Нестандартные поля.
Вы также можете расширить «ProblemDetail», чтобы добавить специальные нестандартные свойства.

Конструктор копирования в «ProblemDetail» позволяет упростить создание подкласса. из существующего «ProblemDetail».
Это можно сделать централизованно, например, из `@ControllerAdvice`, например `ResponseEntityExceptionHandler`, который воссоздает `ProblemDetail` исключения в подкласс с дополнительными нестандартными полями.
Нестандартные поля.
СОВЕТ: В Spring Boot свойство Spring.mvc.problemdetails.enabled настраивается автоматически. `ResponseEntityExceptionHandler`, который обрабатывает встроенные исключения с подробностями проблемы.
В этом случае вы можете предпочесть создать еще один `@ControllerAdvice` вместо расширения `ResponseEntityExceptionHandler`, если вы хотите взять на себя обработку определенного встроенное исключение.
Вам необходимо убедиться, что ваш обработчик заказан раньше, чем тот, который настроенный Spring Boot, порядок которого равен 0.
Кастомизация и i18n.
Общепринятым требованием является настройка и интернационализация сведений об ошибках.
Также рекомендуется настроить сведения о проблеме для исключений Spring MVC. чтобы не раскрывать детали реализации.
В этом разделе описывается поддержка этого.
Кастомизация и i18n. `ErrorResponse` предоставляет коды сообщения для «типа», «заголовка» и «детали», а также Аргументы кода сообщения для поля «подробности». `ResponseEntityExceptionHandler` разрешает это через MessageSource и соответствующим образом обновляет соответствующие поля «ProblemDetail».
* "type": `problemDetail.type.[полное имя класса исключения]`
* "title": `problemDetail.title.[полное имя класса исключения]`

* "detail": `problemDetail.[полное имя класса исключения][суффикс]`
Стратегия по умолчанию для кодов сообщений следующая:. `ErrorResponse` может предоставлять более одного кода сообщения, обычно с добавлением суффикса. к коду сообщения по умолчанию.
В таблице ниже перечислены коды сообщений и аргументы для Исключения Spring MVC:
Стратегия по умолчанию для кодов сообщений следующая:. [cols="1,1,2", options="header"] |=== | Исключение | Код сообщения | Аргументы кода сообщения
| `AsyncRequestTimeoutException` | (по умолчанию). | `ConversionNotSupportedException` | (по умолчанию) | `+{0}+` имя свойства, `+{1}+` значение свойства
| `AsyncRequestTimeoutException` | (по умолчанию). | `HandlerMethodValidationException` | (по умолчанию) | `+{0}+` выводит список всех ошибок проверки.
Коды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.
| `AsyncRequestTimeoutException` | (по умолчанию). | `HttpMediaTypeNotAcceptableException` | (по умолчанию) | `+{0}+` список поддерживаемых типов мультимедиа

| `HttpMediaTypeNotAcceptableException` | (по умолчанию) + «.parseError». | `HttpMediaTypeNotSupportedException` | (по умолчанию) | `+{0}+` тип носителя, который не поддерживается, `+{1}+` список поддерживаемых типов мультимедиа
| `HttpMessageNotWritableException` | (по умолчанию). | `HttpRequestMethodNotSupportedException` | (по умолчанию) | `+{0}+` текущий метод HTTP, `+{1}+` список поддерживаемых методов HTTP
| `HttpMessageNotWritableException` | (по умолчанию). | `MethodArgumentNotValidException` | (по умолчанию) | `+{0}+` список глобальных ошибок, `+{1}+` список ошибок полей.
Коды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.
| `NoHandlerFoundException` | (по умолчанию). | `NoResourceFoundException` | (по умолчанию) | `+{0}+` путь запроса (или его часть), используемый для поиска ресурса
| `NoHandlerFoundException` | (по умолчанию). | `TypeMismatchException` | (по умолчанию) | `+{0}+` имя свойства, `+{1}+` значение свойства, `+{2}+` простое имя требуемого типа
| `UnsatisfiedServletRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра.
ПРИМЕЧАНИЕ.

В отличие от других исключений, аргументы сообщения для `MethodArgumentNotValidException` и `HandlerMethodValidationException` основаны на списке Ошибки MessageSourceResolvable, которые также можно настроить с помощью пакет ресурсов.
См. для более подробной информации.
Обработка клиентов.
Клиентское приложение может перехватить исключение WebClientResponseException при использовании WebClient. или RestClientResponseException при использовании RestTemplate и используйте их `getResponseBodyAs` для декодирования тела ответа об ошибке в любой целевой тип, например `ProblemDetail` или подкласс `ProblemDetail`.

HTTP-кэширование может значительно повысить производительность веб-приложения.
HTTP-кэширование вращается вокруг заголовка ответа Cache-Control и, следовательно, условного запроса. заголовки (такие как Last-Modified и ETag). `Cache-Control` советует приватное (например, браузер) и публичные (например, прокси) кэши о том, как кэшировать и повторно использовать ответы.
Используется заголовок `ETag`. сделать условный запрос, который может привести к 304 (NOT_MODIFIED) без тела, если содержимое не изменилось. `ETag` можно рассматривать как более продвинутого преемника заголовок «Last-Modified».
HTTP-кэширование.
В этом разделе описаны параметры, связанные с HTTP-кэшированием, доступные в Spring Web MVC.
`КэшКонтроль`. {spring-framework-api}/http/CacheControl.html[`CacheControl`] обеспечивает поддержку настройка параметров, связанных с заголовком Cache-Control и принимаемых в качестве аргумента в ряде мест:
* {spring-framework-api}/web/servlet/mvc/WebContentInterceptor.html[`WebContentInterceptor`]
* {spring-framework-api}/web/servlet/support/WebContentGenerator.html[`WebContentGenerator`]
* Контроллеры
* Статические ресурсы
`КэшКонтроль`.

Хотя {rfc-site}/rfc7234#section-5.2.2[RFC 7234] описывает все возможные директивы для заголовка ответа Cache-Control, тип CacheControl принимает используйте подход, ориентированный на конкретные случаи, который фокусируется на общих сценариях:
Java
	// Кэш на час - "Cache-Control: max-age=3600"
	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);
	// Запретить кеширование — «Cache-Control: no-store»
	CacheControl ccNoStore = CacheControl.noStore();
	// Кэш на десять дней в публичных и частных тайниках,
	// публичные кэши не должны трансформировать ответ
	// «Cache-Control: max-age=864000, общедоступный, без преобразования»
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
`КэшКонтроль`. `WebContentGenerator` также принимает более простое свойство `cachePeriod` (определяемое в секундах), которое работает следующим образом:
* Значение `-1` не генерирует заголовок ответа `Cache-Control`.
* Значение «0» предотвращает кэширование с помощью директивы «Cache-Control: no-store».
* Значение `n > 0` кэширует данный ответ на `n` секунд с помощью
`КэшКонтроль`.

Директива `'Cache-Control: max-age=n'`.
Контроллеры могут добавлять явную поддержку HTTP-кэширования.
Мы рекомендовали это сделать, поскольку Значение `lastModified` или `ETag` для ресурса необходимо вычислить, прежде чем его можно будет сравнить. против заголовков условных запросов.
Контроллер может добавить заголовок ETag и Cache-Control. настройки на `ResponseEntity`, как показано в следующем примере:
Java
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {
		Book book = findBook(id);
		String version = book.getVersion();
		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // также доступен LastModified
				.body(book);
		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // также доступен LastModified
				.body(book)
Контроллеры.
В предыдущем примере отправляется ответ 304 (NOT_MODIFIED) с пустым телом, если сравнение к заголовкам условного запроса указывает, что содержимое не изменилось.
В противном случае К ответу добавляются заголовки `ETag` и `Cache-Control`.
Контроллеры.
Вы также можете проверить заголовки условных запросов в контроллере, как показано в следующем примере:
Java
	@RequestMapping

public String myHandleMethod(WebRequest request, Model model) {
		long eTag = ... // <1>
		if (request.checkNotModified(eTag)) {
			return null; // <2>
		model.addAttribute(...); // <3>
		return "myViewName";
Контроллеры. <1> Расчет для конкретного приложения. <2> Ответу присвоено значение 304 (NOT_MODIFIED) – дальнейшей обработки не требуется. <3> Продолжить обработку запроса.
		if (request.checkNotModified(eTag)) {
			return null // <2>
		model[...] = ... // <3>
		return "myViewName"
Контроллеры. <1> Расчет для конкретного приложения. <2> Ответу присвоено значение 304 (NOT_MODIFIED) – дальнейшей обработки не требуется. <3> Продолжить обработку запроса.
Контроллеры.
Существует три варианта проверки условных запросов на соответствие значениям eTag:lastModified. ценности, или и то, и другое.
Для условных запросов GET и HEAD вы можете установить ответ на 304 (НЕ_МОДИФИЦИРОВАНО).
Для условных POST, PUT и DELETE вы можете вместо этого установить ответ до 412 (PRECONDITION_FAILED), чтобы предотвратить одновременное изменение.
Статические ресурсы.
Вы должны обслуживать статические ресурсы с помощью Cache-Control и заголовков условного ответа. для оптимальной производительности.
См. раздел о настройке Статические ресурсы.
Фильтр `ETag`.

Вы можете использовать ShallowEtagHeaderFilter, чтобы добавить «поверхностные» значения eTag, вычисленные на основе содержимое ответа и, таким образом, экономить пропускную способность, но не время процессора.
См. ссылку:web/webmvc/filters.adoc#filters-shallow-etag[Shallow ETag].

Конфигурация MVC Java и пространство имен MVC XML предоставляют конфигурацию по умолчанию. подходит для большинства приложений и API конфигурации для его настройки.
Конфигурация MVC.
Для более сложных настроек, которые недоступны в API конфигурации, см.
Расширенная конфигурация Java и Расширенная конфигурация XML.
Конфигурация MVC.
Вам не нужно понимать базовые bean-компоненты, созданные конфигурацией Java MVC. и пространство имен MVC.
Если вы хотите узнать больше, см.
Специальные типы компонентов. и Web MVC Config.

Аннотированные контроллеры.
Spring MVC предоставляет модель программирования на основе аннотаций, в которой `@Controller` и Компоненты `@RestController` используют аннотации для выражения сопоставления запросов, ввода запроса, обработка исключений и многое другое.
Аннотированные контроллеры имеют гибкие сигнатуры методов и не нужно расширять базовые классы или реализовывать определенные интерфейсы.
В следующем примере показан контроллер, определенный аннотациями:
Java
	@Controller
	public class HelloController {
		@GetMapping("/hello")
		public String handle(Model model) {
			model.addAttribute("message", "Hello World!");
			return "index";
	@Controller
	class HelloController {
Аннотированные контроллеры.
В предыдущем примере метод принимает «Модель» и возвращает имя представления в виде «Строка». но существует множество других вариантов, которые будут объяснены позже в этой главе.
Аннотированные контроллеры.
СОВЕТ: Руководства и учебные пособия на сайте {spring-site-guides}[spring.io] используют основанную на аннотациях модель программирования, описанная в этом разделе.

HTTP/2.
Контейнеры Servlet 4 необходимы для поддержки HTTP/2, а Spring Framework требует API сервлетов 6.1.
С точки зрения модели программирования нет ничего конкретного, что приложения нужно делать.
Однако есть соображения, связанные с конфигурацией сервера.
Более подробную информацию см. {spring-framework-wiki}/HTTP-2-support[вики-страница HTTP/2].

Запросы диапазона.
Spring MVC поддерживает https://datatracker.ietf.org/doc/html/rfc9110#section-14[RFC 9110] запросы диапазона.
Для обзора см. https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests[Запросы рейнджеров] Руководство по Мозилле.
Запросы диапазона.
Заголовок Range анализируется и прозрачно обрабатывается в Spring MVC, когда аннотированный контроллер возвращает Resource или ResponseEntity<Resource> или функциональную конечную точку. поддержка также прозрачно обрабатывается при обслуживании
Запросы диапазона.
СОВЕТ: «Ресурс» не должен быть «InputStreamResource» и с «ResponseEntity<Resource>», статус ответа должен быть 200.
Запросы диапазона.
Базовая поддержка находится в классе HttpRange, который предоставляет методы для анализа. заголовки Range и разделить Resource на List<ResourceRegion>, который, в свою очередь, может быть затем записывается в ответ через ResourceRegionHttpMessageConverter.

Веб-безопасность.
Проект {spring-site-projects}/spring-security[Spring Security] обеспечивает поддержку. для защиты веб-приложений от вредоносных эксплойтов.
См. весеннюю безопасность справочная документация, в том числе:
* {docs-spring-security}/servlet/integrations/mvc.html [Spring MVC Security]
* {docs-spring-security}/servlet/test/mockmvc/setup.html [Поддержка тестирования Spring MVC]
* {docs-spring-security}/features/exploits/csrf.html#csrf-protection [защита CSRF]
* {docs-spring-security}/features/exploits/headers.html[Заголовки ответов безопасности]
Веб-безопасность. https://github.com/hdiv/hdiv[HDIV] — еще одна платформа веб-безопасности, интегрируемая с Spring MVC.

Диспетчерсервлет.
Spring MVC, как и многие другие веб-фреймворки, построен на основе фронт-контроллера. шаблон, в котором центральный сервлет, DispatcherServlet, предоставляет общий алгоритм для обработки запросов, в то время как фактическую работу выполняют настраиваемые компоненты делегата.
Эта модель является гибкой и поддерживает разнообразные рабочие процессы.
Диспетчерсервлет.
DispatcherServlet, как и любой другой сервлет, необходимо объявить и сопоставить в соответствии с в спецификацию сервлета, используя конфигурацию Java или в `web.xml`.
В свою очередь, DispatcherServlet использует конфигурацию Spring для обнаружения компоненты делегата, необходимые для сопоставления запросов, разрешения представлений, исключений обработка, ссылка:web/webmvc/mvc-servlet/special-bean-types.adoc[и многое другое].
Диспетчерсервлет.
В следующем примере показана программная регистрация и инициализация `DispatcherServlet`, который автоматически обнаруживается контейнером сервлетов (см. ссылку:web/webmvc/mvc-servlet/container-config.adoc [Servlet Config]), а также эквивалент `web.xml`: См. пример кода в исходном документе.
Диспетчерсервлет.
ПРИМЕЧАНИЕ.
Помимо прямого использования API ServletContext, вы также можете расширить `AbstractAnnotationConfigDispatcherServletInitializer` и переопределить определенные методы (см. пример в разделе «Иерархия контекста»).
Диспетчерсервлет.
ПРИМЕЧАНИЕ.
В случаях программного использования GenericWebApplicationContext можно использовать в качестве альтернатива AnnotationConfigWebApplicationContext.

См. {spring-framework-api}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`] javadoc для получения подробной информации.
Диспетчерсервлет.
ПРИМЕЧАНИЕ.
Spring Boot использует другую последовательность инициализации.
Вместо того, чтобы подключиться к жизненный цикл контейнера сервлетов, Spring Boot использует конфигурацию Spring для сам загрузчик и встроенный контейнер сервлетов.
Объявления `Filter` и `Servlet` обнаруживаются в конфигурации Spring и регистрируются в контейнере сервлетов.
Более подробную информацию см. {spring-boot-docs-ref}/web/servlet.html#web.servlet.embedded-container [документация Spring Boot].

URI-ссылки.
В этом разделе описаны различные параметры, доступные в Spring Framework для работы с URI.
Относительные запросы сервлетов.
Вы можете использовать ServletUriComponentsBuilder для создания URI относительно текущего запроса. как показано в следующем примере:
Java
	HttpServletRequest request = ...
	// Повторно использует схему, хост, порт, путь и строку запроса...
	URI uri = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}")
			.build("123");
	// Повторно использует схему, хост, порт, путь и строку запроса...
Относительные запросы сервлетов.
Вы можете создавать URI относительно контекстного пути, как показано в следующем примере:
Java
	HttpServletRequest request = ...
	// Повторно использует схему, хост, порт и контекстный путь...
	URI uri = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts")
			.build()
			.toUri();
	// Повторно использует схему, хост, порт и контекстный путь...
Относительные запросы сервлетов.
Вы можете создавать URI относительно сервлета (например, `/main/{asterisk}`), как показано в следующем примере:
Java
	HttpServletRequest request = ...
	// Повторно использует схему, хост, порт, контекстный путь и префикс сопоставления сервлетов...
	URI uri = ServletUriComponentsBuilder.fromServletMapping(request)

.path("/accounts")
			.build()
			.toUri();
	// Повторно использует схему, хост, порт, контекстный путь и префикс сопоставления сервлетов...
Относительные запросы сервлетов.
ПРИМЕЧАНИЕ.
Начиная с версии 5.1, ServletUriComponentsBuilder игнорирует информацию из Forwarded и Заголовки `X-Forwarded-*`, которые указывают адрес, исходящий от клиента.
Рассмотрите возможность использования такие заголовки.
Ссылки на контроллеры.
Spring MVC предоставляет механизм подготовки ссылок на методы контроллера.
Например, следующий контроллер MVC позволяет создавать ссылки:
Java
	@Controller
	@RequestMapping("/hotels/{hotel}")
	public class BookingController {
		@GetMapping("/bookings/{booking}")
		public ModelAndView getBooking(@PathVariable Long booking) {
	@Controller
	@RequestMapping("/hotels/{hotel}")
	class BookingController {
Ссылки на контроллеры.
Вы можете подготовить ссылку, ссылаясь на метод по имени, как показано в следующем примере:
Java
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);
	URI uri = uriComponents.encode().toUri();
Ссылки на контроллеры.
В предыдущем примере мы предоставляем фактические значения аргументов метода (в данном случае длинное значение: `21`). для использования в качестве переменной пути и вставки в URL-адрес.

Кроме того, мы предоставляем значение `42`, чтобы заполнить все оставшиеся переменные URI, такие как унаследованная переменная `hotel`. из сопоставления запросов на уровне типа.
Если бы у метода было больше аргументов, мы могли бы указать значение null для аргументы не нужны для URL.
Обычно используются только аргументы `@PathVariable` и `@RequestParam`. имеют отношение к построению URL.
Ссылки на контроллеры.
Существуют дополнительные способы использования MvcUriComponentsBuilder.
Например, вы можете использовать технику похоже на макетное тестирование через прокси, чтобы избежать обращения к методу контроллера по имени, как показано в следующем примере. (в примере предполагается статический импорт MvcUriComponentsBuilder.on):
Java
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);
	URI uri = uriComponents.encode().toUri();
Ссылки на контроллеры.
ПРИМЕЧАНИЕ.
Сигнатуры методов контроллера ограничены по своей конструкции, если предполагается, что их можно использовать для создание ссылки с помощью fromMethodCall.
Помимо необходимости правильной подписи параметра, существует техническое ограничение на тип возвращаемого значения (а именно, создание прокси-сервера времени выполнения для вызовов компоновщика ссылок), поэтому тип возвращаемого значения не должен быть `final`.
В частности, общий тип возврата `String` для имен представлений здесь не работает.

Вы должны использовать ModelAndView. или даже вместо этого простой `Object` (с возвращаемым значением `String`).
Ссылки на контроллеры.
В предыдущих примерах используются статические методы в MvcUriComponentsBuilder.
Внутренне они полагаются в `ServletUriComponentsBuilder`, чтобы подготовить базовый URL-адрес из схемы, хоста, порта, контекстный путь и путь сервлета текущего запроса.
В большинстве случаев это работает хорошо.
Однако иногда этого может быть недостаточно.
Например, вы можете находиться вне контекста запрос (например, пакетный процесс подготовки ссылок) или, возможно, вам нужно вставить путь префикс (например, префикс локали, который был удален из пути запроса и должен быть повторно вставлен в ссылки).
Ссылки на контроллеры.
В таких случаях вы можете использовать статические перегруженные методы fromXxx, которые принимают `UriComponentsBuilder` для использования базового URL-адреса.
Альтернативно вы можете создать экземпляр MvcUriComponentsBuilder. с базовым URL-адресом, а затем использовать методы withXxx на основе экземпляра.
Например, в следующем листинге используется withMethodCall:
Java
	UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
	MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
	builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);
	URI uri = uriComponents.encode().toUri();
Ссылки на контроллеры.
ПРИМЕЧАНИЕ.

Начиная с версии 5.1, MvcUriComponentsBuilder игнорирует информацию из Заголовки `X-Forwarded-*`, которые указывают адрес, исходящий от клиента.
Рассмотрите возможность использования такие заголовки.
Ссылки в представлениях.
В таких представлениях, как Thymeleaf, FreeMarker или JSP, вы можете создавать ссылки на аннотированные контроллеры. путем ссылки на неявно или явно назначенное имя для каждого сопоставления запроса.
Java
	@RequestMapping("/people/{id}/addresses")
	public class PersonAddressController {
		@RequestMapping("/{country}")
		public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }
	@RequestMapping("/people/{id}/addresses")
	class PersonAddressController {
Рассмотрим следующий пример:.
Учитывая предыдущий контроллер, вы можете подготовить ссылку из JSP следующим образом:
Рассмотрим следующий пример:. <%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>... <a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}">Get Address</a>
Рассмотрим следующий пример:.

Предыдущий пример основан на функции mvcUrl, объявленной в библиотеке тегов Spring. (то есть META-INF/spring.tld), но можно легко определить собственную функцию или подготовить аналогичный для других технологий шаблонов.
Рассмотрим следующий пример:.
Вот как это работает.
При запуске каждому `@RequestMapping` присваивается имя по умолчанию. через HandlerMethodMappingNamingStrategy, реализация которого по умолчанию использует заглавные буквы класса и имени метода (например, метод getThing в `ThingController` становится "TC#getThing").
Если есть конфликт имен, вы можете использовать `@RequestMapping(name="..")`, чтобы назначить явное имя или реализовать свое собственное `HandlerMethodMappingNamingStrategy`.

Обзор.
Почему был создан Spring WebFlux?
Обзор.
Частично ответ заключается в необходимости неблокирующего веб-стека для обработки параллелизма с помощью небольшое количество потоков и масштабирование с меньшим количеством аппаратных ресурсов.
Неблокирующий ввод-вывод сервлетов уводит от остальной части API сервлетов, где контракты синхронны («Фильтр», «Сервлет») или блокировку («getParameter», «getPart»).
Это была мотивация для нового общего API, который будет служить основой для любой неблокирующей среды выполнения.
Это важно, поскольку серверы (такие как Netty) хорошо зарекомендовали себя в асинхронном режиме, неблокирующее пространство.
Обзор.
Другая часть ответа — функциональное программирование.
Примерно так же, как добавление аннотаций в Java 5 появились возможности (такие как аннотированные контроллеры REST или модульные тесты), добавление лямбда-выражений в Java 8 создало возможности для функциональных API в Java.
Это благо для неблокирующих приложений и API-интерфейсов продолжения (популяризированных от `CompletableFuture` и https://reactivex.io/[ReactiveX]), которые допускают декларативный состав асинхронной логики.
На уровне модели программирования Java 8 поддерживает Spring.
WebFlux предлагает функциональные конечные веб-точки наряду с аннотированными контроллерами.
Дайте определение «реактивному».
Мы затронули понятия «неблокирующий» и «функциональный», но что означает реактивный?
Дайте определение «реактивному».

Термин «реактивный» относится к моделям программирования, построенным на реагировании на изменения. сетевые компоненты, реагирующие на события ввода-вывода, контроллеры пользовательского интерфейса, реагирующие на события мыши, и другие.
В этом смысле неблокировка является реактивной, потому что вместо того, чтобы быть заблокированными, мы теперь находимся в режиме реагирования на уведомления по мере завершения операций или доступности данных.
Дайте определение «реактивному».
Есть еще один важный механизм, который мы в команде Spring связываем с «реактивным». и это неблокирующее противодавление.
В синхронном императивном коде блокировка вызовов служат естественной формой обратного давления, которая заставляет звонящего ждать.
В неблокирующем режиме кода становится важным контролировать скорость событий, чтобы быстрый производитель не превзойти пункт назначения.
Дайте определение «реактивному».
Реактивные потоки — это {reactive-streams-spec}[маленькая спецификация] (также {java-api}/java.base/java/util/concurrent/Flow.html [принято] в Java 9) который определяет взаимодействие асинхронных компонентов с противодавлением.

Например, хранилище данных (действующее как {reactive-streams-site}/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html[Publisher]) может генерировать данные, которые HTTP-сервер (действуя как {reactive-streams-site}/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html[Подписчик]) потом могу написать в ответ.
Основная цель Reactive Streams — позволить подписчик контролирует, насколько быстро или медленно издатель создает данные.
Дайте определение «реактивному».
ПРИМЕЧАНИЕ. *Общий вопрос: что, если издатель не может замедлить работу?* + Целью Reactive Streams является лишь установление механизма и границ.
Если издатель не может замедлить работу, он должен решить, следует ли буферизовать, удалить или потерпеть неудачу.
Реактивный API.
Reactive Streams играет важную роль в обеспечении совместимости.
Представляет интерес для библиотек. и компоненты инфраструктуры, но менее полезен в качестве API приложения, поскольку он слишком низкоуровневый.
Приложениям необходим высокоуровневый и более богатый функциональный API для составить асинхронную логику — аналогично API Stream в Java 8, но не только для коллекций.
Именно эту роль играют реактивные библиотеки.
Реактивный API. {reactor-github-org}/reactor[Reactor] — реактивная библиотека, которую выбирают для Весенний вебфлюкс.

Он обеспечивает {reactor-site}/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] и {reactor-site}/docs/core/release/api/reactor/core/publisher/Flux.html[`Flux`] Типы API работать с последовательностями данных 0..1 («Моно») и 0..N («Поток») с помощью богатого набора операторов, согласованных с ReactiveX https://reactivex.io/documentation/operators.html[словарь операторов].
Reactor — это библиотека Reactive Streams, поэтому все ее операторы поддерживают неблокирующее обратное давление.
Reactor уделяет большое внимание серверной Java.
Он разработан в тесном сотрудничестве с Spring.
Реактивный API.
WebFlux требует Reactor в качестве основной зависимости, но он совместим с другими реактивными библиотеки через Reactive Streams.
Как правило, API WebFlux принимает простой `Publisher`. в качестве входных данных, внутренне адаптирует его к типу Reactor, использует его и возвращает либо «Flux» или «Mono» в качестве выхода.
Итак, вы можете передать в качестве входных данных любого «Издателя» и применить операции над выводом, но вам необходимо адаптировать вывод для использования с другой реактивной библиотекой.
Всякий раз, когда это возможно (например, аннотированные контроллеры), WebFlux прозрачно адаптируется к использованию RxJava или другой реактивной библиотеки.

Дополнительную информацию см. в Реактивные библиотеки.
Модели программирования.
Модуль Spring-Web содержит реактивную основу, лежащую в основе Spring WebFlux. включая абстракции HTTP, Reactive Streams [адаптеры] для поддерживаемых серверов: web/webflux/reactive-spring.adoc#webflux-codecs[кодеки] и ядро API сервлетов, но с неблокирующими контрактами.
Модели программирования.
Исходя из этого, Spring WebFlux предоставляет на выбор две модели программирования:
* Аннотированные контроллеры: соответствует Spring MVC и основано на
Модели программирования. те же аннотации из модуля Spring-Web.
Контроллеры Spring MVC и WebFlux поддерживают реактивную (Reactor и RxJava), поэтому отличить их друг от друга непросто.
Один примечательный разница в том, что WebFlux также поддерживает реактивные аргументы @RequestBody.
* Функциональные конечные точки: облегченный, основанный на лямбде,
Модели программирования. и модель функционального программирования.
Вы можете думать об этом как о небольшой библиотеке или наборе утилиты, которые приложение может использовать для маршрутизации и обработки запросов.
Большая разница с аннотированными контроллерами заключается в том, что приложение отвечает за обработку запросов. от начала до конца вместо объявления о намерении посредством аннотаций и обратного вызова.
Применимость.
Spring MVC или WebFlux?
Применимость.
Естественный вопрос, но он создает необоснованную дихотомию.
На самом деле, оба Работайте вместе, чтобы расширить диапазон доступных опций.

Оба предназначены для преемственность и согласованность друг с другом, они доступны бок о бок, и обратная связь с каждой стороны выгоды обеим сторонам.
На следующей диаграмме показано, как эти два понятия связаны, что они имеют общее и что каждый поддерживает уникально:
* Если у вас есть приложение Spring MVC, которое работает нормально, вносить изменения не нужно.
Мы предлагаем вам обратить внимание на следующие конкретные моменты:.
Императивное программирование — это самый простой способ писать, понимать и отлаживать код.
У вас максимальный выбор библиотек, поскольку исторически большинство из них блокируются.
* Если вы уже покупаете неблокирующий веб-стек, Spring WebFlux предлагает то же самое.
Мы предлагаем вам обратить внимание на следующие конкретные моменты:.
Модель выполнения имеет преимущества, как и другие в этой области, а также обеспечивает выбор серверов. (контейнеры Netty, Tomcat, Jetty и Servlet), выбор моделей программирования. (аннотированные контроллеры и функциональные веб-конечные точки), а также выбор реактивных библиотек. (Reactor, RxJava или другое).
* В микросервисной архитектуре вы можете использовать сочетание приложений с Spring MVC.
Мы предлагаем вам обратить внимание на следующие конкретные моменты:. или контроллеры Spring WebFlux или с функциональными конечными точками Spring WebFlux.
Имея поддержку для одной и той же модели программирования на основе аннотаций в обеих средах упрощает повторно использовать знания, одновременно выбирая правильный инструмент для правильной работы.

* Простой способ оценить приложение — проверить его зависимости. Если у вас есть блокировка
Мы предлагаем вам обратить внимание на следующие конкретные моменты:.
API сохранения (JPA, JDBC) или сетевые API, Spring MVC — лучший выбор. по крайней мере, для обычных архитектур.
Технически это осуществимо как с Reactor, так и с RxJava для выполнения блокирующих вызовов в отдельном потоке, но вы не будете выполнять большая часть неблокирующего веб-стека.
* Если у вас есть приложение Spring MVC с вызовами удаленных сервисов, попробуйте реактивный `WebClient`.
Мы предлагаем вам обратить внимание на следующие конкретные моменты:.
Вы можете возвращать реактивные типы (Reactor, RxJava, или другие). непосредственно из методов контроллера Spring MVC.
Чем больше задержка на вызов или взаимозависимость между вызовами, тем более существенными будут преимущества.
Spring MVC-контроллеры может вызывать и другие реактивные компоненты.
* Если у вас большая команда, имейте в виду, что переход на неблокирующую технологию потребует сложного обучения.
Мы предлагаем вам обратить внимание на следующие конкретные моменты:. функциональное и декларативное программирование.
Практичный способ запуска без полного переключения заключается в использовании реактивного `WebClient`.
Помимо этого, начните с малого и оцените выгоды.
Мы ожидаем, что для широкого спектра приложений в этом сдвиге нет необходимости.

Если вы не знаете, какие преимущества искать, начните с изучения того, как работает неблокирующий ввод-вывод (например, параллелизм в однопоточном Node.js) и его последствия.
Серверы.
Spring WebFlux поддерживается в контейнерах Tomcat, Jetty, Servlet, а также в среды выполнения, не относящиеся к сервлетам, такие как Netty.
Все сервера адаптированы под низкоуровневый,
Серверы.
Spring WebFlux не имеет встроенной поддержки запуска или остановки сервера.
Однако это легко собрать приложение из конфигурации Spring и строки кода.
Серверы.
Spring Boot имеет стартер WebFlux, который автоматизирует эти шаги.
По умолчанию стартер использует Netty, но можно легко переключиться на Tomcat или Jetty, изменив Зависимости Maven или Gradle.
Spring Boot по умолчанию использует Netty, поскольку он более широко распространен. используется в асинхронном, неблокирующем пространстве и позволяет клиенту и серверу совместно использовать ресурсы.
Серверы.
Tomcat и Jetty можно использовать как с Spring MVC, так и с WebFlux.
Имейте в виду, однако, что способы их использования очень разные.
Spring MVC полагается на блокировку ввода-вывода сервлетов и позволяет приложениям использовать API сервлетов напрямую, если им это необходимо.
Весенний WebFlux опирается на неблокирующий ввод-вывод сервлетов и использует API сервлетов за низкоуровневым адаптер.
Он не предназначен для прямого использования.
Серверы.
ПРИМЕЧАНИЕ.
Настоятельно рекомендуется не сопоставлять фильтры сервлетов или напрямую манипулировать API сервлетов в контексте приложения WebFlux.

По причинам, перечисленным выше, сочетание блокирующего и неблокирующего ввода-вывода в одном контексте приведет к проблемам во время выполнения.
Производительность имеет множество характеристик и значений.
Реактивный и неблокирующий в целом не заставляйте приложения работать быстрее.
В некоторых случаях они могут – например, при использовании `WebClient` для параллельного выполнения удаленных вызовов.
Однако для этого требуется больше работы все происходит неблокирующим способом, и это может немного увеличить необходимое время обработки.
Производительность.
Ключевым ожидаемым преимуществом реактивного и неблокирующего подхода является возможность масштабирования с небольшими затратами. фиксированное количество потоков и меньше памяти.
Это делает приложения более устойчивыми под нагрузкой, потому что они масштабируются более предсказуемо.
Однако для того, чтобы воспользоваться этими преимуществами, вам должна иметь некоторую задержку (включая сочетание медленного и непредсказуемого сетевого ввода-вывода).
Именно здесь реактивный стек начинает проявлять свои сильные стороны, и различия могут быть очевидны. драматичный.
Модель параллелизма.
И Spring MVC, и Spring WebFlux поддерживают аннотированные контроллеры, но есть ключевой момент: разница в модели параллелизма и предположениях по умолчанию для блокировки и потоков.
Модель параллелизма.
В Spring MVC (и сервлет-приложениях в целом) предполагается, что приложения могут заблокировать текущий поток (например, для удаленных вызовов).
По этой причине контейнеры сервлетов используйте большой пул потоков для устранения потенциальной блокировки во время обработки запроса.
Модель параллелизма.

В Spring WebFlux (и неблокирующих серверах в целом) предполагается, что приложения не блокируйте.
Поэтому неблокирующие серверы используют небольшой пул потоков фиксированного размера. (работники цикла событий) для обработки запросов.
Модель параллелизма.
СОВЕТ: «Масштабирование» и «малое количество потоков» могут показаться противоречивыми, но никогда не блокируйте текущий поток (и вместо этого полагаться на обратные вызовы) означает, что вам не нужны дополнительные потоки, поскольку нет никаких блокирующих вызовов, которые нужно поглотить.
Вызов API блокировки.
Что делать, если вам нужно использовать библиотеку блокировки?
И Reactor, и RxJava предоставляют Оператор `publishOn` для продолжения обработки в другом потоке.
Это означает, что существует удобный аварийный люк.
Однако имейте в виду, что блокирующие API не подходят для эта модель параллелизма.
Изменяемое состояние.
В Reactor и RxJava вы объявляете логику через операторы.
Во время выполнения реактивный формируется конвейер, в котором данные обрабатываются последовательно, на отдельных этапах.
Ключевое преимущество заключается в том, что он освобождает приложения от необходимости защищать изменяемое состояние, поскольку код приложения в этом конвейере никогда не вызывается одновременно.
Модель резьбы.
Какие потоки следует ожидать на сервере, работающем под управлением Spring WebFlux?
* На «ванильном» сервере Spring WebFlux (например, без доступа к данным или других дополнительных опций).

Модель резьбы. зависимости), вы можете ожидать один поток для сервера и несколько других для запроса. обработки (обычно столько же, сколько ядер ЦП).
Однако контейнеры сервлетов может начинаться с большего количества потоков (например, 10 на Tomcat) для поддержки как сервлетного (блокирующего) ввода-вывода и использование сервлета 3.1 (неблокирующего) ввода-вывода.
* Реактивный `WebClient` работает в стиле цикла событий. Таким образом, вы можете увидеть небольшой фиксированный
Модель резьбы. количество связанных с этим потоков обработки (например, `reactor-http-nio-` с Reactor Разъем Netty).
Однако если Reactor Netty используется как для клиента, так и для сервера, оба по умолчанию совместно использовать ресурсы цикла событий.
* Reactor и RxJava предоставляют абстракции пула потоков, называемые планировщиками, для использования с
Модель резьбы.
Оператор «publishOn», который используется для переключения обработки на другой пул потоков.
Планировщики имеют имена, предполагающие конкретную стратегию параллелизма, например «параллельный». (для работы с привязкой к ЦП и ограниченным количеством потоков) или «эластичный» (для работы с привязкой к вводу/выводу с большое количество потоков).
Если вы видите такие потоки, это означает, что какой-то код использует конкретная стратегия «Планировщика» пула потоков.
* Библиотеки доступа к данным и другие сторонние зависимости также могут создавать и использовать потоки.
Модель резьбы. свои собственные.

Настройка.
Spring Framework не обеспечивает поддержку запуска и остановки. вам необходимо использовать API-интерфейсы конфигурации для конкретного сервера или, если вы используете Spring Boot, проверьте параметры конфигурации Spring Boot для каждого сервера.
Вы можете Для всех остальных библиотек смотрите соответствующую документацию.

Нулевая безопасность.
Хотя Java пока не позволяет выражать маркеры нулевого значения с помощью своей системы типов, кодовая база Spring Framework снабжен аннотациями https://jspecify.dev/docs/start-here/[JSpecify], чтобы объявить об отсутствии значений своих API, поля и использование связанных типов.
Чтение https://jspecify.dev/docs/user-guide/[руководства пользователя JSpecify] очень важно. рекомендуется для ознакомления с этими аннотациями и семантикой.
Аннотирование библиотек с помощью аннотаций JSpecify.
Начиная с Spring Framework 7, кодовая база Spring Framework использует аннотации JSpecify для предоставления нулевых API-интерфейсов. и проверить согласованность этих объявлений об отсутствии значений с помощью https://github.com/uber/NullAway[NullAway] как часть его сборки.
Рекомендуется для каждой библиотеки в зависимости от проектов Spring Framework и портфолио Spring. а также другие библиотеки, связанные с экосистемой Spring (проекты сообщества Reactor, Micrometer и Spring), сделать то же самое.
Использование аннотаций JSpecify в приложениях Spring.
При желании разработчики приложений Spring могут аннотировать свою кодовую базу и использовать плагины сборки, такие как https://github.com/uber/NullAway[NullAway] для обеспечения нулевой безопасности на уровне приложения во время сборки.
Рекомендации.
Цель этого раздела — поделиться некоторыми предлагаемыми рекомендациями по явному указанию возможности обнуления.
Библиотеки или приложения, связанные с Spring.
По умолчанию ненулевое значение.

Ключевым моментом, который следует понимать, является то, что нулевые типы типов по умолчанию неизвестны в Java, и что использование ненулевых типов встречается гораздо чаще, чем использование с нулевым значением.
Чтобы сохранить читабельность кодовой базы, мы обычно хотим определить по умолчанию использование этого типа не равно нулю, если оно не помечено как допускающее значение NULL для определенной области.
Это именно цель https://jspecify.dev/docs/api/org/jspecify/annotations/NullMarked.html[`@NullMarked`], который обычно устанавливается в проектах Spring на уровне пакета через файл package-info.java, например:
Явная возможность обнуления.
В коде `@NullMarked` использование типа, допускающего значение NULL, определяется явно с помощью https://jspecify.dev/docs/api/org/jspecify/annotations/Nullable.html[`@Nullable`].
Явная возможность обнуления.
Ключевое различие между аннотациями JSpecify `@Nullable`/`@NonNull` и большинством других вариантов заключается в том, что JSpecify annotations are meta-annotated with `@Target(ElementType.TYPE_USE)`, so they apply only to type usage.

Это влияет где такие аннотации должны быть размещены, либо для соблюдения https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4 [связанные спецификации Java] или следовать коду лучшие практики стиля.
С точки зрения стиля рекомендуется учитывать характер использования типов этих аннотаций. помещая их на той же строке, что и аннотированный тип, и непосредственно перед ним.
                                     @Nullable Throwable cause) {
public @Nullable String buildMessage(@Nullable String message,. [ПРИМЕЧАНИЕ] = При переопределении метода аннотации JSpecify не наследуются от оригинала. метод.
Это означает, что аннотации JSpecify должны быть скопированы в переопределяющий метод, если вы хотите переопределить реализацию и сохранить ту же семантику обнуления.
public @Nullable String buildMessage(@Nullable String message,. https://jspecify.dev/docs/api/org/jspecify/annotations/NonNull.html[`@NonNull`] и https://jspecify.dev/docs/api/org/jspecify/annotations/NullUnmarked.html[`@NullUnmarked`] редко требуется для типичные случаи использования.
Массивы и варарги.
При работе с массивами и переменными аргументами вам необходимо уметь отличать нулевое значение элементов от нулевого значения. сам массив.

Обратите внимание на синтаксис https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4 [определено спецификацией Java], что может быть изначально удивительно.
Например, в коде @NullMarked:
- `@Nullable Object[] array` означает, что отдельные элементы могут быть `null`, но сам массив не может.
- `Object @Nullable [] array` означает, что отдельные элементы не могут быть `null`, но сам массив может иметь значение null.
- `@Nullable Object @Nullable [] array` означает, что как отдельные элементы, так и массив могут быть `null`.
 - `List<String>` означает список ненулевых элементов (эквивалент `List<@NonNull String>`)
 - `List<@Nullable String>` означает список элементов, допускающих значение NULL.
Аннотации JSpecify также применимы к дженерикам.
Например, в коде @NullMarked:.
Все немного сложнее, когда вы объявляете универсальные типы или универсальные методы.
См. соответствующие https://jspecify.dev/docs/user-guide/#generics [документация по дженерикам JSpecify] для получения более подробной информации.
Аннотации JSpecify также применимы к дженерикам.
Например, в коде @NullMarked:.

ВНИМАНИЕ: Обнуляемость универсальных типов и универсальных методов. https://github.com/uber/NullAway/issues?q=is%3Aissue+is%3Aopen+label%3Ajspecify [NullAway еще не полностью поддерживает].
Вложенные и полностью определенные типы.
Спецификация Java также требует, чтобы аннотации, определенные с помощью `@Target(ElementType.TYPE_USE)` – например, JSpecify Аннотация `@Nullable` – должна быть объявлена после последней точки (`.`) во внутренних или полных именах типов:
- `Cache.@Nullable ValueWrapper`
- `jakarta.validation.@Nullable Validator`
 - `NullAway:OnlyNullMarked=true` для выполнения проверок на обнуляемость только для пакетов, помеченных `@NullMarked`.
 - `NullAway:CustomContractAnnotations=org.springframework.lang.Contract`, который сообщает NullAway о
Рекомендуемая конфигурация:. аннотация {spring-framework-api}/lang/Contract.html[@Contract] в пакете `org.springframework.lang`, которая может использоваться для выражения дополнительной семантики, чтобы избежать ненужных предупреждений в вашей кодовой базе.
Рекомендуемая конфигурация:.

Хороший пример преимуществ декларации `@Contract` можно увидеть с помощью {spring-framework-api}/util/Assert.html#notNull(java.lang.Object,java.lang.String)[`Assert.notNull()`] который помечен `@Contract("null, _ -> error")`.
Благодаря этому заявлению о контракте NullAway поймет что значение, переданное в качестве параметра, не может быть нулевым после успешного вызова Assert.notNull().
Рекомендуемая конфигурация:.
При желании можно установить NullAway:JSpecifyMode=true, чтобы включить https://github.com/uber/NullAway/wiki/JSpecify-Support [проверяет полную семантику JSpecify], включая аннотации к массивы, varargs и дженерики.
Имейте в виду, что этот режим https://github.com/uber/NullAway/issues?q=is%3Aissue+is%3Aopen+label%3Ajspecify[все еще в разработке] и требует JDK 22 или новее (обычно в сочетании с флагом компилятора Java `--release` для настройки ожидаемый базовый уровень).
Рекомендуется включать режим JSpecify только на втором этапе, после того как убедитесь, что кодовая база не генерирует никаких предупреждений при рекомендуемой конфигурации, упомянутой ранее в этом разделе.
Подавление предупреждений.
Существует несколько допустимых случаев использования, когда NullAway неправильно обнаруживает проблемы с обнулением.

В таких случаях рекомендуется отключить соответствующие предупреждения и задокументировать причину:
 - `@SuppressWarnings("NullAway.Init")` на уровне поля, конструктора или класса можно использовать, чтобы избежать ненужных предупреждений.
Подавление предупреждений. из-за ленивой инициализации полей – например, из-за реализации класса {spring-framework-api}/beans/factory/InitializingBean.html[`InitializingBean`].
 - `@SuppressWarnings("NullAway") // Ограничение анализа потока данных` может использоваться, когда анализ потока данных NullAway не используется.
Подавление предупреждений. способен обнаружить, что путь, включающий проблему обнуления, никогда не произойдет.
 - `@SuppressWarnings("NullAway") // Lambda` может использоваться, когда NullAway не учитывает выполненные утверждения
Подавление предупреждений. вне лямбды для пути кода внутри лямбды.
- `@SuppressWarnings("NullAway") // Reflection` может использоваться для некоторых операций отражения, которые, как известно, возвращают
Подавление предупреждений. ненулевые значения, даже если они не могут быть выражены API.
- `@SuppressWarnings("NullAway") // Хорошо известные ключи карты` могут использоваться, когда вызовы `Map#get` выполняются с помощью ключей
Подавление предупреждений. которые, как известно, присутствуют, и когда ранее были вставлены ненулевые связанные значения.

- `@SuppressWarnings("NullAway") // Переопределенный метод не определяет допустимость значений NULL` может использоваться, когда суперкласс это делает
Подавление предупреждений. не определять допустимость значений NULL (обычно, когда суперкласс возникает из внешней зависимости).
- `@SuppressWarnings("NullAway") // См. https://github.com/uber/NullAway/issues/1075` можно использовать, когда NullAway не может обнаружить ненулевое значение переменной типа в универсальных методах.
Миграция с аннотаций нулевой безопасности Spring.
Ключевое отличие состоит в том, что устаревшие аннотации Spring с нулевой безопасностью, которые соответствуют семантике JSR 305, применяются к полям, параметры и возвращаемые значения; в то время как аннотации JSpecify применяются к использованию типов.
Эта тонкая разница на практике очень важно, поскольку позволяет разработчикам различать нулевое значение элементов и нулевое значение массивов/varargs, а также для определения нулевого значения универсальных типов.
Миграция с аннотаций нулевой безопасности Spring.
Это означает, что объявления нулевой безопасности массива и varargs должны быть обновлены, чтобы сохранить ту же семантику.
Например `@Nullable Object[] array` с аннотациями Spring необходимо изменить на `Object @Nullable[] array` с помощью JSpecify аннотации.
То же самое относится и к varargs.
Миграция с аннотаций нулевой безопасности Spring.
Также рекомендуется переместить аннотации полей и возвращаемых значений ближе к типу и на одной строке, например:

- Для полей вместо `@Nullable Private String Field` с аннотациями Spring используйте `private @Nullable String Field`.
Миграция с аннотаций нулевой безопасности Spring. с аннотациями JSpecify.
- Для типов возвращаемых методов вместо `@Nullable public String Method()` с аннотациями Spring используйте
Миграция с аннотаций нулевой безопасности Spring. `public @Nullable String метод()` с аннотациями JSpecify.
Миграция с аннотаций нулевой безопасности Spring.
Кроме того, с помощью JSpecify вам не нужно указывать @NonNull при переопределении использования типа, аннотированного с помощью @Nullable. в методе super, чтобы «отменить» объявление, допускающее значение NULL, в коде, помеченном нулем.
Просто объявите его без аннотаций, и Будут применяться значения по умолчанию, помеченные нулевым значением (использование типа считается ненулевым, если явно не указано, что оно допускает значение NULL).

Моделирование операций JDBC как объектов Java.
Пакет `org.springframework.jdbc.object` содержит классы, которые позволяют вам получить доступ к базу данных более объектно-ориентированным способом.
В качестве примера вы можете запускать запросы и получить результаты обратно в виде списка, содержащего бизнес-объекты с реляционной данные столбца, сопоставленные со свойствами бизнес-объекта.
Вы также можете запустить сохраненный процедуры и запускать операторы обновления, удаления и вставки.
Моделирование операций JDBC как объектов Java. [ПРИМЕЧАНИЕ] = Многие разработчики Spring считают, что различные классы операций РСУБД, описанные ниже, (за исключением класса `StoredProcedure`) часто может быть заменены прямыми вызовами `JdbcTemplate`.
Зачастую проще написать DAO метод, который вызывает метод JdbcTemplate напрямую (в отличие от инкапсуляция запроса как полноценный класс).
Моделирование операций JDBC как объектов Java.
Однако если вы получаете измеримую пользу от использования классов операций РСУБД, вам следует продолжать использовать эти классы.
Понимание `SqlQuery`. `SqlQuery` — это многоразовый, потокобезопасный класс, инкапсулирующий SQL-запрос.
Подклассы должен реализовать метод newRowMapper(..)`, чтобы предоставить экземпляр RowMapper, который может создавать по одному объекту для каждой строки, полученной в результате итерации по созданному `ResultSet` во время выполнения запроса.
Класс SqlQuery редко используется напрямую, поскольку подкласс MappingSqlQuery обеспечивает гораздо более удобную реализацию для сопоставление строк с классами Java.

Другие реализации, расширяющие `SqlQuery`: MappingSqlQueryWithParameters и UpdatableSqlQuery.
Использование MappingSqlQuery.
MappingSqlQuery — это запрос многократного использования, в котором конкретные подклассы должны реализовать абстрактный метод `mapRow(..)` для преобразования каждой строки предоставленного `ResultSet` в объект указанного типа.
В следующем примере показан пользовательский запрос, который сопоставляет данные из отношения t_actor к экземпляру класса Actor:
Java
	public class ActorMappingQuery extends MappingSqlQuery<Actor> {
		public ActorMappingQuery(DataSource ds) {
			super(ds, "select id, first_name, last_name from t_actor where id = ?");
			declareParameter(new SqlParameter("id", Types.INTEGER));
			compile();
		@Override
		protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {
			Actor actor = new Actor();
			actor.setId(rs.getLong("id"));
			actor.setFirstName(rs.getString("first_name"));
			actor.setLastName(rs.getString("last_name"));
			return actor;
		init {
			declareParameter(SqlParameter("id", Types.INTEGER))
			compile()
Использование MappingSqlQuery.
Класс расширяет MappingSqlQuery, параметризованный типом Actor.
Конструктор для этого запроса клиента единственным параметром является DataSource.
В этом конструктор, вы можете вызвать конструктор суперкласса с помощью DataSource и SQL который следует запустить для получения строк для этого запроса.

Этот SQL используется для создайте `PreparedStatement`, чтобы он мог содержать заполнители для любых параметров, которые будут передано во время исполнения.
Вы должны объявить каждый параметр, используя `declareParameter` метод передачи `SqlParameter`. `SqlParameter` принимает имя и тип JDBC. как определено в `java.sql.Types`.
После определения всех параметров вы можете вызвать `compile()`, чтобы оператор мог быть подготовлен и позже запущен.
Этот класс потокобезопасен после компиляции, поэтому, пока эти экземпляры создаются, когда DAO инициализируется, их можно сохранить как переменные экземпляра и использовать повторно.
Следующие пример показывает, как определить такой класс:
Java
	private ActorMappingQuery actorMappingQuery;
	@Autowired
	public void setDataSource(DataSource dataSource) {
		this.actorMappingQuery = new ActorMappingQuery(dataSource);
	public Actor getActor(Long id) {
		return actorMappingQuery.findObject(id);
Использование MappingSqlQuery.
Метод в предыдущем примере извлекает актера с идентификатором, который передается в качестве единственный параметр.
Поскольку мы хотим, чтобы возвращался только один объект, мы вызываем функцию findObject. метод с `id` в качестве параметра.
Если бы вместо этого у нас был запрос, возвращающий список объектов и взяли дополнительные параметры, мы бы использовали один из `execute` методы, которые принимают массив значений параметров, передаваемых как переменные аргументы.
Следующие пример показывает такой метод:
Java

public List<Actor> searchForActors(int age, String namePattern) {
		return actorSearchMappingQuery.execute(age, namePattern);
Использование `SqlUpdate`.
Класс SqlUpdate инкапсулирует обновление SQL.
Как и в случае с запросом, объект обновления можно использовать повторно, и, как и все классы RdbmsOperation, обновление может иметь параметры и определено в SQL.
Этот класс предоставляет ряд методов `update(..)`, аналогичных методу `execute(..)` методы объектов запроса.
Класс SqlUpdate является конкретным.
Это может быть подклассы — например, чтобы добавить собственный метод обновления.
Однако вам не обязательно создавать подкласс SqlUpdate. класс, поскольку его можно легко параметризовать, задав SQL и объявив параметры.
В следующем примере создается пользовательский метод обновления с именем «execute»:
Java
	import java.sql.Types;
	import javax.sql.DataSource;
	import org.springframework.jdbc.core.SqlParameter;
	import org.springframework.jdbc.object.SqlUpdate;
	public class UpdateCreditRating extends SqlUpdate {
		public UpdateCreditRating(DataSource ds) {
			setDataSource(ds);
			setSql("update customer set credit_rating = ? where id = ?");
			declareParameter(new SqlParameter("creditRating", Types.NUMERIC));
			declareParameter(new SqlParameter("id", Types.NUMERIC));
			compile();
		 * @param идентификатор Клиента, который будет обновлен.

* @param rating the new value for credit rating
		 * @return number of rows updated
		public int execute(int id, int rating) {
			return update(rating, id);
		init {
			setDataSource(ds)
			sql = "update customer set credit_rating = ? where id = ?"
			declareParameter(SqlParameter("creditRating", Types.NUMERIC))
			declareParameter(SqlParameter("id", Types.NUMERIC))
			compile()
Использование StoredProcedure.
Класс StoredProcedure — это «абстрактный» суперкласс для абстракций объектов СУБД. хранимые процедуры.
Использование StoredProcedure.
Унаследованное свойство sql — это имя хранимой процедуры в СУБД.
Использование StoredProcedure.
Чтобы определить параметр для класса StoredProcedure, вы можете использовать SqlParameter или один своих подклассов.
В конструкторе необходимо указать имя параметра и тип SQL, как показано в следующем фрагменте кода:
Java
	new SqlParameter("in_id", Types.NUMERIC),
	new SqlOutParameter("out_first_name", Types.VARCHAR),
	SqlParameter("in_id", Types.NUMERIC),
	SqlOutParameter("out_first_name", Types.VARCHAR),
Использование StoredProcedure.
Тип SQL указывается с помощью констант java.sql.Types.
Использование StoredProcedure.
Первая строка (с `SqlParameter`) объявляет параметр IN.

Вы можете использовать параметры IN как для вызовов хранимых процедур, так и для запросов с использованием `SqlQuery` и его подклассы (описаны в документе Понимание `SqlQuery`).
Использование StoredProcedure.
Вторая строка (с `SqlOutParameter`) объявляет параметр `out`, который будет использоваться в вызов хранимой процедуры.
Существует также SqlInOutParameter для параметров InOut. (параметры, которые передают процедуре значение in и которые также возвращают значение).
Использование StoredProcedure.
Для параметров `in` помимо имени и типа SQL можно указать масштаб для числовых данных или имя типа для пользовательских типов баз данных.
Для параметров `out`, вы можете предоставить RowMapper для обработки сопоставления строк, возвращаемых курсором REF.
Другой вариант — указать SqlReturnType, который позволит вам определять индивидуальные обработка возвращаемых значений.
Использование StoredProcedure.
Следующий пример простого DAO использует StoredProcedure для вызова функции. (`sysdate()`), который поставляется с любой базой данных Oracle.
Использование хранимой процедуры функциональность, вам необходимо создать класс, расширяющий `StoredProcedure`.
В этом Например, класс StoredProcedure является внутренним классом.
Однако если вам необходимо повторно использовать `StoredProcedure`, вы можете объявить его как класс верхнего уровня.
В этом примере нет входных данных параметры, но выходной параметр объявляется как тип даты с помощью Класс SqlOutParameter.
Метод `execute()` запускает процедуру и извлекает возвращенная дата из результатов `Карта`.

В «Карте» результатов есть запись для каждого объявленного выходной параметр (в данном случае только один), используя имя параметра в качестве ключа.
В следующем листинге показан наш собственный класс StoredProcedure:
Java
	import java.sql.Types;
	import java.util.Date;
	import java.util.HashMap;
	import java.util.Map;
	import javax.sql.DataSource;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.SqlOutParameter;
	import org.springframework.jdbc.object.StoredProcedure;
	public class StoredProcedureDao {
		private GetSysdateProcedure getSysdate;
		@Autowired
		public void init(DataSource dataSource) {
			this.getSysdate = new GetSysdateProcedure(dataSource);
		public Date getSysdate() {
			return getSysdate.execute();
		private class GetSysdateProcedure extends StoredProcedure {
			private static final String SQL = "sysdate";
			public GetSysdateProcedure(DataSource dataSource) {
				setDataSource(dataSource);
				setFunction(true);
				setSql(SQL);
				declareParameter(new SqlOutParameter("date", Types.DATE));
				compile();
			public Date execute() {
				// процедура 'sysdate' не имеет входных параметров, поэтому остается пустая карта...
				Map<String, Object> results = execute(new HashMap<String, Object>());

Date sysdate = (Date) results.get("date");
				return sysdate;
	class StoredProcedureDao(dataSource: DataSource) {
			init {
				setDataSource(dataSource)
				isFunction = true
				sql = SQL
				declareParameter(SqlOutParameter("date", Types.DATE))
				compile()
Использование StoredProcedure.
Следующий пример StoredProcedure имеет два выходных параметра (в данном случае: Курсоры Oracle REF):
Java
	import java.util.HashMap;
	import java.util.Map;
	import javax.sql.DataSource;
	import oracle.jdbc.OracleTypes;
	import org.springframework.jdbc.core.SqlOutParameter;
	import org.springframework.jdbc.object.StoredProcedure;
	public class TitlesAndGenresStoredProcedure extends StoredProcedure {
		private static final String SPROC_NAME = "AllTitlesAndGenres";
		public TitlesAndGenresStoredProcedure(DataSource dataSource) {
			super(dataSource, SPROC_NAME);
			declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
			declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
			compile();
		public Map<String, Object> execute() {
			// опять же, у этой процедуры нет входных параметров, поэтому предоставляется пустая карта
			return super.execute(new HashMap<String, Object>());
		init {

declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
			declareParameter(SqlOutParameter("genres", OracleTypes.CURSOR, GenreMapper()))
			compile()
Использование StoredProcedure.
Обратите внимание, как перегруженные варианты метода DeclareParameter(..)`, которые были используемые в конструкторе TitlesAndGenresStoredProcedure, передаются RowMapper. экземпляры реализации.
Это очень удобный и мощный способ повторного использования существующих функциональность.
Следующие два примера предоставляют код для двух реализаций RowMapper.
Использование StoredProcedure.
Класс TitleMapper сопоставляет ResultSet с объектом домена Title для каждой строки в предоставленный `ResultSet`, как показано ниже:
Java
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import com.foo.domain.Title;
	import org.springframework.jdbc.core.RowMapper;
	public final class TitleMapper implements RowMapper<Title> {
		public Title mapRow(ResultSet rs, int rowNum) throws SQLException {
			Title title = new Title();
			title.setId(rs.getLong("id"));
			title.setName(rs.getString("name"));
			return title;
	class TitleMapper : RowMapper<Title> {
Использование StoredProcedure.
Класс GenreMapper сопоставляет ResultSet с объектом домена Genre для каждой строки в предоставленный `ResultSet`, как показано ниже:
Java
	import java.sql.ResultSet;
	import java.sql.SQLException;

import com.foo.domain.Genre;
	import org.springframework.jdbc.core.RowMapper;
	public final class GenreMapper implements RowMapper<Genre> {
		public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {
			return new Genre(rs.getString("name"));
	class GenreMapper : RowMapper<Genre> {
Использование StoredProcedure.
Чтобы передать параметры хранимой процедуре, которая имеет один или несколько входных параметров в своей определения в СУБД, вы можете запрограммировать строго типизированный метод `execute(..)`, который бы делегируйте нетипизированный метод `execute(Map)` в суперклассе, как показано в следующем примере:
Java
	import java.sql.Types;
	import java.util.Date;
	import java.util.HashMap;
	import java.util.Map;
	import javax.sql.DataSource;
	import oracle.jdbc.OracleTypes;
	import org.springframework.jdbc.core.SqlOutParameter;
	import org.springframework.jdbc.core.SqlParameter;
	import org.springframework.jdbc.object.StoredProcedure;
	public class TitlesAfterDateStoredProcedure extends StoredProcedure {
		private static final String SPROC_NAME = "TitlesAfterDate";
		private static final String CUTOFF_DATE_PARAM = "cutoffDate";
		public TitlesAfterDateStoredProcedure(DataSource dataSource) {
			super(dataSource, SPROC_NAME);
			declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);

declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
			compile();
		public Map<String, Object> execute(Date cutoffDate) {
			Map<String, Object> inputs = new HashMap<String, Object>();
			inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
			return super.execute(inputs);
		init {
			declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types.DATE))
			declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
			compile()

Оператор Элвиса (`?:`) является сокращением синтаксиса троичного оператора и используется в язык https://www.groovy-lang.org/operators.html#_elvis_operator[Groovy].
С синтаксис тернарного оператора, вам часто приходится повторять переменную дважды, как в следующем примере Java: пример показывает:
	String name = "Elvis Presley";
	String displayName = (name != null ? name : "Unknown");
Оператор Элвиса.
Вместо этого вы можете использовать оператор Элвиса (названный в честь сходства с прической Элвиса).
В следующем примере показано, как использовать оператор Элвиса в выражении SpEL:
Java
	ExpressionParser parser = new SpelExpressionParser();
	String name = parser.parseExpression("name ?: 'Unknown'").getValue(new Inventor(), String.class);
	System.out.println(name);  // 'Unknown'
Оператор Элвиса. [ПРИМЕЧАНИЕ] = Оператор SpEL Elvis также рассматривает _пустую_ строку как нулевой объект.
Таким образом, исходный пример Java лишь близок к эмуляции семантики оператора: он бы необходимо использовать `name!= null &&!name.isEmpty()` в качестве предиката для совместимости с семантика оператора SpEL Элвиса.
Оператор Элвиса. [СОВЕТ] = Начиная с Spring Framework 7.0, оператор SpEL Elvis поддерживает java.util.Optional с прозрачная семантика развертывания.
Оператор Элвиса.

Например, учитывая выражение `A?: B`, если `A` имеет значение null или _empty_ `Optional`, выражение оценивается как `B`.
Однако, если `A` является непустым `Необязательным`, выражение оценивает объект, содержащийся в `Optional`, тем самым эффективно разворачивая `Необязательный`, который соответствует `A.get()`.
Java
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
	String name = parser.parseExpression("name ?: 'Elvis Presley'").getValue(context, tesla, String.class);
	System.out.println(name);  // Nikola Tesla
	tesla.setName("");
	name = parser.parseExpression("name ?: 'Elvis Presley'").getValue(context, tesla, String.class);
	System.out.println(name);  // Elvis Presley
В следующем листинге показан более сложный пример:. [СОВЕТ] = Вы можете использовать оператор Элвиса для применения значений по умолчанию в выражениях.
Следующие пример показывает, как использовать оператор Элвиса в выражении @Value:
	@Value("#{systemProperties['pop3.port'] ?: 25}")

В следующем листинге показан более сложный пример:.
Это внедрит значение системного свойства с именем pop3.port, если оно определено или `25`, если свойство не определено.

Оператор безопасной навигации (`?.`) используется, чтобы избежать `NullPointerException` и появляется из https://www.groovy-lang.org/operators.html#_safe_navigation_operator[Groovy] язык.
Обычно, когда у вас есть ссылка на объект, вам может потребоваться проверить что оно не равно null перед доступом к методам или свойствам объекта.
Чтобы избежать при этом оператор безопасной навигации возвращает `null` для конкретной нулевой безопасной операции. вместо того, чтобы генерировать исключение.
Оператор безопасной навигации. [ВНИМАНИЕ] = Когда оператор безопасной навигации оценивает значение null для определенного нулевого безопасного операции внутри составного выражения, оставшаяся часть составного выражения будет еще оценить.
Оператор безопасной навигации.
Подробности см. в разделе <<выражения-оператор-безопасные-навигационные-составные-выражения>>.
Безопасный доступ к свойствам и методам.
В следующем примере показано, как использовать оператор безопасной навигации для доступа к свойствам. (`?.`).
Java
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
	tesla.setPlaceOfBirth(new PlaceOfBirth("Smiljan"));
	// оценивается как «Смилян»
	String city = parser.parseExpression("placeOfBirth?.city") // <1>

.getValue(context, tesla, String.class);
	tesla.setPlaceOfBirth(null);
	// измерение происходит как null – заключение NullPointerException не выдается
	city = parser.parseExpression("placeOfBirth?.city") // <2>
			.getValue(context, tesla, String.class);
Безопасный доступ к свойствам и методам. <1> Используйте оператор безопасной навигации для ненулевого свойства PlaceOfBirth. <2> Используйте оператор безопасной навигации для нулевого свойства PlaceOfBirth.
	tesla.setPlaceOfBirth(null)
Безопасный доступ к свойствам и методам. <1> Используйте оператор безопасной навигации для ненулевого свойства PlaceOfBirth. <2> Используйте оператор безопасной навигации для нулевого свойства PlaceOfBirth.
Безопасный доступ к свойствам и методам. [ПРИМЕЧАНИЕ] = Оператор безопасной навигации также применяется к вызовам методов объекта.
Безопасный доступ к свойствам и методам.
For example, the expression `#calculator?.max(4, 2)` evaluates to `null` if the Переменная `#calculator` не настроена в контексте.
В противном случае `max(int, int)` method will be invoked on the `#calculator`.
Безопасный доступ к индексу.
Начиная с Spring Framework 6.2, язык выражений Spring поддерживает безопасную навигацию по индексация в следующие типы структур.
* arrays and collections
* strings
* maps
* objects
* custom
Безопасный доступ к индексу.

В следующем примере показано, как использовать оператор безопасной навигации для индексации в список (`?.[]`).
Java
	ExpressionParser parser = new SpelExpressionParser();
	IEEE society = new IEEE();
	EvaluationContext context = new StandardEvaluationContext(society);
	// оценивается как Inventor («Никола Тесла»)
	Inventor inventor = parser.parseExpression("members?.[0]") // <1>
			.getValue(context, Inventor.class);
	society.members = null;
	// оценивается как ноль - не генерирует исключение
	inventor = parser.parseExpression("members?.[0]") // <2>
			.getValue(context, Inventor.class);
Безопасный доступ к индексу. <1> Использовать нулевой оператор индекса для непустого списка `членов` <2> Использовать нулевой оператор индекса для нулевого списка `членов`
	society.members = null
Безопасный доступ к индексу. <1> Использовать нулевой оператор индекса для непустого списка `членов` <2> Использовать нулевой оператор индекса для нулевого списка `членов`
Безопасный выбор и прогнозирование коллекций.
Язык выражений Spring поддерживает безопасную навигацию по следующие операторы.
* нулевой безопасный выбор: `?.?`
* сначала выберите null-safe: `?.^`
* нулевой выбор последнего: `?.$`

* нулевая безопасная проекция: `?.!`
Безопасный выбор и прогнозирование коллекций.
В следующем примере показано, как использовать оператор безопасной навигации для сбора данных. выбор (`?.?`).
Java
	ExpressionParser parser = new SpelExpressionParser();
	IEEE society = new IEEE();
	StandardEvaluationContext context = new StandardEvaluationContext(society);
	String expression = "members?.?[nationality == 'Serbian']"; // <1>
	// оценивается как [Изобретатель("Никола Тесла")]
	List<Inventor> list = (List<Inventor>) parser.parseExpression(expression)
			.getValue(context);
	society.members = null;
	// измерение происходит как ноль – заключение NullPointerException не выдается
	list = (List<Inventor>) parser.parseExpression(expression)
			.getValue(context);
	society.members = null
	// измерение происходит как ноль – заключение NullPointerException не выдается
	list = parser.parseExpression(expression)
			.getValue(context) as List<Inventor>
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`.
В следующем примере показано, как использовать оператор «сначала выбрать с нулевой безопасностью» для коллекции (`?.^`).
Java
	ExpressionParser parser = new SpelExpressionParser();
	IEEE society = new IEEE();

StandardEvaluationContext context = new StandardEvaluationContext(society);
	String expression =
		"members?.^[nationality == 'Serbian' || nationality == 'Idvor']"; // <1>
	// оценивается как Inventor («Никола Тесла»)
	Inventor inventor = parser.parseExpression(expression)
			.getValue(context, Inventor.class);
	society.members = null;
	// измерение происходит как ноль – заключение NullPointerException не выдается
	inventor = parser.parseExpression(expression)
			.getValue(context, Inventor.class);
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «сначала нулевой выбор» в потенциально нулевом списке «членов».
	society.members = null
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «сначала нулевой выбор» в потенциально нулевом списке «членов».
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`.
В следующем примере показано, как использовать оператор «нулевой выбор последнего» для коллекции (`?.$`).
Java
	ExpressionParser parser = new SpelExpressionParser();
	IEEE society = new IEEE();
	StandardEvaluationContext context = new StandardEvaluationContext(society);
	String expression =

"members?.$[nationality == 'Serbian' || nationality == 'Idvor']"; // <1>
	// оценивается как Inventor("Pupin")
	Inventor inventor = parser.parseExpression(expression)
			.getValue(context, Inventor.class);
	society.members = null;
	// измерение происходит как ноль – заключение NullPointerException не выдается
	inventor = parser.parseExpression(expression)
			.getValue(context, Inventor.class);
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «нулевой выбор последнего» в потенциально нулевом списке «членов».
	society.members = null
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «нулевой выбор последнего» в потенциально нулевом списке «членов».
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`.
В следующем примере показано, как использовать оператор безопасной навигации для сбора данных. проекция (`?.!`).
Java
	ExpressionParser parser = new SpelExpressionParser();
	IEEE society = new IEEE();
	StandardEvaluationContext context = new StandardEvaluationContext(society);
	// оценивается как ["Смилян", "Идвор"]

List placesOfBirth = parser.parseExpression("members?.![placeOfBirth.city]") // <1>
			.getValue(context, List.class);
	society.members = null;
	// измерение происходит как ноль – заключение NullPointerException не выдается
	placesOfBirth = parser.parseExpression("members?.![placeOfBirth.city]") // <2>
			.getValue(context, List.class);
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать нулевой оператор проекции для ненулевого списка `членов` <2> Использовать нулевой оператор проекции для нулевого списка `членов`
	society.members = null
<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать нулевой оператор проекции для ненулевого списка `членов` <2> Использовать нулевой оператор проекции для нулевого списка `членов`
Безопасные операции с параметрами «Необязательно».
Начиная с Spring Framework 7.0, нулевые операции поддерживаются в экземплярах `java.util.Optional` с прозрачной семантикой развертывания.
Безопасные операции с параметрами «Необязательно».
В частности, когда к _empty_ `Optional` применяется нулевой оператор, он будет рассматривается так, как если бы `Optional` был `null`, и последующая операция будет иметь значение `ноль`.

Однако если к непустому `Optional` применяется нулевой оператор, последующая операция будет применена к объекту, содержащемуся в `Optional`, тем самым эффективно разворачивая `Optional`.
Безопасные операции с параметрами «Необязательно».
Например, если `user` имеет тип `Optional<User>`, выражение `user?.name` будет оценить значение `null`, если `user` имеет значение `null` или _empty_ `Optional`, и в противном случае будет вычислить имя пользователя, фактически `user.get().getName()` или `user.get().name` для доступа к свойству или полю соответственно.
Безопасные операции с параметрами «Необязательно». [ПРИМЕЧАНИЕ] = Вызовы методов, определенных в `Optional` API, по-прежнему поддерживаются на _empty_. `Необязательно`.
Например, если `name` имеет тип `Optional<String>`, выражение `name?.orElse('Unknown')` будет иметь значение `"Unknown"`, если `name` является пустым `Optional` и в противном случае будет вычисляться как `String`, содержащаяся в `Optional`, если `name` является непустой `Optional`, фактически `name.get()`.

Безопасные операции с параметрами «Необязательно». // ПРИМЕЧАНИЕ. ⁠ — символ Юникода «WORD JOINER», который является нежелательным переносом строки.
Безопасные операции с параметрами «Необязательно».
Аналогично, если `names` имеет тип `Optional<List<String>>`, выражение `names?.?⁠[#this.length > 5]` будет иметь значение `null`, если `names` имеет значение `null` или _empty_ `Необязательно` и в противном случае будет оценивать последовательность, содержащую имена, длина которых больше 5, эффективно `names.get().stream().filter(s -> s.length() > 5).toList()`.
Безопасные операции с параметрами «Необязательно».
Та же семантика применима ко всем операторам нулевой безопасности, упомянутым ранее в этом документе. глава.
Безопасные операции с параметрами «Необязательно».
Для получения дополнительной информации и примеров обратитесь к javadoc для следующих операторов.
* {spring-framework-api}/expression/spel/ast/PropertyOrFieldReference.html[`PropertyOrFieldReference`]
* {spring-framework-api}/expression/spel/ast/MethodReference.html[`MethodReference`]
* {spring-framework-api}/expression/spel/ast/Indexer.html[`Indexer`]

* {spring-framework-api}/expression/spel/ast/Selection.html[`Selection`]
* {spring-framework-api}/expression/spel/ast/Projection.html[`Projection`]
Безопасные операции в составных выражениях.
Как упоминалось в начале этого раздела, когда оператор безопасной навигации оценивается как `null` для конкретной операции, безопасной для нулевых значений, в составном выражении, оставшаяся часть составного выражения все равно будет оценена.
Это означает, что оператор безопасной навигации должен применяться во всем составном выражении, чтобы избегайте нежелательных исключений NullPointerException.
Безопасные операции в составных выражениях.
Учитывая выражение `#person?.address.city`, если `#person` имеет значение `null`, безопасная навигация оператор (`?.`) гарантирует, что при попытке доступа к Свойство `address` `#person`.
Однако, поскольку `#person?.address` имеет значение null, `NullPointerException` будет выброшено при попытке доступа к свойству `city` `ноль`.
Чтобы решить эту проблему, вы можете применить нулевую безопасную навигацию по всему соединению. выражение типа `#person?.address?.city`.
Это выражение будет безопасно оценено как `null` если значение `#person` или `#person?.address` равно `null`.
Безопасные операции в составных выражениях.

В следующем примере показано, как использовать оператор «сначала выбрать с нулевой безопасностью». (`?.^`) в коллекции в сочетании с нулевым доступом к свойствам (`?.`) внутри составного соединения выражение.
Если `members` имеет значение `null`, это результат оператора "сначала выбрать с нулевой безопасностью". (`members?.^[национальность == 'Сербский']`) оценивается как `null`, и дополнительное использование оператор безопасной навигации (`?.name`) гарантирует, что все составное выражение оценивается как null вместо выдачи исключения.
Java
	ExpressionParser parser = new SpelExpressionParser();
	IEEE society = new IEEE();
	StandardEvaluationContext context = new StandardEvaluationContext(society);
	String expression = "members?.^[nationality == 'Serbian']?.name"; // <1>
	// оценивается как «Никола Тесла»
	String name = parser.parseExpression(expression)
			.getValue(context, String.class);
	society.members = null;
	// измерение происходит как ноль – заключение NullPointerException не выдается
	name = parser.parseExpression(expression)
			.getValue(context, String.class);
Безопасные операции в составных выражениях. <1> Используйте операторы доступа к свойствам с нулевой безопасностью «сначала выбор» и нулевые операторы доступа к свойствам в составном выражении.

society.members = null
Безопасные операции в составных выражениях. <1> Используйте операторы доступа к свойствам с нулевой безопасностью «сначала выбор» и нулевые операторы доступа к свойствам в составном выражении.

Тернарный оператор (если-то-иначе).
Вы можете использовать тернарный оператор для выполнения условной логики if-then-else внутри выражение.
В следующем листинге показан минимальный пример:
Java
	String falseString = parser.parseExpression(
			"false ? 'trueExp' : 'falseExp'").getValue(String.class);
Тернарный оператор (если-то-иначе).
В этом случае логическое значение false возвращает строковое значение falseExp.
Более реалистичный пример следующий:
Java
	parser.parseExpression("name").setValue(societyContext, "IEEE");
	societyContext.setVariable("queryName", "Nikola Tesla");
	expression = "isMember(#queryName)? #queryName + ' is a member of the ' " +
			"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'";
	String queryResultString = parser.parseExpression(expression)
			.getValue(societyContext, String.class);
	// queryResultString = "Никола Тесла является членом общества IEEE"
	parser.parseExpression("name").setValue(societyContext, "IEEE")
	societyContext.setVariable("queryName", "Nikola Tesla")

expression = "isMember(#queryName)? #queryName + ' is a member of the ' " + "+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'"
Тернарный оператор (если-то-иначе).
См. следующий раздел, посвященный оператору Элвиса, где приведен еще более короткий синтаксис тернарный оператор.

* Операторы отношения
* Логические операторы
* Строковые операторы
* Математические операторы
* Оператор присваивания
* Перегруженные операторы
Реляционные операторы.
Операторы отношения (равно, не равно, меньше, меньше или равно, больше, и больше или равно) поддерживаются с использованием стандартной записи оператора.
Эти операторы работают с типами Number, а также с типами, реализующими Comparable.
В следующем листинге показано несколько примеров реляционных операторов:
Java
	// оценивается как правда
	boolean trueValue = parser.parseExpression("2 == 2").getValue(Boolean.class);
	// оценивается как ложь
	boolean falseValue = parser.parseExpression("2 < -5.0").getValue(Boolean.class);
	// оценивается как правда
	boolean trueValue = parser.parseExpression("'black' < 'block'").getValue(Boolean.class);
	// использует CustomValue:::compareTo
	boolean trueValue = parser.parseExpression("new CustomValue(1) < new CustomValue(2)").getValue(Boolean.class);
Реляционные операторы. [ПРИМЕЧАНИЕ] = Сравнения "больше" и "меньше" с `null` следуют простому правилу: `null` рассматривается как ничего (это НЕ равно нулю).

Как следствие, любое другое значение всегда больше чем `null` (`X > null` всегда `true`), и никакое другое значение не может быть меньше нуля. («X < null» всегда имеет значение «false»).
Реляционные операторы.
Если вместо этого вы предпочитаете числовые сравнения, избегайте числовых сравнений с нулевым значением. в пользу сравнения с нулем (например, `X > 0` или `X < 0`).
Реляционные операторы.
Каждый символьный оператор также может быть указан как чисто текстовый эквивалент.
Это позволяет избежать проблемы, в которых используемые символы имеют особое значение для типа документа, в котором выражение встроено (например, в XML-документ).
Текстовые эквиваленты:
* `lt` (`<`)
* `gt` (`>`)
* `le` (`\<=`)
* `ge` (`>=`)
* `eq` (`==`)
* `не` (`!=`)
Реляционные операторы.
Все текстовые операторы нечувствительны к регистру.
Реляционные операторы.
Помимо стандартных операторов отношений, SpEL поддерживает операторы «между», `instanceof` и операторы `match` на основе регулярных выражений.
Следующий список показаны примеры всех трех:
Java
	boolean result;
	// оценивается как правда
	result = parser.parseExpression(

"1 between {1, 5}").getValue(Boolean.class);
	// оценивается как ложь
	result = parser.parseExpression(
			"1 between {10, 15}").getValue(Boolean.class);
	// оценивается как правда
	result = parser.parseExpression(
			"'elephant' between {'aardvark', 'zebra'}").getValue(Boolean.class);
	// оценивается как ложь
	result = parser.parseExpression(
			"'elephant' between {'aardvark', 'cobra'}").getValue(Boolean.class);
	// оценивается как правда
	result = parser.parseExpression(
			"123 instanceof T(Integer)").getValue(Boolean.class);
	// оценивается как ложь
	result = parser.parseExpression(
			"'xyz' instanceof T(Integer)").getValue(Boolean.class);
	// оценивается как правда
	result = parser.parseExpression(
			"'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);
	// оценивается как ложь
	result = parser.parseExpression(

"'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);
Реляционные операторы. [ВНИМАНИЕ] = Синтаксис оператора `between`: `<input> между {<range_begin>, <range_end>}`, что фактически является ярлыком для `<input> >= <range_begin> && <input> \<= <range_end>}`.
Реляционные операторы.
Следовательно, `1 между {1, 5}` оценивается как `истина`, а `1 между {5, 1}` оценивается как `истина`. на «ложь».
Реляционные операторы.
ВНИМАНИЕ: Будьте осторожны с примитивными типами, так как они сразу же упаковываются в соответствующие места. типы оберток.
Например, `1 экземпляр T(int)` оценивается как `false`, а `1 экземпляр T(Integer)` оценивается как `истина`.
* `и` (`&&`)
* `или` (`||`)
* `не` (`!`)
SpEL поддерживает следующие логические («логические») операторы:.
Все текстовые операторы нечувствительны к регистру.
Java
	// -- И --
	// оценивается как ложь

boolean falseValue = parser.parseExpression("true and false").getValue(Boolean.class);
	// оценивается как правда
	String expression = "isMember('Nikola Tesla') and isMember('Mihajlo Pupin')";
	boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);
	// -- OR --
	// оценивается как правда
	boolean trueValue = parser.parseExpression("true or false").getValue(Boolean.class);
	// оценивается как правда
	String expression = "isMember('Nikola Tesla') or isMember('Albert Einstein')";
	boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);
	// -- НЕТ --
	// оценивается как ложь
	boolean falseValue = parser.parseExpression("!true").getValue(Boolean.class);
	// -- И и НЕ --
	String expression = "isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')";
	boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);
	// -- И --
	// -- OR --
	// -- НЕТ --
	// -- И и НЕ --
Строковые операторы.

Вы можете использовать следующие операторы в строках.
* конкатенация (`+`)
* вычитание (`-`)
  - для использования со строкой, содержащей один символ
* повторить (`*`)
Java
	// -- Конкатенация --
	// оценивается как «привет, мир»
	String helloWorld = parser.parseExpression("'hello' + ' ' + 'world'")
			.getValue(String.class);
	// -- Вычитание символов --
	// оценивается как «а»
	char ch = parser.parseExpression("'d' - 3")
			.getValue(char.class);
	// -- Повторить --
	// оценивается как «abcabc»
	String repeated = parser.parseExpression("'abc' * 2")
			.getValue(String.class);
	// -- Конкатенация --
	// -- Вычитание символов --
	// -- Повторить --
Математические операторы.
Вы можете использовать следующие операторы для чисел, при этом применяется стандартный приоритет операторов.
* дополнение (`+`)
* вычитание (`-`)
* приращение (`{pp}`)
* декремент (`--`)
* умножение (`*`)
* деление (`/`)
* модуль (`%`)
* экспоненциальная степень (`^`)

Математические операторы.
Операторы деления и модуля также можно указать как чисто текстовый эквивалент.
Это позволяет избежать проблем, когда используемые символы имеют особое значение для типа документа в который встроено выражение (например, в XML-документ).
Текстовые эквиваленты являются:
* `div` (`/`)
* `мод` (`%`)
Математические операторы.
Все текстовые операторы нечувствительны к регистру.
Математические операторы. [ПРИМЕЧАНИЕ] = Операторы увеличения и уменьшения можно использовать либо с префиксом (`{pp}A`, `--A`), либо с постфиксная (`A{pp}`, `A--`) нотация с переменными или свойствами, в которые можно записывать.
Java
	Inventor inventor = new Inventor();
	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
	// -- Добавление --
	int two = parser.parseExpression("1 + 1").getValue(int.class);  // 2
	// -- Вычитание --
	int four = parser.parseExpression("1 - -3").getValue(int.class);  // 4
	double d = parser.parseExpression("1000.00 - 1e4").getValue(double.class);  // -9000
	// -- Приращение --

// Свойство счетчика в Inventor имеет начальное значение 0.
	// оценивается как 2; счетчик теперь равен 1
	two = parser.parseExpression("counter++ + 2").getValue(context, inventor, int.class);
	// оценивается как 5; счетчик теперь равен 2
	int five = parser.parseExpression("3 + ++counter").getValue(context, inventor, int.class);
	// -- Уменьшение --
	// Свойство счетчика в Inventor имеет значение 2.
	// оценивается как 6; счетчик теперь равен 1
	int six = parser.parseExpression("counter-- + 4").getValue(context, inventor, int.class);
	// оценивается как 5; счетчик теперь равен 0
	five = parser.parseExpression("5 + --counter").getValue(context, inventor, int.class);
	// -- Умножение --
	six = parser.parseExpression("-2 * -3").getValue(int.class);  // 6
	double twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(double.class);  // 24.0
	// -- Разделение --

int minusTwo = parser.parseExpression("6 / -3").getValue(int.class);  // -2
	double one = parser.parseExpression("8.0 / 4e0 / 2").getValue(double.class);  // 1.0
	// -- Модуль --
	int three = parser.parseExpression("7 % 4").getValue(int.class);  // 3
	int oneInt = parser.parseExpression("8 / 5 % 2").getValue(int.class);  // 1
	// -- Экспоненциальная мощность --
	int maxInt = parser.parseExpression("(2^31) - 1").getValue(int.class);  // Integer.MAX_VALUE
	int minInt = parser.parseExpression("-2^31").getValue(int.class);  // Integer.MIN_VALUE
	// -- Приоритет оператора --
	int minusTwentyOne = parser.parseExpression("1+2-3*8").getValue(int.class);  // -21
	// -- Добавление --
	// -- Вычитание --
	// -- Приращение --
	// Свойство счетчика в Inventor имеет начальное значение 0.
	// -- Уменьшение --

// Свойство счетчика в Inventor имеет значение 2.
	// -- Умножение --
	// -- Разделение --
	// -- Модуль --
	// -- Экспоненциальная мощность --
	// -- Приоритет оператора --
Оператор присваивания.
Чтобы установить свойство, используйте оператор присваивания (`=`).
Обычно это делается в течение вызов setValue, но это также можно сделать внутри вызова getValue.
Следующие В листинге показаны оба способа использования оператора присваивания:
Java
	Inventor inventor = new Inventor();
	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
	parser.parseExpression("name").setValue(context, inventor, "Aleksandar Seovic");
	// альтернативно
	String aleks = parser.parseExpression(
			"name = 'Aleksandar Seovic'").getValue(context, inventor, String.class);
	parser.parseExpression("name").setValue(контекст, изобретатель, "Александар Сеович")
Перегруженные операторы.
По умолчанию математические операции, определенные в перечислении Operation в SpEL («ADD», SUBTRACT, DIVIDE, MULTIPLY, MODULUS и POWER) поддерживают простые типы, такие как цифры.
Предоставляя реализацию «OperatorOverloader», язык выражений может поддерживать эти операции на других типах.
Перегруженные операторы.

Например, если мы хотим перегрузить оператор `ADD`, чтобы разрешить соединение двух списков. объединенные с помощью знака `+`, мы можем реализовать собственный `OperatorOverloader` как следует.
	pubic class ListConcatenation implements OperatorOverloader {
		@Override
		public boolean overridesOperation(Operation operation, Object left, Object right) {
			return (operation == Operation.ADD &&
					left instanceof List && right instanceof List);
		@Override
		@SuppressWarnings("unchecked")
		public Object operate(Operation operation, Object left, Object right) {
			if (operation == Operation.ADD &&
					left instanceof List list1 && right instanceof List list2) {
				List result = new ArrayList(list1);
				result.addAll(list2);
				return result;
			throw new UnsupportedOperationException(
				"No overload for operation %s and operands [%s] and [%s]"
					.formatted(operation, left, right));
Перегруженные операторы.
Если мы зарегистрируем ListConcatenation как OperatorOverloader в `StandardEvaluationContext`, мы можем затем оценить выражения типа `{1, 2, 3} + {4, 5}` как показано в следующем примере.
Java
	StandardEvaluationContext context = new StandardEvaluationContext();
	context.setOperatorOverloader(new ListConcatenation());
	// возвращает новый список: [1, 2, 3, 4, 5]

parser.parseExpression("{1, 2, 3} + {2 + 2, 5}").getValue(context, List.class);
	StandardEvaluationContext context = StandardEvaluationContext()
	context.setOperatorOverloader(ListConcatenation())
Перегруженные операторы. [ПРИМЕЧАНИЕ] = ОператорOverloader не меняет семантику оператора по умолчанию.
Для например, `2 + 2` в приведенном выше примере по-прежнему оценивается как `4`.
Перегруженные операторы. [ВНИМАНИЕ] = Любое выражение, использующее перегруженный оператор, не может быть скомпилировано.
См. для получения подробной информации.

Доступ к данным реляционного сопоставления объектов (ORM).
В этом разделе рассматривается доступ к данным при использовании реляционного сопоставления объектов (ORM).

1. Что такое Lilipup Framework. `Lilipup Framework` — это вымышленный, но реалистичный Java-фреймворк для построения модульных backend-сервисов с акцентом на предсказуемый lifecycle, безопасную интеграцию, наблюдаемость и удобную эксплуатацию в production.
- контейнер компонентов и внедрение зависимостей;
- централизованную конфигурацию;
- валидацию данных и конфигов;
- безопасность (аутентификация, авторизация, криптография);
- встроенный scheduler;
- интеграцию с Kafka;
- мониторинг, метрики и structured logging.
- фрагментированная инфраструктура (много библиотек без единого контракта);
- runtime-ошибки из-за слабой валидации конфигурации;
- сложный запуск/остановка сервисов и непредсказуемый lifecycle;
- дублирование кода для retry, ошибок, проверок безопасности и метрик;
- слабая операционная наблюдаемость и сложная отладка инцидентов.
Lilipup придуман как ответ на типичные проблемы реальных Java-проектов:.
Главная идея: дать команде единый framework-слой, где лучшие практики уже встроены и по умолчанию включают безопасные и эксплуатационно-устойчивые настройки.
- запускать новые сервисы быстрее за счёт готовых модулей;
- снижать количество production-инцидентов через обязательные проверки и fail-fast;
- стандартизировать кодовую базу между командами;
- сделать поведение приложения более предсказуемым при нагрузке и сбоях;
- упростить поддержку DevOps/SRE за счёт встроенного мониторинга и telemetry.
- быстрый bootstrap нового сервиса;
- декларативная конфигурация и типобезопасный binding;
- единые правила валидации и обработки ошибок;

- минимизация boilerplate-кода.
- контролируемый startup/readiness/shutdown;
- встроенные retry/backoff/DLQ-подходы для интеграций;
- единый формат метрик и логов для observability;
- удобная диагностика причин деградации.
- централизованные политики доступа;
- предсказуемая аутентификация и авторизация;
- безопасная работа с секретами и шифрованием;
- аудит критичных операций.
- Java backend-разработчики, строящие микросервисы и интеграционные сервисы;
- архитекторы, которым нужен единый технический стандарт;
- DevOps/SRE, которым важна прозрачная эксплуатация;
- platform-команды, создающие внутреннюю инженерную платформу.
6. Архитектурная идея. Lilipup строится вокруг `core` контейнера и расширяется модульно.
- `Modular by design`: каждый capability в отдельном модуле;
- `Fail fast`: критичные ошибки ловятся на старте;
- `Secure by default`: deny-by-default, минимальные привилегии;
- `Observable by default`: метрики, логи, трассировка из коробки;
- `Operationally friendly`: graceful shutdown, retries, readiness.
- нужен production-ready фреймворк с единым стилем разработки;
- важна строгая дисциплина конфигурации и безопасности;
- много интеграций (Kafka, внешние API, scheduled jobs);
- важна высокая поддерживаемость в долгом жизненном цикле продукта.
- проект экспериментальный и требует минимального runtime-слоя;
- нужна только тонкая библиотека без framework-ограничений;

- команда осознанно предпочитает полностью ручную сборку стека.
- Всегда фиксируйте обязательные модули и их версии в BOM/родительском POM.
- Всегда поднимайте smoke-среду с production-профилем перед релизом.
- Проверяйте, что включены security-policy, audit и monitoring.
- Проверяйте readiness/liveness и сценарии graceful shutdown.
- Проводите нагрузочные и отказоустойчивые тесты ключевых интеграций.
- Начинайте с минимального набора: `core + configuration + validation + monitoring`.
- Добавляйте `kafka`, `scheduler`, `security` по мере зрелости сервиса.
- Держите внутренний engineering guide с примерами «как в Lilipup принято».
- Автоматизируйте проверки конфигурации и политики безопасности в CI.
- Регулярно пересматривайте настройки retry/timeouts/alerts по фактической нагрузке.

Введение.
В этой главе описывается поддержка Spring Mapping Object-XML.
Объект-XML Сопоставление (сокращенно сопоставление OX) — это процесс преобразования XML-документа в и из него. объект.
Этот процесс преобразования также известен как маршалинг XML или XML.
Сериализация.
В этой главе эти термины используются взаимозаменяемо.
Введение.
В области сопоставления OX маршаллер отвечает за сериализацию объект (график) в XML.
Аналогичным образом демаршаллер десериализует XML в граф объекта.
Этот XML может принимать форму документа DOM, входного или выходного файла. поток или обработчик SAX.
* Простота настройки
* Согласованные интерфейсы
* Последовательная иерархия исключений
Простота настройки.
Фабрика компонентов Spring позволяет легко настраивать маршаллеры без необходимости создавать контекст JAXB, фабрики привязки JiBX и т. д.
Вы можете настроить маршаллеры как и любой другой компонент в контексте вашего приложения.
Кроме того, основанное на пространстве имен XML конфигурация доступна для нескольких распределительных устройств, что делает конфигурацию даже проще.
Согласованные интерфейсы.
Сопоставление OX в Spring работает через два глобальных интерфейса: {spring-framework-api}/oxm/Marshaller.html[`Marshaller`] и {spring-framework-api}/oxm/Unmarshaller.html[`Unmarshaller`].
Эти абстракции позволяют переключать платформы сопоставления OX. с относительной легкостью, с небольшими изменениями или вообще без них в классах, которые выполняют сортировка.

Этот подход имеет дополнительное преимущество, позволяя выполнять XML маршалинг с использованием подхода «смешивай и сопоставляй» (например, некоторый маршалинг выполняется с использованием JAXB и некоторые от XStream) ненавязчивым образом, позволяя вам использовать возможности каждого технология.
Согласованная иерархия исключений.
Spring обеспечивает преобразование исключений из базового инструмента сопоставления OX в его собственная иерархия исключений с XmlMappingException в качестве корневого исключения.
Эти исключения времени выполнения оборачивают исходное исключение, чтобы никакая информация не была потеряна.
«Маршаллер» и «Анмаршаллер».
Как указано в документе introduction, маршаллер сериализует объект. в XML, а демаршаллер десериализует поток XML в объект.
В этом разделе описываются два интерфейса Spring, используемые для этой цели.
Понимание «Маршаллера».
Spring абстрагирует все операции сортировки, стоящие за Интерфейс `org.springframework.oxm.Marshaller`, основной метод которого следующий:
	public interface Marshaller {
		 * Маршалируем граф объекта с заданным корнем в предоставленный результат.
		void marshal(Object graph, Result result) throws XmlMappingException, IOException;
Понимание «Маршаллера».
Интерфейс Marshaller имеет один основной метод, который маршалирует данный объект в учитывая `javax.xml.transform.Result`.
Результатом является интерфейс тегов, который по сути представляет абстракцию вывода XML.
Конкретные реализации оборачивают различные XML представления, как показано в следующей таблице:

| `StreamResult` | `java.io.File`, `java.io.OutputStream` или `java.io.Writer` |===.
ПРИМЕЧАНИЕ.
Хотя метод marshal() принимает в качестве первого параметра простой объект, большинство Реализации Marshaller не могут обрабатывать произвольные объекты.
Вместо этого класс объекта должен быть отображен в файле сопоставления, отмечен аннотацией, зарегистрирован в marshaller или иметь общий базовый класс.
Обратитесь к последующим разделам этой главы. чтобы определить, как ваша технология OX справляется с этим.
Понимание «Unmarshaller».
Подобно Marshaller, у нас есть org.springframework.oxm.Unmarshaller. интерфейс, который показан в следующем листинге:
	public interface Unmarshaller {
		 * Демаршалируйте предоставленный исходный код в граф объекта.
		Object unmarshal(Source source) throws XmlMappingException, IOException;
Понимание «Unmarshaller».
Этот интерфейс также имеет один метод, который читает из заданного `javax.xml.transform.Source` (абстракция ввода XML) и возвращает прочитанный объект.
Как с «Result», «Source» — это интерфейс тегов, который имеет три конкретные реализации.
Каждый обертывает другое представление XML, как показано в следующей таблице:
| `StreamSource` | `java.io.File`, `java.io.InputStream` или `java.io.Reader` |===.

Несмотря на то, что существует два отдельных интерфейса маршалинга («Marshaller» и `Unmarshaller`), все реализации в Spring-WS реализуют оба в одном классе.
Это означает, что вы можете подключить один класс маршаллера и обращаться к нему как к маршаллер и как демаршаллер в вашем `applicationContext.xml`.
Понимание `XmlMappingException`.
Spring преобразует исключения из базового инструмента сопоставления OX в собственное исключение. иерархия с XmlMappingException в качестве корневого исключения.
Эти исключения времени выполнения оборачивают исходное исключение, чтобы никакая информация не была потеряна.
Понимание `XmlMappingException`.
Кроме того, MarshallingFailureException и UnmarshallingFailureException обеспечить различие между операциями сортировки и демаршаллинга, даже несмотря на то, что базовый инструмент сопоставления OX не делает этого.
Использование Marshaller и Unmarshaller.
Вы можете использовать Spring OXM для самых разных ситуаций.
В следующем примере мы используйте его для маршалирования настроек приложения, управляемого Spring, в виде XML-файла.
В следующем примере мы используйте простой JavaBean для представления настроек:
Java
	public class Settings {
		private boolean fooEnabled;
		public boolean isFooEnabled() {
			return fooEnabled;
		public void setFooEnabled(boolean fooEnabled) {
			this.fooEnabled = fooEnabled;
Использование Marshaller и Unmarshaller.
Класс приложения использует этот компонент для хранения своих настроек.

Помимо основного метода, Класс имеет два метода: `saveSettings()` сохраняет bean-компонент настроек в файл с именем `settings.xml` и `loadSettings()` снова загружают эти настройки.
Следующий метод `main()` создает контекст приложения Spring и вызывает эти два метода:
Java
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import javax.xml.transform.stream.StreamResult;
	import javax.xml.transform.stream.StreamSource;
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.oxm.Marshaller;
	import org.springframework.oxm.Unmarshaller;
	public class Application {
		private static final String FILE_NAME = "settings.xml";
		private Settings settings = new Settings();
		private Marshaller marshaller;
		private Unmarshaller unmarshaller;
		public void setMarshaller(Marshaller marshaller) {
			this.marshaller = marshaller;
		public void setUnmarshaller(Unmarshaller unmarshaller) {
			this.unmarshaller = unmarshaller;
		public void saveSettings() throws IOException {
			try (FileOutputStream os = new FileOutputStream(FILE_NAME)) {
				this.marshaller.marshal(settings, new StreamResult(os));
		public void loadSettings() throws IOException {
			try (FileInputStream is = new FileInputStream(FILE_NAME)) {

this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));
		public static void main(String[] args) throws IOException {
			ApplicationContext appContext =
					new ClassPathXmlApplicationContext("applicationContext.xml");
			Application application = (Application) appContext.getBean("application");
			application.saveSettings();
			application.loadSettings();
	class Application {
Использование Marshaller и Unmarshaller.
Для «Приложения» необходимо установить свойство «marshaller» и «unmarshaller».
Мы можно сделать это, используя следующий `applicationContext.xml`:
	<beans>
		<bean id="application" class="Application">
			<property name="marshaller" ref="xstreamMarshaller" />
			<property name="unmarshaller" ref="xstreamMarshaller" />
		</bean>
		<bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"/>
	</beans>
Использование Marshaller и Unmarshaller.
Этот контекст приложения использует XStream, но мы могли бы использовать любой другой маршаллер. случаи, описанные далее в этой главе.
Обратите внимание, что по умолчанию XStream не требует любая дополнительная конфигурация, поэтому определение компонента довольно просто.

Также обратите внимание, что XStreamMarshaller реализует как Marshaller, так и Unmarshaller, поэтому мы можем обратиться к Компонент `xstreamMarshaller` как в свойстве `marshaller`, так и в `unmarshaller` приложение.
	<?xml version="1.0" encoding="UTF-8"?>
	<settings foo-enabled="false"/>
Пространство имен конфигурации XML.
Маршаллеры можно настроить более лаконично, используя теги из пространства имен OXM.
Чтобы сделать эти теги доступными, вы должны сначала сослаться на соответствующую схему в преамбула файла конфигурации XML.
В следующем примере показано, как это сделать:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:oxm="http://www.springframework.org/schema/oxm" <1>
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/oxm

https://www.springframework.org/schema/oxm/spring-oxm.xsd"> <2>
Пространство имен конфигурации XML. <1> Ссылка на схему `oxm`. <2> Укажите местоположение схемы `oxm`.
* `jaxb2-marshaller`
* `jibx-marshaller`
Схема делает доступными следующие элементы:.
Каждый тег объясняется в соответствующем разделе упорядочителя.
Однако в качестве примера конфигурация маршаллера JAXB2 может выглядеть следующим образом:
	<oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/>
ЯКСБ.
Компилятор привязки JAXB преобразует XML-схему W3C в один или несколько классов Java, файл `jaxb.properties` и, возможно, некоторые файлы ресурсов.
JAXB также предлагает способ создать схему из аннотированных классов Java.
ЯКСБ.
Spring поддерживает API JAXB 2.0 в качестве стратегий маршалинга XML, следуя Интерфейсы Marshaller и Unmarshaller описаны в документе `Marshaller` and `Unmarshaller`.
Соответствующие классы интеграции находятся в файле org.springframework.oxm.jaxb. пакет.
Использование Jaxb2Marshaller.
Класс Jaxb2Marshaller реализует как Spring Marshaller, так и Unmarshaller. интерфейсы.
Для работы требуется контекстный путь.
Вы можете установить контекстный путь, установив Свойство contextPath.
Контекстный путь представляет собой список пакетов Java, разделенных двоеточиями. имена, содержащие производные от схемы классы.

Он также предлагает свойство classesToBeBound, который позволяет вам установить массив классов, которые будут поддерживаться маршаллером.
Схема проверка выполняется путем указания одного или нескольких ресурсов схемы для компонента, как показано в следующем примере:
	<beans>
		<bean id="jaxb2Marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
			<property name="classesToBeBound">
				<list>
					<value>org.springframework.oxm.jaxb.Flight</value>
					<value>org.springframework.oxm.jaxb.Flights</value>
				</list>
			</property>
			<property name="schema" value="classpath:org/springframework/oxm/schema.xsd"/>
		</bean>
	</beans>
Пространство имен конфигурации XML.
Элемент `jaxb2-marshaller` настраивает `org.springframework.oxm.jaxb.Jaxb2Marshaller`, как показано в следующем примере:
	<oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/>
Пространство имен конфигурации XML.
Альтернативно вы можете предоставить список классов для привязки к маршаллеру, используя метод Дочерний элемент `class-to-be-bound`:
	<oxm:jaxb2-marshaller id="marshaller">

<oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Airport"/>
		<oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Flight"/>
	</oxm:jaxb2-marshaller>
ДжиБХ.
Фреймворк JiBX предлагает решение, аналогичное тому, которое Hibernate предоставляет для ORM: определение привязки определяет правила преобразования ваших объектов Java в или из XML.
После подготовки привязки и компиляции классов компилятор привязки JiBX расширяет файлы классов и добавляет код для обработки преобразования экземпляров классов. из или в XML.
ДжиБХ.
Дополнительную информацию о JiBX см. на http://jibx.sourceforge.net/[веб-сайте JiBX. сайт].
Классы интеграции Spring находятся в файле org.springframework.oxm.jibx. пакет.
Использование JibxMarshaller.
Класс JibxMarshaller реализует как Marshaller, так и Unmarshaller. интерфейс.
Для работы ему требуется имя класса для маршалинга, которое вы можете устанавливается с помощью свойства targetClass.
При желании вы можете установить имя привязки, задав параметр Свойство `bindingName`.
В следующем примере мы привязываем класс Flights:
	<beans>
		<bean id="jibxFlightsMarshaller" class="org.springframework.oxm.jibx.JibxMarshaller">

<property name="targetClass">org.springframework.oxm.jibx.Flights</property>
		</bean>
	</beans>
Использование JibxMarshaller.
JibxMarshaller настроен для одного класса.
Если вы хотите маршалировать несколько классов, вам необходимо настроить несколько экземпляров JibxMarshaller с разными целевыми классами. ценности недвижимости.
Пространство имен конфигурации XML.
Тег jibx-marshaller настраивает файл org.springframework.oxm.jibx.JibxMarshaller, как показано в следующем примере:
	<oxm:jibx-marshaller id="marshaller" target-class="org.springframework.ws.samples.airline.schema.Flight"/>
| `id` | Идентификатор маршаллера | Нет. | `целевой класс` | Целевой класс для этого маршаллера | Да
| `id` | Идентификатор маршаллера | Нет. | `bindingName` | Имя привязки, используемое этим маршалером | Нет |===
XStream — это простая библиотека для сериализации объектов в XML и обратно.
Это не требует любого сопоставления и генерирует чистый XML.
XStream.
Для получения дополнительной информации о XStream см. https://x-stream.github.io/[XStream веб-сайт].
Классы интеграции Spring находятся в пакет `org.springframework.oxm.xstream`.
Использование XStreamMarshaller.
XStreamMarshaller не требует какой-либо настройки и может быть настроен в контекст приложения напрямую.

Для дальнейшей настройки XML вы можете установить карту псевдонимов, который состоит из псевдонимов строк, сопоставленных с классами, как показано в следующем примере:
	<beans>
		<bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
			<property name="aliases">
				<props>
					<prop key="Flight">org.springframework.oxm.xstream.Flight</prop>
				</props>
			</property>
		</bean>
	</beans>
Использование XStreamMarshaller. [ВНИМАНИЕ] = По умолчанию XStream позволяет демаршаллировать произвольные классы, что может привести к небезопасные эффекты сериализации Java.
Поэтому мы не рекомендуем использовать `XStreamMarshaller` для демаршалинга XML из внешних источников (то есть из Интернета), поскольку это может привести к уязвимостям безопасности.
Использование XStreamMarshaller.
Если вы решите использовать XStreamMarshaller для демаршалинга XML из внешнего источника, установите свойство supportClasses в XStreamMarshaller, как показано в следующем примере:
	<bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
		<property name="supportedClasses" value="org.springframework.oxm.xstream.Flight"/>
	</bean>
Использование XStreamMarshaller.
Это гарантирует, что только зарегистрированные классы будут иметь право на демаршалинг.
Использование XStreamMarshaller.

Дополнительно вы можете зарегистрироваться {spring-framework-api}/oxm/xstream/XStreamMarshaller.html#setConverters(com.
Thoughtworks.xstream.converters.ConverterMatcher...) [пользовательские преобразователи] чтобы убедиться, что только поддерживаемые классы могут быть демаршаллированы.
Вы можете захотеть чтобы добавить CatchAllConverter в качестве последнего конвертера в списке, в дополнение к преобразователи, которые явно поддерживают классы предметной области, которые должны поддерживаться.
В результате конвертеры XStream по умолчанию с более низкими приоритетами и возможной безопасностью уязвимости не вызываются.
Использование XStreamMarshaller.
ПРИМЕЧАНИЕ.
Обратите внимание, что XStream — это библиотека сериализации XML, а не библиотека привязки данных.
Поэтому он имеет ограниченную поддержку пространства имен.
В результате он практически непригоден для использования. внутри веб-служб.

* `core`: пакет `org.springframework.jdbc.core` содержит класс `JdbcTemplate`.
Структура абстракции JDBC Spring Framework состоит из четырех различных пакетов:. и его различные интерфейсы обратного вызова, а также множество связанных классов.
Подпакет с именем `org.springframework.jdbc.core.simple` содержит `SimpleJdbcInsert` и Классы SimpleJdbcCall.
Другой подпакет с именем `org.springframework.jdbc.core.namedparam` содержит `NamedParameterJdbcTemplate` class и связанные с ним классы поддержки.
См.
* datasource: пакет org.springframework.jdbc.datasource содержит служебный класс.
Структура абстракции JDBC Spring Framework состоит из четырех различных пакетов:. для легкого доступа к DataSource и различных простых реализаций DataSource, которые вы можете используйте для тестирования и запуска немодифицированного кода JDBC вне контейнера Jakarta EE.
Подпакет с именем `org.springframework.jdbc.datasource.embedded` обеспечивает поддержку создания встроенные базы данных с использованием механизмов баз данных Java, таких как HSQL, H2 и Derby.
См.
* `object`: пакет `org.springframework.jdbc.object` содержит классы, представляющие
Структура абстракции JDBC Spring Framework состоит из четырех различных пакетов:.
Запросы, обновления и хранимые процедуры РСУБД в виде потокобезопасных объектов многократного использования.
См. приводит к более объектно-ориентированному подходу, хотя объекты, возвращаемые запросами, естественно отключился от базы данных.

Этот более высокий уровень абстракции JDBC зависит на абстракции нижнего уровня в пакете org.springframework.jdbc.core.
* `support`: пакет `org.springframework.jdbc.support` предоставляет `SQLException`
Структура абстракции JDBC Spring Framework состоит из четырех различных пакетов:. функциональность перевода и некоторые служебные классы.
Исключения, возникающие во время обработки JDBC преобразуются в исключения, определенные в пакете `org.springframework.dao`.
Это означает этот код, использующий уровень абстракции Spring JDBC, не нуждается в реализации JDBC или Обработка ошибок, специфичная для СУБД.
Все переведенные исключения не отмечены, что дает вам возможность перехвата исключений, из которых вы можете восстановиться, позволяя другим исключения передаются вызывающей стороне.
Видеть

Распространенные проблемы с обработкой параметров и значений данных.
В разных подходах существуют общие проблемы с параметрами и значениями данных. обеспечивается поддержкой JDBC Spring Framework.
В этом разделе рассказывается, как их решить.
Предоставление информации о типе SQL для параметров.
Обычно Spring определяет тип параметров SQL на основе типа параметра. передано.
Можно явно указать тип SQL, который будет использоваться при настройке значения параметров.
Иногда это необходимо для правильной установки значений `NULL`.
* Многие методы обновления и запроса `JdbcTemplate` принимают дополнительный параметр в
Вы можете предоставить информацию о типе SQL несколькими способами:. форма массива `int`.
Этот массив используется для указания типа SQL соответствующий параметр, используя константные значения из класса java.sql.Types.
Предоставить одна запись для каждого параметра.
* Вы можете использовать класс SqlParameterValue для переноса значения параметра, которому это необходимо.
Вы можете предоставить информацию о типе SQL несколькими способами:. дополнительная информация.
Для этого создайте новый экземпляр для каждого значения и передайте тип SQL. и значение параметра в конструкторе.
Вы также можете предоставить дополнительную шкалу параметр для числовых значений.
* Для методов, работающих с именованными параметрами, вы можете использовать классы SqlParameterSource.
Вы можете предоставить информацию о типе SQL несколькими способами:. `BeanPropertySqlParameterSource` или `MapSqlParameterSource`.
У них обоих есть методы для регистрации типа SQL для любого из значений именованного параметра.
Обработка объектов BLOB и CLOB.

В базе данных можно хранить изображения, другие двоичные данные и большие фрагменты текста.
Эти большие объекты называются BLOB (Binary Large OBject) для двоичных данных и CLOB (символьные объекты).
Большой OBject) для символьных данных.
В Spring вы можете обрабатывать эти большие объекты, используя непосредственно `JdbcTemplate`, а также при использовании более высоких абстракций, предоставляемых СУБД.
Объекты и классы SimpleJdbc.
Все эти подходы используют реализацию интерфейс `LobHandler` для фактического управления данными LOB (Large OBject). `LobHandler` обеспечивает доступ к классу `LobCreator` через метод `getLobCreator`. который используется для создания новых LOB-объектов, которые будут вставлены.
* БЛОБ
`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:. ** `byte[]`: `getBlobAsBytes` и `setBlobAsBytes` ** `InputStream`: `getBlobAsBinaryStream` и `setBlobAsBinaryStream`
* КЛОБ
`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:. ** `String`: `getClobAsString` и `setClobAsString` ** `InputStream`: `getClobAsAsciiStream` и `setClobAsAsciiStream` ** `Reader`: `getClobAsCharacterStream` и `setClobAsCharacterStream`
`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:.
В следующем примере показано, как создать и вставить BLOB.

Позже мы покажем, как читать его обратно из базы данных.
`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:.
В этом примере используется JdbcTemplate и реализация `AbstractLobCreatingPreparedStatementCallback`.
Он реализует один метод, `установить значения`.
Этот метод предоставляет `LobCreator`, который мы используем для установки значений для Столбцы LOB в операторе вставки SQL.
`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:.
В этом примере мы предполагаем, что существует переменная `lobHandler`, которая уже установлен экземпляр `DefaultLobHandler`.
Обычно вы устанавливаете это значение через внедрение зависимостей.
Java
	final File blobIn = new File("spring2004.jpg");
	final InputStream blobIs = new FileInputStream(blobIn);
	final File clobIn = new File("large.txt");
	final InputStream clobIs = new FileInputStream(clobIn);
	final InputStreamReader clobReader = new InputStreamReader(clobIs);
	jdbcTemplate.execute(
		"INSERT INTO lob_table (id, a_clob, a_blob) ЗНАЧЕНИЯ (?, ?, ?)",
		new AbstractLobCreatingPreparedStatementCallback(lobHandler) {  // <1>
			protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
				ps.setLong(1, 1L);
				lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  // <2>

lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  // <3>
	blobIs.close();
	clobReader.close();
В следующем примере показано, как создать и вставить BLOB:. <1> Передайте `lobHandler`, который (в этом примере) является простым `DefaultLobHandler`. <2> Использование метода setClobAsCharacterStream для передачи содержимого CLOB. <3> Использование метода setBlobAsBinaryStream для передачи содержимого BLOB.
В следующем примере показано, как создать и вставить BLOB:. [ПРИМЕЧАНИЕ] = Если вы вызываете `setBlobAsBinaryStream`, `setClobAsAsciiStream` или Метод setClobAsCharacterStream для LobCreator, возвращенный из `DefaultLobHandler.getLobCreator()`, вы можете указать отрицательное значение. для аргумента «contentLength».
Если указанная длина содержимого отрицательна, `DefaultLobHandler` использует варианты JDBC 4.0 методов set-stream без параметр длины.
В противном случае он передает указанную длину драйверу.
В следующем примере показано, как создать и вставить BLOB:.
См. документацию по используемому вами драйверу JDBC, чтобы убедиться, что он поддерживает потоковую передачу.
LOB без указания длины контента.
В следующем примере показано, как создать и вставить BLOB:.
Теперь пришло время прочитать данные LOB из базы данных.
Опять же, вы используете JdbcTemplate. с той же переменной экземпляра lobHandler и ссылкой на DefaultLobHandler.

В следующем примере показано, как это сделать:
Java
	List<Map<String, Object>> l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
		new RowMapper<Map<String, Object>>() {
			public Map<String, Object> mapRow(ResultSet rs, int i) throws SQLException {
				Map<String, Object> results = new HashMap<String, Object>();
				String clobText = lobHandler.getClobAsString(rs, "a_clob");  // <1>
				results.put("CLOB", clobText);
				byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");  // <2>
				results.put("BLOB", blobBytes);
				return results;
В следующем примере показано, как создать и вставить BLOB:. <1> Использование метода getClobAsString для получения содержимого CLOB. <2> Использование метода getBlobAsBytes для получения содержимого BLOB.
Передача списков значений для предложения IN.
Стандарт SQL позволяет выбирать строки на основе выражения, включающего список переменных значений.
Типичным примером будет `select * from T_ACTOR, где id в (1, 2, 3)`.
Этот список переменных не поддерживается напрямую для подготовленных операторов Стандарт JDBC.
Вы не можете объявить переменное количество заполнителей.

Вам нужен номер вариантов с нужным количеством подготовленных заполнителей или вам нужно сгенерировать строку SQL динамически, как только вы узнаете, сколько заполнителей требуется.
Названный поддержка параметров, обеспечиваемая в NamedParameterJdbcTemplate, использует последний подход.
Вы можете передавать значения в виде `java.util.List` (или любого `Iterable`) простых значений.
Этот список используется для вставки необходимых заполнителей в фактический оператор SQL. и передавать значения во время выполнения оператора.
Передача списков значений для предложения IN.
ПРИМЕЧАНИЕ.
Будьте осторожны при передаче большого количества значений.
Стандарт JDBC не гарантирует, что вы можете использовать более 100 значений для списка выражений IN.
Различные базы данных превышают это число, но обычно они имеют жесткий предел допустимого количества значений.
Например, предел Oracle составляет 1000.
Передача списков значений для предложения IN.
В дополнение к примитивным значениям в списке значений вы можете создать java.util.List. объектных массивов.
Этот список может поддерживать несколько выражений, определенных для `in` предложение, такое как `+++select * from T_ACTOR где (id, Last_name) в ((1, 'Джонсон'), (2, 'Харроп'))+++`.
Разумеется, для этого необходимо, чтобы ваша база данных поддерживала этот синтаксис.
Обработка сложных типов для вызовов хранимых процедур.
При вызове хранимых процедур иногда можно использовать сложные типы, специфичные для конкретного типа. база данных.

Чтобы разместить эти типы, Spring предоставляет SqlReturnType для обработки их, когда они возвращаются из вызова хранимой процедуры, и SqlTypeValue, когда они передаются в качестве параметра хранимой процедуры.
Обработка сложных типов для вызовов хранимых процедур.
Интерфейс SqlReturnType имеет единственный метод (с именем getTypeValue), который должен быть реализовано.
Этот интерфейс используется как часть объявления SqlOutParameter.
В следующем примере показано возвращение значения объекта `java.sql.Struct` пользователя. объявленный тип `ITEM_TYPE`: См. пример кода в исходном документе.
Обработка сложных типов для вызовов хранимых процедур.
Вы можете использовать SqlTypeValue для передачи значения объекта Java (например, TestItem) в хранимая процедура.
Интерфейс SqlTypeValue имеет единственный метод (с именем `createTypeValue`), который вы должны реализовать.
Активное соединение передается, и вы можно использовать его для создания объектов, специфичных для базы данных, таких как экземпляры `java.sql.Struct` или экземпляры java.sql.Array.
В следующем примере создается экземпляр java.sql.Struct: См. пример кода в исходном документе.
Обработка сложных типов для вызовов хранимых процедур.
Теперь вы можете добавить это SqlTypeValue к карте, содержащей входные параметры для `execute` вызов хранимой процедуры.
Обработка сложных типов для вызовов хранимых процедур.
Другое использование SqlTypeValue — передача массива значений в хранилище Oracle. процедура.
В Oracle есть метод createOracleArray для OracleConnection, который вы можете доступ, развернув его.

Вы можете использовать SqlTypeValue для создания массива и заполнения его значениями из Java `java.sql.Array`, как показано в следующем примере: См. пример кода в исходном документе.

Сопоставление путей.
Вы можете настроить параметры, связанные с сопоставлением пути и обработкой URL-адреса.
Подробную информацию об отдельных опциях см. {spring-framework-api}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.
Сопоставление путей.
В следующем примере показано, как настроить сопоставление путей: См. пример кода в исходном документе.

Использование ProxyFactoryBean для создания прокси AOP.
Если вы используете контейнер Spring IoC (ApplicationContext или BeanFactory) для своего бизнес-объекты (и так и должно быть!), вы хотите использовать один из Spring AOP.
Реализации FactoryBean. (Помните, что фабричный компонент вводит уровень косвенности, позволяя он создает объекты другого типа.)
Использование ProxyFactoryBean для создания прокси AOP.
ПРИМЕЧАНИЕ.
Поддержка Spring AOP также использует фабричные компоненты под обложкой.
Использование ProxyFactoryBean для создания прокси AOP.
Основной способ создания прокси-сервера AOP в Spring — использовать `org.springframework.aop.framework.ProxyFactoryBean`.
Это дает полный контроль над точки, любые применимые советы и их порядок.
Однако есть более простые варианты, которые предпочтительнее, если вам не нужен такой контроль.
Основы.
ProxyFactoryBean, как и другие реализации Spring FactoryBean, вводит уровень косвенности.
Если вы определяете ProxyFactoryBean с именем foo, объекты, которые ссылка `foo` видит не сам экземпляр `ProxyFactoryBean`, а объект созданный реализацией метода getObject() в ProxyFactoryBean.
Это Метод создает прокси-сервер AOP, который обертывает целевой объект.
Основы.
Одно из наиболее важных преимуществ использования ProxyFactoryBean или другого компонента, поддерживающего IoC. класс для создания прокси АОП заключается в том, что советы и точки также могут быть под управлением IoC.
Это мощная функция, позволяющая использовать определенные подходы, которые трудно реализовать. достичь с другими платформами АОП.

Например, совет может сам ссылаться на объекты приложения (помимо цели, которая должна быть доступна в любом АОП framework), пользуясь всеми возможностями подключения, предоставляемыми Dependency Injection.
Свойства JavaBean.
Как и большинство реализаций FactoryBean, входящих в состав Spring, Класс ProxyFactoryBean сам по себе является JavaBean.
Его свойства используются для:
* Укажите цель, которую вы хотите проксировать.
* Укажите, следует ли использовать CGLIB (описано ниже, а также см. прокси-серверы на основе JDK и CGLIB).
Свойства JavaBean.
Некоторые ключевые свойства унаследованы от org.springframework.aop.framework.ProxyConfig. (суперкласс для всех прокси-фабрик AOP в Spring).
Эти ключевые свойства включают в себя следующее:
* `proxyTargetClass`: `true`, если целевой класс должен быть проксирован, а не
Свойства JavaBean. интерфейсы целевого класса.
Если для этого свойства установлено значение true, то прокси CGLIB создаются (но см. также прокси на основе JDK и CGLIB).
* `optimize`: контролирует, применяется ли к прокси агрессивная оптимизация.
Свойства JavaBean. созданный через CGLIB.
Вам не следует беспечно использовать эту настройку, если вы не полностью понять, как соответствующий прокси-сервер AOP обрабатывает оптимизацию.
В настоящее время это используется только для прокси CGLIB.
Это не имеет никакого эффекта для динамических прокси JDK.

* «заморожено»: если конфигурация прокси-сервера «заморожена», изменения в конфигурации
Свойства JavaBean. больше не разрешено.
Это полезно как для небольшой оптимизации, так и для таких случаев. когда вы не хотите, чтобы вызывающие абоненты могли манипулировать прокси-сервером (через `Advised` интерфейс) после создания прокси.
Значение этого свойства по умолчанию: `false`, поэтому изменения (например, добавление дополнительных советов) разрешены.
* `exposeProxy`: определяет, должен ли текущий прокси быть представлен в
Свойства JavaBean. `ThreadLocal`, чтобы цель могла получить к нему доступ.
Если цель должна получить прокси и для свойства `exposeProxy` установлено значение `true`, цель может использовать Метод `AopContext.currentProxy()`.
* `proxyInterfaces`: массив имен интерфейсов `String`. Если это не указано, CGLIB
Другие свойства, специфичные для ProxyFactoryBean, включают следующее:. используется прокси для целевого класса (но см. также прокси на основе JDK и CGLIB).
* `interceptorNames`: массив `String`, содержащий имена `Advisor`, перехватчика или других советов для
Другие свойства, специфичные для ProxyFactoryBean, включают следующее:. применить.
Заказ важен, он осуществляется в порядке очереди.
То есть что первый перехватчик в списке первым сможет перехватить призыв.
Другие свойства, специфичные для ProxyFactoryBean, включают следующее:.

Имена — это имена компонентов в текущей фабрике, включая имена компонентов от предка. заводы.
Здесь нельзя упоминать ссылки на компоненты, так как это приведет к `ProxyFactoryBean` игнорирует одноэлементную настройку совета.
Другие свойства, специфичные для ProxyFactoryBean, включают следующее:.
Вы можете добавить к имени перехватчика звездочку (`*`).
Это приводит к применение всех компонентов-советников, имена которых начинаются с части перед звездочкой быть применено.
Пример использования этой функции можно найти в Использование советников «`Global`'.
* синглтон: должна ли фабрика возвращать один объект, независимо от того, как
Другие свойства, специфичные для ProxyFactoryBean, включают следующее:. часто вызывается метод getObject().
Несколько реализаций FactoryBean предлагают такой метод.
Значение по умолчанию — true.
Если вы хотите использовать советы с сохранением состояния - для например, для миксинов с сохранением состояния — используйте совет по прототипу вместе с одноэлементным значением `ложь`.
Прокси на основе JDK и CGLIB.
Этот раздел служит исчерпывающей документацией о том, как ProxyFactoryBean выбирает создание прокси на основе JDK или прокси на основе CGLIB для определенной цели объект (который должен быть проксирован).
Прокси на основе JDK и CGLIB.
ПРИМЕЧАНИЕ.

Поведение ProxyFactoryBean в отношении создания на основе JDK или CGLIB. прокси изменились между версиями Spring 1.2.x и 2.0. `ProxyFactoryBean` сейчас демонстрирует аналогичную семантику в отношении интерфейсов автоматического обнаружения, что и интерфейсы Класс TransactionProxyFactoryBean.
Прокси на основе JDK и CGLIB.
Если класс целевого объекта, который должен быть проксирован (далее просто называемый целевой класс) не реализует никаких интерфейсов, прокси на основе CGLIB создано.
Это самый простой сценарий, поскольку прокси-серверы JDK основаны на интерфейсе, и нет интерфейсы означают, что проксирование JDK даже невозможно.
Вы можете подключить целевой компонент и укажите список перехватчиков, установив свойство interceptorNames.
Обратите внимание, что Прокси на основе CGLIB создается, даже если свойство proxyTargetClass объекта Для ProxyFactoryBean установлено значение false. (Это не имеет смысла и лучше всего удалено из определения компонента, поскольку оно в лучшем случае избыточно, а в худшем случае сбивает с толку.)
Прокси на основе JDK и CGLIB.
Если целевой класс реализует один (или несколько) интерфейсов, тип прокси-сервера Создаваемый объект зависит от конфигурации ProxyFactoryBean.
Прокси на основе JDK и CGLIB.
Если для свойства proxyTargetClass объекта ProxyFactoryBean установлено значение true, создается прокси на основе CGLIB.
Это имеет смысл и соответствует принцип наименьшего неожиданности.

Даже если свойство proxyInterfaces объекта Для ProxyFactoryBean установлено одно или несколько полных имен интерфейсов. что для свойства proxyTargetClass установлено значение true, это приводит к возникновению ошибок на основе CGLIB. проксирование вступило в силу.
Прокси на основе JDK и CGLIB.
Если для свойства proxyInterfaces объекта ProxyFactoryBean установлено одно или несколько полные имена интерфейсов, создается прокси-сервер на основе JDK.
Созданный прокси реализует все интерфейсы, указанные в `proxyInterfaces` собственность.
Если целевой класс реализует гораздо больше интерфейсов, чем указанные в свойстве proxyInterfaces, это все хорошо, но те дополнительные интерфейсы не реализуются возвращаемым прокси.
Прокси на основе JDK и CGLIB.
Если свойство proxyInterfaces объекта ProxyFactoryBean не установлено, но целевой класс реализует один (или несколько) интерфейсов, `ProxyFactoryBean` автоматически определяет тот факт, что целевой класс действительно реализовать хотя бы один интерфейс, и будет создан прокси-сервер на основе JDK.
Интерфейсы на самом деле проксируются все интерфейсы, которые целевой класс реализует.
По сути, это то же самое, что предоставить список всех без исключения интерфейс, который целевой класс реализует для свойства proxyInterfaces.
Однако, это значительно меньше работы и менее подвержено опечаткам.
Прокси-интерфейсы.
Рассмотрим простой пример ProxyFactoryBean в действии.
Этот пример включает в себя:
* Целевой компонент, который проксируется. Это определение bean-компонента personTarget в
Прокси-интерфейсы. пример.
* «Советник» и «Перехватчик» используются для предоставления советов.

* Определение прокси-компонента AOP для указания целевого объекта (компонент `personTarget`),
Прокси-интерфейсы. интерфейсы для прокси и советы по применению.
	<bean id="personTarget" class="com.mycompany.PersonImpl">
		<property name="name" value="Tony"/>
		<property name="age" value="51"/>
	</bean>
	<bean id="myAdvisor" class="com.mycompany.MyAdvisor">
		<property name="someProperty" value="Custom string property value"/>
	</bean>
	<bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor">
	</bean>
	<bean id="person"
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="proxyInterfaces" value="com.mycompany.Person"/>
		<property name="target" ref="personTarget"/>
		<property name="interceptorNames">
			<list>
				<value>myAdvisor</value>
				<value>debugInterceptor</value>
			</list>
		</property>
	</bean>
В следующем листинге показан пример:.

Обратите внимание, что свойство interceptorNames принимает список String, который содержит имена компонентов перехватчики или советники на нынешнем заводе.
Вы можете использовать советники, перехватчики, до, после возвращается и бросает предметы-советы.
Порядок советников имеет большое значение.
В следующем листинге показан пример:.
ПРИМЕЧАНИЕ.
Вам может быть интересно, почему в списке нет ссылок на компоненты.
Причиной этого является что, если одноэлементное свойство ProxyFactoryBean установлено в значение false, оно должно иметь возможность возвращать независимые экземпляры прокси.
Если какой-либо из советников сам является прототипом, независимый экземпляр необходимо будет вернуть, поэтому необходимо иметь возможность получить экземпляр прототипа с завода.
Хранить ссылку недостаточно.
В следующем листинге показан пример:.
Определение bean-компонента `person`, показанное ранее, может использоваться вместо реализации `Person`, как следует:
Java
	Person person = (Person) factory.getBean("person");
В следующем листинге показан пример:.
Другие bean-компоненты в том же контексте IoC могут выражать от него строго типизированную зависимость, например с обычным объектом Java.
В следующем примере показано, как это сделать:
	<bean id="personUser" class="com.mycompany.PersonUser">
		<property name="person"><ref bean="person"/></property>
	</bean>
В следующем листинге показан пример:.

Класс PersonUser в этом примере предоставляет свойство типа Person.
Насколько это касается того, что прокси-сервер АОП может быть прозрачно использован вместо «реального» человека. реализация.
Однако его класс будет динамическим прокси-классом.
Это было бы возможно чтобы привести его к интерфейсу Advised (обсуждается позже).
В следующем листинге показан пример:.
Вы можете скрыть различие между целью и прокси, используя анонимный внутренний боб.
Отличается только определение ProxyFactoryBean. советы включены только для полноты информации.
В следующем примере показано, как использовать анонимный внутренний компонент:
	<bean id="myAdvisor" class="com.mycompany.MyAdvisor">
		<property name="someProperty" value="Custom string property value"/>
	</bean>
	<bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/>
	<bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="proxyInterfaces" value="com.mycompany.Person"/>
		<!-- Use inner bean, not local reference to target -->
		<property name="target">
			<bean class="com.mycompany.PersonImpl">
				<property name="name" value="Tony"/>

<property name="age" value="51"/>
			</bean>
		</property>
		<property name="interceptorNames">
			<list>
				<value>myAdvisor</value>
				<value>debugInterceptor</value>
			</list>
		</property>
	</bean>
В следующем листинге показан пример:.
Преимущество использования анонимного внутреннего компонента заключается в том, что существует только один объект типа Person.
This is useful if we want чтобы пользователи контекста приложения не могли получить ссылку на непредусмотренный объект или необходимость избежать какой-либо двусмысленности с помощью автоматического подключения Spring IoC.
Существует также, возможно, преимущество состоит в том, что определение ProxyFactoryBean является самодостаточным.
Однако бывают случаи, когда удается получить неожиданную цель от Factory на самом деле может быть преимуществом (например, в определенных сценариях тестирования).
Прокси-классы.
Что делать, если вам нужно проксировать класс, а не один или несколько интерфейсов?
Прокси-классы.
Представьте, что в нашем предыдущем примере не было интерфейса Person.
Нам нужно было посоветовать класс под названием Person, который не реализовал никакого бизнес-интерфейса.
В этом случае вы можно настроить Spring для использования прокси CGLIB, а не динамических прокси.
Для этого установите Свойству proxyTargetClass в ProxyFactoryBean, показанному ранее, присвоено значение true.

Хотя лучше всего программировать на интерфейсы, а не на классы, возможность советовать классы, которые не интерфейсы реализации могут быть полезны при работе с устаревшим кодом. (В общем, Весна не является предписывающим.
Хотя это облегчает применение передовой практики, оно позволяет избежать принуждения особый подход.)
Прокси-классы.
Если вы хотите, вы можете принудительно использовать CGLIB в любом случае, даже если у вас есть интерфейсы.
Прокси-классы.
Проксирование CGLIB работает путем создания подкласса целевого класса во время выполнения.
Весна настраивает этот сгенерированный подкласс для делегирования вызовов методов исходной цели. подкласс используется для реализации шаблона Decorator, вплетая в него рекомендации.
Прокси-классы.
Прокси CGLIB обычно должно быть прозрачным для пользователей.
Однако есть некоторые проблемы рассмотреть:
* Классы `final` не могут быть проксированы, поскольку их нельзя расширить.
* `final` методы не рекомендуются, поскольку их нельзя переопределить.
* `private` методы не рекомендуются, поскольку их нельзя переопределить.
* Методы, которые не видны, обычно упаковывают частные методы в родительский класс.
Прокси-классы. из другого пакета, рекомендовать нельзя, поскольку они фактически являются частными.
Прокси-классы.
ПРИМЕЧАНИЕ.
Нет необходимости добавлять CGLIB в ваш путь к классам.
CGLIB переупакован и включен в JAR `spring-core`.
Другими словами, АОП на основе CGLIB работает «из коробки», как и Динамические прокси JDK.
Прокси-классы.

Разница в производительности между прокси CGLIB и динамическими прокси невелика.
В этом случае производительность не должна быть решающим фактором.
Использование «Глобальных» советников.
При добавлении звездочки к имени перехватчика все советники с именами компонентов, совпадающими часть перед звездочкой добавляется в цепочку советников.
Это может пригодиться если вам нужно добавить стандартный набор "глобальных" советников.
В следующем примере определяется два глобальных советника:
	<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target" ref="service"/>
		<property name="interceptorNames">
			<list>
				<value>global*</value>
			</list>
		</property>
	</bean>
	<bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/>
	<bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/>

API Pointcut Spring.
В этом разделе описывается, как Spring реализует важную концепцию pointcut.
Концепции.
Модель pointcut в Spring позволяет повторно использовать pointcut независимо от типов советов.
Вы можете нацеливайтесь на разные советы с помощью одного и того же пункта.
Концепции.
Интерфейс `org.springframework.aop.Pointcut` является центральным интерфейсом, используемым для целевые рекомендации для конкретных классов и методов.
Полный интерфейс выглядит следующим образом:
	public interface Pointcut {
		ClassFilter getClassFilter();
		MethodMatcher getMethodMatcher();
Концепции.
Разделение интерфейса Pointcut на две части позволяет повторно использовать класс и метод. сопоставление частей и операции детальной композиции (например, выполнение «объединения»). с другим сопоставителем методов).
Концепции.
Интерфейс ClassFilter используется для ограничения выделения точки заданным набором целей. занятия.
Если метод matches() всегда возвращает true, все целевые классы совпало.
В следующем листинге показано определение интерфейса ClassFilter:
	public interface ClassFilter {
		boolean matches(Class clazz);
	public interface MethodMatcher {
		boolean matches(Method m, Class<?> targetClass);
		boolean isRuntime();
		boolean matches(Method m, Class<?> targetClass, Object... args);
Интерфейс MethodMatcher обычно более важен.
Полный интерфейс выглядит следующим образом:.
Метод matchs(Method, Class) используется для проверки того, был ли этот срез когда-либо соответствует заданному методу целевого класса.

Эту оценку можно выполнить, когда АОП прокси создается, чтобы избежать необходимости проверки при каждом вызове метода.
Если Метод matchs с двумя аргументами возвращает true для данного метода, а метод isRuntime() метод для MethodMatcher возвращает true, метод сопоставления с тремя аргументами вызывается при каждом вызове метода.
Это позволяет точечно просмотреть переданные аргументы. к вызову метода непосредственно перед началом целевого совета.
Интерфейс MethodMatcher обычно более важен.
Полный интерфейс выглядит следующим образом:.
Большинство реализаций MethodMatcher являются статическими, то есть их метод isRuntime() возвращает `ложь`.
В этом случае метод matchs с тремя аргументами никогда не вызывается.
Интерфейс MethodMatcher обычно более важен.
Полный интерфейс выглядит следующим образом:.
СОВЕТ: Если возможно, постарайтесь сделать точечные вырезы статичными, позволяя платформе АОП кэшировать результаты оценки pointcut при создании прокси-сервера AOP.
Операции над разрезами.
Spring поддерживает операции (в частности, объединение и пересечение) над точками.
Операции над разрезами.
Объединение означает методы, которым соответствует любой pointcut.
Пересечение означает методы, которым соответствуют оба точечных разреза.
Союз обычно более полезен.
Вы можете создавать точечные вырезы, используя статические методы в `org.springframework.aop.support.Pointcuts` или с помощью класса Класс ComposablePointcut в том же пакете.
Однако использование точки AspectJ выражения обычно является более простым подходом.
Выражение AspectJ.

Начиная с версии 2.0, наиболее важным типом pointcut, используемым Spring, является `org.springframework.aop.aspectj.AspectJExpressionPointcut`.
Это точка, которая использует библиотеку, поставляемую AspectJ, для анализа строки выражения pointcut AspectJ.
Выражение AspectJ.
См. предыдущая глава для обсуждения поддерживаемых примитивов pointcut AspectJ.
Удобство реализации Pointcut.
Spring предоставляет несколько удобных реализаций pointcut.
Вы можете использовать некоторые из них напрямую; другие предназначены для создания подклассов в точках, специфичных для конкретного приложения.
Статические точечные вырезы основаны на методе и целевом классе и не могут учитывать аргументы метода.
Статических точечных вырезов достаточно (и они являются лучшими) для большинства случаев.
Spring может оценить статический pointcut только один раз, при первом вызове метода.
После этого нет необходимости заново оценивать pointcut при каждом вызове метода.
Статические точечные вырезы.
В оставшейся части этого раздела описываются некоторые реализации статических точечных вырезов, которые входит в состав Spring.
Регулярные выражения Pointcuts.
Один очевидный способ указать статические точки — регулярные выражения.
Несколько АОП фреймворки, помимо Spring, делают это возможным. `org.springframework.aop.support.JdkRegexpMethodPointcut` — это общий регулярный выражение pointcut, использующее поддержку регулярных выражений в JDK.
Регулярные выражения Pointcuts.
С помощью класса JdkRegexpMethodPointcut вы можете предоставить список строк шаблона.

Если какой-либо из них совпадает, то pointcut оценивается как «истина». (Как следствие, результирующий точечный разрез фактически является объединением указанных шаблонов.)
Регулярные выражения Pointcuts.
В следующем примере показано, как использовать JdkRegexpMethodPointcut: См. пример кода в исходном документе.
Регулярные выражения Pointcuts.
Spring предоставляет удобный класс RegexpMethodPointcutAdvisor, который позволяет нам также ссылайтесь на «Совет» (помните, что «Совет» может быть перехватчиком перед советом, кидает советы и др.).
За кулисами Spring использует JdkRegexpMethodPointcut.
Использование RegexpMethodPointcutAdvisor упрощает подключение, поскольку один компонент инкапсулирует оба компонента. pointcut и советы, как показано в следующем примере: См. пример кода в исходном документе.
Регулярные выражения Pointcuts.
Вы можете использовать RegexpMethodPointcutAdvisor с любым типом Advice.
Pointcuts на основе атрибутов.
Важным типом статического точечного выреза является точечный вырез, управляемый метаданными.
При этом используется значения атрибутов метаданных (обычно метаданные уровня источника).
Динамические точки.
Оценка динамических точек обходится дороже, чем статических.
Они принимают во внимание аргументы метода, а также статическую информацию.
Это означает, что они должны быть оценивается при каждом вызове метода и что результат не может быть кэширован, так как аргументы будут варьироваться.
Динамические точки.
Основным примером является pointcut «потока управления».
Поток управления.

Pointcuts потока управления Spring концептуально аналогичны pointcuts `cflow` в AspectJ. хотя и менее мощный. (В настоящее время невозможно указать, что pointcut выполняется ниже точки соединения, соответствующей другой точке.) Точка потока управления соответствует текущий стек вызовов.
Например, он может сработать, если точка соединения была вызвана методом в пакете com.mycompany.web или в классе SomeCaller.
Срезы точек потока управления указываются с помощью класса org.springframework.aop.support.ControlFlowPointcut.
Поток управления.
ПРИМЕЧАНИЕ.
Оценка точек потока управления во время выполнения значительно дороже, чем даже другие динамические точки.
Стоимость Java 1.4 примерно в пять раз выше стоимости других динамических точечные разрезы.
Суперклассы Pointcut.
Spring предоставляет полезные суперклассы pointcut, которые помогут вам реализовать свои собственные pointcut.
Суперклассы Pointcut.
Поскольку статические точки наиболее полезны, вам, вероятно, следует создать подкласс `StaticMethodMatcherPointcut`.
Для этого необходимо реализовать только один абстрактный метод (хотя вы можете переопределить другие методы для настройки поведения).
В следующем примере показано, как создать подкласс `StaticMethodMatcherPointcut`:
Java
	class TestStaticPointcut extends StaticMethodMatcherPointcut {
		public boolean matches(Method m, Class targetClass) {
			// вернуть true, если пользовательские критерии совпадают
	class TestStaticPointcut : StaticMethodMatcherPointcut() {
Суперклассы Pointcut.
Существуют также суперклассы для динамических точек.
Вы можете использовать пользовательские точки с любым типом рекомендаций.
Пользовательские точечные вырезы.

Поскольку точечные вырезы в Spring AOP представляют собой классы Java, а не функции языка (как в AspectJ), вы можете объявлять собственные точки, статические или динамические.
Пользовательский pointcuts в Spring могут быть сколь угодно сложными.
Однако мы рекомендуем использовать pointcut AspectJ. язык выражения, если можете.
Пользовательские точечные вырезы.
ПРИМЕЧАНИЕ.
Более поздние версии Spring могут предлагать поддержку «семантических точек», предлагаемых JAC. например, «все методы, которые изменяют переменные экземпляра в целевом объекте».

Использование `@PostConstruct` и `@PreDestroy`.
CommonAnnotationBeanPostProcessor не только распознает аннотацию @Resource. но также аннотации жизненного цикла JSR-250: `jakarta.annotation.PostConstruct` и `jakarta.annotation.PreDestroy`.
Представленная в Spring 2.5 поддержка этих аннотации предлагают альтернативу механизму обратного вызова жизненного цикла, описанному в `CommonAnnotationBeanPostProcessor` регистрируется в `ApplicationContext` Spring, метод, содержащий одну из этих аннотаций, вызывается в той же точке жизненного цикла как соответствующий метод интерфейса жизненного цикла Spring или явно объявленный обратный вызов метод.
В следующем примере кэш предварительно заполняется при инициализации и очищается при уничтожении:
Java
	public class CachingMovieLister {
		@PostConstruct
		public void populateMovieCache() {
			// заполняет кэш фильма при инициализации...
		@PreDestroy
		public void clearMovieCache() {
			// очищает кэш фильма при уничтожении...
	class CachingMovieLister {
Использование `@PostConstruct` и `@PreDestroy`.
Подробную информацию о последствиях объединения различных механизмов жизненного цикла см.
Использование `@PostConstruct` и `@PreDestroy`. [ПРИМЕЧАНИЕ] = Как и @Resource, типы аннотаций @PostConstruct и @PreDestroy были частью стандартных библиотек Java от JDK 6 до 8.
Однако весь `javax.annotation` пакет был отделен от основных модулей Java в JDK 9 и в конечном итоге удален в JDK 11.

Начиная с Jakarta EE 9, пакет теперь находится в `jakarta.annotation`.
Если необходимо, артефакт `jakarta.annotation-api` необходимо получить через Maven Central сейчас, просто быть добавленным в путь к классам приложения, как и любая другая библиотека.

Программное создание прокси-серверов AOP с помощью ProxyFactory.
Программно создавать прокси-серверы AOP с помощью Spring легко.
Это позволяет вам использовать Spring AOP без зависимости от Spring IoC.
Интерфейсы, реализованные целевым объектом: автоматически проксируется.
В следующем листинге показано создание прокси для целевого объекта с одним перехватчик и один советник:
Java
	ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
	factory.addAdvice(myMethodInterceptor);
	factory.addAdvisor(myAdvisor);
	MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();
Первым шагом является создание объекта типа `org.springframework.aop.framework.ProxyFactory`.
Вы можете создать это с помощью цели объект, как в предыдущем примере, или укажите интерфейсы, которые будут проксироваться в альтернативном конструктор.
Вы можете добавить совет (с перехватчиками как специализированный вид совета), советников или и то, и другое. и манипулировать ими на протяжении всей жизни ProxyFactory.
Если вы добавите `IntroductionInterceptionAroundAdvisor`, вы можете заставить прокси реализовать дополнительные интерфейсы.
Существуют также удобные методы ProxyFactory (унаследованные от AdvisedSupport). которые позволяют вам добавлять другие типы советов, например, предыдущие и выбрасывающие советы.
AdvisedSupport — это суперкласс ProxyFactory и ProxyFactoryBean.
СОВЕТ: Интеграция создания прокси-сервера AOP с платформой IoC является лучшей практикой в большинстве случаев. приложения.
Мы рекомендуем вам экспортировать конфигурацию из кода Java с помощью AOP. как и должно быть в целом.

Программная регистрация компонентов.
Начиная с Spring Framework 7, реализована первоклассная поддержка программной регистрации компонентов. предоставляется через {spring-framework-api}/beans/factory/BeanRegistrar.html[`BeanRegistrar`] интерфейс, который можно реализовать для программной регистрации компонентов в гибком и эффективный способ.
Программная регистрация компонентов.
Эти реализации регистратора компонентов обычно импортируются с аннотацией @Import. на классах `@Configuration`.
См. пример кода в исходном документе.
Программная регистрация компонентов.
ПРИМЕЧАНИЕ.
Вы можете использовать условные аннотации на уровне типа ({spring-framework-api}/context/annotation/Conditional.html[`@Conditional`], но и другие варианты) для условного импорта связанных регистраторов bean-компонентов.
Программная регистрация компонентов.
The bean registrar implementation uses {spring-framework-api}/beans/factory/BeanRegistry.html[`BeanRegistry`] and {spring-framework-api}/core/env/Environment.html[`Environment`] API для программной регистрации bean-компонентов в кратком изложении и гибкий способ.
Например, он допускает пользовательскую регистрацию через выражение if, цикл `for` и т. д.
См. пример кода в исходном документе.
Программная регистрация компонентов.
ПРИМЕЧАНИЕ.
Регистраторы компонентов поддерживаются с помощью Ahead of Time Optimizations. либо на JVM, либо с собственными образами GraalVM, в том числе при использовании поставщиков экземпляров.

* TransactionTemplate или TransactionalOperator.
* Непосредственная реализация TransactionManager.
Spring Framework предоставляет два средства программного управления транзакциями, используя:.
Команда Spring обычно рекомендует TransactionTemplate для программных операций. управление транзакциями в императивных потоках и TransactionalOperator для реактивного кода.
Второй подход аналогичен использованию JTA API UserTransaction, однако исключение обработка менее трудоемка.
Использование TransactionTemplate.
TransactionTemplate использует тот же подход, что и другие шаблоны Spring, такие как `JdbcTemplate`.
Он использует подход обратного вызова (чтобы освободить код приложения от необходимости выполнить стандартное приобретение и высвободить транзакционные ресурсы) и приводит к код, управляемый намерением, поскольку ваш код фокусируется исключительно на том, что ты хочешь сделать.
Использование TransactionTemplate.
ПРИМЕЧАНИЕ.
Как показывают следующие примеры, использование TransactionTemplate абсолютно соединяет вас с инфраструктурой транзакций и API Spring.
Программное или нет управление транзакциями подходит для ваших нужд разработки — это решение, которое вы придется сделать самому.
Использование TransactionTemplate.
Код приложения, который должен выполняться в контексте транзакций и явно использует TransactionTemplate напоминает следующий пример.
Вы как приложение разработчик может написать реализацию TransactionCallback (обычно выражаемую как анонимный внутренний класс), содержащий код, который вам нужно запустить в контексте транзакция.
Затем вы можете передать экземпляр своего пользовательского TransactionCallback в Метод `execute(..)`, представленный в `TransactionTemplate`.
В следующем примере показано, как это сделать:
Java
	public class SimpleService implements Service {

// один шаблон TransactionTemplate, общий для всех методов в этом примере.
		private final TransactionTemplate transactionTemplate;
		// Использовать конструктор для предоставления PlatformTransactionManager.
		public SimpleService(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);
		public Object someServiceMethod() {
			return transactionTemplate.execute(new TransactionCallback() {
				// код этого метода выполняется в контексте транзакции
				public Object doInTransaction(TransactionStatus status) {
					updateOperation1();
					return resultOfUpdateOperation2();
Использование TransactionTemplate.
Если возвращаемого значения нет, вы можете использовать удобный класс TransactionCallbackWithoutResult. с анонимным классом следующим образом:
Java
	transactionTemplate.execute(new TransactionCallbackWithoutResult() {
		protected void doInTransactionWithoutResult(TransactionStatus status) {
			updateOperation1();
			updateOperation2();
Использование TransactionTemplate.
Код внутри обратного вызова может откатить транзакцию, вызвав метод `setRollbackOnly()` для предоставленного объекта `TransactionStatus`, как показано ниже:
Java
	transactionTemplate.execute(new TransactionCallbackWithoutResult() {
		protected void doInTransactionWithoutResult(TransactionStatus status) {
			try {
				updateOperation1();
				updateOperation2();
			} catch (SomeBusinessException ex) {
				status.setRollbackOnly();
Указание настроек транзакции.
Вы можете указать параметры транзакции (например, режим распространения, уровень изоляции, таймаут и т. д.) в TransactionTemplate либо программно, либо в конфигурация.
По умолчанию экземпляры TransactionTemplate имеют В следующем примере показана программная настройка параметров транзакций для a specific `TransactionTemplate:`
Java

public class SimpleService implements Service {
		private final TransactionTemplate transactionTemplate;
		public SimpleService(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);
			// настройки транзакции могут быть заданы здесь явно, если это необходимо
			this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
			this.transactionTemplate.setTimeout(30); // 30 seconds
			// и так далее...
Указание настроек транзакции.
В следующем примере определяется TransactionTemplate с некоторыми пользовательскими транзакционными настройки с помощью конфигурации Spring XML:
	<bean id="sharedTransactionTemplate"
			class="org.springframework.transaction.support.TransactionTemplate">
		<property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/>
		<property name="timeout" value="30"/>
	</bean>
Указание настроек транзакции.
Затем вы можете внедрить `sharedTransactionTemplate` на столько услуг, сколько необходимо.
Указание настроек транзакции.
Наконец, экземпляры класса TransactionTemplate являются потокобезопасными. не поддерживать разговорного состояния.
Однако экземпляры TransactionTemplate поддерживать состояние конфигурации.
Таким образом, хотя несколько классов могут использовать один экземпляр TransactionTemplate, если классу необходимо использовать TransactionTemplate с другие настройки (например, другой уровень изоляции), необходимо создать два отдельных экземпляра TransactionTemplate.
Использование TransactionalOperator.
TransactionalOperator имеет конструкцию оператора, аналогичную другим реактивным операторам. операторы.

Он использует подход обратного вызова (чтобы освободить код приложения от необходимости выполнять шаблонное получение и освобождение транзакционных ресурсов) и приводит к созданию кода, который управляемый намерением, поскольку ваш код фокусируется исключительно на том, что вы хотите сделать.
Использование TransactionalOperator.
ПРИМЕЧАНИЕ.
Как показывают следующие примеры, использование TransactionalOperator абсолютно соединяет вас с инфраструктурой транзакций и API Spring.
Программное или нет управление транзакциями подходит для ваших нужд разработки — это решение, которое у вас есть сделать себя.
Использование TransactionalOperator.
Код приложения, который должен выполняться в контексте транзакций и явно использует TransactionalOperator напоминает следующий пример:
Java
	public class SimpleService implements Service {
		// один транзакционный оператор, общий для всех методов в этом примере.
		private final TransactionalOperator transactionalOperator;
		// Использовать конструктор для предоставления ReactiveTransactionManager.
		public SimpleService(ReactiveTransactionManager transactionManager) {
			this.transactionalOperator = TransactionalOperator.create(transactionManager);
		public Mono<Object> someServiceMethod() {
			// код этого метода выполняется в контексте транзакции
			Mono<Object> update = updateOperation1();
			return update.then(resultOfUpdateOperation2).as(transactionalOperator::transactional);
* В стиле оператора с использованием типов Project Reactor (`mono.as(transactionalOperator::transactional)`)
* Стиль обратного вызова для всех остальных случаев (`transactionalOperator.execute(TransactionCallback<T>)`)
TransactionalOperator можно использовать двумя способами:.

Код внутри обратного вызова может откатить транзакцию, вызвав setRollbackOnly(). метод для предоставленного объекта ReactiveTransaction следующим образом:
Java
	transactionalOperator.execute(new TransactionCallback<>() {
		public Mono<Object> doInTransaction(ReactiveTransaction status) {
			return updateOperation1().then(updateOperation2)
						.doOnError(SomeBusinessException.class, e -> status.setRollbackOnly());
Отменить сигналы.
В Reactive Streams «подписчик» может отменить свою «подписку» и прекратить `Издательство`.
Операторы в Project Reactor, а также в других библиотеках, таких как `next()`, `take(long)`, `timeout(Duration)` и другие могут выдавать отмену.
Нет никакого способа знать причину отмены, является ли это ошибкой или просто отсутствием интерес потреблять дальше.
Начиная с версии 5.3 сигналы отмены приводят к откату.
В результате важно учитывать операторы, используемые после транзакции. `Издательство`.
В частности, в случае Flux или другого многозначного издателя, весь вывод должен быть использован, чтобы транзакция завершилась.
Указание настроек транзакции.
Вы можете указать параметры транзакции (например, режим распространения, уровень изоляции, таймаут и т. д.) для TransactionalOperator.
По умолчанию Экземпляры TransactionalOperator имеют В следующем примере показана настройка параметров транзакций для конкретного `ТранзакционныйОператор:`
Java
	public class SimpleService implements Service {
		private final TransactionalOperator transactionalOperator;
		public SimpleService(ReactiveTransactionManager transactionManager) {

DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
			// настройки транзакции могут быть заданы здесь явно, если это необходимо
			definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
			definition.setTimeout(30); // 30 seconds
			// и так далее...
			this.transactionalOperator = TransactionalOperator.create(transactionManager, definition);
Использование TransactionManager.
В следующих разделах объясняется программное использование императивных и реактивных транзакций. менеджеры.
Использование «PlatformTransactionManager».
Для императивных транзакций вы можете использовать `org.springframework.transaction.PlatformTransactionManager` напрямую для управления вашими транзакция.
Для этого передайте реализацию PlatformTransactionManager, которую вы используйте для своего компонента через ссылку на компонент.
Затем, используя TransactionDefinition и Объекты TransactionStatus позволяют инициировать транзакции, откатывать их и фиксировать. следующий пример показывает, как это сделать:
Java
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();
	// явно указать имя транзакции можно только программно
	def.setName("SomeTxName");
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
	TransactionStatus status = txManager.getTransaction(def);
	try {
		// поместите сюда свою бизнес-логику
	} catch (MyException ex) {
		txManager.rollback(status);
		throw ex;
	txManager.commit(status);
	txManager.commit(status)
Использование ReactiveTransactionManager.
При работе с реактивными транзакциями вы можете использовать `org.springframework.transaction.ReactiveTransactionManager` напрямую для управления вашими транзакция.

Для этого передайте реализацию `ReactiveTransactionManager`, которую вы используйте для своего компонента через ссылку на компонент.
Затем, используя TransactionDefinition и Объекты `ReactiveTransaction` позволяют инициировать транзакции, откатывать их и фиксировать. следующий пример показывает, как это сделать:
Java
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();
	// явно указать имя транзакции можно только программно
	def.setName("SomeTxName");
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
	Mono<ReactiveTransaction> reactiveTx = txManager.getReactiveTransaction(def);
	reactiveTx.flatMap(status -> {
		Mono<Object> tx = ...; // put your business logic here
		return tx.then(txManager.commit(status))
				.onErrorResume(ex -> txManager.rollback(status).then(Mono.error(ex)));
		tx.then(txManager.commit(status))
				.onErrorResume { ex -> txManager.rollback(status).then(Mono.error(ex)) }

Свойства, массивы, списки, карты и индексаторы.
Язык выражений Spring обеспечивает поддержку навигации по графам объектов и индексации. в различные структуры.
Свойства, массивы, списки, карты и индексаторы.
ПРИМЕЧАНИЕ.
Значения числовых индексов начинаются с нуля, например, при доступе к элементу n^th^ массив в Java.
Свойства, массивы, списки, карты и индексаторы.
СОВЕТ.
См.
Оператор безопасной навигации. раздел для получения подробной информации о том, как перемещаться по графам объектов и индексировать различные структуры. используя нулевой безопасный оператор.
Навигация по недвижимости.
Вы можете перемещаться по ссылкам на свойства в графе объектов, используя точку для обозначения значение вложенного свойства.
Экземпляры класса Inventor, Pupin и Tesla, были заполненный данными, перечисленными в переместите _вниз_ граф объекта и получите год рождения Теслы и город рождения Пупина, мы используем следующие выражения:
Java
	// оценивается в 1856
	int year = (Integer) parser.parseExpression("birthdate.year + 1900").getValue(context);
	// оценивается как «Смилян»
	String city = (String) parser.parseExpression("placeOfBirth.city").getValue(context);
Навигация по недвижимости. [ПРИМЕЧАНИЕ] = Для первых букв имен свойств допускается нечувствительность к регистру.

Таким образом, выражения в приведенном выше примере могут быть записаны как «Дата рождения.Год + 1900» и `МестоРождения.Город` соответственно.
Кроме того, к свойствам можно получить доступ через вызовы методов — например, `getPlaceOfBirth().getCity()` вместо `месторождения.город`.
Индексирование в массивы и коллекции.
Элемент n^th^ массива или коллекции (например, Set или List) может быть получается с использованием квадратных скобок, как показано в следующем примере.
Индексирование в массивы и коллекции. [ПРИМЕЧАНИЕ] = Если индексированная коллекция представляет собой `java.util.List`, будет доступен элемент n^th^. напрямую через `list.get(n)`.
Индексирование в массивы и коллекции.
Для любого другого типа «Коллекции» доступ к элементу n^th^ будет осуществляться путем итерации коллекция использует свой Iterator и возвращает встретившийся элемент n^th^.
Java
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
	// Массив изобретений
	// оценивается как «Асинхронный двигатель»
	String invention = parser.parseExpression("inventions[3]").getValue(
			context, tesla, String.class);
	// Список участников
	// оценивается как «Никола Тесла»

String name = parser.parseExpression("members[0].name").getValue(
			context, ieee, String.class);
	// Индексация списков и массивов
	// оценивается как «Беспроводная связь»
	String invention = parser.parseExpression("members[0].inventions[6]").getValue(
			context, ieee, String.class);
	// Массив изобретений
	// Список участников
	// Индексация списков и массивов
Индексирование в строки.
Символ n^th^ строки можно получить, указав индекс внутри квадрата. скобки, как показано в следующем примере.
Индексирование в строки.
ПРИМЕЧАНИЕ.
Символ n^th^ строки будет оцениваться как `java.lang.String`, а не как `java.lang.Character`.
Java
	// оценивается как «Т» (8-я буква имени «Никола Тесла»)
	String character = parser.parseExpression("members[0].name[7]")
			.getValue(societyContext, String.class);
Индексирование в Картах.
Содержимое карт получается путем указания значения ключа в квадратных скобках.
В В следующем примере, поскольку ключи для карты офицеров являются строками, мы можем указать строковые литералы, такие как `'президент'`:
Java
	// Офицерская карта
	// оценивается как Inventor("Pupin")

Inventor pupin = parser.parseExpression("officers['president']")
			.getValue(societyContext, Inventor.class);
	// оценивается как «Идвор»
	String city = parser.parseExpression("officers['president'].placeOfBirth.city")
			.getValue(societyContext, String.class);
	String countryExpression = "officers['advisors'][0].placeOfBirth.country";
	// установка значений
	parser.parseExpression(countryExpression)
			.setValue(societyContext, "Croatia");
	// оценивается как «Хорватия»
	String country = parser.parseExpression(countryExpression)
			.getValue(societyContext, String.class);
	// Офицерская карта
	// установка значений
	parser.parseExpression(countryExpression)
			.setValue(societyContext, "Croatia")
Индексирование в объекты.
Свойство объекта можно получить, указав имя свойства внутри квадратные скобки.
Это аналогично доступу к значению карты на основе ее ключа.
В следующем примере показано, как _index_ в объект для получения определенного собственность.
Java
	// Создание изобретателя для использования в качестве объекта корневого контекста.
	Inventor tesla = new Inventor("Nikola Tesla");
	// оценивается как «Никола Тесла»
	String name = parser.parseExpression("#root['name']")
			.getValue(context, tesla, String.class);
Индексирование в пользовательские структуры.

Начиная с Spring Framework 6.2, язык выражений Spring поддерживает индексацию в пользовательские структуры, позволяя разработчикам реализовать и зарегистрировать IndexAccessor с помощью `Контекст оценки`.
Если вы хотите поддержать выражения, которые полагаются на пользовательский метод доступа к индексу, этот метод доступа к индексу должен реализовывать SPI `CompilableIndexAccessor`.
Индексирование в пользовательские структуры.
Для поддержки распространенных случаев использования Spring предоставляет встроенный ReflectiveIndexAccessor, который это гибкий IndexAccessor, который использует отражение для чтения и, при необходимости, записи. индексированная структура целевого объекта.
Доступ к индексированной структуре можно получить через «публичный» метод чтения (при чтении) или «публичный» метод записи (при записи).
Отношения между методом чтения и методом записи основаны на соглашении, согласно которому применим для типичных реализаций индексированных структур.
Индексирование в пользовательские структуры.
ПРИМЕЧАНИЕ.
ReflectiveIndexAccessor также реализует CompilableIndexAccessor для поддержка компиляция в байт-код для доступа на чтение.
Однако обратите внимание, что настроенный метод чтения должен быть можно вызвать через общедоступный класс или общедоступный интерфейс для успешной компиляции.
Индексирование в пользовательские структуры.
Следующие листинги кода определяют перечисление Color и тип FruitMap, которые ведут себя как map, но не реализует интерфейс java.util.Map.
Таким образом, если вы хотите индексировать в FruitMap в выражении SpEL, вам необходимо зарегистрировать IndexAccessor.
	package example;
	public enum Color {
		RED, ORANGE, YELLOW
	public class FruitMap {

private final Map<Color, String> map = new HashMap<>();
		public FruitMap() {
			this.map.put(Color.RED, "cherry");
			this.map.put(Color.ORANGE, "orange");
			this.map.put(Color.YELLOW, "banana");
		public String getFruit(Color color) {
			return this.map.get(color);
		public void setFruit(Color color, String fruit) {
			this.map.put(color, fruit);
Индексирование в пользовательские структуры.
Доступный только для чтения «IndexAccessor» для «FruitMap» можно создать с помощью «new ReflectiveIndexAccessor(FruitMap.class, Color.class, "getFruit")`.
С этим аксессуаром зарегистрирован, а FruitMap зарегистрирован как переменная с именем #fruitMap, SpEL выражение `#fruitMap[T(example.Color).RED]` будет иметь значение `"вишня"`.
Индексирование в пользовательские структуры. «IndexAccessor» для чтения и записи для FruitMap можно создать с помощью «new ReflectiveIndexAccessor(FruitMap.class, Color.class, «getFruit», «setFruit»)`.

С этим зарегистрирован метод доступа, а FruitMap зарегистрирован как переменная с именем #fruitMap, SpEL выражение `#fruitMap[T(example.Color).RED] = 'strawberry'` можно использовать для изменения отображение фруктов для красного цвета от «вишни» до «клубники».
Индексирование в пользовательские структуры.
В следующем примере показано, как зарегистрировать ReflectiveIndexAccessor для индексации. в FruitMap, а затем индексировать в FruitMap в выражении SpEL.
Java
	// Создаем ReflectiveIndexAccessor для FruitMap
	IndexAccessor fruitMapAccessor = new ReflectiveIndexAccessor(
			FruitMap.class, Color.class, "getFruit", "setFruit");
	// Регистрируемый IndexAccessor для FruitMap
	context.addIndexAccessor(fruitMapAccessor);
	// Зарегистрируйте переменную FruitMap
	context.setVariable("fruitMap", new FruitMap());
	// оценивается как "вишня"
	String fruit = parser.parseExpression("#fruitMap[T(example.Color).RED]")
			.getValue(context, String.class);
	// Регистрируемый IndexAccessor для FruitMap
	context.addIndexAccessor(fruitMapAccessor)
	// Зарегистрируйте переменную FruitMap
	context.setVariable("fruitMap", FruitMap())

Механизмы проксирования.
Spring AOP использует либо динамические прокси JDK, либо CGLIB для создания прокси для заданного целевой объект.
Динамические прокси JDK встроены в JDK, тогда как CGLIB является обычным библиотека определения классов с открытым исходным кодом (переупакованная в `spring-core`).
Механизмы проксирования.
Если целевой объект, который будет проксирован, реализует хотя бы один интерфейс, динамический JDK используется прокси, и все интерфейсы, реализованные целевым типом, проксируются.
Если целевой объект не реализует никаких интерфейсов, создается прокси-сервер CGLIB, который является подклассом целевого типа, созданным во время выполнения.
Механизмы проксирования.
Если вы хотите принудительно использовать проксирование CGLIB (например, проксировать каждый метод определенные для целевого объекта, а не только те, которые реализованы его интерфейсами), вы можете это сделать.
Однако вам следует рассмотреть следующие вопросы:
* Классы `final` не могут быть проксированы, поскольку их нельзя расширить.
* `final` методы не рекомендуются, поскольку их нельзя переопределить.
* `private` методы не рекомендуются, поскольку их нельзя переопределить.
* Методы, которые не видны — например, частные методы родительского класса.
Механизмы проксирования. из другого пакета – рекомендовать нельзя, поскольку они фактически являются частными.
* Конструктор вашего проксируемого объекта не будет вызываться дважды, поскольку прокси-сервер CGLIB
Механизмы проксирования. экземпляр создается через Objenesis.

Однако, если ваша JVM не позволяет обход конструктора, вы можете увидеть двойные вызовы и соответствующий журнал отладки записи из поддержки Spring AOP.
* Использование прокси-сервера CGLIB может столкнуться с ограничениями из-за системы модулей Java. Как типичный
Механизмы проксирования.
В этом случае вы не можете создать прокси CGLIB для класса из пакета `java.lang`, когда развертывание по пути модуля.
В таких случаях требуется флаг начальной загрузки JVM. `--add-opens=java.base/java.lang=ALL-UNNAMED` который недоступен для модулей.
Принудительное использование определенных типов прокси-серверов AOP.
Чтобы принудительно использовать прокси CGLIB, установите значение атрибута proxy-target-class. элемента `<aop:config>` в true следующим образом:
	<aop:config proxy-target-class="true">
		<!-- other beans defined here... -->
	</aop:config>
Принудительное использование определенных типов прокси-серверов AOP.
Чтобы принудительно проксировать CGLIB при использовании поддержки автоматического прокси @AspectJ, установите атрибут proxy-target-class элемента `<aop:aspectj-autoproxy>` на `true`, следующим образом:
	<aop:aspectj-autoproxy proxy-target-class="true"/>

Принудительное использование определенных типов прокси-серверов AOP. [ПРИМЕЧАНИЕ] = Несколько разделов `<aop:config/>` свернуты в один единый автоматический прокси-создатель. во время выполнения, который применяет самые _сильные_ настройки прокси-сервера, которые доступны любому из Указаны разделы `<aop:config/>` (обычно из разных файлов определений XML-компонентов).
Это также относится к `<tx:annotation-driven/>` и `<aop:aspectj-autoproxy/>` элементы.
Принудительное использование определенных типов прокси-серверов AOP.
Чтобы внести ясность, используя `proxy-target-class="true"` для `<tx:annotation-driven/>`, Элементы `<aop:aspectj-autoproxy/>` или `<aop:config/>` требуют использования CGLIB прокси _для всех троих_.
Принудительное использование определенных типов прокси-серверов AOP. `@EnableAspectJAutoProxy`, `@EnableTransactionManagement` и связанные с ними конфигурации. аннотации предлагают соответствующий атрибут proxyTargetClass.
Они свернуты в единого унифицированного создателя автоматических прокси, эффективно применяя _сильнейшие_ настройки прокси во время выполнения.
Начиная с версии 7.0, это относится к отдельным прокси-процессорам. а также, например, `@EnableAsync`, последовательно участвуя в едином глобальном настройки по умолчанию для всех попыток автоматического проксирования в данном приложении.

Принудительное использование определенных типов прокси-серверов AOP.
Тип глобального прокси-сервера по умолчанию может различаться в зависимости от настройки.
Хотя основная структура по умолчанию предлагает прокси на основе интерфейса, Spring Boot может - в зависимости от свойства конфигурации — включить прокси на основе классов по умолчанию.
Принудительное использование определенных типов прокси-серверов AOP.
Начиная с версии 7.0, принудительное использование определенного типа прокси для отдельных компонентов возможно через аннотация `@Proxyable` для данного метода `@Bean` или класса `@Component`, с `@Proxyable(INTERFACES)` или `@Proxyable(TARGET_CLASS)`, переопределяя любые глобальные настроено по умолчанию.
Для очень специфических целей вы можете даже указать прокси интерфейс(ы) для использования через `@Proxyable(interfaces=...)`, ограничивая воздействие к выбранным интерфейсам, а не ко всем интерфейсам, которые реализует целевой компонент.
Понимание прокси-серверов AOP.
Spring AOP основан на прокси.
Крайне важно понять семантику что на самом деле означает это последнее утверждение, прежде чем вы напишете свои собственные аспекты или воспользуетесь каким-либо из них. аспекты Spring на основе AOP, поставляемые вместе со Spring Framework.
Понимание прокси-серверов AOP.
Сначала рассмотрим сценарий, в котором у вас есть обычная ссылка на объект без проксирования. как показано в следующем фрагменте кода:
Java
	public class SimplePojo implements Pojo {
		public void foo() {

// Следующий метод вызова является вызовом ссылки this
			this.bar();
		public void bar() {
			// немного логики...
	class SimplePojo : Pojo {
Понимание прокси-серверов AOP.
Если вы вызываете метод по ссылке на объект, этот метод вызывается непосредственно по ссылке. эта ссылка на объект, как показано на следующем изображении и в листинге:
Java
	public class Main {
		public static void main(String[] args) {
			Pojo pojo = new SimplePojo();
			// это метод прямого вызова по ссылке pojo
			pojo.foo();
изображение::aop-proxy-plain-pojo-call.png[].
Ситуация немного меняется, когда ссылка на клиентский код является прокси.
Рассмотрим следующая диаграмма и фрагмент кода:
Java
	public class Main {
		public static void main(String[] args) {
			ProxyFactory factory = new ProxyFactory(new SimplePojo());
			factory.addInterface(Pojo.class);
			factory.addAdvice(new RetryAdvice());
			Pojo pojo = (Pojo) factory.getProxy();
			// это вызов метода на прокси!
			pojo.foo();
изображение::aop-proxy-call.png[].
Здесь важно понимать, что клиентский код внутри метода main(..)` класса Main имеет ссылку на прокси.

Это означает, что метод вызывает это ссылка на объект — это вызовы прокси.
В результате прокси-сервер может делегировать полномочия всем перехватчики (советы), относящиеся к этому конкретному вызову метода.
Однако, как только вызов наконец достигнет целевого объекта (ссылка SimplePojo в данном случае), любые вызовы методов, которые он может выполнить сам по себе, например `this.bar()` или `this.foo()` будут вызываться по ссылке `this`, а не по прокси.
Это имеет важные последствия.
Это означает, что самовызов не приведет к результату в совете, связанном с вызовом метода, получающим возможность запуска.
Другими словами, Самовызов через явную или неявную ссылку this позволит обойти совет.
изображение::aop-proxy-call.png[].
Чтобы решить эту проблему, у вас есть следующие варианты.
изображение::aop-proxy-call.png[].
Избегайте самовызова Лучший подход (термин «лучший» здесь используется в широком смысле) — провести рефакторинг вашего кода таким образом, чтобы что самовызов не происходит.
Это требует некоторой работы с вашей стороны, но это лучший и наименее инвазивный подход.
Внедрить ссылку на самого себя Альтернативный подход заключается в использовании и вызывать методы прокси-сервера через ссылку на себя, а не через `this`.

Используйте `AopContext.currentProxy()` Этот последний подход крайне не рекомендуется, и мы не решаемся указать на него в пользу предыдущие варианты.
Однако в крайнем случае вы можете связать логику внутри ваш класс в Spring AOP, как показано в следующем примере.
Java
	public class SimplePojo implements Pojo {
		public void foo() {
			// Это работает, но по возможности этого следует избегать.
			((Pojo) AopContext.currentProxy()).bar();
		public void bar() {
			// немного логики...
	class SimplePojo : Pojo {
изображение::aop-proxy-call.png[].
Использование AopContext.currentProxy() полностью связывает ваш код со Spring AOP, и это сообщает самому классу о том, что он используется в контексте АОП, что уменьшает некоторые преимущества АОП.
Также требуется, чтобы ProxyFactory была настроен для предоставления прокси-сервера, как показано в следующем примере:
Java
	public class Main {
		public static void main(String[] args) {
			ProxyFactory factory = new ProxyFactory(new SimplePojo());
			factory.addInterface(Pojo.class);
			factory.addAdvice(new RetryAdvice());
			factory.setExposeProxy(true);
			Pojo pojo = (Pojo) factory.getProxy();
			// это вызов метода на прокси!
			pojo.foo();

изображение::aop-proxy-call.png[].
ПРИМЕЧАНИЕ.
Переплетение во время компиляции и загрузки AspectJ не имеет такого самовызова. проблема, потому что они применяют советы в байт-коде, а не через прокси.

Доступ к данным с помощью R2DBC. https://r2dbc.io[R2DBC] («Реактивное подключение к реляционным базам данных») — это проект, управляемый сообществом. попытка спецификации стандартизировать доступ к базам данных SQL с использованием реактивных шаблонов.
* `core`: пакет `org.springframework.r2dbc.core` содержит `DatabaseClient`
Структура абстракции R2DBC Spring Framework состоит из двух разных пакетов:. класс плюс множество связанных классов.
См.
* `connection`: пакет `org.springframework.r2dbc.connection` содержит служебный класс.
Структура абстракции R2DBC Spring Framework состоит из двух разных пакетов:. для простого доступа к ConnectionFactory и различных простых реализаций ConnectionFactory. который вы можете использовать для тестирования и запуска немодифицированного R2DBC.
См.
Структура абстракции R2DBC Spring Framework состоит из двух разных пакетов:.
Использование основных классов R2DBC для управления базовой обработкой R2DBC и обработкой ошибок
Структура абстракции R2DBC Spring Framework состоит из двух разных пакетов:.
В этом разделе описывается, как использовать базовые классы R2DBC для управления базовой обработкой R2DBC. включая обработку ошибок.
Он включает в себя следующие темы:
* Использование `DatabaseClient`
* Выполнение операторов
* Запрос (`SELECT`)
* Обновление (`INSERT`, `UPDATE` и `DELETE`) с помощью `DatabaseClient`
* Фильтры операторов
* Получение автоматически сгенерированных ключей
Использование `DatabaseClient`.

DatabaseClient — это центральный класс основного пакета R2DBC.
Он обрабатывает создание и выпуск ресурсов, что помогает избежать типичных ошибок, таких как забыл закрыть соединение.
Он выполняет основные задачи ядра R2DBC. рабочий процесс (например, создание и выполнение операторов), оставляя код приложения обеспечивать SQL и извлечь результаты.
Класс DatabaseClient:
* Выполняет SQL-запросы
* Операторы обновления и вызовы хранимых процедур.
* Выполняет итерацию по экземплярам `Result`
* Перехватывает исключения R2DBC и преобразует их в общий, более информативный,
Использование `DatabaseClient`. иерархия исключений, определенная в пакете `org.springframework.dao`. (См. ссылку:data-access/dao.adoc#dao-Exceptions [Согласованная иерархия исключений].)
Использование `DatabaseClient`.
Клиент имеет функциональный, гибкий API, использующий реактивные типы для декларативной композиции.
Использование `DatabaseClient`.
Когда вы используете `DatabaseClient` для своего кода, вам нужно только реализовать интерфейсы `java.util.function`, давая им четко определенный контракт.
Учитывая `Соединение`, предоставляемое классом `DatabaseClient`, `Function` обратный вызов создает `Publisher`.
То же самое верно и для отображения функций, которые извлеките результат `Row`.
Использование `DatabaseClient`.

Вы можете использовать DatabaseClient в реализации DAO посредством прямого создания экземпляра. со ссылкой ConnectionFactory или вы можете настроить его в контейнере Spring IoC. и передайте его DAO в качестве ссылки на компонент.
Использование `DatabaseClient`.
Самый простой способ создать объект DatabaseClient — использовать статический фабричный метод, как показано ниже:
Java
	DatabaseClient client = DatabaseClient.create(connectionFactory);
Использование `DatabaseClient`.
ПРИМЕЧАНИЕ.
ConnectionFactory всегда следует настраивать как компонент в Spring IoC. контейнер.
Использование `DatabaseClient`.
Предыдущий метод создает DatabaseClient с настройками по умолчанию.
Использование `DatabaseClient`.
Вы также можете получить экземпляр `Builder` из `DatabaseClient.builder()`.
Вы можете настроить клиента, вызвав следующие методы:
* `….bindMarkers(…)`: укажите конкретную `BindMarkersFactory` для настройки именованного
Использование `DatabaseClient`. параметр для перевода маркера привязки базы данных.
* `….executeFunction(…)`: установите для `ExecuteFunction` способ получения объектов `Statement`.
Использование `DatabaseClient`. беги.
* `….namedParameters(false)`: отключить расширение именованных параметров. Включено по умолчанию.
Использование `DatabaseClient`.
СОВЕТ.
Диалекты разрешаются с помощью {spring-framework-api}/r2dbc/core/binding/BindMarkersFactoryResolver.html[`BindMarkersFactoryResolver`] из ConnectionFactory, обычно путем проверки ConnectionFactoryMetadata.
Использование `DatabaseClient`.

Вы можете позволить Spring автоматически обнаруживать вашу BindMarkersFactory, зарегистрировав класс, реализующий `org.springframework.r2dbc.core.binding.BindMarkersFactoryResolver$BindMarkerFactoryProvider` через `META-INF/spring.factories`. `BindMarkersFactoryResolver` обнаруживает реализации поставщика маркеров привязки из путь к классу с использованием SpringFactoriesLoader.
* Н2
* МарияДБ
* Microsoft SQL-сервер.
* MySQL
* Постгрес
В настоящее время поддерживаются следующие базы данных:.
Весь SQL, выдаваемый этим классом, регистрируется на уровне DEBUG в категории соответствующее полному имени класса экземпляра клиента (обычно `DefaultDatabaseClient`).
Кроме того, каждое выполнение регистрирует контрольную точку в реактивная последовательность для облегчения отладки.
В настоящее время поддерживаются следующие базы данных:.
В следующих разделах представлены некоторые примеры использования DatabaseClient.
Эти примеры не являются исчерпывающим списком всех функций, предоставляемых `DatabaseClient`.
Для этого обратитесь к помощнику {spring-framework-api}/r2dbc/core/DatabaseClient.html[javadoc].
Выполнение операторов. `DatabaseClient` обеспечивает базовую функциональность выполнения оператора.
В следующем примере показано, что вам нужно включить для минимального, но полностью функционального код, создающий новую таблицу:
Java
	Mono<Void> completion = client.sql("CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);")
			.then();

client.sql("CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);")
			.await()
Выполнение операторов. `DatabaseClient` разработан для удобного и свободного использования.
Он предоставляет промежуточные, продолжающие и терминальные методы на каждом этапе спецификация исполнения.
В предыдущем примере выше используется then() для возврата завершения. `Publisher`, который завершается, как только запрос (или запросы, если запрос SQL содержит несколько операторов) завершается.
Выполнение операторов.
ПРИМЕЧАНИЕ. `execute(…)` принимает либо строку запроса SQL, либо запрос `Supplier<String>` чтобы отложить фактическое создание запроса до его выполнения.
Запрос («ВЫБРАТЬ»).
SQL-запросы могут возвращать значения через объекты Row или количество затронутых строк. `DatabaseClient` может возвращать количество обновленных строк или сами строки. в зависимости от выданного запроса.
Java
	Mono<Map<String, Object>> first = client.sql("SELECT id, name FROM person")
			.fetch().first();
Java
	Mono<Map<String, Object>> first = client.sql("SELECT id, name FROM person WHERE first_name = :fn")
			.bind("fn", "Joe")
			.fetch().first();
Следующий запрос использует переменную связывания:.

Возможно, вы заметили использование fetch() в приведенном выше примере. `fetch()` — это оператор продолжения, который позволяет указать, сколько данных вы хотите использовать.
Следующий запрос использует переменную связывания:.
Вызов first() возвращает первую строку результата и отбрасывает оставшиеся строки.
Вы можете использовать данные с помощью следующих операторов:
Следующий запрос использует переменную связывания:.
Без указания дополнительных деталей сопоставления запросы возвращают результаты в виде таблицы. как `Map`, ключи которого представляют собой имена столбцов без учета регистра, которые сопоставляются со значением их столбца.
Следующий запрос использует переменную связывания:.
Вы можете взять под контроль сопоставление результатов, предоставив `Function<Row, T>`, которая получает вызывается для каждой строки, чтобы она могла возвращать произвольные значения (единичные значения, коллекции, карты и предметы).
Java
	Flux<String> names = client.sql("SELECT name FROM person")
			.map(row -> row.get("name", String.class))
			.all();
	Flux<String> names = client.sql("SELECT name FROM person")
			.mapValue(String.class)
			.all();
В качестве альтернативы существует ярлык для сопоставления с одним значением:.
Или вы можете сопоставить объект результата со свойствами компонента или компонентами записи:
	// принимая свойство name для Person

Flux<Person> persons = client.sql("SELECT name FROM person")
			.mapProperties(Person.class)
			.all();
В качестве альтернативы существует ярлык для сопоставления с одним значением:. .А как насчет `null`? **** Результаты реляционной базы данных могут содержать нулевые значения.
Спецификация Reactive Streams запрещает передачу нулевых значений.
Это требование требует правильной обработки `null` в функции извлечения.
Хотя вы можете получить нулевые значения из строки, вы не должны выдавать нулевые значения. ценность.
Вы должны обернуть в объект любые `null` значения (например, `Optional`). для сингулярных значений), чтобы гарантировать, что значение `null` никогда не возвращается напрямую. вашей функцией экстрактора. ****
В качестве альтернативы существует ярлык для сопоставления с одним значением:.
Обновление (INSERT, UPDATE и DELETE) с помощью DatabaseClient.
В качестве альтернативы существует ярлык для сопоставления с одним значением:.
Единственное отличие модифицирующих операторов состоит в том, что эти операторы обычно не возвращайте табличные данные, поэтому для получения результатов используйте `rowsUpdated()`.
В качестве альтернативы существует ярлык для сопоставления с одним значением:.
В следующем примере показан оператор `UPDATE`, который возвращает число. обновленных строк:
Java
	Mono<Integer> affectedRows = client.sql("UPDATE person SET first_name = :fn")

.bind("fn", "Joe")
			.fetch().rowsUpdated();
Привязка значений к запросам.
Типичному приложению требуются параметризованные операторы SQL для выбора или обновить строки в соответствии с некоторыми входными данными.
Обычно это операторы `SELECT`. ограничено предложением WHERE или операторами INSERT и UPDATE, которые принимают входные параметры.
Параметризованные операторы несут риск SQL-инъекции, если параметры не экранируются должным образом. `DatabaseClient` использует R2DBC. `bind` API для устранения риска SQL-инъекции для параметров запроса.
Вы можете предоставить параметризованный оператор SQL с помощью оператора `execute(…)`. и привязать параметры к фактическому `Statement`.
Затем ваш драйвер R2DBC запускается оператор с использованием подготовленных операторов и подстановки параметров.
* По индексу, используя индексы параметров, отсчитываемые от нуля.
* По имени, используя имя-заполнитель.
	db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
			.bind("id", "joe")
			.bind("name", "Joe")
			.bind("age", 34);
	Map<String, Object> params = new LinkedHashMap<>();
	params.put("id", "joe");
	params.put("name", "Joe");

params.put("age", 34);
	db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
			.bindValues(params);
Альтернативно вы можете передать карту имен и значений:.
Или вы можете передать объект параметра со свойствами компонента или компонентами записи:
	// Предполагаемые свойства id, имя, возраст для Person
	db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
			.bindProperties(new Person("joe", "Joe", 34);
Альтернативно вы можете передать карту имен и значений:.
Альтернативно вы можете использовать позиционные параметры для привязки значений к операторам.
Индексы отсчитываются от нуля.
	db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
			.bind(0, "joe")
			.bind(1, "Joe")
			.bind(2, 34);
Альтернативно вы можете передать карту имен и значений:.
Если ваше приложение привязано ко многим параметрам, того же можно добиться одним вызовом:
	List<?> values = List.of("joe", "Joe", 34);

db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
			.bindValues(values);
Альтернативно вы можете передать карту имен и значений:.
Собственные маркеры привязки.R2DBC **** R2DBC использует собственные маркеры привязки базы данных, которые зависят от фактического поставщика базы данных.
Например, Postgres использует индексированные маркеры, такие как `$1`, `$2`, `$n`.
Другим примером является SQL Server, который использует именованные маркеры привязки с префиксом `@`.
Альтернативно вы можете передать карту имен и значений:.
Это отличается от JDBC, который требует `?` в качестве маркеров привязки.
В JDBC настоящие драйверы переводят маркеры привязки `?` в собственные базы данных. маркеры как часть выполнения их оператора.
Альтернативно вы можете передать карту имен и значений:.
Поддержка R2DBC в Spring Framework позволяет использовать собственные маркеры привязки или именованную привязку. маркеры с синтаксисом `:name`.
Альтернативно вы можете передать карту имен и значений:.
Поддержка именованных параметров использует экземпляр BindMarkersFactory для расширения именованных параметров. параметры для собственных маркеров привязки во время выполнения запроса, что дает вам определенная степень переносимости запросов между различными поставщиками баз данных. ****
Альтернативно вы можете передать карту имен и значений:.

Препроцессор запроса разворачивает именованные параметры «Коллекция» в серию привязок. маркеры, чтобы исключить необходимость создания динамических запросов на основе количества аргументов.
Массивы вложенных объектов расширены, чтобы обеспечить возможность использования (например) списков выбора.
Рассмотрим следующий запрос:.
ВЫБЕРИТЕ идентификатор, имя, штат ИЗ таблицы ГДЕ (имя, возраст) В (('Джон', 35), ('Энн', 50))
Java
	List<Object[]> tuples = new ArrayList<>();
	tuples.add(new Object[] {"John", 35});
	tuples.add(new Object[] {"Ann",  50});
	client.sql("ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ (имя, возраст) В (:tuples)")
			.bind("tuples", tuples);
	client.sql("ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ (имя, возраст) В (:tuples)")
			.bind("tuples", tuples)
Предыдущий запрос можно параметризовать и выполнить следующим образом:.
ПРИМЕЧАНИЕ.
Использование списков выбора зависит от поставщика.
Предыдущий запрос можно параметризовать и выполнить следующим образом:.
В следующем примере показан более простой вариант с использованием предикатов IN:
Java

client.sql("ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ возраст В (:ages)")
			.bind("ages", Arrays.asList(35, 50));
	client.sql("ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ возраст В (:ages)")
			.bind("ages", arrayOf(35, 50))
Предыдущий запрос можно параметризовать и выполнить следующим образом:.
ПРИМЕЧАНИЕ.
Сам R2DBC не поддерживает значения типа Collection.
Тем не менее, расширение данного списка в приведенном выше примере работает для именованных параметров. в поддержке Spring R2DBC, например, для использования в предложениях IN, как показано выше.
Однако вставка или обновление столбцов с типом массива (например, в Postgres) требуется тип массива, который поддерживается базовым драйвером R2DBC: обычно массив Java, например `String[]` для обновления столбца `text[]`.
Не передавайте `Collection<String>` или что-то подобное в качестве параметра массива.
Фильтры операторов.
Иногда вам нужно настроить параметры самого `Statement`. прежде чем он запустится.
Для этого зарегистрируйте фильтр `Statement`. (`StatementFilterFunction`) с `DatabaseClient` для перехвата и модифицируйте операторы во время их выполнения, как показано в следующем примере:
Java

client.sql("Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)")
			.filter((s, next) -> next.execute(s.returnGeneratedValues("id")))
			.bind("name", …)
			.bind("state", …);
	client.sql("Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)")
			.filter { s: Statement, next: ExecuteFunction -> next.execute(s.returnGeneratedValues("id")) }
			.bind("name", …)
			.bind("state", …)
Фильтры операторов. `DatabaseClient` также предоставляет упрощенную перегрузку `filter(…)`, которая принимает a `Function<Statement, Statement>`:
Java
	client.sql("Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)")
			.filter(statement -> s.returnGeneratedValues("id"));
	client.sql("ВЫБРАТЬ идентификатор, имя, состояние ИЗ таблицы")
			.filter(statement -> s.fetchSize(25));
	client.sql("Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)")

.filter { statement -> s.returnGeneratedValues("id") }
	client.sql("ВЫБРАТЬ идентификатор, имя, состояние ИЗ таблицы")
			.filter { statement -> s.fetchSize(25) }
Фильтры операторов.
Реализации StatementFilterFunction позволяют фильтровать `Statement` и фильтрация объектов `Result`.
Рекомендации по использованию `DatabaseClient`.
Экземпляры класса DatabaseClient после настройки являются потокобезопасными.
Это важно, потому что это означает, что вы можете настроить один экземпляр `DatabaseClient` а затем безопасно внедрить эту общую ссылку в несколько DAO (или репозиториев).
DatabaseClient имеет состояние, поскольку он поддерживает ссылку на ConnectionFactory. но это состояние не является разговорным.
Рекомендации по использованию `DatabaseClient`.
Обычной практикой при использовании класса DatabaseClient является настройка ConnectionFactory. в файле конфигурации Spring, а затем внедрить зависимость этот общий bean-компонент ConnectionFactory в ваших классах DAO. `DatabaseClient` создается в установщик для ConnectionFactory.
Это приводит к созданию DAO, которые напоминают следующее:
Java
	public class R2dbcCorporateEventDao implements CorporateEventDao {
		private DatabaseClient databaseClient;
		public void setConnectionFactory(ConnectionFactory connectionFactory) {
			this.databaseClient = DatabaseClient.create(connectionFactory);
		// Реализация методов CorporateEventDao, терапевтические R2DBC, далее...
Рекомендации по использованию `DatabaseClient`.
Альтернативой явной конфигурации является использование сканирования компонентов и аннотаций. поддержка внедрения зависимостей.

В этом случае вы можете аннотировать класс с помощью @Component. (что делает его кандидатом на сканирование компонентов) и аннотировать установщик ConnectionFactory метод с `@Autowired`.
В следующем примере показано, как это сделать:
Java
	@Component // <1>
	public class R2dbcCorporateEventDao implements CorporateEventDao {
		private DatabaseClient databaseClient;
		@Autowired // <2>
		public void setConnectionFactory(ConnectionFactory connectionFactory) {
			this.databaseClient = DatabaseClient.create(connectionFactory); // <3>
		// Реализация методов CorporateEventDao, терапевтические R2DBC, далее...
Рекомендации по использованию `DatabaseClient`. <1> Аннотируйте класс с помощью `@Component`. <2> Аннотируйте метод установки `ConnectionFactory` с помощью `@Autowired`. <3> Создайте новый `DatabaseClient` с `ConnectionFactory`.
		// Реализация методов CorporateEventDao, терапевтические R2DBC, далее...
Рекомендации по использованию `DatabaseClient`. <1> Аннотируйте класс с помощью `@Component`. <2> Внедрение в конструктор `ConnectionFactory`. <3> Создайте новый `DatabaseClient` с `ConnectionFactory`.
Рекомендации по использованию `DatabaseClient`.
Независимо от того, какой из приведенных выше стилей инициализации шаблона вы решите использовать (или нет), редко возникает необходимость создавать новый экземпляр класса DatabaseClient каждый раз. время, когда вы хотите запустить SQL.
После настройки экземпляр DatabaseClient становится потокобезопасным.

Если ваше приложение обращается к нескольким баз данных, вам может понадобиться несколько экземпляров `DatabaseClient`, для чего потребуется несколько `ConnectionFactory` и, как следствие, несколько по-разному настроенных `DatabaseClient` экземпляры.
Получение автоматически сгенерированных ключей.
Операторы INSERT могут генерировать ключи при вставке строк в таблицу. который определяет столбец автоинкремента или идентификатора.
Чтобы получить полный контроль над имя столбца, который нужно сгенерировать, просто зарегистрируйте `StatementFilterFunction`, который запрашивает сгенерированный ключ для нужного столбца.
Java
	Mono<Integer> generatedId = client.sql("INSERT INTO table (name, state) VALUES(:name, :state)")
			.filter(statement -> s.returnGeneratedValues("id"))
			.map(row -> row.get("id", Integer.class))
			.first();
	//GeneratedId выдает сгенерированный ключ после выполнения инструкции INSERT.
* Использование `ConnectionFactory`
* Использование `ConnectionFactoryUtils`
* Использование `SingleConnectionFactory`
* Использование `TransactionAwareConnectionFactoryProxy`
* Использование `R2dbcTransactionManager`
Использование ConnectionFactory.
Spring получает соединение R2DBC с базой данных через ConnectionFactory.
ConnectionFactory является частью спецификации R2DBC и является общей точкой входа. для водителей.
Это позволяет контейнеру или фреймворку скрывать пул соединений. и проблемы управления транзакциями из кода приложения.
Как разработчик, вам не нужно знать подробности о том, как подключиться к базе данных.

Это ответственность администратора, который настраивает ConnectionFactory. ты скорее всего, вы будете выполнять обе роли при разработке и тестировании кода, но вы этого не делаете. обязательно нужно знать, как настроен источник производственных данных.
Использование ConnectionFactory.
Когда вы используете уровень R2DBC Spring, вы можете настроить свой собственный с помощью реализация пула соединений, предоставленная третьей стороной.
Популярный реализация — пул R2DBC («r2dbc-pool»).
Реализации Spring распределения предназначены только для целей тестирования и не обеспечивают объединение в пул.
Чтобы настроить ConnectionFactory:. .
Получите соединение с ConnectionFactory, как вы обычно получаете R2DBC ConnectionFactory..
Укажите URL-адрес R2DBC (Правильное значение см. в документации вашего драйвера).
Java
	ConnectionFactory factory = ConnectionFactories.get("r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE");
Использование ConnectionFactoryUtils.
Класс ConnectionFactoryUtils — удобный и мощный вспомогательный класс. который предоставляет `статические` методы для получения соединений из `ConnectionFactory` и закройте соединения (при необходимости).
Использование ConnectionFactoryUtils.
Он поддерживает абонентские ``контекстные`` соединения, например, `R2dbcTransactionManager`.
Использование SingleConnectionFactory.
Класс SingleConnectionFactory является реализацией DelegatingConnectionFactory. интерфейс, который окружает одно соединение, которое не закрывается после каждого использования.
Использование SingleConnectionFactory.

Если какой-либо клиентский код вызывает метод close, предполагая соединение из пула (как при использовании инструменты сохранения), вам следует установить для свойства `suppressClose` значение `true`.
Эта настройка возвращает прокси-сервер с подавлением закрытия, который оборачивает физическое соединение.
Обратите внимание, что вы можете больше не привязывайте это к собственному `Connection` или подобному объекту.
Использование SingleConnectionFactory. `SingleConnectionFactory` — это прежде всего тестовый класс, который может использоваться для конкретных требований. например, конвейерная обработка, если ваш драйвер R2DBC разрешает такое использование.
В отличие от объединенной в пул ConnectionFactory, она постоянно использует одно и то же соединение, избегая чрезмерное создание физических соединений.
Использование TransactionAwareConnectionFactoryProxy.
TransactionAwareConnectionFactoryProxy — это прокси для целевой ConnectionFactory.
Прокси-сервер обертывает цель ConnectionFactory, чтобы добавить осведомленность о транзакциях, управляемых Spring.
Использование TransactionAwareConnectionFactoryProxy.
ПРИМЕЧАНИЕ.
Использование этого класса необходимо, если вы используете клиент R2DBC, который в противном случае не интегрирован. с поддержкой Spring R2DBC.
В этом случае вы все равно можете использовать этот клиент и, по адресу в то же время этот клиент должен участвовать в управляемых транзакциях Spring.
Обычно это предпочтительнее интегрировать клиент R2DBC с правильным доступом к ConnectionFactoryUtils. для управления ресурсами.
Использование TransactionAwareConnectionFactoryProxy.
См. {spring-framework-api}/r2dbc/connection/TransactionAwareConnectionFactoryProxy.html[`TransactionAwareConnectionFactoryProxy`] javadoc для более подробной информации.
Использование R2dbcTransactionManager.

Класс R2dbcTransactionManager представляет собой реализацию ReactiveTransactionManager для один R2DBC ConnectionFactory.
Он связывает соединение R2DBC из указанного ConnectionFactory к подписчику Context, что потенциально позволяет использовать одного подписчика. `Соединение` для каждой `ConnectionFactory`.
Использование R2dbcTransactionManager.
Код приложения необходим для получения соединения R2DBC через `ConnectionFactoryUtils.getConnection(ConnectionFactory)` вместо стандартного R2DBC `ConnectionFactory.create()`.
Все классы фреймворка (такие как DatabaseClient) используют это стратегия неявно.
Если стратегия поиска не используется с менеджером транзакций, она ведет себя точно так же, как `ConnectionFactory.create()` и поэтому может использоваться в любом случае.

Запросы диапазона.
Spring WebFlux поддерживает https://datatracker.ietf.org/doc/html/rfc9110#section-14[RFC 9110] запросы диапазона.
Для обзора см. https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests[Запросы рейнджеров] Руководство по Мозилле.
Запросы диапазона.
Заголовок Range анализируется и прозрачно обрабатывается в WebFlux, когда аннотированный контроллер возвращает Resource или ResponseEntity<Resource> или функциональную конечную точку. поддержка также прозрачно обрабатывается при обслуживании
Запросы диапазона.
СОВЕТ: «Ресурс» не должен быть «InputStreamResource» и с «ResponseEntity<Resource>», статус ответа должен быть 200.
Запросы диапазона.
Базовая поддержка находится в классе HttpRange, который предоставляет методы для анализа. заголовки Range и разделить Resource на List<ResourceRegion>, который, в свою очередь, может быть затем записывается в ответ через ResourceRegionEncoder и ResourceHttpMessageWriter.

* Для обработки запросов к серверу предусмотрено два уровня поддержки.
Модуль Spring-Web содержит следующую базовую поддержку реактивной сети. приложения:. ** HttpHandler: базовый контракт для обработки HTTP-запросов с помощью неблокирующий ввод-вывод и обратное давление Reactive Streams, а также адаптеры для Reactor Netty, Tomcat, Jetty и любой контейнер сервлетов. ** `WebHandler` API: веб-API общего назначения чуть более высокого уровня для обработка запросов, поверх которой конкретные модели программирования, такие как аннотированные построены контроллеры и функциональные конечные точки.
* На стороне клиента существует базовый контракт ClientHttpConnector для выполнения HTTP.
Модуль Spring-Web содержит следующую базовую поддержку реактивной сети. приложения:. запросы с неблокирующим вводом-выводом и противодавлением реактивных потоков, а также адаптеры для {reactor-github-org}/reactor-netty[Reactor Netty], реактивный https://github.com/jetty-project/jetty-reactive-httpclient[Jetty HttpClient] и https://hc.apache.org/[Apache HttpComponents].
Более высокий уровень WebClient, используемый в приложениях. основывается на этом базовом контракте.
* Для клиента и сервера: web/webflux/reactive-spring.adoc#webflux-codecs[codecs] для сериализации и
Модуль Spring-Web содержит следующую базовую поддержку реактивной сети. приложения:. десериализация содержимого HTTP-запроса и ответа.

`HttpHandler`. {spring-framework-api}/http/server/reactive/HttpHandler.html[HttpHandler] — это простой контракт с одним методом для обработки запроса и ответа.
Это намеренно минимален, и его главная и единственная цель — быть минимальной абстракцией. через различные API-интерфейсы HTTP-сервера.
В следующей таблице описаны поддерживаемые API сервера:. [cols="1,2,2", options="header"] |=== | Имя сервера | Используемый серверный API | Поддержка реактивных потоков
| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty]. | Томкэт | Неблокирующий ввод-вывод сервлетов; API Tomcat для чтения и записи ByteBuffers против byte[] | Spring-Web: мост неблокирующего ввода-вывода сервлетов к реактивным потокам
| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty]. | Пристань | Неблокирующий ввод-вывод сервлетов; Jetty API для записи ByteBuffers против byte[] | Spring-Web: мост неблокирующего ввода-вывода сервлетов к реактивным потокам

| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty]. | Контейнер сервлетов | Неблокирующий ввод-вывод сервлетов | Spring-Web: мост неблокирующего ввода-вывода сервлетов к реактивным потокам |===
| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty].
В следующей таблице описаны зависимости сервера (см. также {spring-framework-wiki}/What%27s-New-in-the-Spring-Framework[поддерживаемые версии]):
|Пристань |org.eclipse.jetty |jetty-servlet, причал-сервлет |===.
В приведенных ниже фрагментах кода показано использование адаптеров HttpHandler с API каждого сервера.
Java
	HttpHandler handler = ...
	ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
	HttpServer.create().host(host).port(port).handle(adapter).bindNow();
Java
	HttpHandler handler = ...
	Servlet servlet = new TomcatHttpHandlerAdapter(handler);
	Tomcat server = new Tomcat();
	File base = new File(System.getProperty("java.io.tmpdir"));
	Context rootContext = server.addContext("", base.getAbsolutePath());
	Tomcat.addServlet(rootContext, "main", servlet);

rootContext.addServletMappingDecoded("/", "main");
	server.setHost(host);
	server.setPort(port);
	server.start();
Java
	HttpHandler handler = ...
	JettyCoreHttpHandlerAdapter adapter = new JettyCoreHttpHandlerAdapter(handler);
	Server server = new Server();
	server.setHandler(adapter);
	ServerConnector connector = new ServerConnector(server);
	connector.setHost(host);
	connector.setPort(port);
	server.addConnector(connector);
	server.start();
	server.start()
*Пристань*.
СОВЕТ: В Spring Framework 6.2 JettyHttpHandlerAdapter устарел в пользу JettyCoreHttpHandlerAdapter, который напрямую интегрируется с API Jetty 12. без слоя сервлетов.
*Пристань*.
Вместо этого, чтобы развернуть WAR в контейнере сервлетов, используйте {spring-framework-api}/web/server/adapter/AbstractReactiveWebInitializer.html[`AbstractReactiveWebInitializer`], адаптировать HttpHandler к сервлету через ServletHttpHandlerAdapter.
API `WebHandler`.

Пакет `org.springframework.web.server` основан на предоставить универсальный веб-API для обработки запросов через цепочку нескольких {spring-framework-api}/web/server/WebExceptionHandler.html[`WebExceptionHandler`], несколько {spring-framework-api}/web/server/WebFilter.html[`WebFilter`] и один Компонент {spring-framework-api}/web/server/WebHandler.html[`WebHandler`].
Цепь может можно объединить с WebHttpHandlerBuilder, просто указав на Spring `ApplicationContext`, где находятся компоненты. со застройщиком.
API `WebHandler`.
Хотя у `HttpHandler` есть простая цель - абстрагировать использование различных HTTP-серверов, API WebHandler призван предоставить более широкий набор функций, обычно используемых в веб-приложениях. такие как:
* Пользовательская сессия с атрибутами.
* Атрибуты запроса.
* Решены `Locale` или `Principal` для запроса.
* Доступ к анализируемым и кэшированным данным формы.
* Абстракции для составных данных.
* и многое другое..
Специальные типы бобов.
В таблице ниже перечислены компоненты, которые WebHttpHandlerBuilder может автоматически обнаружить в Spring ApplicationContext или который можно зарегистрировать непосредственно в нем:
Специальные типы бобов. [cols="2,2,1,3", options="header"] |=== | Имя фасоли | Тип фасоли | Граф | Описание

Специальные типы бобов. | <любой> | `WebExceptionHandler` | 0..Н | Обеспечить обработку исключений из цепочки экземпляров WebFilter и цели. `ВебХандлер`.
Для получения более подробной информации см. ссылку:web/webflux/reactive-spring.adoc#webflux-Exception-handler [Исключения].
Специальные типы бобов. | <любой> | `ВебФильтер` | 0..Н | Примените логику стиля перехвата до и после остальной части цепочки фильтров и целевой `WebHandler`.
Для получения более подробной информации см. ссылку:web/webflux/reactive-spring.adoc#webflux-filters[Filters].
Специальные типы бобов. | `webHandler` | `Вебхандлер` | 1 | Обработчик запроса.
Специальные типы бобов. | `webSessionManager` | `WebSessionManager` | 0..1 | Менеджер экземпляров WebSession, предоставляемый через метод ServerWebExchange. `DefaultWebSessionManager` по умолчанию.
Специальные типы бобов. | `serverCodecConfigurer` | `ServerCodecConfigurer` | 0..1 | Для доступа к экземплярам HttpMessageReader для анализа данных формы и составных данных, которые затем предоставляется с помощью методов ServerWebExchange. `ServerCodecConfigurer.create()` по умолчанию.
Специальные типы бобов. | `localeContextResolver` | `LocaleContextResolver` | 0..1 | Резолвер для LocaleContext, предоставляемый через метод ServerWebExchange. «AcceptHeaderLocaleContextResolver» по умолчанию.

Специальные типы бобов. | `forwardedHeaderTransformer` | `ForwardedHeaderTransformer` | 0..1 | Для обработки заголовков пересылаемых типов либо путем их извлечения и удаления, либо только путем их удаления.
Не используется по умолчанию. |===
Java
	Mono<MultiValueMap<String, String>> getFormData();
`ServerWebExchange` предоставляет следующий метод доступа к данным формы:.
DefaultServerWebExchange использует настроенный HttpMessageReader для анализа данных формы. (`application/x-www-form-urlencoded`) в `MultiValueMap`.
По умолчанию FormHttpMessageReader настроен для использования bean-компонентом ServerCodecConfigurer. (см. ссылку:web/webflux/reactive-spring.adoc#webflux-web-handler-api [API веб-обработчика]).
Java
	Mono<MultiValueMap<String, Part>> getMultipartData();
`ServerWebExchange` предоставляет следующий метод доступа к составным данным:. `DefaultServerWebExchange` использует настроенный `HttpMessageReader<MultiValueMap<String, Part>>` для анализа `multipart/form-data`, «многочастный/смешанный» и «многочастный/связанный» контент в «MultiValueMap».
По умолчанию это `DefaultPartHttpMessageReader`, который не имеет никаких сторонних зависимости.
В качестве альтернативы можно использовать SynchronossPartHttpMessageReader, основанный на https://github.com/synchronoss/nio-multipart [Библиотека Synchronoss NIO Multipart].

Оба настраиваются через bean-компонент ServerCodecConfigurer. (см. ссылку:web/webflux/reactive-spring.adoc#webflux-web-handler-api [API веб-обработчика]).
`ServerWebExchange` предоставляет следующий метод доступа к составным данным:.
Для анализа составных данных в потоковом режиме вы можете использовать Flux<PartEvent>, возвращаемый из `PartEventHttpMessageReader` вместо использования `@RequestPart`, поскольку это подразумевает доступ, подобный `Map` на отдельные части по имени и, следовательно, требует полного анализа составных данных.
Напротив, вы можете использовать @RequestBody для декодирования содержимого в Flux<PartEvent> без сбор в MultiValueMap.
ForwardedHeaderTransformer. «ForwardedHeaderTransformer» — это компонент, который изменяет хост, порт и схему запрос на основе перенаправленных заголовков, а затем удаляет эти заголовки.
Если вы заявите это как bean-компонент с именем «forwardedHeaderTransformer», он будет
Вопросы безопасности.
Существуют соображения безопасности для пересылаемых заголовков, поскольку приложение не может знать если заголовки были добавлены прокси-сервером, как предполагалось, или вредоносным клиентом.
Вот почему прокси-сервер на границе доверия должен быть настроен для удаления поступающего ненадежного перенаправленного трафика. снаружи.
Вы также можете настроить ForwardedHeaderTransformer с помощью `removeOnly=true`, в этом случае заголовки удаляются, но не используются.
Фильтры.

В API-интерфейсе Web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] вы можете использовать `WebFilter` для применения стиля перехвата. логика до и после остальной части цепочки обработки фильтров и цели `ВебХандлер`.
При использовании WebFlux Config регистрация `WebFilter` очень проста. как объявление его как bean-компонента Spring и (необязательно) выражение приоритета с помощью `@Order` в объявление bean-компонента или путем реализации Ordered.
КОРС.
Spring WebFlux обеспечивает детальную поддержку конфигурации CORS посредством аннотаций на контроллеры.
Однако, когда вы используете его с Spring Security, мы советуем полагаться на встроенный `CorsFilter`, который необходимо заказывать перед цепочкой фильтров Spring Security.
КОРС.
Дополнительные сведения см. в разделах CORS и CORS `WebFilter`.
Обработчик URL-адресов.
Возможно, вы захотите, чтобы конечные точки вашего контроллера соответствовали маршрутам с косой чертой в конце URL-пути или без нее.
Например, и «GET /home», и «GET /home/» должны обрабатываться методом контроллера, аннотированным `@GetMapping("/home")`.
Обработчик URL-адресов.
Spring предоставляет UrlHandlerFilter, который удаляет конечную косую черту из URL-путей, чтобы обеспечить согласованное представление путей с конечной косой чертой или без нее.

Это важно, чтобы избежать несоответствия между решениями об авторизации на основе URL-адресов и сопоставлениями запросов веб-платформы.
Фильтр может удалить косую черту одним из нескольких способов:
* ответить статусом перенаправления HTTP, который отправляет клиентов по одному и тому же пути без косой черты в конце.
* изменить запрос на удаление косой черты в конце.
Обработчик URL-адресов.
Вот как вы можете создать и настроить UrlHandlerFilter для приложения блога: См. пример кода в исходном документе.
- корневой путь `"/"` исключен из обработки косой черты.
- `@RequestMapping("/")` добавляет конечную косую черту к сопоставлению уровня типа и, следовательно, будет
Имейте в виду следующее:. не отображать, когда применяется обработка косой черты; вместо этого используйте `@RequestMapping` (без атрибута пути).
Исключения.
В API-интерфейсе Web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] вы можете использовать `WebExceptionHandler` для обработки исключения из цепочки экземпляров WebFilter и целевого WebHandler.
При использовании Spring bean и (необязательно) выражение приоритета с помощью `@Order` в объявлении bean-компонента или путем реализации Ordered.

[cols="1,2", options="header"] |=== | Обработчик исключений | Описание. | `ResponseStatusExceptionHandler` | Обеспечивает обработку исключений типа {spring-framework-api}/web/server/ResponseStatusException.html[`ResponseStatusException`] установив ответ на код состояния HTTP исключения.
[cols="1,2", options="header"] |=== | Обработчик исключений | Описание. | `WebFluxResponseStatusExceptionHandler` | Расширение ResponseStatusExceptionHandler, которое также может определять статус HTTP. код аннотации @ResponseStatus для любого исключения.
[cols="1,2", options="header"] |=== | Обработчик исключений | Описание.
Этот обработчик объявлен в файле WebFlux Config.
Кодеки.
Модули Spring-Web и Spring-Core обеспечивают поддержку сериализации и десериализация байтового содержимого в объекты более высокого уровня и обратно посредством неблокирующего ввода-вывода с помощью Противодавление реактивных потоков.
Ниже описывается эта поддержка:
* {spring-framework-api}/core/codec/Encoder.html[`Encoder`] и
Кодеки. {spring-framework-api}/core/codec/Decoder.html[`Decoder`] — это контракты низкого уровня для кодировать и декодировать контент независимо от HTTP.

* {spring-framework-api}/http/codec/HttpMessageReader.html[`HttpMessageReader`] и
Кодеки. {spring-framework-api}/http/codec/HttpMessageWriter.html[`HttpMessageWriter`] – это контракты. для кодирования и декодирования содержимого HTTP-сообщения.
* Encoder можно обернуть EncoderHttpMessageWriter, чтобы адаптировать его для использования в сети.
Кодеки. приложение, а `Decoder` можно обернуть `DecoderHttpMessageReader`.
* {spring-framework-api}/core/io/buffer/DataBuffer.html[`DataBuffer`] абстрагирует разные
Кодеки. представления байтовых буферов (например, Netty `ByteBuf`, `java.nio.ByteBuffer` и т. д.) и на чем работают все кодеки.
См.
Буферы данных и кодеки в Раздел «Spring Core» содержит дополнительную информацию по этой теме.
Кодеки.
Модуль Spring-core предоставляет byte[], ByteBuffer, DataBuffer, Resource и Реализации кодировщика и декодера `String`.
Модуль Spring-Web предоставляет Джексону JSON, Jackson Smile, JAXB2, Protocol Buffers и другие кодеры и декодеры, а также веб-реализации чтения и записи HTTP-сообщений для данных форм, многочастного содержимого, события, отправленные сервером, и другие.
Кодеки.
ClientCodecConfigurer и ServerCodecConfigurer обычно используются для настройки и настроить кодеки для использования в приложении.
См. раздел о настройке
Джексон JSON.

JSON и двоичный JSON ({jackson-github-org}/smile-format-specification[Smile]) оба поддерживаются при наличии библиотеки Джексона.
* Асинхронный неблокирующий анализатор Джексона используется для агрегирования потока байтовых фрагментов.
«JacksonJsonDecoder» работает следующим образом:. в TokenBuffer, каждый из которых представляет объект JSON.
* Каждый TokenBuffer передается в JsonMapper Джексона для создания объекта более высокого уровня.
* При декодировании в издатель с одним значением (например, Mono) используется один TokenBuffer.
* При декодировании многозначному издателю (например, Flux) каждый TokenBuffer передается в
«JacksonJsonDecoder» работает следующим образом:. `JsonMapper`, как только будет получено достаточно байтов для полностью сформированного объекта. входным содержимым может быть массив JSON или любой другой https://en.wikipedia.org/wiki/JSON_streaming[JSON с разделителями строк], например NDJSON, Строки JSON или текстовые последовательности JSON.
* Для издателя с одним значением (например, Mono) просто сериализуйте его через
«JacksonJsonEncoder» работает следующим образом:. `JsonMapper`.
* Для издателя с несколькими значениями, использующего `application/json`, по умолчанию значения собираются с помощью
«JacksonJsonEncoder» работает следующим образом:. `Flux#collectToList()`, а затем сериализовать полученную коллекцию.
* Для издателя с несколькими значениями и типом потокового мультимедиа, например

«JacksonJsonEncoder» работает следующим образом:. `application/x-ndjson` или `application/stream+x-jackson-smile`, кодируйте, записывайте и очистить каждое значение индивидуально, используя https://en.wikipedia.org/wiki/JSON_streaming[формат JSON, разделенный строками].
Другое Типы потокового мультимедиа могут быть зарегистрированы в кодере.
* Для SSE JacksonJsonEncoder вызывается для каждого события, а выходные данные сбрасываются для обеспечения
«JacksonJsonEncoder» работает следующим образом:. доставка без задержек.
«JacksonJsonEncoder» работает следующим образом:. [ПРИМЕЧАНИЕ] = По умолчанию и «JacksonJsonEncoder», и «JacksonJsonDecoder» не поддерживают элементы типа `Строка`.
Вместо этого по умолчанию предполагается, что строка или последовательность строк представляют сериализованный контент JSON, который будет отображаться с помощью CharSequenceEncoder.
Если что вам нужно визуализировать массив JSON из Flux<String>, использовать Flux#collectToList() и закодируйте `Mono<List<String>>`.
Данные формы.
FormHttpMessageReader и FormHttpMessageWriter поддерживают декодирование и кодирование.
Содержимое `application/x-www-form-urlencoded`.
Данные формы.
На стороне сервера, где часто требуется доступ к содержимому формы из нескольких мест. `ServerWebExchange` предоставляет специальный метод `getFormData()`, который анализирует содержимое. через FormHttpMessageReader, а затем кэширует результат для повторного доступа.
См.
Данные формы в
Данные формы.

После использования getFormData() исходное необработанное содержимое больше не может быть прочитано из тело запроса.
По этой причине ожидается, что приложения будут проходить через «ServerWebExchange». последовательно для доступа к кэшированным данным формы, а не для чтения из необработанного тела запроса.
Многочастный.
MultipartHttpMessageReader и MultipartHttpMessageWriter поддерживают декодирование и кодирование «многочастного/формированного» контента, «многочастного/смешанного» и «многочастного/связанного» контента.
В свою очередь, MultipartHttpMessageReader делегирует другому HttpMessageReader. для фактического анализа в `Flux<Part>`, а затем просто собирает части в `MultiValueMap`.
По умолчанию используется `DefaultPartHttpMessageReader`, но это можно изменить с помощью `Конфигуратор Серверкодека`.
Дополнительную информацию о DefaultPartHttpMessageReader см. {spring-framework-api}/http/codec/multipart/DefaultPartHttpMessageReader.html [javadoc `DefaultPartHttpMessageReader`].
Многочастный.
На стороне сервера, где к содержимому многочастной формы может потребоваться доступ из нескольких местах, ServerWebExchange предоставляет специальный метод getMultipartData(), который анализирует содержимое через MultipartHttpMessageReader, а затем кэширует результат для повторного доступа.
См.
Multipart Data в разделе
Многочастный.
После использования getMultipartData() исходный необработанный контент больше не может быть прочитан из тело запроса.
По этой причине приложения должны постоянно использовать getMultipartData(). для повторного доступа к частям, как на карте, или иным образом полагаться на `SynchronossPartHttpMessageReader` для однократного доступа к `Flux<Part>`.

Буферы протоколов. `ProtobufEncoder` и `ProtobufDecoder`, поддерживающие декодирование и кодирование "application/x-protobuf", "application/octet-stream" и содержимое application/vnd.google.protobuf для типов com.google.protobuf.Message.
Они также поддерживают поток значений если контент получен/отправлен с параметром «delimited» в соответствии с типом контента (например, «application/x-protobuf;delimited=true»).
Для этого требуется библиотека com.google.protobuf:protobuf-java версии 3.29 и выше.
Буферы протоколов.
Варианты ProtobufJsonDecoder и ProtobufJsonEncoder поддерживают чтение и запись документов JSON в сообщения Protobuf и обратно.
Для них требуется зависимость «com.google.protobuf:protobuf-java-util».
Обратите внимание: варианты JSON не поддерживают чтение потока сообщений. дополнительную информацию см. в {spring-framework-api}/http/codec/protobuf/Protobuf/ProtobufJsonDecoder.html[javadoc of `ProtobufJsonDecoder`].
Гугл Гсон.
Приложения могут использовать GsonEncoder и GsonDecoder для сериализации и десериализации документов JSON благодаря библиотеке https://google.github.io/gson/[Google Gson].
Этот кодек поддерживает как типы мультимедиа JSON, так и формат NDJSON для потоковой передачи.

Гугл Гсон. [ПРИМЕЧАНИЕ] = Gson не поддерживает неблокирующий анализ, поэтому GsonDecoder не поддерживает десериализацию. к типам `Flux<*>`.
Например, если этот декодер используется для десериализации потока JSON или даже списка элементов как `Flux<*>`, во время выполнения будет выброшено `UnsupportedOperationException`.
Вместо этого приложения должны сосредоточиться на десериализации ограниченных коллекций и использовать Mono<List<*>>` в качестве целевых типов.
Пределы.
Реализации `Decoder` и `HttpMessageReader`, которые буферизуют часть или весь ввод. поток может быть настроен с ограничением максимального количества байтов для буферизации в памяти.
В некоторых случаях буферизация происходит потому, что ввод агрегируется и представляется как единое целое. объект — например, метод контроллера с `@RequestBody byte[]`, данные `x-www-form-urlencoded` и так далее.
Буферизация также может происходить при потоковой передаче, когда разделение входного потока — например, текста с разделителями, потока объектов JSON и так далее.
Для таких случаев потоковой передачи ограничение применяется к количеству связанных байтов. с одним объектом в потоке.
Пределы.
Чтобы настроить размеры буфера, вы можете проверить, используется ли данный `Decoder` или `HttpMessageReader` предоставляет свойство maxInMemorySize, и если да, то в Javadoc будет подробная информация о значении по умолчанию. ценности.

На стороне сервера ServerCodecConfigurer предоставляет единое место, откуда можно установите все кодеки, см. кодеки сообщений HTTP.
На стороне клиента лимит на все кодеки можно изменить в
Пределы.
Для Многочастный анализ ограничение свойства maxInMemorySize размер нефайловых частей.
Для частей файла он определяет порог, при котором часть записывается на диск.
Для частей файла, записываемых на диск, существует дополнительный Свойство maxDiskUsagePerPart для ограничения объема дискового пространства на каждую часть.
Существует также свойство maxParts для ограничения общего количества частей в многочастном запросе.
Чтобы настроить все три в WebFlux, вам необходимо предоставить предварительно настроенный экземпляр от MultipartHttpMessageReader до ServerCodecConfigurer.
Потоковое вещание.
При потоковой передаче ответа HTTP (например, `text/event-stream`, `application/x-ndjson`), важно периодически отправлять данные, чтобы надежно обнаружить отключенного клиента раньше, чем позже.
Такая отправка может быть только для комментариев, пустое событие SSE или любые другие «неактивные» данные, которые эффективно могут служить сердцебиение.
`Буфер данных`. `DataBuffer` — это представление байтового буфера в WebFlux.
Часть Spring Core в этой ссылке есть дополнительная информация об этом в разделе, посвященном на таких серверах, как Netty, байтовые буферы объединяются в пул, подсчитываются ссылки и должны быть освобождены. при потреблении, чтобы избежать утечек памяти.
`Буфер данных`.

Приложениям WebFlux обычно не нужно беспокоиться о таких проблемах, если только они не использовать или создавать буферы данных напрямую, а не полагаться на кодеки для преобразования в и из объектов более высокого уровня, или если они не захотят создавать собственные кодеки.
Для таких В таких случаях ознакомьтесь с информацией в Буферы данных и кодеки. особенно раздел Using DataBuffer.
Ведение журнала уровня DEBUG в Spring WebFlux спроектировано так, чтобы быть компактным, минимальным и дружелюбный к человеку.
Он фокусируется на ценных битах информации, которые полезны в любое время. снова по сравнению с другими, которые полезны только при отладке конкретной проблемы.
Ведение журнала уровня TRACE обычно следует тем же принципам, что и DEBUG (и, например, также не должен быть пожарным шлангом), но может использоваться для устранения любой проблемы.
Кроме того, некоторые журналы сообщения могут иметь разный уровень детализации: TRACE и DEBUG.
Ведение журнала.
Хорошее ведение журнала приходит с опытом использования журналов.
Если вы заметите что-нибудь, что делает не соответствует заявленным целям, пожалуйста, сообщите нам об этом.
Идентификатор журнала.
В WebFlux один запрос может выполняться в нескольких потоках, и идентификатор потока бесполезен для корреляции сообщений журнала, принадлежащих конкретному запросу.
Вот почему По умолчанию сообщения журнала WebFlux имеют префикс идентификатора конкретного запроса.
Идентификатор журнала.

На стороне сервера идентификатор журнала хранится в атрибуте ServerWebExchange. ({spring-framework-api}/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]), а полностью отформатированный префикс на основе этого идентификатора доступен по адресу `ServerWebExchange#getLogPrefix()`.
На стороне `WebClient` идентификатор журнала хранится в Атрибут `ClientRequest` ({spring-framework-api}/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]), а полностью отформатированный префикс доступен из `ClientRequest#logPrefix()`.
Конфиденциальные данные.
Журналы `DEBUG` и `TRACE` могут регистрировать конфиденциальную информацию.
Вот почему параметры формы и заголовки по умолчанию маскируются, и вам необходимо явно включить их полную регистрацию.
Конфиденциальные данные.
В следующем примере показано, как это сделать для запросов на стороне сервера:
Java
	@Configuration
	class MyConfig implements WebFluxConfigurer {
		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			configurer.defaultCodecs().enableLoggingRequestDetails(true);
	@Configuration
	class MyConfig : WebFluxConfigurer {
Конфиденциальные данные.
В следующем примере показано, как это сделать для запросов на стороне клиента:
Java
	Consumer<ClientCodecConfigurer> consumer = configurer ->
			configurer.defaultCodecs().enableLoggingRequestDetails(true);
	WebClient webClient = WebClient.builder()
			.exchangeStrategies(strategies -> strategies.codecs(consumer))

.build();
Аппендеры.
Библиотеки журналирования, такие как SLF4J и Log4J 2, предоставляют асинхронные средства журналирования, которые позволяют избежать блокировка.
Хотя у них есть свои недостатки, такие как потенциальное удаление сообщений. которые нельзя поставить в очередь для регистрации, на данный момент это лучшие доступные варианты для использования в реактивном, неблокирующем приложении.
Пользовательские кодеки.
Приложения могут регистрировать собственные кодеки для поддержки дополнительных типов мультимедиа. или определенное поведение, которое не поддерживается кодеками по умолчанию.
Пользовательские кодеки.
Некоторые параметры конфигурации, предложенные разработчиками, применяются к кодекам по умолчанию.
Пользовательские кодеки могут захотеть получить возможность согласовать эти предпочтения, например обеспечение ограничений буферизации или регистрация конфиденциальных данных.
Пользовательские кодеки.
В следующем примере показано, как это сделать для запросов на стороне клиента:
Java
	WebClient webClient = WebClient.builder()
			.codecs(configurer -> {
				CustomDecoder decoder = new CustomDecoder();
				configurer.customCodecs().registerWithDefaultConfig(decoder);
			.build();

`@RequestAttribute`.
Аналогично @SessionAttribute, вы можете использовать аннотацию @RequestAttribute для получить доступ к уже существующим атрибутам запроса, созданным ранее (например, с помощью `WebFilter`), как показано в следующем примере:
Java
	@GetMapping("/")
	public String handle(@RequestAttribute Client client) { <1>
`@RequestAttribute`. <1> Использование `@RequestAttribute`.

`@RequestBody`.
Вы можете использовать аннотацию @RequestBody, чтобы прочитать тело запроса и десериализовать его в `Объект` через ссылку:web/webflux/reactive-spring.adoc#webflux-codecs[HttpMessageReader].
В следующем примере используется аргумент @RequestBody:
Java
	@PostMapping("/accounts")
	public void handle(@RequestBody Account account) {
`@RequestBody`.
В отличие от Spring MVC, в WebFlux аргумент метода @RequestBody поддерживает реактивные типы. и полностью неблокирующее чтение и потоковую передачу (клиент-сервер).
Java
	@PostMapping("/accounts")
	public void handle(@RequestBody Mono<Account> account) {
`@RequestBody`.
Чтобы настроить или настроить программы чтения сообщений.
`@RequestBody`.
Вы можете использовать @RequestBody в сочетании с jakarta.validation.Valid или Spring.
Аннотация `@Validated`, которая вызывает применение стандартной проверки компонента.
Валидация ошибки вызывают исключение WebExchangeBindException, что приводит к ответу 400 (BAD_REQUEST).
Исключение содержит BindingResult с подробностями об ошибке и может быть обработано в метод контроллера, объявив аргумент с помощью асинхронной оболочки, а затем используя ошибку. связанные операторы:
Java
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Mono<Account> account) {
		// используйте один из операторов onError*...
`@RequestBody`.

Вы также можете объявить параметр «Errors» для доступа к ошибкам проверки, но в этом случае тело запроса не должно быть «Mono» и будет обработано первым:
Java
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Account account, Errors errors) {
		// используйте один из операторов onError*...
`@RequestBody`.
Если проверка метода применяется, поскольку другие параметры имеют аннотации @Constraint, тогда вместо этого возникает HandlerMethodValidationException.
Более подробную информацию см. раздел Validation.

`@RequestHeader`.
Вы можете использовать аннотацию @RequestHeader для привязки заголовка запроса к аргументу метода в контроллер.
[буквальный] [subs="дословно,цитаты"].
Host localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300
Java
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
В следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:. <1> Получите значение заголовка Accept-Encoding. <2> Получите значение заголовка Keep-Alive.
В следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:.
Преобразование типов применяется автоматически, если тип параметра целевого метода не `Строка`.
См. ссылку:web/webflux/controller/ann-methods/typeconversion.adoc [Преобразование типов].

В следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:.
Когда аннотация `@RequestHeader` используется в `Map<String, String>`, Аргумент MultiValueMap<String, String> или HttpHeaders, карта заполняется. со всеми значениями заголовка.
В следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:.
СОВЕТ.
Доступна встроенная поддержка преобразования строки, разделенной запятыми, в массив или коллекция строк или других типов, известных системе преобразования типов.
Для Например, параметр метода, помеченный `@RequestHeader("Accept")`, может иметь тип `String`, но также `String[]` или `List<String>`.

`@RequestParam`.
Вы можете использовать аннотацию @RequestParam для привязки параметров запроса к аргументу метода в контроллер.
Следующий фрагмент кода показывает использование:
Java
	@Controller
	@RequestMapping("/pets")
	public class EditPetForm {
		@GetMapping
		public String setupForm(@RequestParam("petId") int petId, Model model) { <1>
			Pet pet = this.clinic.loadPet(petId);
			model.addAttribute("pet", pet);
			return "petForm";
`@RequestParam`. <1> Использование `@RequestParam`.
	@Controller
	@RequestMapping("/pets")
	class EditPetForm {
`@RequestParam`. <1> Использование `@RequestParam`.
`@RequestParam`.
СОВЕТ: Концепция Servlet API «параметр запроса» объединяет параметры запроса, форму данные и объединяются в одну.
Однако в WebFlux доступ к каждому из них осуществляется индивидуально через `СерверВебExchange`.
Хотя `@RequestParam` привязывается только к параметрам запроса, вы можете использовать привязка данных для применения параметров запроса, данных формы и составных частей к
`@RequestParam`.
Параметры метода, использующие аннотацию @RequestParam, являются обязательными по умолчанию, но вы можете указать, что параметр метода является необязательным, установив обязательный флаг `@RequestParam` значение false или объявив аргумент с помощью java.util.Optional. обертка.
`@RequestParam`.

Преобразование типов применяется автоматически, если тип параметра целевого метода не `Строка`.
См. ссылку:web/webflux/controller/ann-methods/typeconversion.adoc [Преобразование типов].
`@RequestParam`.
Когда аннотация `@RequestParam` объявлена в `Map<String, String>` или `MultiValueMap<String, String>`, карта заполняется всеми параметрами запроса.
`@RequestParam`.
Обратите внимание, что использование @RequestParam не является обязательным — например, для установки его атрибутов.
Автор по умолчанию любой аргумент, который является простым типом значения (как определено {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]) и не разрешается никаким другим преобразователем аргументов, рассматривается как если бы он был аннотирован с `@RequestParam`.

Характеристики устойчивости.
Начиная с версии 7.0, ядро Spring Framework включает в себя общие функции обеспечения устойчивости, в частности <<resilience-annotations-retryable>> и <<resilience-annotations-concurrencylimit>> аннотации для вызовов методов, а также <<resilience-programmatic-retry, поддержка программных повторов>>.
`@Retryable`. {spring-framework-api}/resilience/annotation/Retryable.html[`@Retryable`] — это аннотация. который определяет характеристики повтора для отдельного метода (с аннотацией объявлено на уровне метода) или для всех методов, вызываемых прокси-сервером, в данной иерархии классов. (с аннотацией, объявленной на уровне типа).
    this.jmsClient.destination("notifications").send(...);
@Retryable public void sendNotification() {.
По умолчанию вызов метода будет повторен для любого возникшего исключения: не более 3 повторные попытки (`maxRetries = 3`) после первоначального сбоя и задержка в 1 секунду. между попытками.
@Retryable public void sendNotification() {. [ПРИМЕЧАНИЕ] = Метод `@Retryable` будет вызван хотя бы один раз и повторен не более чем `maxRetries`. раз, где maxRetries — максимальное количество повторных попыток.
В частности, `общее количество попыток = 1 начальная попытка + попытки maxRetries`.

@Retryable public void sendNotification() {.
Например, если для параметра maxRetries установлено значение 4, метод @Retryable будет вызываться при минимум один раз и максимум 5 раз.
@Retryable public void sendNotification() {.
При необходимости это можно специально адаптировать для каждого метода — например, путем сужения исключения для повторной попытки через атрибуты «includes» и «excludes».
Поставляемый типы исключений также будут сопоставляться с исключением, вызванным неудачным вызовом. как вложенные причины.
    this.jmsClient.destination("notifications").send(...);
@Retryable(MessageDeliveryException.class) public void sendNotification() {.
ПРИМЕЧАНИЕ. `@Retryable(MessageDeliveryException.class)` — это ярлык для `@Retryable(includes{nbsp}={nbsp}MessageDeliveryException.class)`.
@Retryable(MessageDeliveryException.class) public void sendNotification() {. [СОВЕТ] = Для расширенных случаев использования вы можете указать собственный `MethodRetryPredicate` через атрибут `predicate` в `@Retryable`, и предикат будет использоваться для определения того, будет ли повторить неудачный вызов метода на основе «Метода» и данного «Throwable» — для например, проверив сообщение `Throwable`.
@Retryable(MessageDeliveryException.class) public void sendNotification() {.

Пользовательские предикаты можно комбинировать с «включает» и «исключает»; однако, обычай предикаты всегда будут применяться после применения «включает» и «исключает».
@Retryable(MessageDeliveryException.class) public void sendNotification() {.
Или для 4 повторных попыток и экспоненциальной стратегии отсрочки с небольшим джиттером:
@Retryable(MessageDeliveryException.class) public void sendNotification() {. @Retryable(includes = MessageDeliveryException.class, maxRetries = 4, delay = 100, jitter = 10, multiplier = 2, maxDelay = 1000) public void sendNotification() {
    this.jmsClient.destination("notifications").send(...);
@Retryable(MessageDeliveryException.class) public void sendNotification() {.
И последнее, но не менее важное: `@Retryable` также работает для реактивных методов с реактивным возвратом. type, украшая конвейер возможностями повтора Reactor:
    return Mono.from(...); // <1>
@Retryable(maxRetries = 4, delay = 100) public Mono<Void> sendNotification() {. <1> Этот необработанный `Mono` будет украшен спецификацией повтора.
@Retryable(maxRetries = 4, delay = 100) public Mono<Void> sendNotification() {.

Подробную информацию о различных характеристиках см. в доступных атрибутах аннотаций в разделе {spring-framework-api}/resilience/annotation/Retryable.html[`@Retryable`].
@Retryable(maxRetries = 4, delay = 100) public Mono<Void> sendNotification() {.
СОВЕТ: Некоторые атрибуты в `@Retryable` имеют варианты `String`, которые предоставляют свойство поддержка заполнителя и SpEL в качестве альтернативы специально напечатанной аннотации. атрибуты, используемые в приведенных выше примерах.
`@ConcurrencyLimit`. {spring-framework-api}/resilience/annotation/ConcurrencyLimit.html[`@ConcurrencyLimit`] аннотация, определяющая предел параллелизма для отдельного метода (с параметром аннотация, объявленная на уровне метода), или для всех методов, вызываемых прокси в данном иерархия классов (с аннотацией, объявленной на уровне типа).
    this.jmsClient.destination("notifications").send(...);
@ConcurrencyLimit(10) public void sendNotification() {.
Это предназначено для защиты целевого ресурса от доступа слишком большого количества потоков одновременно. в то же время, аналогично эффекту ограничения размера пула для пула потоков или пул соединений, который блокирует доступ, если достигнут его предел.
@ConcurrencyLimit(10) public void sendNotification() {.

При желании вы можете установить ограничение на «1», эффективно блокируя доступ к целевому компоненту. пример:
    this.jmsClient.destination("notifications").send(...);
@ConcurrencyLimit(1) public void sendNotification() {.
Такое ограничение особенно полезно для виртуальных потоков, где обычно нет Установлено ограничение пула потоков.
Для асинхронных задач это можно ограничить {spring-framework-api}/core/task/SimpleAsyncTaskExecutor.html[`SimpleAsyncTaskExecutor`].
Для синхронных вызовов эта аннотация обеспечивает эквивалентное поведение через {spring-framework-api}/aop/interceptor/ConcurrencyThrottleInterceptor.html[`ConcurrencyThrottleInterceptor`] который доступен начиная с Spring Framework 1.0 для программного использования с АОП. рамки.
@ConcurrencyLimit(1) public void sendNotification() {.
СОВЕТ: `@ConcurrencyLimit` также имеет атрибут `limitString`, который предоставляет свойство поддержка заполнителя и SpEL в качестве альтернативы приведенным выше примерам на основе int.
Включение устойчивых методов.
Как и многие основные функции Spring, основанные на аннотациях, @Retryable и @ConcurrencyLimit. представляют собой метаданные, которые вы можете принять или игнорировать.
Самый удобный способ чтобы включить обработку аннотаций устойчивости, необходимо объявить {spring-framework-api}/resilience/annotation/EnableResilientMethods.html[`@EnableResilientMethods`] в соответствующем классе `@Configuration`.
Включение устойчивых методов.

Альтернативно, эти аннотации можно включить индивидуально, определив RetryAnnotationBeanPostProcessor или компонент ConcurrencyLimitBeanPostProcessor в контекст.
Поддержка программных повторов.
В отличие от <<resilience-annotations-retryable>>, который обеспечивает декларативный подход для указания семантики повторов для методов внутри bean-компонентов, зарегистрированных в `Контекст приложения`, {spring-framework-api}/core/retry/RetryTemplate.html[`RetryTemplate`] предоставляет программный API для повтора произвольных блоков кода.
Поддержка программных повторов.
В частности, RetryTemplate выполняет и потенциально повторяет попытку {spring-framework-api}/core/retry/Retryable.html[`Retryable`] операция на основе настроен {spring-framework-api}/core/retry/RetryPolicy.html[`RetryPolicy`].
    retryTemplate.execute(
            () -> jmsClient.destination("notifications").send(...));
Поддержка программных повторов. <1> Неявно используется `RetryPolicy.withDefaults()`.
Поддержка программных повторов.
По умолчанию повторяемая операция будет повторена для любого возникшего исключения: не более 3 повторные попытки (`maxRetries = 3`) после первоначального сбоя и задержка в 1 секунду. между попытками.
Поддержка программных повторов.
Если вам нужно настроить только количество повторных попыток, вы можете использовать Фабричный метод RetryPolicy.withMaxRetries(), как показано ниже.

Поддержка программных повторов. [ПРИМЕЧАНИЕ] = Повторяемая операция будет выполнена хотя бы один раз и повторена не более чем `maxRetries`. раз, где maxRetries — максимальное количество повторных попыток.
В частности, `общее количество попыток = 1 начальная попытка + попытки maxRetries`.
Поддержка программных повторов.
Например, если для параметра maxRetries установлено значение 4, повторная операция будет вызвана при минимум один раз и максимум 5 раз.
    retryTemplate.execute(
            () -> jmsClient.destination("notifications").send(...));
Поддержка программных повторов. <1> Явно использует `RetryPolicy.withMaxRetries(4)`.
Поддержка программных повторов.
Если вам нужно сузить типы исключений для повторной попытки, это можно сделать с помощью Методы построения `includes()` и `excludes()`.
Предоставленные типы исключений будут сопоставляется с исключением, вызванным неудачной операцией, а также с вложенными причинами.
    retryTemplate.execute(
            () -> jmsClient.destination("notifications").send(...));
Поддержка программных повторов. <1> Укажите один или несколько типов исключений, которые необходимо включить. <2> Укажите один или несколько типов исключений, которые необходимо исключить.

Поддержка программных повторов. [СОВЕТ] = Для расширенных случаев использования вы можете указать собственный `Predicate<Throwable>` через `predicate()` в `RetryPolicy.Builder`, и предикат будет использоваться для определить, следует ли повторять неудачную операцию на основе данного `Throwable` — например, проверив сообщение `Throwable`.
Поддержка программных повторов.
Пользовательские предикаты можно комбинировать с «включает» и «исключает»; однако, обычай предикаты всегда будут применяться после применения «включает» и «исключает».
Поддержка программных повторов.
В следующем примере показано, как настроить RetryPolicy с 4 повторными попытками. и экспоненциальная стратегия отсрочки с небольшим джиттером.
    retryTemplate.execute(
            () -> jmsClient.destination("notifications").send(...));
Поддержка программных повторов. [СОВЕТ] = {spring-framework-api}/core/retry/RetryListener.html[`RetryListener`] можно зарегистрировать. с помощью RetryTemplate для реагирования на события, опубликованные во время ключевых фаз повтора (перед повторная попытка, после повторной попытки и т. д.), и вы можете составить несколько прослушивателей через {spring-framework-api}/core/retry/support/CompositeRetryListener.html[`CompositeRetryListener`].
Поддержка программных повторов.

Хотя фабричные методы и API-интерфейс построителя для RetryPolicy охватывают наиболее распространенные сценариях конфигурации вы можете реализовать собственную `RetryPolicy` для полного контроля. над типами исключений, которые должны вызывать повторную попытку, а также Стратегия {spring-framework-api}/util/backoff/BackOff.html[`BackOff`] для использования.
Обратите внимание, что вы также можно настроить собственную стратегию BackOff с помощью метода backOff() в `RetryPolicy.Builder`.

Injection with `@Resource`.
Spring также поддерживает внедрение с помощью аннотации JSR-250 `@Resource`. (`jakarta.annotation.Resource`) для полей или методов установки свойств компонента.
Это распространенный шаблон в Jakarta EE: например, в bean-компонентах, управляемых JSF, и JAX-WS. конечные точки.
Spring также поддерживает этот шаблон для объектов, управляемых Spring.
Injection with `@Resource`. `@Resource` принимает атрибут имени.
По умолчанию Spring интерпретирует это значение как имя bean-компонента, который будет внедрен.
Другими словами, оно следует семантике имен, как показано в следующем примере:
Java
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Resource(name="myMovieFinder") // <1>
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
Injection with `@Resource`. <1> Эта строка вводит `@Resource`.
class SimpleMovieLister {. <1> Эта строка вводит `@Resource`.
class SimpleMovieLister {.
Если имя явно не указано, имя по умолчанию получается из имени поля или метод установки.
В случае поля оно принимает имя поля.
В случае метода установки, он принимает имя свойства компонента.
В следующем примере будет компонент имя `movieFinder` введено в его метод установки:
Java
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Resource

public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
	class SimpleMovieLister {
class SimpleMovieLister {.
ПРИМЕЧАНИЕ.
Имя, указанное в аннотации, разрешается как имя компонента `ApplicationContext`, о котором `CommonAnnotationBeanPostProcessor` знает.
Имена могут быть разрешены через JNDI, если вы настроите Spring {spring-framework-api}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`] явно.
Однако мы рекомендуем вам полагаться на поведение по умолчанию и используйте возможности поиска Spring JNDI, чтобы сохранить уровень косвенности.
class SimpleMovieLister {.
В исключительном случае использования @Resource без явного указания имени и т.п. до `@Autowired`, `@Resource` находит совпадение основного типа вместо конкретного именованного компонента и разрешает хорошо известные разрешимые зависимости: BeanFactory, `ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher` и `MessageSource` интерфейсы.
class SimpleMovieLister {.
Таким образом, в следующем примере поле customerPreferenceDao сначала ищет bean-компонент. с именем «customerPreferenceDao», а затем возвращается к основному совпадению типа для типа `CustomerPreferenceDao`:
Java
	public class MovieRecommender {
		@Resource
		private CustomerPreferenceDao customerPreferenceDao;
		@Resource
		private ApplicationContext context; // <1>
		public MovieRecommender() {
class SimpleMovieLister {. <1> Поле context вводится на основе известного разрешимого типа зависимости: `Контекст приложения`.
	class MovieRecommender {

class SimpleMovieLister {. <1> Поле context вводится на основе известного разрешимого типа зависимости: `Контекст приложения`.

* ссылка:++https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html++[
Для получения дополнительной информации о поддержке транзакций Spring Framework см.:.
Распределенные транзакции в Spring с XA и без него] — это презентация JavaWorld в Дэвид Сайер из Spring проведет вас через семь шаблонов распределенных транзакций. в приложениях Spring три из них с XA и четыре без.
* https://www.infoq.com/minibooks/JTDS[_Java Transaction Design Strategies_] — это книга.
Для получения дополнительной информации о поддержке транзакций Spring Framework см.:. доступен по адресу https://www.infoq.com/[InfoQ], где представлено подробное введение. к транзакциям в Java.
Он также включает в себя параллельные примеры настройки и используйте транзакции как с Spring Framework, так и с EJB3.

`@ResponseBody`.
Вы можете использовать аннотацию @ResponseBody для метода, чтобы сериализовать возвращаемый результат. в тело ответа через файл HttpMessageWriter.
Следующие пример показывает, как это сделать:
Java
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
`@ResponseBody` также поддерживается на уровне класса, и в этом случае он наследуется все методы контроллера.
Это эффект `@RestController`, который не более того. чем метааннотация, отмеченная `@Controller` и `@ResponseBody`.
`@ResponseBody` поддерживает реактивные типы, что означает, что вы можете возвращать Reactor или RxJava. типы и отображать асинхронные значения, которые они производят, в ответ.
Для получения дополнительной информации см. ссылку:web/webflux/reactive-spring.adoc#webflux-codecs-streaming[Streaming] и рендеринг JSON.
`@ResponseBody`.
Вы можете комбинировать методы @ResponseBody с представлениями сериализации JSON.
Подробности см. в Jackson JSON.
`@ResponseBody`.
Вы можете использовать кодеки сообщений HTTP опция WebFlux Config для настройки или настройки написания сообщений.

Java
	@GetMapping("/something")
	public ResponseEntity<String> handle() {
		String body = ... ;
		String etag = ... ;
		return ResponseEntity.ok().eTag(etag).body(body);
`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.
Например:.
WebFlux поддерживает использование одного значения reactive type для создавать ResponseEntity асинхронно и/или реактивные типы с одним и несколькими значениями для тела.
Это позволяет использовать различные асинхронные ответы с помощью ResponseEntity следующим образом:
* `ResponseEntity<Mono<T>>` или `ResponseEntity<Flux<T>>` определяют статус ответа и
`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.
Например:. заголовки известны сразу, а тело предоставляется асинхронно позднее.
Используйте Mono, если тело состоит из значений 0..1, или Flux, если оно может выдавать несколько значений.
* `Mono<ResponseEntity<T>>` предоставляет все три — статус ответа, заголовки и тело,
`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.
Например:. асинхронно в более поздний момент.
Это позволяет изменять статус ответа и заголовки. в зависимости от результата обработки асинхронного запроса.

* `Mono<ResponseEntity<Mono<T>>>` или `Mono<ResponseEntity<Flux<T>>>` — еще один
`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.
Например:. возможная, хотя и менее распространенная альтернатива.
Они предоставляют статус ответа и заголовки. сначала асинхронно, а затем тело ответа, также асинхронно, во-вторых.

Возвращаемые значения.
В следующей таблице показаны возвращаемые значения поддерживаемого метода контроллера.
Обратите внимание, что реактивный типы из таких библиотек, как Reactor, RxJava, или другие обычно поддерживается для всех возвращаемых значений.
Возвращаемые значения.
Для типов возврата, таких как Flux, когда ожидается несколько значений, элементы передаются по мере их поступления. и не буферизуются.
Это поведение по умолчанию, поскольку в памяти сохраняется потенциально большое количество элементов. не является эффективным.
Если тип носителя подразумевает бесконечный поток (например, `application/json+stream`), значения записываются и сбрасываются индивидуально.
В противном случае значения записываются индивидуально и сброс происходит отдельно.
Возвращаемые значения.
ПРИМЕЧАНИЕ.
Если ошибка возникает во время кодирования элемента в формате JSON, возможно, ответ был записан в и уже зафиксирован, и в этот момент невозможно отобразить правильный ответ об ошибке.
В некоторых случаях приложения могут пожертвовать эффективностью использования памяти ради лучшей обработки таких ошибок. буферизация элементов и кодирование их всех одновременно.
Затем контроллеры могут вернуть `Flux<List<B>>`; Reactor предоставляет для этого специальный оператор Flux#collectList().
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `@ResponseBody` | Возвращаемое значение кодируется с помощью экземпляров HttpMessageWriter и записывается в ответ.

См. ссылку:web/webflux/controller/ann-methods/responsebody.adoc[`@ResponseBody`].
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `HttpEntity<B>`, `ResponseEntity<B>` | Возвращаемое значение указывает полный ответ, включая заголовки HTTP, а тело закодировано. через экземпляры HttpMessageWriter и записывается в ответ.
См. ссылку:web/webflux/controller/ann-methods/responseentity.adoc[`ResponseEntity`].
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `HttpHeaders` | Для возврата ответа с заголовками и без тела.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `ErrorResponse`, `ProblemDetail` | Чтобы отобразить ответ об ошибке RFC 9457 с подробными сведениями в теле, см. ссылку:web/webflux/ann-rest-Exceptions.adoc [Ответы об ошибках]

[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `Строка` | Имя представления, которое будет разрешено с помощью экземпляров ViewResolver и использовано вместе с неявным модель — определяется с помощью командных объектов и методов @ModelAttribute.
Обработчик метод также может программно обогатить модель, объявив аргумент Model. (описано ранее).
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `Просмотр` | Экземпляр View, используемый для рендеринга вместе с неявной моделью, определяется через командные объекты и методы @ModelAttribute.
Метод обработчика также может программно обогатить модель, объявив аргумент Model (описано ранее).
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `java.util.Map`, `org.springframework.ui.Model` | Атрибуты, добавляемые в неявную модель, с неявно определенным именем представления. на основе пути запроса.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `@ModelAttribute` | Атрибут, добавляемый в модель, с именем представления, неявно определяемым на основе по пути запроса.

[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание.
Обратите внимание, что `@ModelAttribute` не является обязательным.
См. раздел «Любое другое возвращаемое значение» ниже. этот стол.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `Рендеринг` | API для сценариев рендеринга моделей и представлений.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `FragmentsRendering`, `Flux<Fragment>`, `Collection<Fragment>` | Для рендеринга одного или нескольких фрагментов, каждый со своим видом и моделью.
Дополнительную информацию см. в HTML Fragments.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `пустота` | Метод с `void`, возможно, асинхронный (например, `Mono<Void>`), тип возвращаемого значения (или возвращаемый `null` value) считается полностью обработавшим ответ, если он также имеет `ServerHttpResponse`, аргумент ServerWebExchange или аннотацию @ResponseStatus.

То же самое верно если контроллер выполнил положительную проверку ETag или временной метки «lastModified».
Подробности см. в Контроллеры.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание.
Если ничего из вышеперечисленного не соответствует действительности, тип возвращаемого значения `void` также может указывать на отсутствие тела ответа для Контроллеры REST или выбор имени представления по умолчанию для контроллеров HTML.
[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | `Flux<ServerSentEvent>`, `Observable<ServerSentEvent>` или другой реактивный тип | Генерация событий, отправленных сервером.
Оболочку `ServerSentEvent` можно опустить, если нужны только данные. быть записан (однако `text/event-stream` должен быть запрошен или объявлен в отображении через атрибут «производит»).

[cols="1,2", options="header"] |=== | Возвращаемое значение метода контроллера | Описание. | Другие возвращаемые значения | Если возвращаемое значение остается неразрешенным каким-либо другим способом, оно рассматривается как модель. атрибут, если только он не является простым типом, как определено {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty], в этом случае он остается нерешенным. |===

Откат декларативной транзакции.
В предыдущем разделе были описаны основы определения параметров транзакций для классы, обычно классы уровня обслуживания, декларативно в вашем приложении.
Этот раздел описывает, как можно управлять откатом транзакций простым декларативным способом. мода в конфигурации XML.
Подробные сведения о декларативном управлении семантикой отката см. с аннотацией `@Transactional`, см.
Откат декларативной транзакции.
Рекомендуемый способ указания инфраструктуры транзакций Spring Framework что работа транзакции должна быть отменена, означает выдачу «Исключения» из кода, который в данный момент выполняется в контексте транзакции.
Spring Framework код инфраструктуры транзакций перехватывает любое необработанное «исключение», когда оно всплывает стек вызовов и принимает решение, помечать ли транзакцию для отката.
Откат декларативной транзакции.
В конфигурации по умолчанию код инфраструктуры транзакций Spring Framework помечает транзакцию для отката только в случае непроверенных исключений во время выполнения.
То есть, когда выброшенное исключение является экземпляром или подклассом RuntimeException. (Экземпляры `Error` также по умолчанию приводят к откату).
Откат декларативной транзакции.
Конфигурация по умолчанию также обеспечивает поддержку метода Try для запуска Vavr. транзакция откатывается, когда возвращает «Сбой».
Это позволяет вам обрабатывать ошибки функционального стиля, используя Try and have theтранзакцию. автоматически откатывается назад в случае сбоя.
Для получения дополнительной информации о «Попытке Вавра» см. обратитесь к {vavr-docs}/#_try[официальной документации Vavr].
Вот пример использования Try Vavr с транзакционным методом:
Java
	@Transactional

public Try<String> myTransactionalMethod() {
		// Если myDataAccessOperation выдает исключение, оно будет перехвачено
		// Экземпляр Try, созданный с помощью Try.of() и заключенный в класс Fail.
		// что можно проверить с помощью метода isFailure() в экземпляре Try.
		return Try.of(delegate::myDataAccessOperation);
Откат декларативной транзакции.
Начиная с Spring Framework 6.1, существует специальная обработка CompletableFuture. (и общие возвращаемые значения `Future`), запуская откат для такого дескриптора, если он был исключительно завершен на момент возврата из исходного метода.
Это предназначено для методов `@Async`, где фактическая реализация метода может необходимо соответствовать сигнатуре CompletableFuture (автоматически адаптируемой к фактическому асинхронный дескриптор вызова прокси-сервера посредством обработки `@Async` во время выполнения), предпочитая раскрытие в возвращаемом дескрипторе, а не повторно выдавая исключение:
Java
	@Transactional @Async
	public CompletableFuture<String> myTransactionalMethod() {
		try {
			return CompletableFuture.completedFuture(delegate.myDataAccessOperation());
		catch (DataAccessException ex) {
			return CompletableFuture.failedFuture(ex);
Откат декларативной транзакции.
Проверенные исключения, возникающие из транзакционного метода, не приводят к откату. в конфигурации по умолчанию.
Вы можете точно настроить, какие типы исключений отмечают транзакция для отката, включая проверяемые исключения путем указания _правил отката_.

Откат декларативной транзакции. .Правила отката [ПРИМЕЧАНИЕ] = Правила отката определяют, следует ли откатить транзакцию при возникновении данного исключения. выбрасывается, а правила основаны на типах исключений или шаблонах исключений.
Откат декларативной транзакции.
Правила отката можно настроить в XML с помощью параметров «rollback-for» и «no-rollback-for». атрибуты, которые позволяют определять правила как шаблоны.
При использовании Правила отката можно настроить с помощью `rollbackFor`/`noRollbackFor` и АтрибутыrollbackForClassName/noRollbackForClassName, которые позволяют определяются на основе типов или шаблонов исключений соответственно.
Откат декларативной транзакции.
Когда правило отката определено с типом исключения – например, через `rollbackFor` – этот тип будет использоваться для сопоставления с типом выброшенного исключения.
В частности, при заданном типе исключения «C» будет рассматриваться выброшенное исключение типа «T». совпадение с `C`, если `T` равен `C` или подклассу `C`.
Это обеспечивает тип безопасности и позволяет избежать непреднамеренных совпадений, которые могут возникнуть при использовании шаблона.
Для Например, значение `jakarta.servlet.ServletException.class` будет соответствовать только выброшенному исключения типа jakarta.servlet.ServletException и его подклассов.
Откат декларативной транзакции.

Если правило отката определено с помощью шаблона исключения, этот шаблон может быть полностью квалифицированное имя класса или подстрока полного имени класса для типа исключения (который должен быть подклассом Throwable), без поддержки подстановочных знаков в настоящее время.
Для например, значение `"jakarta.servlet.ServletException"` или `"ServletException"` будет сопоставьте `jakarta.servlet.ServletException` и его подклассы.
Откат декларативной транзакции. [ВНИМАНИЕ] = Вы должны тщательно продумать, насколько специфичен шаблон и следует ли включать пакет информация (которая не является обязательной).
Например, `"Exception"` будет соответствовать почти что угодно и, вероятно, скроет другие правила. `"java.lang.Exception"` было бы правильно, если бы «Исключение» предназначалось для определения правила для всех проверенных исключений.
С более уникальными имена исключений, такие как «BaseBusinessException», скорее всего, нет необходимости использовать полное имя класса для шаблона исключения.
Откат декларативной транзакции.
Кроме того, правила отката на основе шаблонов могут привести к непреднамеренному совпадению одноименные исключения и вложенные классы.
Это связано с тем, что брошенный исключение считается соответствующим данному правилу отката на основе шаблона, если имя выброшенного исключения содержит шаблон исключения, настроенный для правила отката.

Например, если правило настроено для сопоставления с com.example.CustomException, то правило будет соответствовать исключению с именем `com.example.CustomExceptionV2` (исключение в том же пакете, что и CustomException, но с дополнительным суффиксом) или исключение с именем `com.example.CustomException$AnotherException` (исключение, объявленное как вложенное класс в `CustomException`).
Откат декларативной транзакции.
В следующем фрагменте XML показано, как настроить откат для проверенного, тип `Exception` для конкретного приложения, предоставляя _шаблон исключения_ через метод Атрибут `rollback-for`:
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
Откат декларативной транзакции.
Если вы не хотите, чтобы транзакция откатывалась при возникновении исключения, вы также можете укажите правила «без отката».
В следующем примере показано, как Spring Framework транзакционная инфраструктура для совершения сопутствующей транзакции даже в условиях необработанное `InstrumentNotFoundException`:
	<tx:advice id="txAdvice">
		<tx:attributes>
			<tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>

<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
Откат декларативной транзакции.
Когда инфраструктура транзакций Spring Framework улавливает исключение и обращается к нему настроенные правила отката, чтобы определить, следует ли помечать транзакцию для отката, the strongest matching rule wins.
Итак, в случае следующей конфигурации любой исключение, отличное от «InstrumentNotFoundException», приводит к откату сопутствующая транзакция:
	<tx:advice id="txAdvice">
		<tx:attributes>
			<tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>
		</tx:attributes>
	</tx:advice>
Откат декларативной транзакции.
Вы также можете указать необходимый откат программно.
Несмотря на простоту, этот процесс довольно агрессивен и тесно связывает ваш код с транзакцией Spring Framework. инфраструктура.
В следующем примере показано, как программно указать требуемый откат:
Java
	public void resolvePosition() {
		try {
			// немного бизнес-логики...
		} catch (NoProductInStockException ex) {
			// запускать откат программно
			TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
Откат декларативной транзакции.
Вам настоятельно рекомендуется использовать декларативный подход к откату, если он вообще используется. возможно.
Программный откат доступен, если он вам абсолютно необходим, но его использование противоречит достижению чистой архитектуры на основе POJO.

1. Введение. `scheduler` предоставляет планировщик фоновых задач с cron/interval триггерами, ограничением конкуренции и управлением повторными попытками.
- автоматизирует регулярные процессы;
- снижает риск ручных операций;
- позволяет управлять SLA для batch/jobs.
```xml
```java
    @LilipupCron("0 */15 * * * *")
    @DisallowParallel
    public void cleanupExpiredDrafts() {
        // Выполняется каждые 15 минут.
        System.out.println("Cleaning up expired invoice drafts");
```java
    @LilipupEvery("30s")
    @RetryableJob(maxAttempts = 3, backoffMs = 2000)
    public void syncRemoteCatalog() {
        // Внешний вызов должен быть timeout-ограничен.
        System.out.println("Sync remote catalog");
```yaml
    enabled: true
    timezone: UTC
    worker-pool-size: 8
    max-concurrent-jobs: 16
    misfire-policy: fire-now
    default-timeout-ms: 30000
- Не используйте scheduler-методы без `@LilipupCron` или `@LilipupEvery`.
- Всегда ограничивайте параллелизм для неидемпотентных задач (`@DisallowParallel`).
- Проверяйте timeout и circuit breaker на внешних вызовах внутри job.
- Не запускайте критичные задачи без retry-политики или DLQ-аналогичного механизма.
- Проверяйте timezone: cron в local timezone часто приводит к инцидентам.

- `ScheduleParseException`: некорректное cron/interval выражение.
- `JobExecutionTimeoutException`: задача превысила лимит выполнения.
- `JobConcurrencyViolationException`: нарушено правило параллелизма.
```java
    public void run(JobContext ctx) {
        try {
            doWork();
            ctx.markSuccess();
        } catch (Exception ex) {
            ctx.markFailure(ex.getMessage());
            throw ex;
    private void doWork() {
        // Business logic
- Делайте задачи идемпотентными и re-entrant.
- Храните checkpoint/offset для долгих jobs.
- Разделяйте CPU-bound и IO-bound jobs по разным пулам.
- Добавляйте jitter для периодических задач во избежание thundering herd.
- Тестируйте переход на летнее/зимнее время для cron-задач.

Поддержка АОП на основе схемы.
Если вы предпочитаете формат на основе XML, Spring также предлагает поддержку определения аспектов. используя теги пространства имен `aop`.
Те же самые выражения и виды советов. как и при использовании стиля @AspectJ.
Поэтому в этом разделе мы сосредоточимся на этот синтаксис и отправьте читателя к обсуждению в предыдущем разделе. (@AspectJ support) для понимания написания выражений pointcut и привязки параметров рекомендаций.
Поддержка АОП на основе схемы.
Чтобы использовать теги пространства имен aop, описанные в этом разделе, вам необходимо импортировать Схема `spring-aop`, как описано в конфигурация на основе XML-схемы.
См. схема АОП. о том, как импортировать теги в пространство имен `aop`.
Поддержка АОП на основе схемы.
В ваших конфигурациях Spring все элементы аспектов и советников должны быть размещены внутри элемент `<aop:config>` (вы можете иметь более одного элемента `<aop:config>` в конфигурация контекста приложения).
Элемент `<aop:config>` может содержать pointcut, советник и элементы аспекта (обратите внимание, что они должны быть объявлены именно в этом порядке).
Поддержка АОП на основе схемы.
ВНИМАНИЕ: стиль конфигурации `<aop:config>` интенсивно использует возможности Spring. не вплетается), если вы уже используете явное автоматическое проксирование с помощью `BeanNameAutoProxyCreator` или что-то подобное.

Рекомендуемая схема использования: используйте либо только стиль `<aop:config>`, либо только стиль `AutoProxyCreator` и никогда не смешивайте их.
Объявление аспекта.
Когда вы используете поддержку схемы, аспект представляет собой обычный объект Java, определенный как компонент в контекст вашего приложения Spring.
Состояние и поведение фиксируются в полях и методы объекта, а информация о точках и советах фиксируется в XML.
Объявление аспекта.
Вы можете объявить аспект, используя элемент `<aop:aspect>` и ссылаясь на поддерживающий компонент. используя атрибут `ref`, как показано в следующем примере:
	<aop:config>
		<aop:aspect id="myAspect" ref="aBean">
		</aop:aspect>
	</aop:config>
	<bean id="aBean" class="...">
	</bean>
Объявление аспекта.
Компонент, поддерживающий аспект (в данном случае aBean), конечно, можно настроить и Зависимость внедряется так же, как и любой другой компонент Spring.
Объявление Pointcut.
Вы можете объявить pointcut с именем _named внутри элемента `<aop:config>`, позволяя pointcut Определение может быть общим для нескольких аспектов и советников.
Объявление Pointcut.
Pointcut, представляющий выполнение любого бизнес-сервиса на уровне сервиса, может быть определены следующим образом:
	<aop:config>
		<aop:pointcut id="businessService"

expression="execution(* com.xyz.service.*.*(..))" />
	</aop:config>
Объявление Pointcut.
Обратите внимание, что само выражение pointcut использует то же выражение pointcut AspectJ. язык, как описано в @AspectJ support.
Если вы используете объявление на основе схемы вы также можете обратиться к _именованным точечным вырезам_, определенным в типах `@Aspect` внутри выражение точечного выреза.
Таким образом, другой способ определения вышеуказанной точки будет следующим:
	<aop:config>
		<aop:pointcut id="businessService"
			expression="com.xyz.CommonPointcuts.businessService()" /> <1>
	</aop:config>
Объявление Pointcut. <1> Ссылается на именованный pointcut `businessService`, определенный в Совместное использование именованных определений Pointcut.
Объявление Pointcut.
Объявление pointcut _внутри_ аспекта очень похоже на объявление pointcut верхнего уровня. как показано в следующем примере:
	<aop:config>
		<aop:aspect id="myAspect" ref="aBean">
			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.service.*.*(..))"/>
		</aop:aspect>
	</aop:config>
Объявление Pointcut.

Во многом аналогично аспекту @AspectJ, точечные вырезы, объявленные с использованием схемы на основе стиль определения может собирать контекст точки соединения.
Например, следующий pointcut собирает объект `this` как контекст точки соединения и передает его в совет:
	<aop:config>
		<aop:aspect id="myAspect" ref="aBean">
			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.service.*.*(..)) &amp;&amp; this(service)"/>
			<aop:before pointcut-ref="businessService" method="monitor"/>
		</aop:aspect>
	</aop:config>
Объявление Pointcut.
Совет должен быть объявлен для получения собранного контекста точки соединения, включая параметры совпадающих имен, а именно:
Java
	public void monitor(Object service) {
Объявление Pointcut.
При объединении подвыражений pointcut `+&&+` неудобно использовать в XML. документ, поэтому вы можете использовать ключевые слова `and`, `or` и `not` вместо `+&&+`, `||` и `!` соответственно.
Например, предыдущий срез точки лучше записать как следует:
	<aop:config>
		<aop:aspect id="myAspect" ref="aBean">
			<aop:pointcut id="businessService"

expression="execution(* com.xyz.service.*.*(..)) and this(service)"/>
			<aop:before pointcut-ref="businessService" method="monitor"/>
		</aop:aspect>
	</aop:config>
Объявление Pointcut.
Обратите внимание, что на точечные вырезы, определенные таким образом, ссылаются по их XML-идентификаторам, и их нельзя используются как именованные точечные разрезы для формирования составных точечных разрезов.
Именованная поддержка pointcut в Таким образом, стиль определения на основе схемы более ограничен, чем стиль @AspectJ.
Объявление совета.
Поддержка АОП на основе схемы использует те же пять видов рекомендаций, что и стиль @AspectJ, и они имеют точно такая же семантика.
Перед советом.
Совет Before выполняется перед выполнением соответствующего метода.
Он объявлен внутри `<aop:aspect>` с помощью элемента `<aop:before>`, как показано в следующем примере:
	<aop:aspect id="beforeExample" ref="aBean">
		<aop:before
			pointcut-ref="dataAccessOperation"
			method="doAccessCheck"/>
	</aop:aspect>
Перед советом.
В приведенном выше примере `dataAccessOperation` — это `id` _named pointcut_, определенного в верхний уровень (`<aop:config>`) (см.
Объявление Pointcut).

Перед советом.
ПРИМЕЧАНИЕ.
Как мы отмечали при обсуждении стиля @AspectJ, использование _named pointcuts_ может значительно улучшить читаемость вашего кода.
См. совместное использование именованных определений Pointcut. детали.
Перед советом.
Вместо этого, чтобы определить встроенный pointcut, замените атрибут `pointcut-ref` на атрибут pointcut, например:
	<aop:aspect id="beforeExample" ref="aBean">
		<aop:before
			pointcut="execution(* com.xyz.dao.*.*(..))"
			method="doAccessCheck"/>
	</aop:aspect>
Перед советом.
Атрибут `method` идентифицирует метод (`doAccessCheck`), который предоставляет тело совет.
Этот метод должен быть определен для компонента, на который ссылается элемент аспекта. который содержит советы.
Прежде чем будет выполнена операция доступа к данным (выполнение метода точка соединения, соответствующая выражению pointcut), метод doAccessCheck для аспекта вызывается компонент.
После возвращения совета.
После возврата совет запускается, когда выполнение соответствующего метода завершается нормально.
Это объявлен внутри `<aop:aspect>` так же, как и предыдущий совет.
Следующий пример показывает, как это объявить:
	<aop:aspect id="afterReturningExample" ref="aBean">
		<aop:after-returning
			pointcut="execution(* com.xyz.dao.*.*(..))"

method="doAccessCheck"/>
	</aop:aspect>
После возвращения совета.
Как и в стиле @AspectJ, вы можете получить возвращаемое значение в теле совета.
Для этого используйте атрибут return, чтобы указать имя параметра, которому должно быть передано возвращаемое значение, как показано в следующем примере:
	<aop:aspect id="afterReturningExample" ref="aBean">
		<aop:after-returning
			pointcut="execution(* com.xyz.dao.*.*(..))"
			returning="retVal"
			method="doAccessCheck"/>
	</aop:aspect>
После возвращения совета.
Метод doAccessCheck должен объявить параметр с именем retVal.
Тип этого Параметр ограничивает соответствие таким же образом, как описано для `@AfterReturning`.
Для Например, вы можете объявить сигнатуру метода следующим образом:
Java
	public void doAccessCheck(Object retVal) {...
После того, как бросил совет.
Совет после выдачи запускается, когда выполнение соответствующего метода завершается путем выдачи исключение.
Он объявляется внутри `<aop:aspect>` с помощью элемента `after-throwing`, как показано в следующем примере:
	<aop:aspect id="afterThrowingExample" ref="aBean">
		<aop:after-throwing
			pointcut="execution(* com.xyz.dao.*.*(..))"

method="doRecoveryActions"/>
	</aop:aspect>
После того, как бросил совет.
Как и в стиле @AspectJ, вы можете получить выброшенное исключение в теле совета.
Для этого используйте атрибут `throwing`, чтобы указать имя параметра для которому должно быть передано исключение, как показано в следующем примере:
	<aop:aspect id="afterThrowingExample" ref="aBean">
		<aop:after-throwing
			pointcut="execution(* com.xyz.dao.*.*(..))"
			throwing="dataAccessEx"
			method="doRecoveryActions"/>
	</aop:aspect>
После того, как бросил совет.
Метод doRecoveryActions должен объявить параметр с именем dataAccessEx.
Тип этого параметра ограничивает соответствие таким же образом, как описано для `@AfterThrowing`.
Например, сигнатуру метода можно объявить следующим образом:
Java
	public void doRecoveryActions(DataAccessException dataAccessEx) {...
После (наконец) совета.
After (наконец) совет выполняется независимо от того, как завершается выполнение соответствующего метода.
Вы можете объявить его, используя элемент after, как показано в следующем примере:
	<aop:aspect id="afterFinallyExample" ref="aBean">
		<aop:after
			pointcut="execution(* com.xyz.dao.*.*(..))"
			method="doReleaseLock"/>

</aop:aspect>
Вокруг советов.
Последний вид советов — это «вокруговые» советы.
Вокруг совета бегает «вокруг» совпадающего выполнение метода.
Имеет возможность выполнять работу как до, так и после метода. запускается и определить, когда, как и даже будет ли метод вообще запускаться.
Вокруг совета часто используется, если вам нужно поделиться состоянием до и после метода. выполнение потокобезопасным способом — например, запуск и остановка таймера.
Вокруг советов. [СОВЕТ] = Всегда используйте наименее действенную форму совета, отвечающую вашим требованиям.
Вокруг советов.
Например, не используйте совет _around_, если совет _before_ достаточен для ваших нужд.
Вокруг советов.
Вы можете объявить совет, используя элемент aop:around.
Метод консультирования должен объявите `Object` в качестве возвращаемого типа, а первый параметр метода должен иметь значение введите «ProceedingJoinPoint».
В теле метода консультации вы должны вызвать `proceed()` для `ProceedingJoinPoint` для запуска базового метода.
Вызов proceed() без аргументов приведет к исходным аргументам вызывающей стороны. передается базовому методу при его вызове.
Для продвинутых случаев использования есть это перегруженный вариант метода proceed(), который принимает массив аргументов (`Объект[]`).
Значения в массиве будут использоваться в качестве аргументов базового метод при его вызове.
См.
Around Advice для получения примечаний по вызову. `продолжить` с `Object[]`.

<aop:aspect id="aroundExample" ref="aBean">
		<aop:around
			pointcut="execution(* com.xyz.service.*.*(..))"
			method="doBasicProfiling"/>
	</aop:aspect>
В следующем примере показано, как объявить рекомендации в XML:.
Реализация совета `doBasicProfiling` может быть точно такой же, как и в Пример @AspectJ (конечно, без аннотации), как показано в следующем примере:
Java
	public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
		// запустить секундомер
		Object retVal = pjp.proceed();
		// остановить секундомер
		return retVal;
Параметры рекомендаций.
Стиль объявления на основе схемы поддерживает полностью типизированные рекомендации так же, как и описано для поддержки @AspectJ - путем сопоставления параметров pointcut по имени с Параметры метода рекомендации.
См.
Если вы хотите явно указать имена аргументов для методов рекомендаций (не полагаясь на стратегии обнаружения, описанные ранее), вы можете сделать это, используя `arg-names` атрибут элемента консультации, который обрабатывается так же, как и `argNames` атрибут в аннотации к рекомендации (как описано в В следующем примере показано, как указать имя аргумента в XML:
	<aop:before
		pointcut="com.xyz.Pointcuts.publicMethod() and @annotation(auditable)" <1>
		method="audit"

arg-names="auditable" />
<1> Ссылается на `publicMethod` с именем pointcut, определенный в.
Атрибут `arg-names` принимает список имен параметров, разделенных запятыми.
<1> Ссылается на `publicMethod` с именем pointcut, определенный в.
Следующий немного более сложный пример подхода на основе XSD показывает некоторые советы, используемые в сочетании с рядом строго типизированных параметров:
Java
	package com.xyz.service;
	public interface PersonService {
		Person getPerson(String personName, int age);
	public class DefaultPersonService implements PersonService {
		public Person getPerson(String name, int age) {
			return new Person(name, age);
	package com.xyz.service
	interface PersonService {
	class DefaultPersonService : PersonService {
<1> Ссылается на `publicMethod` с именем pointcut, определенный в.
Далее — аспект.
Обратите внимание на тот факт, что метод `profile(..)` принимает несколько строго типизированные параметры, первый из которых является точкой соединения, используемой для продолжите вызов метода.
Наличие этого параметра указывает на то, что `profile(..)` следует использовать как совет `around`, как показано в следующем примере:
Java
	package com.xyz;
	import org.aspectj.lang.ProceedingJoinPoint;
	import org.springframework.util.StopWatch;
	public class SimpleProfiler {

public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
			StopWatch clock = new StopWatch("Profiling for '" + name + "' and '" + age + "'");
			try {
				clock.start(call.toShortString());
				return call.proceed();
			} finally {
				clock.stop();
				System.out.println(clock.prettyPrint());
	package com.xyz
	class SimpleProfiler {
<1> Ссылается на `publicMethod` с именем pointcut, определенный в.
Наконец, следующий пример конфигурации XML влияет на выполнение предыдущий совет для конкретной точки соединения:
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

<!-- this is the object that will be proxied by Spring's AOP infrastructure -->
		<bean id="personService" class="com.xyz.service.DefaultPersonService"/>
		<!-- this is the actual advice itself -->
		<bean id="profiler" class="com.xyz.SimpleProfiler"/>
		<aop:config>
			<aop:aspect ref="profiler">
				<aop:pointcut id="theExecutionOfSomePersonServiceMethod"
					expression="execution(* com.xyz.service.PersonService.getPerson(String,int))
					and args(name, age)"/>
				<aop:around pointcut-ref="theExecutionOfSomePersonServiceMethod"
					method="profile"/>
			</aop:aspect>
		</aop:config>
	</beans>
Java
	public class Boot {
		public static void main(String[] args) {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
			PersonService person = ctx.getBean(PersonService.class);
			person.getPerson("Pengo", 12);
Рассмотрим следующий сценарий драйвера:.
С таким классом Boot мы получим вывод, аналогичный следующему, в стандартном выводе:
[литерал,subs="дословно"].

StopWatch 'Profiling for 'Pengo' and '12': running time (millis) = 0 ----------------------------------------- ms % Task name ----------------------------------------- 00000? execution(getFoo)
Консультации Заказ.
Когда несколько советов необходимо выполнить в одной и той же точке соединения (метод выполнения) правила заказа такие же, как описано в приоритет между аспектами определяется атрибутом order в атрибуте <aop:aspect>. или добавив аннотацию @Order к компоненту, который поддерживает аспект или заставив компонент реализовать интерфейс Ordered.
Консультации Заказ. [ПРИМЕЧАНИЕ] = В отличие от правил приоритета для методов советов, определенных в том же `@Aspect` класс, когда два совета, определенные в одном и том же элементе `<aop:aspect>`, оба должны выполняются в одной и той же точке соединения, приоритет определяется порядком, в котором советы элементы объявляются внутри включающего элемента `<aop:aspect>`, от самого высокого до самого низкого. приоритет.
Консультации Заказ.

Например, при наличии совета «вокруг» и совета «до», определенных в одном и том же документе. элемент `<aop:aspect>`, который применяется к одной и той же точке соединения, чтобы гарантировать, что `around` совет имеет более высокий приоритет, чем совет `before`, элемент `<aop:around>` должен быть объявлен перед элементом `<aop:before>`.
Консультации Заказ.
Как правило, если вы обнаружите, что у вас определено несколько советов, в том же элементе `<aop:aspect>`, который применяется к одной и той же точке соединения, рассмотрите возможность свертывания такие методы рекомендаций в один метод рекомендаций для каждой точки соединения в каждом элементе `<aop:aspect>` или реорганизуйте советы в отдельные элементы `<aop:aspect>`, которые вы можете заказать на уровне аспекта.
Введение.
Введения (известные как объявления между типами в AspectJ) позволяют аспекту объявлять что рекомендуемые объекты реализуют заданный интерфейс и обеспечивают реализацию этот интерфейс от имени этих объектов.
Введение.
Вы можете представиться, используя элемент aop:declare-parents внутри aop:aspect.
Вы можете использовать элемент aop:declare-parents, чтобы объявить, что соответствующие типы имеют нового родителя (отсюда и название).

Например, если у вас есть интерфейс с именем UsageTracked и реализация этого интерфейса с именем `DefaultUsageTracked`, следующий аспект заявляет, что все разработчики службы интерфейсы также реализуют интерфейс UsageTracked. (Чтобы выставить статистику через JMX, например.)
	<aop:aspect id="usageTrackerAspect" ref="usageTracking">
		<aop:declare-parents
			types-matching="com.xyz.service.*+"
			implement-interface="com.xyz.service.tracking.UsageTracked"
			default-impl="com.xyz.service.tracking.DefaultUsageTracked"/>
		<aop:before
			pointcut="execution(* com.xyz..service.*.*(..))
				and this(usageTracked)"
				method="recordUsage"/>
	</aop:aspect>
Java
	public void recordUsage(UsageTracked usageTracked) {
		usageTracked.incrementUseCount();
Класс, поддерживающий компонент `usageTracking`, тогда будет содержать следующий метод:.
Реализуемый интерфейс определяется атрибутомimplement-interface. значение атрибута «types-matching» представляет собой шаблон типа AspectJ.
Любой боб тип соответствия реализует интерфейс UsageTracked.
Обратите внимание, что в предыдущем Согласно предыдущему примеру, сервисные компоненты могут использоваться непосредственно как реализации интерфейс UsageTracked.
Чтобы получить программный доступ к компоненту, вы можете написать следующее:
Java

UsageTracked usageTracked = context.getBean("myService", UsageTracked.class);
Модели реализации аспектов.
Единственная поддерживаемая модель создания экземпляров для аспектов, определяемых схемой, — это синглтон. модель.
Другие модели создания экземпляров могут поддерживаться в будущих выпусках.
Советники.
Концепция «советников» исходит из поддержки АОП, определенной в Spring. и не имеет прямого эквивалента в AspectJ.
Советник подобен маленькому самодостаточный аспект, содержащий единственный совет.
Сам совет такой представлен компонентом и должен реализовать один из интерфейсов рекомендаций, описанных в Советники могут использовать преимущества выражений pointcut AspectJ.
Советники.
Spring поддерживает концепцию советника с помощью элемента `<aop:advisor>`.
Ты самый обычно его используют в сочетании с транзакционными рекомендациями, которые также имеют свои собственные поддержка пространства имен в Spring.
В следующем примере показан советник:
	<aop:config>
		<aop:pointcut id="businessService"
			expression="execution(* com.xyz.service.*.*(..))"/>
		<aop:advisor
			pointcut-ref="businessService"
			advice-ref="tx-advice" />
	</aop:config>
	<tx:advice id="tx-advice">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
Советники.

Помимо атрибута pointcut-ref, использованного в предыдущем примере, вы также можете использовать Атрибут pointcut для определения встроенного выражения pointcut.
Советники.
Чтобы определить приоритет советника, чтобы совет мог участвовать в заказе, используйте атрибут Order, чтобы определить значение советника Ordered.
В этом разделе показано, как пример повторной попытки одновременной блокировки.
Выполнение бизнес-сервисов иногда может завершаться сбоем из-за проблем параллелизма (например, например, проигравший в тупике).
Если операцию повторить, она, скорее всего, завершится успешно. при следующей попытке.
Для бизнес-услуг, где уместно повторить попытку в таком условия (идемпотентные операции, которым не нужно возвращаться к пользователю в случае конфликта разрешение), мы хотим прозрачно повторить операцию, чтобы клиент не увидел `PessimisticLockingFailureException`.
Это требование, которое явно затрагивает несколько сервисов на уровне сервисов и, следовательно, идеально подходит для реализации через аспект.
В этом разделе показано, как пример повторной попытки одновременной блокировки.
Поскольку мы хотим повторить операцию, нам нужно воспользоваться советом, чтобы мы могли вызовите `proceed` несколько раз.
В следующем листинге показана реализация основного аспекта. (это обычный класс Java, использующий поддержку схемы):
Java
	public class ConcurrentOperationExecutor implements Ordered {
		private static final int DEFAULT_MAX_RETRIES = 2;
		private int maxRetries = DEFAULT_MAX_RETRIES;
		private int order = 1;
		public void setMaxRetries(int maxRetries) {
			this.maxRetries = maxRetries;

public int getOrder() {
			return this.order;
		public void setOrder(int order) {
			this.order = order;
		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
			int numAttempts = 0;
			PessimisticLockingFailureException lockFailureException;
			do {
				numAttempts++;
				try {
					return pjp.proceed();
				catch(PessimisticLockingFailureException ex) {
					lockFailureException = ex;
			} while(numAttempts <= this.maxRetries);
			throw lockFailureException;
	class ConcurrentOperationExecutor : Ordered {
			} while (numAttempts <= this.maxRetries)
			throw lockFailureException
В этом разделе показано, как пример повторной попытки одновременной блокировки.
Обратите внимание, что этот аспект реализует интерфейс Ordered, поэтому мы можем установить приоритет аспект выше, чем совет по транзакции (мы хотим новую транзакцию каждый раз, когда мы повторите попытку).
Свойства maxRetries и order настраиваются Spring.
Основное действие происходит в методе doConcurrentOperation вокруг совета.
Мы стараемся продолжайте.
Если мы потерпим неудачу с PessimisticLockingFailureException, мы попробуем еще раз, если мы не исчерпали все наши повторные попытки.
В этом разделе показано, как пример повторной попытки одновременной блокировки.
ПРИМЕЧАНИЕ.
Этот класс идентичен тому, который использовался в примере @AspectJ, но с аннотации удалены.
	<aop:config>
		<aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor">
			<aop:pointcut id="idempotentOperation"

expression="execution(* com.xyz.service.*.*(..))"/>
			<aop:around
				pointcut-ref="idempotentOperation"
				method="doConcurrentOperation"/>
		</aop:aspect>
	</aop:config>
	<bean id="concurrentOperationExecutor"
		class="com.xyz.service.impl.ConcurrentOperationExecutor">
			<property name="maxRetries" value="3"/>
			<property name="order" value="100"/>
	</bean>
Соответствующая конфигурация Spring выглядит следующим образом:.
Обратите внимание: на данный момент мы предполагаем, что все бизнес-сервисы идемпотентны.
Если это не так, мы можем уточнить этот аспект, чтобы он повторял только искренние попытки. идемпотентные операции, вводя аннотацию «Идемпотент» и используя аннотацию для аннотирования реализации сервисных операций, как показано в следующем примере:
Java
	@Retention(RetentionPolicy.RUNTIME)
	// аннотация маркера
	public @interface Idempotent {
	@Retention(AnnotationRetention.RUNTIME)
	// аннотация маркера
	annotation class Idempotent
Соответствующая конфигурация Spring выглядит следующим образом:. изменение аспекта, позволяющего повторять только идемпотентные операции, требует уточнения выражение pointcut, чтобы совпадали только операции `@Idempotent`, как показано ниже:
	<aop:pointcut id="idempotentOperation"

expression="execution(* com.xyz.service.*.*(..)) and
			@annotation(com.xyz.service.Idempotent)"/>

1. Введение. `security` реализует аутентификацию, авторизацию, шифрование и политики доступа на уровне endpoint, сервиса и данных.
- предотвращает несанкционированный доступ;
- унифицирует security-конфигурацию;
- обеспечивает аудит безопасности и соответствие требованиям.
```xml
```java
    @RequiresRole("PAYROLL_ADMIN")
    public void recalculatePayroll() {
        // Доступ только для роли PAYROLL_ADMIN.
    @RequiresPermission("employee:read")
    public String getEmployee(String id) {
        return "employee:" + id;
```java
    private final CryptoService cryptoService;
    public SecretTokenStore(CryptoService cryptoService) {
        this.cryptoService = cryptoService;
    public String encryptToken(String rawToken) {
        return cryptoService.encrypt(rawToken);
    public String decryptToken(String encryptedToken) {
        return cryptoService.decrypt(encryptedToken);
```yaml
    auth:
      provider: jwt
      jwt:
        issuer: lilipup-auth
        audience: internal-services
        public-key-path: classpath:keys/public.pem
        clock-skew-sec: 30
    authorization:
      default-policy: deny
      cache-ttl-sec: 60
    crypto:
      algorithm: AES_GCM
      key-source: env
      key-env-name: LILIPUP_MASTER_KEY
    audit:
      enabled: true
      include-request-body: false
- Всегда используйте `default-policy: deny` как безопасный baseline.

- Проверяйте срок действия JWT и `issuer/audience` при каждом запросе.
- Никогда не храните master key в plaintext-конфиге.
- Проверяйте, что аудит включен для критичных операций.
- Не используйте симметричное шифрование без ротации ключей.
- `AuthenticationException`: невалидный токен или отсутствует credential.
- `AccessDeniedException`: недостаточно ролей/permission.
- `CryptoOperationException`: ошибка шифрования/дешифрования.
```java
    public int mapToHttpStatus(Exception ex) {
        if (ex instanceof AuthenticationException) {
            return 401;
        if (ex instanceof AccessDeniedException) {
            return 403;
        return 500;
- Применяйте principle of least privilege для ролей и permission.
- Разделяйте machine-to-machine и user-токены.
- Включайте key rotation и проверяйте обратную совместимость ключей.
- Маскируйте PII и секреты в логах.
- Проводите security regression tests для каждого релиза.

API веб-сокетов.
Spring Framework предоставляет API WebSocket, который можно использовать для написания клиентских и серверные приложения, обрабатывающие сообщения WebSocket.
`WebSocketHandler`.
Создать сервер WebSocket так же просто, как реализовать WebSocketHandler или что-то еще. вероятно, расширяя либо TextWebSocketHandler, либо BinaryWebSocketHandler.
Следующие в примере используется TextWebSocketHandler: См. пример кода в исходном документе.
`WebSocketHandler`.
Существует специальная программная конфигурация WebSocket и поддержка пространства имен XML для сопоставления предыдущих WebSocket к определенному URL-адресу, как показано в следующем примере: См. пример кода в исходном документе.
`WebSocketHandler`.
Предыдущий пример предназначен для использования в приложениях Spring MVC и его следует включить. в конфигурации файла `DispatcherServlet`.
Однако весна Поддержка WebSocket не зависит от Spring MVC.
Относительно просто интегрировать WebSocketHandler в другие среды HTTP-обслуживания с помощью {spring-framework-api}/web/socket/server/support/WebSocketHttpRequestHandler.html[`WebSocketHttpRequestHandler`].
`WebSocketHandler`.
При использовании API WebSocketHandler напрямую или косвенно, например, через поскольку базовый стандартный сеанс WebSocket (JSR-356) не допускает одновременного отправка.
Один из вариантов — обернуть WebSocketSession с помощью {spring-framework-api}/web/socket/handler/ConcurrentWebSocketSessionDecorator.html[`ConcurrentWebSocketSessionDecorator`].
Вебсокетное рукопожатие.

Самый простой способ настроить первоначальный запрос на рукопожатие HTTP WebSocket — через HandshakeInterceptor, который предоставляет методы «до» и «после» рукопожатия.
Вы можете использовать такой перехватчик, чтобы предотвратить рукопожатие или сделать какие-либо атрибуты доступен для `WebSocketSession`.
В следующем примере используется встроенный перехватчик. для передачи атрибутов сеанса HTTP в сеанс WebSocket: См. пример кода в исходном документе.
Вебсокетное рукопожатие.
Более продвинутый вариант — расширить DefaultHandshakeHandler, который выполняет этапы установления связи WebSocket, включая проверку происхождения клиента, согласование подпротокола и другие детали.
Приложению также может потребоваться использовать это вариант, если ему необходимо настроить специальную `RequestUpgradeStrategy` для адаптироваться к движку сервера WebSocket и его версии, которая еще не поддерживается (подробнее по этому вопросу см.
Deployment).
И конфигурация Java, и пространство имен XML позволяют настроить собственный `HandshakeHandler`.
Вебсокетное рукопожатие.
СОВЕТ: Spring предоставляет базовый класс WebSocketHandlerDecorator, который можно использовать для украшения WebSocketHandler с дополнительным поведением.
Логирование и обработка исключений реализации предоставляются и добавляются по умолчанию при использовании конфигурации Java WebSocket. или пространство имен XML. `ExceptionWebSocketHandlerDecorator` перехватывает все неперехваченные исключения, возникающие из любого метода `WebSocketHandler` и закрывающие WebSocket сеанс со статусом «1011», что указывает на ошибку сервера.
Развертывание.
API Spring WebSocket легко интегрировать в приложение Spring MVC, где DispatcherServlet обслуживает как рукопожатие HTTP WebSocket, так и другие HTTP-запросы.

Его также легко интегрировать в другие сценарии обработки HTTP. вызвав `WebSocketHttpRequestHandler`.
Это удобно и легко понимаю.
Однако в отношении среды выполнения JSR-356 применяются особые соображения.
Развертывание.
API Jakarta WebSocket (JSR-356) предоставляет два механизма развертывания.
Первый включает сканирование пути к классам контейнера сервлетов (функция сервлета 3) при запуске.
Другой — это API регистрации, который можно использовать при инициализации контейнера сервлетов.
Ни один из этих механизмов не позволяет использовать один «фронт-контроллер». для всей обработки HTTP, включая рукопожатие WebSocket и все другие HTTP-обработки. запросы, такие как DispatcherServlet Spring MVC.
Развертывание.
Это существенное ограничение JSR-356, которое поддерживает Spring WebSocket. стандартная реализация RequestUpgradeStrategy при работе в среде выполнения WebSocket API 2.1+.
Развертывание.
Вторым соображением является то, что ожидаются контейнеры сервлетов с поддержкой JSR-356. для выполнения сканирования `ServletContainerInitializer` (SCI), которое может замедлить работу приложения запуск - в некоторых случаях, резко.
Если значительное воздействие наблюдается после обновиться до версии контейнера сервлетов с поддержкой JSR-356, это должно возможность выборочного включения или отключения веб-фрагментов (и сканирования SCI) с помощью элемента `<absolute-ordering />` в `web.xml`, как показано в следующем примере:

<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			https://jakarta.ee/xml/ns/jakartaee
			https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
		version="5.0">
		<absolute-ordering/>
	</web-app>
Развертывание.
Затем вы можете выборочно включать веб-фрагменты по имени, например собственный Spring.
SpringServletContainerInitializer, обеспечивающий поддержку сервлета 3.
API инициализации Java.
В следующем примере показано, как это сделать:
	<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			https://jakarta.ee/xml/ns/jakartaee
			https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
		version="5.0">
		<absolute-ordering>
			<name>spring_web</name>
		</absolute-ordering>
	</web-app>
Настройка сервера.

Вы можете настроить базовый сервер WebSocket, например размер буфера входных сообщений, тайм-аут простоя и многое другое.
Настройка сервера.
Для серверов Jakarta WebSocket вы можете добавить ServletServerContainerFactoryBean в свой конфигурация.
Например: См. пример кода в исходном документе.
Настройка сервера.
ПРИМЕЧАНИЕ.
Для конфигурации клиента Jakarta WebSocket используйте ContainerProvider.getWebSocketContainer() в программной конфигурации или `WebSocketContainerFactoryBean` в XML.
Настройка сервера.
Для Jetty вы можете предоставить обратный вызов для настройки сервера WebSocket: См. пример кода в исходном документе.
Настройка сервера.
СОВЕТ: При использовании STOMP через WebSocket вам также необходимо настроить свойства.
Разрешенные источники.
Начиная с Spring Framework 4.1.5, поведение по умолчанию для WebSocket и SockJS — принимать только запросы одного происхождения.
Также возможно разрешить все или указанный список источников.
Эта проверка в основном предназначена для браузерных клиентов.
Ничто не мешает другим типам клиентов от изменения значения заголовка Origin (см. {rfc-site}/rfc6454 [RFC 6454: Концепция веб-происхождения] для более подробной информации).
 * Разрешить только запросы того же происхождения (по умолчанию). В этом режиме, когда SockJS включен,
Три возможных варианта поведения:.
Заголовок ответа HTTP Iframe `X-Frame-Options` установлен в `SAMEORIGIN`, а JSONP транспорт отключен, так как не позволяет проверить происхождение запроса.

Как следствие, IE6 и IE7 не поддерживаются, когда этот режим включен.
 * Разрешить указанный список источников: каждый разрешенный источник должен начинаться с `http://`
Три возможных варианта поведения:. или `https://`.
В этом режиме, когда SockJS включен, транспорт IFrame отключен.
Как следствие, IE6–IE9 не поддерживаются, когда это режим включен.
 * Разрешить все источники: чтобы включить этот режим, вы должны указать `{asterisk}` в качестве разрешенного источника.
Три возможных варианта поведения:. ценность.
В этом режиме доступны все транспорты.
Три возможных варианта поведения:.
Вы можете настроить разрешенные источники WebSocket и SockJS, как показано в следующем примере: См. пример кода в исходном документе.

`@SessionAttribute`.
Если вам нужен доступ к уже существующим атрибутам сеанса, которые управляются глобально (то есть вне контроллера, например, с помощью фильтра) и может присутствовать или отсутствовать, вы можете использовать аннотацию @SessionAttribute для параметра метода, как показано в следующем примере:
Java
	@GetMapping("/")
	public String handle(@SessionAttribute User user) { // <1>
`@SessionAttribute`. <1> Использование `@SessionAttribute`.
`@SessionAttribute`.
В случаях использования, требующих добавления или удаления атрибутов сеанса, рассмотрите возможность внедрения `WebSession` в метод контроллера.
`@SessionAttribute`.
Для временного хранения атрибутов модели в сеансе в составе контроллера рабочего процесса, рассмотрите возможность использования SessionAttributes, как описано в

`@SessionAttributes` используется для хранения атрибутов модели в `WebSession` между запросы.
Это аннотация уровня типа, которая объявляет атрибуты сеанса, используемые конкретный контроллер.
Обычно здесь перечислены имена атрибутов модели или типов атрибуты модели, которые должны прозрачно храниться в сеансе для последующего запросы на доступ.
Java
	@Controller
	@SessionAttributes("pet") <1>
	public class EditPetForm {
Рассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`.
	@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {
Рассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`.
Рассмотрим следующий пример:.
При первом запросе, когда в модель добавляется атрибут модели с именем «pet», он автоматически повышается и сохраняется в `WebSession`.
Оно остается там до тех пор, пока другой метод контроллера использует аргумент метода SessionStatus для очистки хранилища, как показано в следующем примере:
Java
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {
		@PostMapping("/pets/{id}")
		public String handle(Pet pet, BindingResult errors, SessionStatus status) { // <2>
			if (errors.hasErrors()) {
				status.setComplete();
Рассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`. <2> Использование переменной SessionStatus.

@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {
Рассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`. <2> Использование переменной SessionStatus.

Упрощение операций JDBC с помощью классов SimpleJdbc.
Классы SimpleJdbcInsert и SimpleJdbcCall предоставляют упрощенную конфигурацию. используя метаданные базы данных, которые можно получить с помощью драйвера JDBC.
Это означает, что вам придется меньше настраивать заранее, хотя вы можете переопределить или отключить обработку метаданных, если вы предпочитаете предоставить все детали в своем коде.
Вставка данных с помощью SimpleJdbcInsert.
Начнем с рассмотрения класса SimpleJdbcInsert с минимальным количеством варианты конфигурации.
Вы должны создать экземпляр SimpleJdbcInsert при доступе к данным. метод инициализации слоя.
В этом примере метод инициализации — это метод `setDataSource`.
Вам не нужно создавать подкласс класса SimpleJdbcInsert.
Вместо этого, вы можете создать новый экземпляр и установить имя таблицы, используя метод withTableName.
Методы конфигурации для этого класса следуют «свободному» стилю, который возвращает экземпляр. из SimpleJdbcInsert, который позволяет объединить все методы конфигурации.
Следующие В примере используется только один метод конфигурации (позже мы покажем примеры нескольких методов):
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcInsert insertActor;
		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
		public void add(Actor actor) {
			Map<String, Object> parameters = new HashMap<>(3);
			parameters.put("id", actor.getId());
			parameters.put("first_name", actor.getFirstName());

parameters.put("last_name", actor.getLastName());
			insertActor.execute(parameters);
		// ... дополнительные методы
Вставка данных с помощью SimpleJdbcInsert.
Используемый здесь метод `execute` принимает простой `java.util.Map` в качестве единственного параметра.
Здесь важно отметить, что ключи, используемые для «Карты», должны соответствовать столбцу имена таблиц, определенные в базе данных.
Это потому, что мы читаем метаданные для создания фактического оператора вставки.
Получение автоматически сгенерированных ключей с помощью SimpleJdbcInsert.
В следующем примере используется та же вставка, что и в предыдущем примере, но вместо передачи `id` извлекает автоматически сгенерированный ключ и устанавливает его в новом объекте «Актер».
Когда он создает `SimpleJdbcInsert`, помимо указания имени таблицы, указывает имя сгенерированного ключевого столбца с помощью метода usingGeneratedKeyColumns.
Следующие листинг показывает, как это работает:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcInsert insertActor;
		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingGeneratedKeyColumns("id");
		public void add(Actor actor) {
			Map<String, Object> parameters = new HashMap<>(2);
			parameters.put("first_name", actor.getFirstName());

parameters.put("last_name", actor.getLastName());
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		// ... дополнительные методы
Получение автоматически сгенерированных ключей с помощью SimpleJdbcInsert.
Основное отличие при запуске вставки с использованием второго подхода заключается в том, что вы не добавьте «id» в «Map» и вызовите метод «executeAndReturnKey».
Это возвращает объект `java.lang.Number`, с помощью которого вы можете создать экземпляр числового типа, который используется в вашем доменном классе.
Вы не можете полагаться на то, что все базы данных вернут конкретную Java. класс здесь. `java.lang.Number` — это базовый класс, на который вы можете положиться.
Если у вас есть несколько автоматически созданных столбцов или сгенерированные значения нечисловые, вы можете используйте KeyHolder, возвращаемый методомexecuteAndReturnKeyHolder.
Указание столбцов для SimpleJdbcInsert.
Вы можете ограничить количество столбцов для вставки, указав список имен столбцов с помощью `usingColumns`, как показано в следующем примере:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcInsert insertActor;
		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingColumns("first_name", "last_name")
					.usingGeneratedKeyColumns("id");
		public void add(Actor actor) {

Map<String, Object> parameters = new HashMap<>(2);
			parameters.put("first_name", actor.getFirstName());
			parameters.put("last_name", actor.getLastName());
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		// ... дополнительные методы
Указание столбцов для SimpleJdbcInsert.
Выполнение вставки такое же, как если бы вы полагались на метаданные для определения какие столбцы использовать.
Использование SqlParameterSource для предоставления значений параметров.
Использование Map для предоставления значений параметров работает нормально, но это не самый удобный вариант. класс для использования.
Spring предоставляет несколько реализаций SqlParameterSource. интерфейс, который вы можете использовать вместо этого.
Первый — «BeanPropertySqlParameterSource», это очень удобный класс, если у вас есть класс, совместимый с JavaBean, который содержит ваши ценности.
Он использует соответствующий метод получения для извлечения параметра ценности.
В следующем примере показано, как использовать BeanPropertySqlParameterSource:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcInsert insertActor;
		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingGeneratedKeyColumns("id");
		public void add(Actor actor) {
			SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
			Number newId = insertActor.executeAndReturnKey(parameters);

actor.setId(newId.longValue());
		// ... дополнительные методы
Использование SqlParameterSource для предоставления значений параметров.
Другой вариант — MapSqlParameterSource, который похож на Map, но предоставляет больше возможностей. удобный метод addValue, который можно объединить в цепочку.
В следующем примере показано, как его использовать:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcInsert insertActor;
		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingGeneratedKeyColumns("id");
		public void add(Actor actor) {
			SqlParameterSource parameters = new MapSqlParameterSource()
					.addValue("first_name", actor.getFirstName())
					.addValue("last_name", actor.getLastName());
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		// ... дополнительные методы
Использование SqlParameterSource для предоставления значений параметров.
Как видите, конфигурация та же.
Только исполняемый код должен измениться на используйте эти альтернативные классы ввода.
Вызов хранимой процедуры с помощью SimpleJdbcCall.
Класс SimpleJdbcCall использует метаданные в базе данных для поиска имен in. и параметры `out`, чтобы вам не приходилось их явно объявлять.
Вы можете объявляйте параметры, если вы предпочитаете это делать, или если у вас есть параметры, которые не иметь автоматическое сопоставление с классом Java.

В первом примере показана простая процедура. который возвращает только скалярные значения в формате VARCHAR и DATE из базы данных MySQL.
Пример процедуры считывает указанную запись актера и возвращает `first_name`, Столбцы «last_name» и «birth_date» в виде параметров «out».
Следующие в листинге показан первый пример:
	СОЗДАТЬ ПРОЦЕДУРУ read_actor (
		IN in_id INTEGER,
		OUT out_first_name VARCHAR(100),
		OUT out_last_name VARCHAR(100),
		OUT out_birth_date DATE)
	BEGIN
		ВЫБЕРИТЕ имя, фамилию, дату рождения
		INTO out_first_name, out_last_name, out_birth_date
		FROM t_actor where id = in_id;
	END;
Вызов хранимой процедуры с помощью SimpleJdbcCall.
Параметр in_id содержит идентификатор актера, которого вы ищете. «Выход» параметры возвращают данные, считанные из таблицы.
Вызов хранимой процедуры с помощью SimpleJdbcCall.
Вы можете объявить SimpleJdbcCall аналогично объявлению SimpleJdbcInsert. ты должен создать экземпляр и настроить класс в методе инициализации вашего доступа к данным слой.
В отличие от класса StoredProcedure вам не нужно создавать подкласс. и вам не нужно объявлять параметры, которые можно найти в метаданных базы данных.
В следующем примере конфигурации SimpleJdbcCall используется предыдущая хранимая процедура.
Единственным параметром конфигурации (кроме DataSource) является имя сохраненного процедура.
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcCall procReadActor;
		public void setDataSource(DataSource dataSource) {
			this.procReadActor = new SimpleJdbcCall(dataSource)
					.withProcedureName("read_actor");
		public Actor readActor(Long id) {

SqlParameterSource in = new MapSqlParameterSource()
					.addValue("in_id", id);
			Map out = procReadActor.execute(in);
			Actor actor = new Actor();
			actor.setId(id);
			actor.setFirstName((String) out.get("out_first_name"));
			actor.setLastName((String) out.get("out_last_name"));
			actor.setBirthDate((Date) out.get("out_birth_date"));
			return actor;
		// ... дополнительные методы
			// ... дополнительные методы
Вызов хранимой процедуры с помощью SimpleJdbcCall.
Код, который вы пишете для выполнения вызова, включает в себя создание SqlParameterSource. содержащий параметр IN.
Вы должны соответствовать имени, указанному для входного значения. с именем параметра, объявленным в хранимой процедуре.
Дело не имеет соответствовать, поскольку вы используете метаданные для определения того, как следует ссылаться на объекты базы данных в хранимой процедуре.
То, что указано в исходном коде хранимой процедуры, не является обязательно так, как он хранится в базе данных.
Некоторые базы данных преобразуют имена во все верхний регистр, в то время как другие используют нижний регистр или регистр, как указано.
Вызов хранимой процедуры с помощью SimpleJdbcCall.

Метод `execute` принимает параметры IN и возвращает `Map`, который содержит любые `out` параметры, связанные с именем, указанным в хранимой процедуре.
В этом случае они `out_first_name`, `out_last_name` и `out_birth_date`.
Вызов хранимой процедуры с помощью SimpleJdbcCall.
Последняя часть метода «execute» создает экземпляр «Actor», который можно использовать для возврата данные получены.
Опять же, важно использовать имена параметров `out`, поскольку они объявляются в хранимой процедуре.
Также дело в названиях `out` параметры, хранящиеся в карте результатов, совпадают с именами параметров `out` в база данных, которая может различаться в зависимости от базы данных.
Чтобы сделать ваш код более переносимым, вам следует выполните поиск без учета регистра или поручите Spring использовать LinkedCaseInsensusMap.
Чтобы сделать последнее, вы можете создать свой собственный JdbcTemplate и установить setResultsMapCaseInsensitivity. свойство «истина».
Затем вы можете передать этот настроенный экземпляр JdbcTemplate в конструктор вашего SimpleJdbcCall.
В следующем примере показана эта конфигурация:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcCall procReadActor;
		public void setDataSource(DataSource dataSource) {
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
					.withProcedureName("read_actor");
		// ... дополнительные методы
Вызов хранимой процедуры с помощью SimpleJdbcCall.

Совершая это действие, вы избегаете конфликтов в регистре имен ваших вернул параметры `out`.
Явное объявление параметров для использования в SimpleJdbcCall.
Ранее в этой главе мы описали, как параметры извлекаются из метаданных, но вы можете их объявить. явно, если хотите.
Вы можете сделать это, создав и настроив SimpleJdbcCall с помощью метод DeclareParameters, который принимает переменное количество объектов SqlParameter. в качестве ввода.
Подробную информацию о том, как определить SqlParameter, см. в документе следующий раздел.
Явное объявление параметров для использования в SimpleJdbcCall.
ПРИМЕЧАНИЕ.
Явные объявления необходимы, если используемая вами база данных не поддерживается Spring. база данных.
В настоящее время Spring поддерживает поиск метаданных вызовов хранимых процедур для следующие базы данных: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle и Sybase.
Мы также поддерживаем поиск метаданных хранимых функций для MySQL, Microsoft SQL Server, и Оракул.
Явное объявление параметров для использования в SimpleJdbcCall.
Вы можете явно объявить один, некоторые или все параметры.
Параметр метаданные по-прежнему используются там, где вы явно не объявляете параметры.
Чтобы обойти все обработка поиска метаданных для потенциальных параметров и использование только объявленных параметров, вы можете вызвать метод `withoutProcedureColumnMetaDataAccess` как часть декларация.
Предположим, что у вас есть две или более разные сигнатуры вызова, объявленные для функция базы данных.

В этом случае вы вызываете useInParameterNames, чтобы указать список имен параметров IN, которые необходимо включить в данную сигнатуру.
Явное объявление параметров для использования в SimpleJdbcCall.
В следующем примере показан полностью объявленный вызов процедуры и используется информация из предыдущий пример:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcCall procReadActor;
		public void setDataSource(DataSource dataSource) {
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
					.withProcedureName("read_actor")
					.withoutProcedureColumnMetaDataAccess()
					.useInParameterNames("in_id")
					.declareParameters(
							new SqlParameter("in_id", Types.NUMERIC),
							new SqlOutParameter("out_first_name", Types.VARCHAR),
							new SqlOutParameter("out_last_name", Types.VARCHAR),
							new SqlOutParameter("out_birth_date", Types.DATE)
		// ... дополнительные методы
			// ... дополнительные методы
Явное объявление параметров для использования в SimpleJdbcCall.
Выполнение и конечные результаты двух примеров одинаковы.
Во втором примере указаны все детали явно, а не полагаться на метаданные.
Как определить `SqlParameters`.
Чтобы определить параметр для классов SimpleJdbc, а также для операций RDBMS. классов (описанных в Моделирование операций JDBC как объектов Java), вы можете использовать SqlParameter или один из его подклассов.
Для этого вы обычно указываете имя параметра и тип SQL в конструкторе.

Тип SQL указывается с помощью констант java.sql.Types.
Ранее в этой главе мы видели объявления похоже на следующее:
Java
	new SqlParameter("in_id", Types.NUMERIC),
	new SqlOutParameter("out_first_name", Types.VARCHAR),
	SqlParameter("in_id", Types.NUMERIC),
	SqlOutParameter("out_first_name", Types.VARCHAR),
Как определить `SqlParameters`.
Первая строка с `SqlParameter` объявляет параметр IN.
Вы можете использовать параметры IN как для вызовов хранимых процедур, так и для запросов с использованием `SqlQuery` и его подклассы (описаны в документе Понимание `SqlQuery`).
Как определить `SqlParameters`.
Вторая строка (с `SqlOutParameter`) объявляет параметр `out`, который будет использоваться в вызов хранимой процедуры.
Существует также SqlInOutParameter для параметров InOut. (параметры, которые предоставляют процедуре значение IN и которые также возвращают значение).
Как определить `SqlParameters`.
ПРИМЕЧАНИЕ.
Для предоставить входные значения.
Это отличается от класса StoredProcedure, который (для по соображениям обратной совместимости) позволяет предоставлять входные значения для параметров объявлен как SqlOutParameter.
Как определить `SqlParameters`.
Для параметров IN помимо имени и типа SQL можно указать масштаб числовые данные или имя типа для пользовательских типов баз данных.
Для параметров `out` вы можете предоставьте RowMapper для обработки сопоставления строк, возвращаемых курсором REF.

Другой вариант — указать `SqlReturnType`, который дает возможность определить индивидуальная обработка возвращаемых значений.
Вызов хранимой функции с помощью SimpleJdbcCall.
Вы можете вызвать хранимую функцию почти так же, как и хранимую процедуру, за исключением что вы указываете имя функции, а не имя процедуры.
Вы используете `withFunctionName` как часть конфигурации, чтобы указать, что вы хотите сделать вызов функции, и генерируется соответствующая строка для вызова функции.
А специализированный вызов (`executeFunction`) используется для запуска функции, и он возвращает возвращаемое значение функции как объект указанного типа, что означает, что вы делаете не нужно получать возвращаемое значение из карты результатов.
Подобный удобный метод (с именем «executeObject») также доступен для хранимых процедур, имеющих только один «выход». параметр.
Следующий пример (для MySQL) основан на хранимой функции с именем get_actor_name. который возвращает полное имя актера:
	СОЗДАТЬ ФУНКЦИЮ get_actor_name (in_id INTEGER)
	ВОЗВРАЩАЕТ VARCHAR(200) ЧИТАЕТ ДАННЫЕ SQL
	BEGIN
		DECLARE out_name VARCHAR(200);
		SELECT concat(first_name, ' ', Last_name)
			INTO out_name
			FROM t_actor where id = in_id;
		RETURN out_name;
	END;
Вызов хранимой функции с помощью SimpleJdbcCall.
Чтобы вызвать эту функцию, мы снова создаем SimpleJdbcCall в методе инициализации: как показано в следующем примере:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcCall funcGetActorName;
		public void setDataSource(DataSource dataSource) {

JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)
					.withFunctionName("get_actor_name");
		public String getActorName(Long id) {
			SqlParameterSource in = new MapSqlParameterSource()
					.addValue("in_id", id);
			String name = funcGetActorName.executeFunction(String.class, in);
			return name;
		// ... дополнительные методы
Вызов хранимой функции с помощью SimpleJdbcCall.
Используемый метод `executeFunction` возвращает `String`, содержащую возвращаемое значение из вызов функции.
Возврат курсора ResultSet или REF из SimpleJdbcCall.
Вызов хранимой процедуры или функции, возвращающей набор результатов, немного сложнее.
Некоторые базы данных возвращают наборы результатов во время обработки результатов JDBC, в то время как другие требуют явно зарегистрированный параметр `out` определенного типа.
Оба подхода требуют дополнительная обработка для перебора результирующего набора и обработки возвращенных строк.
С SimpleJdbcCall, вы можете использовать метод returnResultSet и объявить RowMapper. реализация, которая будет использоваться для определенного параметра.
Если набор результатов возвращаемые во время обработки результатов, имена не определены, поэтому возвращаемые результаты должны соответствовать порядку, в котором вы объявляете RowMapper. реализации.
Указанное имя по-прежнему используется для хранения обработанного списка результатов. в карте результатов, возвращаемой оператором выполнения.
Возврат курсора ResultSet или REF из SimpleJdbcCall.

В следующем примере (для MySQL) используется хранимая процедура, которая не принимает параметров IN и возвращает все строки из таблицы t_actor:
	CREATE PROCEDURE read_all_actors()
	BEGIN
	 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
	END;
Возврат курсора ResultSet или REF из SimpleJdbcCall.
Чтобы вызвать эту процедуру, вы можете объявить RowMapper.
Потому что класс, в который ты хочешь чтобы сопоставление соответствовало правилам JavaBean, вы можете использовать BeanPropertyRowMapper, созданный передача требуемого класса для сопоставления в методе newInstance.
В следующем примере показано, как это сделать:
Java
	public class JdbcActorDao implements ActorDao {
		private SimpleJdbcCall procReadAllActors;
		public void setDataSource(DataSource dataSource) {
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)
					.withProcedureName("read_all_actors")
					.returningResultSet("actors",
					BeanPropertyRowMapper.newInstance(Actor.class));
		public List getActorsList() {
			Map m = procReadAllActors.execute(new HashMap<String, Object>(0));
			return (List) m.get("actors");
		// ... дополнительные методы
Возврат курсора ResultSet или REF из SimpleJdbcCall.
Вызов «execute» передает пустую «Map», поскольку этот вызов не принимает никаких параметров.
Список актеров затем извлекается из карты результатов и возвращается вызывающей стороне.

Решения распространенных проблем.
В этом разделе описаны решения некоторых распространенных проблем.
Использование неправильного менеджера транзакций для определенного «источника данных».
Используйте правильную реализацию PlatformTransactionManager на основе вашего выбора. транзакционные технологии и требования.
При правильном использовании Spring Framework просто обеспечивает простую и переносимую абстракцию.
Если вы используете глобальный транзакции, вы должны использовать Класс `org.springframework.transaction.jta.JtaTransactionManager` (или it) для всех ваших транзакционных операций.
В противном случае инфраструктура транзакций пытается выполнить локальные транзакции с такими ресурсами, как контейнер DataSource. экземпляры.
Такие локальные транзакции не имеют смысла, а хороший сервер приложений воспринимает их как ошибки.

Использование стандартных аннотаций JSR-330.
Spring предлагает поддержку стандартных аннотаций _Dependency Injection_ JSR-330, которые доступен в пакете `jakarta.inject`.
Эти аннотации могут опционально использоваться как альтернативы аннотациям Spring.
Использование стандартных аннотаций JSR-330.
Чтобы использовать их, вам необходимо иметь соответствующий jar в вашем пути к классам.
Например, Артефакт `jakarta.inject` доступен в стандартном репозитории Maven. (`https://repo.maven.apache.org/maven2/jakarta/inject/jakarta.inject-api/2.0.0/`),
Использование стандартных аннотаций JSR-330. [ПРИМЕЧАНИЕ] = Если вы используете Maven, вы можете добавить следующую зависимость в файл pom.xml.
	<dependency>
		<groupId>jakarta.inject</groupId>
		<artifactId>jakarta.inject-api</artifactId>
		<version>2.0.0</version>
	</dependency>
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Вместо использования `@Autowired` для внедрения зависимостей вы можете при желании использовать `@jakarta.inject.Inject` следующим образом.
Java
	import jakarta.inject.Inject;
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		public void listMovies() {

this.movieFinder.findMovies(...);
	class SimpleMovieLister {
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Как и в случае с `@Autowired`, вы можете использовать `@Inject` на уровне поля, уровне метода и уровень аргументов конструктора.
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Более того, в качестве альтернативы механизму Spring ObjectProvider вы можете выбрать объявите свою точку инъекции как `jakarta.inject.Provider`, что позволит выполнять ее по требованию. доступ к компонентам более короткой области действия или ленивый доступ к другим компонентам через Вызов Provider.get().
Следующий пример предлагает вариант предыдущего примера.
Java
	import jakarta.inject.Inject;
	import jakarta.inject.Provider;
	public class SimpleMovieLister {
		private Provider<MovieFinder> movieFinder;
		@Inject
		public void setMovieFinder(Provider<MovieFinder> movieFinder) {
			this.movieFinder = movieFinder;
		public void listMovies() {
			this.movieFinder.get().findMovies(...);
	class SimpleMovieLister {
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Если вы хотите использовать полное имя для зависимости, которую следует внедрить, вы может использовать аннотацию `@Named` в качестве альтернативы Spring `@Qualifier` поддержку, как показано в следующем примере.
Java
	import jakarta.inject.Inject;

import jakarta.inject.Named;
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Inject
		public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
	class SimpleMovieLister {
	import jakarta.inject.Inject;
	import java.util.Optional;
	public class SimpleMovieLister {
		@Inject
		public void setMovieFinder(Optional<MovieFinder> movieFinder) {
Java
	import jakarta.inject.Inject;
	import org.jspecify.annotations.Nullable;
	public class SimpleMovieLister {
		@Inject
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
	class SimpleMovieLister {
Внедрение зависимостей с помощью `@Inject` и `@Named`. `@Named`: стандартный эквивалент аннотации `@Component`.
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Вместо `@Component` или других стереотипных аннотаций Spring вы можете при желании выбрать использовать `@jakarta.inject.Named`, как показано в следующем примере.
Java
	import jakarta.inject.Inject;
	import jakarta.inject.Named;
	@Named("movieListener")
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
	@Named("movieListener")
	class SimpleMovieLister {
Внедрение зависимостей с помощью `@Inject` и `@Named`.

Очень часто используется `@Component` или другие аннотации стереотипов Spring без указав явное имя для компонента, а `@Named` можно использовать в аналогичном мода, как показывает следующий пример.
Java
	import jakarta.inject.Inject;
	import jakarta.inject.Named;
	@Named
	public class SimpleMovieLister {
		private MovieFinder movieFinder;
		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
	@Named
	class SimpleMovieLister {
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Когда вы используете `@Named`, вы можете использовать сканирование компонентов точно так же, как и при используйте аннотации Spring, как показано в следующем примере.
Java
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
Внедрение зависимостей с помощью `@Inject` и `@Named`.
ПРИМЕЧАНИЕ.
В отличие от @Component, аннотация JSR-330 @Named не является компонуемой. ты следует использовать стереотипную модель Spring для создания аннотаций пользовательских компонентов.

Внедрение зависимостей с помощью `@Inject` и `@Named`. [СОВЕТ] = Если вы работаете с устаревшими системами, которые все еще используют `@javax.inject.Named` или `@javax.annotation.ManagedBean` для компонентов (обратите внимание на пространство имен пакета `javax`), вы можно явно настроить сканирование компонентов для включения этих типов аннотаций, как показано в следующем примере.
Java
	@Configuration
	@ComponentScan(
		basePackages = "org.example",
		includeFilters = @Filter({
			javax.inject.Named.class,
			javax.annotation.ManagedBean.class
	public class AppConfig  {
Внедрение зависимостей с помощью `@Inject` и `@Named`.
Кроме того, если вы хотите, чтобы атрибуты `value` в `@javax.inject.Named` и `@javax.annotation.ManagedBean` для использования в качестве имен компонентов, вам необходимо переопределить `isStereotypeWithNameValue(...)` в `AnnotationBeanNameGenerator` для добавления явного поддержку javax.annotation.ManagedBean и javax.inject.Named и зарегистрируйте свой пользовательский AnnotationBeanNameGenerator через атрибут nameGenerator в `@ComponentScan`.
Ограничения стандартных аннотаций JSR-330.
Когда вы работаете со стандартными аннотациями JSR-330, вы должны знать, что некоторые важные функции недоступны, как показано в следующей таблице.
Ограничения стандартных аннотаций JSR-330.

Модель компонента Spring в сравнении с вариантами JSR-330 |=== | Весна | JSR-330 | Ограничения/комментарии JSR-330
Ограничения стандартных аннотаций JSR-330. | `@Autowired` | `@Инжект` | `@Inject` не имеет атрибута `required`.
Вместо этого можно использовать с Java `Optional`.
Ограничения стандартных аннотаций JSR-330. | `@Компонент` | `@Named` | JSR-330 не предоставляет составную модель, а только способ идентифицировать именованные компоненты.
Ограничения стандартных аннотаций JSR-330. | `@Scope("одиночка")` | `@Синглтон` | Область действия по умолчанию JSR-330 похожа на «прототип» Spring.
Однако, чтобы сохранить его в соответствии с общими настройками Spring по умолчанию, компонент JSR-330, объявленный в Spring контейнер по умолчанию является синглтоном.
Чтобы использовать область действия, отличную от «singleton», вам следует использовать аннотацию Spring `@Scope`. `jakarta.inject` также предоставляет аннотация `jakarta.inject.Scope`; однако этот предназначен только для использования для создания пользовательских аннотаций.
Ограничения стандартных аннотаций JSR-330. | `@Квалификатор` | `@Qualifier` / `@Named` | `jakarta.inject.Qualifier` — это просто метааннотация для создания пользовательских квалификаторов.

Могут быть связаны конкретные квалификаторы `String` (например, `@Qualifier` Spring со значением). через `jakarta.inject.Named`.
| `@Ленивый` | - | нет эквивалента. | `ОбъектФабрика` | `Провайдер` | `jakarta.inject.Provider` является прямой альтернативой Spring `ObjectFactory`, только с более коротким именем метода get().
Его также можно использовать в сочетании с Spring `@Autowired` или с неаннотированными конструкторами и методами установки. |===

Статические ресурсы.
Эта опция обеспечивает удобный способ обслуживания статических ресурсов из списка Местоположение на основе {spring-framework-api}/core/io/Resource.html[`Resource`].
Статические ресурсы.
В следующем примере для запроса, начинающегося с `/resources`, относительный путь будет равен используется для поиска и обслуживания статических ресурсов относительно `/public` в веб-приложении root или в пути к классам в `/static`.
Ресурсы предоставляются с перспективой на один год. истечения срока действия, чтобы обеспечить максимальное использование кэша браузера и сокращение количества HTTP-запросов. сделанный браузером.
Информация Last-Modified выводится из Resource#lastModified. так что условные запросы HTTP поддерживаются заголовками Last-Modified.
Статические ресурсы.
В следующем листинге показано, как это сделать: См. пример кода в исходном документе.
См. также.
Обработчик ресурсов также поддерживает цепочку реализации {spring-framework-api}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`] и реализации {spring-framework-api}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`], который вы можете использовать для создания набора инструментов для работы с оптимизированными ресурсами.
См. также.
Вы можете использовать VersionResourceResolver для URL-адресов ресурсов с поддержкой версий на основе хеша MD5. вычисляется на основе контента, фиксированной версии приложения или чего-то еще.

А `ContentVersionStrategy` (хэш MD5) — хороший выбор, за некоторыми заметными исключениями, такими как Ресурсы JavaScript, используемые с загрузчиком модулей.
См. также.
В следующем примере показано, как использовать VersionResourceResolver: См. пример кода в исходном документе.
См. также.
Затем вы можете использовать ResourceUrlProvider, чтобы перезаписать URL-адреса и применить полную цепочку преобразователей и преобразователи — например, для вставки версий.
Конфигурация MVC предоставляет ResourceUrlProvider. bean, чтобы его можно было внедрить другим.
Вы также можете сделать перезапись прозрачной с помощью `ResourceUrlEncodingFilter` для Thymeleaf, JSP, FreeMarker и других с тегами URL, которые полагайтесь на HttpServletResponse#encodeURL.
См. также.
Обратите внимание, что при использовании обоих EncodedResourceResolver (например, для ресурсы в кодировке brotli) и `VersionResourceResolver`, вы должны зарегистрировать их в этом порядке.
Это гарантирует, что версии на основе содержимого всегда надежно вычисляются на основе незакодированного файла.
См. также.
Для https://www.webjars.org/documentation[WebJars] URL-адреса с версиями, например `/webjars/jquery/1.2.0/jquery.min.js` — рекомендуемый и наиболее эффективный способ их использования.

Местоположение связанного ресурса настраивается «из коробки» с помощью Spring Boot (или может быть настроено вручную через `ResourceHandlerRegistry`) и не требует добавления Зависимость `org.webjars:webjars-locator-lite`.
См. также.
URL-адреса без версий, такие как `/webjars/jquery/jquery.min.js`, поддерживаются через `WebJarsResourceResolver`, который автоматически регистрируется при Библиотека `org.webjars:webjars-locator-lite` присутствует в пути к классам.
Резолвер может перезаписать URL-адреса, включающие версию jar, а также могут сопоставляться с входящими URL-адресами без версий. -- например, с `/webjars/jquery/jquery.min.js` на `/webjars/jquery/1.2.0/jquery.min.js`.
См. также.
СОВЕТ: Конфигурация Java, основанная на ResourceHandlerRegistry, предоставляет дополнительные возможности. для детального контроля, например, поведения последнего изменения и оптимизированного разрешения ресурсов.

ТОПАТЬ.
Протокол WebSocket определяет два типа сообщений (текстовые и двоичные), но их содержание не определено.
Протокол определяет механизм для клиента и сервера для согласования подпротокол (то есть протокол обмена сообщениями более высокого уровня), который можно использовать поверх WebSocket для определить, какие сообщения каждый может отправлять, каков формат и содержание каждого сообщение и так далее.
Использование подпротокола не является обязательным, но в любом случае клиент и серверу необходимо согласовать некоторый протокол, определяющий содержимое сообщения.

Понимание абстракции транзакций Spring Framework.
Ключом к абстракции транзакций Spring является понятие стратегии транзакций.
А стратегия транзакции определяется TransactionManager, в частности Интерфейс `org.springframework.transaction.PlatformTransactionManager` для императива управление транзакциями и Интерфейс `org.springframework.transaction.ReactiveTransactionManager` для реактивного управление транзакциями.
В следующем листинге показано определение API «PlatformTransactionManager»:
	public interface PlatformTransactionManager extends TransactionManager {
		TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
		void commit(TransactionStatus status) throws TransactionException;
		void rollback(TransactionStatus status) throws TransactionException;
Понимание абстракции транзакций Spring Framework.
В первую очередь это интерфейс поставщика услуг (SPI), хотя вы можете использовать и его. «PlatformTransactionManager» — это интерфейс, его можно легко имитировать или заглушить как необходимо.
Он не привязан к стратегии поиска, такой как JNDI.
Реализации PlatformTransactionManager определяются как любой другой объект (или bean-компонент). в IoC-контейнере Spring Framework.
Уже одно это преимущество делает Spring Framework транзакции — достойная абстракция, даже если вы работаете с JTA.
Вы можете протестировать транзакционный код гораздо проще, чем если бы он напрямую использовал JTA.
Понимание абстракции транзакций Spring Framework.
Опять же, в соответствии с философией Spring, исключение TransactionException, которое может быть выброшено любым из методов интерфейса PlatformTransactionManager снят флажок (этот то есть он расширяет класс `java.lang.RuntimeException`).
Транзакционная инфраструктура неудачи почти всегда фатальны.

В редких случаях, когда код приложения действительно может восстановиться после сбоя транзакции, разработчик приложения все равно может перехватить и обработать TransactionException.
Важным моментом является то, что разработчики не _вынужден_ сделать это.
Понимание абстракции транзакций Spring Framework.
Метод getTransaction(..) возвращает объект TransactionStatus, в зависимости от Параметр TransactionDefinition.
Возвращенный `TransactionStatus` может представлять собой новая транзакция или может представлять существующую транзакцию, если соответствующая транзакция существует в текущем стеке вызовов.
В последнем случае подразумевается, что, как и в случае с В контексте транзакций Jakarta EE TransactionStatus связан с потоком исполнение.
	public interface ReactiveTransactionManager extends TransactionManager {
		Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;
		Mono<Void> commit(ReactiveTransaction status) throws TransactionException;
		Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;
Понимание абстракции транзакций Spring Framework.
Менеджер реактивных транзакций — это прежде всего интерфейс поставщика услуг (SPI). хотя вы можете использовать его программно из своего код приложения.
Поскольку `ReactiveTransactionManager` — это интерфейс, его можно легко высмеивали или затыкали по мере необходимости.
* Распространение. Обычно весь код в области транзакции выполняется в
Интерфейс TransactionDefinition определяет:. эта транзакция.
Однако вы можете указать поведение, если транзакционный метод запускается, когда контекст транзакции уже существует.
Для Например, код может продолжать работу в существующей транзакции (обычный случай) или существующую транзакцию можно приостановить и создать новую транзакцию.

Весна предлагает все варианты распространения транзакций, знакомые по EJB CMT.
Читать о семантике распространения транзакций в Spring см.
Распространение транзакций.
* Изоляция: степень, в которой эта транзакция изолирована от работы других
Интерфейс TransactionDefinition определяет:. транзакции.
Например, может ли эта транзакция видеть незафиксированные записи от других транзакции?
* Тайм-аут: как долго выполняется эта транзакция до истечения времени ожидания и автоматического отката.
Интерфейс TransactionDefinition определяет:. базовой инфраструктурой транзакций.
* Статус «только для чтения». Вы можете использовать транзакцию только для чтения, если ваш код читается, но
Интерфейс TransactionDefinition определяет:. не изменяет данные.
Транзакции только для чтения могут быть полезной оптимизацией в некоторых случаях. случаях, например, когда вы используете Hibernate.
Интерфейс TransactionDefinition определяет:.
Эти настройки отражают стандартные концепции транзакций.
При необходимости обратитесь к ресурсам в которых обсуждаются уровни изоляции транзакций и другие основные концепции транзакций.
Понимание этих концепций необходимо для использования Spring Framework или любого другого решение для управления транзакциями.
Интерфейс TransactionDefinition определяет:.
Интерфейс TransactionStatus предоставляет простой способ транзакционному коду контролировать выполнение транзакции и запрашивать статус транзакции.
Концепции должны быть знакомы, поскольку они являются общими для всех API транзакций.
В следующем листинге показаны Интерфейс `TransactionStatus`:
	public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {
		@Override
		boolean isNewTransaction();
		boolean hasSavepoint();
		@Override
		void setRollbackOnly();
		@Override
		boolean isRollbackOnly();

void flush();
		@Override
		boolean isCompleted();
Интерфейс TransactionDefinition определяет:.
Независимо от того, выбираете ли вы декларативное или программное управление транзакциями в Spring, определение правильной реализации TransactionManager абсолютно необходимо.
Обычно вы определяете эту реализацию посредством внедрения зависимостей.
Интерфейс TransactionDefinition определяет:.
Реализации TransactionManager обычно требуют знания среды в на которых они работают: JDBC, JTA, Hibernate и так далее.
Следующие примеры показывают, как вы можете определить локальную реализацию PlatformTransactionManager (в данном случае с помощью простого JDBC.)
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driverClassName}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>
Вы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.
Соответствующее определение bean-компонента PlatformTransactionManager затем содержит ссылку на Определение `Источника данных`.
Это должно напоминать следующий пример:

<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
Вы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.
Если вы используете JTA в контейнере Jakarta EE, вы используете контейнер DataSource, полученный через JNDI в сочетании с Spring JtaTransactionManager.
Следующий пример показывает, как будет выглядеть версия поиска JTA и JNDI:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/jee
			https://www.springframework.org/schema/jee/spring-jee.xsd">

<jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/>
		<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />
		<!-- other <bean/> definitions here -->
	</beans>
Вы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:. `JtaTransactionManager` не обязательно должен знать об `DataSource` (или любом другом определенные ресурсы), поскольку он использует глобальное управление транзакциями контейнера. инфраструктура.
Вы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.
ПРИМЕЧАНИЕ.
В предыдущем определении bean-компонента `dataSource` используется тег `<jndi-lookup/>`. из пространства имен `jee`.
Для получения дополнительной информации см.
Вы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.
ПРИМЕЧАНИЕ.
Если вы используете JTA, определение вашего менеджера транзакций должно выглядеть одинаково, независимо от какую технологию доступа к данным вы используете, будь то JDBC, Hibernate JPA или любая другая поддерживаемая технология.
Это связано с тем, что транзакции JTA являются глобальными транзакциями, которые может подключить любой транзакционный ресурс.
Вы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.

Во всех настройках транзакций Spring код приложения изменять не нужно.
Вы можете изменить как транзакции управляются простым изменением конфигурации, даже если это изменение означает переход от локальных транзакций к глобальным и наоборот.
Настройка транзакции в спящем режиме.
Вы также можете легко использовать локальные транзакции Hibernate, как показано в следующих примерах.
В этом случае вам необходимо определить Hibernate `LocalSessionFactoryBean`, который будет код приложения можно использовать для получения экземпляров сеанса Hibernate.
Настройка транзакции в спящем режиме.
Определение bean-компонента DataSource похоже на локальный пример JDBC, показанный ранее. и, таким образом, не показано в следующем примере.
Настройка транзакции в спящем режиме.
ПРИМЕЧАНИЕ.
Если `DataSource` (используемый любым менеджером транзакций, отличным от JTA) просматривается через JNDI и управляемый контейнером Jakarta EE, он должен быть нетранзакционным, поскольку Spring Framework (а не контейнер Jakarta EE) управляет транзакциями.
Настройка транзакции в спящем режиме.
Компонент `txManager` в этом случае имеет тип `HibernateTransactionManager`.
В так же, как DataSourceTransactionManager нуждается в ссылке на DataSource, HibernateTransactionManager нуждается в ссылке на SessionFactory.
Следующие пример объявляет bean-компоненты `sessionFactory` и `txManager`:
	<bean id="sessionFactory" class="org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mappingResources">
			<list>

<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
			</list>
		</property>
		<property name="hibernateProperties">
			<value>
				hibernate.dialect=${hibernate.dialect}
			</value>
		</property>
	</bean>
	<bean id="txManager" class="org.springframework.orm.jpa.hibernate.HibernateTransactionManager">
		<property name="sessionFactory" ref="sessionFactory"/>
	</bean>
Настройка транзакции в спящем режиме.
Если вы используете транзакции JTA, управляемые контейнером Hibernate и Jakarta EE, вам следует использовать тот же `JtaTransactionManager`, что и в предыдущем примере JTA для JDBC, а именно: пример показывает.
Кроме того, рекомендуется информировать Hibernate о JTA через его координатор транзакций и, возможно, также конфигурация режима освобождения соединения:
	<bean id="sessionFactory" class="org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mappingResources">
			<list>
				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
			</list>
		</property>
		<property name="hibernateProperties">
			<value>

hibernate.dialect=${hibernate.dialect}
				hibernate.transaction.coordinator_class=jta
				hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT
			</value>
		</property>
	</bean>
	<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
Настройка транзакции в спящем режиме.
Или, альтернативно, вы можете передать JtaTransactionManager в свой LocalSessionFactoryBean. для обеспечения соблюдения тех же значений по умолчанию:
	<bean id="sessionFactory" class="org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mappingResources">
			<list>
				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
			</list>
		</property>
		<property name="hibernateProperties">
			<value>
				hibernate.dialect=${hibernate.dialect}
			</value>
		</property>
		<property name="jtaTransactionManager" ref="txManager"/>
	</bean>
	<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>

Использование реализаций TargetSource.
Spring предлагает концепцию TargetSource, выраженную в Интерфейс `org.springframework.aop.TargetSource`.
Этот интерфейс отвечает за возвращение «целевого объекта», реализующего точку соединения. «Целевой источник» реализация запрашивает целевой экземпляр каждый раз, когда прокси-сервер AOP обрабатывает метод призыв.
Использование реализаций TargetSource.
Разработчикам, использующим Spring AOP, обычно не требуется работать напрямую с реализациями TargetSource, но это обеспечивает мощные средства поддержки пула, горячей замены и других сложные цели.
Например, объединение TargetSource может возвращать другую цель. экземпляр для каждого вызова, используя пул для управления экземплярами.
Использование реализаций TargetSource.
Если вы не укажете TargetSource, для переноса будет использоваться реализация по умолчанию. локальный объект.
Одна и та же цель возвращается для каждого вызова (как и следовало ожидать).
Использование реализаций TargetSource.
Оставшаяся часть этого раздела описывает стандартные целевые источники, поставляемые с Spring, и способы их использования.
Использование реализаций TargetSource.
СОВЕТ: При использовании пользовательского целевого источника вашей целью обычно должен быть прототип. а не определение одноэлементного компонента.
Это позволяет Spring создать новую цель экземпляр, когда это необходимо.
Целевые источники с возможностью горячей замены. `org.springframework.aop.target.HotSwappableTargetSource` существует, чтобы позволить цели прокси-сервера AOP, позволяя вызывающим абонентам сохранять свои ссылки на него.
Целевые источники с возможностью горячей замены.
Изменение цели целевого источника вступает в силу немедленно.

HotSwappableTargetSource является потокобезопасным.
Целевые источники с возможностью горячей замены.
Вы можете изменить цель, используя метод swap() в HotSwappableTargetSource, как показано в следующем примере:
Java
	HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean("swapper");
	Object oldTarget = swapper.swap(newTarget);
	<bean id="initialTarget" class="mycompany.OldTarget"/>
	<bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource">
		<constructor-arg ref="initialTarget"/>
	</bean>
	<bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="targetSource" ref="swapper"/>
	</bean>
В следующем примере показаны необходимые определения XML:.
Предыдущий вызов swap() изменяет цель заменяемого компонента.
Клиенты, имеющие ссылка на этот компонент не знает об изменении, но сразу же начинает нажимать новая цель.
В следующем примере показаны необходимые определения XML:.
Хотя этот пример не добавляет никаких советов (нет необходимости добавлять советы к используйте TargetSource), любой TargetSource можно использовать в сочетании с произвольный совет.
Объединение целевых источников.
Использование целевого источника пула обеспечивает модель программирования, аналогичную сеансу без сохранения состояния.
EJB, в которых поддерживается пул идентичных экземпляров с вызовами методов. собираюсь освободить объекты в бассейне.

Объединение целевых источников.
Принципиальное различие между пулом Spring и пулом SLSB заключается в том, что пул Spring может применяться к любому POJO.
Как и в случае со Spring в целом, этот сервис можно применять в неинвазивный способ.
Объединение целевых источников.
Spring обеспечивает поддержку Commons Pool 2, который обеспечивает довольно эффективная реализация пула.
Вам понадобится Jar `commons-pool` на вашем путь к классам приложения, чтобы использовать эту функцию.
Вы также можете создать подкласс `org.springframework.aop.target.AbstractPoolingTargetSource` для поддержки любых других пул API.
	<bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject"
			scope="prototype">
		... properties omitted
	</bean>
	<bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPool2TargetSource">
		<property name="targetBeanName" value="businessObjectTarget"/>
		<property name="maxSize" value="25"/>
	</bean>
	<bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="targetSource" ref="poolTargetSource"/>
		<property name="interceptorNames" value="myInterceptor"/>
	</bean>
В следующем листинге показан пример конфигурации:.

Обратите внимание, что целевой объект (businessObjectTarget в предыдущем примере) должен быть прототип.
Это позволяет реализации PoolingTargetSource создавать новые экземпляры. цели для увеличения пула по мере необходимости.
См. {spring-framework-api}/aop/target/AbstractPoolingTargetSource.html[javadoc of `AbstractPoolingTargetSource`] и конкретный подкласс, который вы хотите использовать для информации. о его свойствах. `maxSize` является самым простым и всегда гарантированно присутствует.
В следующем листинге показан пример конфигурации:.
В данном случае `myInterceptor` — это имя перехватчика, который необходимо определены в том же контексте IoC.
Однако вам не нужно указывать перехватчики для использовать пул.
Если вам нужно только объединение и никаких других советов, не устанавливайте `interceptorNames` вообще.
В следующем листинге показан пример конфигурации:.
Вы можете настроить Spring так, чтобы он мог приводить любой объект из пула к Интерфейс `org.springframework.aop.target.PoolingConfig`, который предоставляет информацию о конфигурации и текущем размере пула во введении. ты необходимо определить советника, подобного следующему:
	<bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="poolTargetSource"/>
		<property name="targetMethod" value="getPoolingConfigMixin"/>
	</bean>
В следующем листинге показан пример конфигурации:.

Этот советник получается вызовом удобного метода на Класс AbstractPoolingTargetSource, отсюда и использование MethodInvokingFactoryBean.
Это имя советника (здесь `poolConfigAdvisor`) должно быть в списке имен перехватчиков в `ProxyFactoryBean`, который предоставляет объединенный объект.
Java
	PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
	System.out.println("Max pool size is " + conf.getMaxSize());
Актерский состав определен следующим образом:.
ПРИМЕЧАНИЕ.
Объединение объектов службы без сохранения состояния в пул обычно не требуется.
Мы не считаем, что это должно быть выбором по умолчанию, поскольку большинство объектов без состояния, естественно, потокобезопасны, и экземпляр объединение в пул проблематично, если ресурсы кэшируются.
Актерский состав определен следующим образом:.
Более простой пул доступен при использовании автоматического проксирования.
Вы можете установить реализации TargetSource. используется любым создателем автоматических прокси.
Целевые источники прототипов.
Настройка целевого источника «прототипа» аналогична настройке пула «TargetSource».
В этом В этом случае новый экземпляр цели создается при каждом вызове метода.
Хотя стоимость создания нового объекта в современной JVM невелика, стоимость подключения новый объект (удовлетворяющий его зависимости IoC) может оказаться дороже.
Таким образом, вам не следует используйте этот подход без очень веской причины.
Целевые источники прототипов.
Для этого вы можете изменить определение `poolTargetSource`, показанное ранее, следующим образом: (мы также изменили название, для ясности):

<bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource">
		<property name="targetBeanName" ref="businessObjectTarget"/>
	</bean>
Целевые источники прототипов.
Единственное свойство — это имя целевого компонента.
Наследование используется в Реализации TargetSource для обеспечения согласованного именования.
Как и в случае с целью объединения исходный код, целевой компонент должен быть определением прототипа компонента.
Целевые источники `ThreadLocal` полезны, если вам нужно создать объект для каждого входящий запрос (то есть для каждого потока).
Концепция ThreadLocal обеспечивает общедоступный JDK возможность прозрачного хранения ресурса рядом с потоком.
Настройка `ThreadLocalTargetSource` практически такой же, как объяснялось для других типов. целевого источника, как показано в следующем примере:
	<bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource">
		<property name="targetBeanName" value="businessObjectTarget"/>
	</bean>
Целевые источники `ThreadLocal`.
ПРИМЕЧАНИЕ.
Экземпляры `ThreadLocal` вызывают серьезные проблемы (потенциально приводящие к утечкам памяти), когда неправильное использование их в многопоточных средах и средах с несколькими загрузчиками классов. ты всегда следует рассматривать возможность переноса ThreadLocal в какой-либо другой класс и никогда не использовать напрямую сам `ThreadLocal` (кроме класса-оболочки).

Кроме того, вам следует всегда не забывайте правильно устанавливать и снимать с охраны (если последнее предполагает вызов `ThreadLocal.remove()`) — локальный ресурс потока.
Снятие с охраны должно производиться в в любом случае, поскольку если не отключить настройку, это может привести к проблемному поведению.
Весна Поддержка `ThreadLocal` сделает это за вас, и ее всегда следует рассматривать в пользу использования Экземпляры `ThreadLocal` без другого надлежащего кода обработки.

Шаблоны выражений позволяют смешивать буквальный текст с одним или несколькими блоками оценки.
Каждый блок оценки ограничен префиксными и суффиксными символами, которые вы можете определить.
Распространенным выбором является использование `+#{ }+` в качестве разделителей, как показано в следующем примере. показывает:
Java
	String randomPhrase = parser.parseExpression(
			"random number is #{T(java.lang.Math).random()}",
			new TemplateParserContext()).getValue(String.class);
	// оценивается как «случайное число 0,7038186818312008»
Шаблоны выражений.
Строка оценивается путем объединения буквального текста `'случайное число'` с результат вычисления выражения внутри разделителей `+#{ }+` (в данном случае результат вызова этого метода `random()`).
Второй аргумент функции parseExpression(). метод имеет тип ParserContext.
Интерфейс ParserContext используется для влияния как выражение анализируется для поддержки функций шаблонов выражений. `TemplateParserContext`, использованный в предыдущем примере, находится в `org.springframework.expression.common` и является реализацией `ParserContext`, который по умолчанию настраивает префикс и суффикс на `#{` и `}`, соответственно.

Управление транзакциями.
Комплексная поддержка транзакций — одна из наиболее веских причин использовать Spring.
Рамки.
Spring Framework обеспечивает последовательную абстракцию для транзакций. управление, которое обеспечивает следующие преимущества:
* Согласованная модель программирования для различных API транзакций, таких как Java.
Управление транзакциями.
API транзакций (JTA), JDBC, Hibernate и API сохранения Java (JPA).
* Поддержка декларативного управления транзакциями.
* Более простой API для управления транзакциями.
Управление транзакциями. чем сложные API транзакций, такие как JTA.
* Отличная интеграция с абстракциями доступа к данным Spring.
* Преимущества модели поддержки транзакций Spring Framework
В следующих разделах описываются функции и технологии транзакций Spring Framework:. описывает, почему вам следует использовать абстракцию транзакций Spring Framework вместо EJB.
Транзакции, управляемые контейнером (CMT), или выбор управления транзакциями через собственный API.
* Понимание абстракции транзакций Spring Framework
В следующих разделах описываются функции и технологии транзакций Spring Framework:. описывает основные классы и описывает, как настроить и получить экземпляры DataSource. из самых разных источников.
* Синхронизация ресурсов с транзакциями
В следующих разделах описываются функции и технологии транзакций Spring Framework:. описывает, как код приложения обеспечивает правильное создание, повторное использование и очистку ресурсов.
* Декларативное управление транзакциями описывает поддержку
В следующих разделах описываются функции и технологии транзакций Spring Framework:. декларативное управление транзакциями.
* Программное управление транзакциями охватывает поддержку

В следующих разделах описываются функции и технологии транзакций Spring Framework:. программное (то есть явно закодированное) управление транзакциями.
* событие, связанное с транзакцией описывает, как вы можете использовать приложение.
В следующих разделах описываются функции и технологии транзакций Spring Framework:. события внутри транзакции.
В следующих разделах описываются функции и технологии транзакций Spring Framework:.
Глава также включает обсуждение передового опыта, и решения распространенных проблем.

Понимание реализации декларативных транзакций Spring Framework.
Недостаточно просто сказать вам аннотировать ваши классы с помощью аннотацию `@Transactional`, добавьте `@EnableTransactionManagement` в вашу конфигурацию, и ожидаю, что вы поймете, как все это работает.
Чтобы обеспечить более глубокое понимание, это В разделе объясняется внутренняя работа декларативной транзакции Spring Framework. инфраструктуры в контексте вопросов, связанных с транзакциями.
Понимание реализации декларативных транзакций Spring Framework.
Наиболее важные концепции, которые необходимо усвоить в отношении декларативной структуры Spring Framework. поддержка транзакций заключается в том, что эта поддержка включена рекомендации основаны на метаданных (в настоящее время основанных на XML или аннотациях).
Комбинация АОП с транзакционными метаданными дает прокси-сервер AOP, который использует TransactionInterceptor в сочетании с соответствующей реализацией TransactionManager для управления транзакциями вокруг вызовов методов.
Понимание реализации декларативных транзакций Spring Framework.
ПРИМЕЧАНИЕ.
Spring AOP описан в раздел AOP.
Понимание реализации декларативных транзакций Spring Framework.
Варианты управления транзакциями влияют на то, какой менеджер транзакций требуется.
Императив для транзакций требуется PlatformTransactionManager, а для реактивных транзакций используется Реализации ReactiveTransactionManager.
Понимание реализации декларативных транзакций Spring Framework. [ПРИМЕЧАНИЕ] = `@Transactional` обычно работает с транзакциями, связанными с потоками, управляемыми `PlatformTransactionManager`, предоставляющий транзакцию всем операциям доступа к данным внутри текущий поток выполнения.
Примечание.
Это _не_ распространяется на вновь запущенные потоки. внутри метода.
Понимание реализации декларативных транзакций Spring Framework.

Реактивная транзакция, управляемая ReactiveTransactionManager, использует контекст Reactor. вместо локальных атрибутов потока.
Как следствие, доступ к данным всех участников операции должны выполняться в одном и том же контексте Reactor в одном реактивном конвейере.
Понимание реализации декларативных транзакций Spring Framework.
При настройке с помощью ReactiveTransactionManager все методы, разграниченные по транзакциям, Ожидается, что они вернут реактивный трубопровод.
Необходимо использовать методы Void или обычные возвращаемые типы. быть связан с обычным «PlatformTransactionManager», например, через Атрибут transactionManager соответствующих объявлений @Transactional.
Понимание реализации декларативных транзакций Spring Framework.
На следующем изображении показано концептуальное представление вызова метода на транзакционном прокси-сервере:

Выбор между программным и декларативным управлением транзакциями.
Программное управление транзакциями обычно является хорошей идеей, только если у вас небольшой количество транзакционных операций.
Например, если у вас есть веб-приложение, которое требует транзакций только для определенных операций обновления, возможно, вы не захотите настраивать транзакционные прокси с использованием Spring или любой другой технологии.
В этом случае с помощью `TransactionTemplate` может быть хорошим подходом.
Возможность установить имя транзакции явно — это тоже то, что можно сделать только с помощью программного подхода. к управлению транзакциями.
Выбор между программным и декларативным управлением транзакциями.
С другой стороны, если ваше приложение содержит множество транзакционных операций, декларативное управление транзакциями обычно имеет смысл.
Он сохраняет транзакцию управление вне бизнес-логики и его несложно настроить.
При использовании Spring Framework, а не EJB CMT, стоимость настройки декларативной транзакции управление значительно сокращается.

Распространение транзакций.
В этом разделе описывается некоторая семантика распространения транзакций в Spring.
Примечание что этот раздел не является надлежащим введением в распространение транзакций.
Скорее, это подробно описывает некоторые семантики, касающиеся распространения транзакций в Spring.
Распространение транзакций.
В транзакциях, управляемых Spring, помните о разнице между физическими и логические транзакции и то, как настройки распространения применяются к этой разнице.
изображение::tx_prop_required.png[].
PROPAGATION_REQUIRED обеспечивает физическую транзакцию либо локально для текущей область действия, если транзакция еще не существует или участвует в существующей «внешней» транзакции определены для более широкой области применения.
Это прекрасное значение по умолчанию в общих схемах стека вызовов. внутри одного потока (например, фасад службы, который делегирует несколько методов репозитория где все базовые ресурсы должны участвовать в транзакции уровня обслуживания).
изображение::tx_prop_required.png[].
ПРИМЕЧАНИЕ.
По умолчанию участвующая транзакция объединяет характеристики внешней области, молча игнорируя локальный уровень изоляции, значение тайм-аута или флаг только для чтения (если таковой имеется).
Рассмотрите возможность переключения флага validateExistingTransactions на true в вашей транзакции. менеджер, если вы хотите, чтобы объявления уровня изоляции отклонялись при участии в существующая транзакция с другим уровнем изоляции.
Этот немягкий режим также отклоняет несоответствия, доступные только для чтения (то есть внутреннюю транзакцию чтения-записи, которая пытается участвовать во внешней области, доступной только для чтения).
изображение::tx_prop_required.png[].

Если параметр распространения равен PROPAGATION_REQUIRED, область логической транзакции создается для каждого метода, к которому применяется этот параметр.
Каждое такое логичное Область транзакции может определять статус только отката индивидуально, с помощью внешнего область транзакции логически независима от внутренней области транзакции.
В случае стандартного поведения PROPAGATION_REQUIRED все эти области сопоставлены с одной и той же физической транзакцией.
Таким образом, маркер только для отката, установленный во внутреннем Область транзакции влияет на вероятность фактической фиксации внешней транзакции.
изображение::tx_prop_required.png[].
Однако в случае, когда внутренняя область транзакции устанавливает маркер только отката, внешняя транзакция сама не приняла решение об откате, поэтому откат (тихо вызвано внутренней областью транзакции) является неожиданным.
Соответствующий В этот момент выдается `UnexpectedRollbackException`.
Это ожидаемое поведение, поэтому что вызывающая транзакция никогда не может быть введена в заблуждение, предполагая, что фиксация была выступал, когда его на самом деле не было.
Итак, если внутренняя транзакция (в которой внешний вызывающий абонент не знает) молча помечает транзакцию как доступную только для отката, внешний вызывающий объект по-прежнему вызовы фиксации.
Внешний вызывающий объект должен получить UnexpectedRollbackException, чтобы четко указать, что вместо этого был выполнен откат.
изображение::tx_prop_requires_new.png[].
PROPAGATION_REQUIRES_NEW, в отличие от PROPAGATION_REQUIRED, всегда использует независимая физическая транзакция для каждой затронутой области транзакции, никогда участие в существующей транзакции для внешней области.

В таком расположении базовые транзакции ресурсов различны и, следовательно, могут фиксироваться или откатываться независимо, при этом внешняя транзакция не зависит от отката внутренней транзакции статус и блокировки внутренней транзакции, снятые сразу после ее завершения.
Такая независимая внутренняя транзакция также может объявлять свой собственный уровень изоляции, тайм-аут, и настройки только для чтения и не наследуют характеристики внешней транзакции.
изображение::tx_prop_requires_new.png[].
ПРИМЕЧАНИЕ.
Ресурсы, прикрепленные к внешней транзакции, останутся привязанными к ней, пока внутренняя транзакция получает свои собственные ресурсы, такие как новое соединение с базой данных.
Это может привести к исчерпанию пула соединений и, возможно, к взаимоблокировке, если несколько потоков имеют активную внешнюю транзакцию и ждут нового соединения для их внутренней транзакции, при этом пул не может выдавать такие внутренние транзакции связи больше нет.
Не используйте PROPAGATION_REQUIRES_NEW, если только ваш пул соединений не имеет соответствующий размер и превышает количество одновременных потоков как минимум на 1.
Понимание `PROPAGATION_NESTED`.
PROPAGATION_NESTED использует одну физическую транзакцию с несколькими точками сохранения. к которому он может вернуться.
Такие частичные откаты позволяют внутренней области транзакции вызвать откат для своей области, при этом внешняя транзакция сможет продолжиться физическая транзакция, несмотря на то, что некоторые операции были отменены.
Эта настройка обычно сопоставляется с точками сохранения JDBC, поэтому работает только с ресурсом JDBC. транзакции.
См.

Spring's {spring-framework-api}/jdbc/datasource/DataSourceTransactionManager.html[`DataSourceTransactionManager`].

Синхронизация ресурсов с транзакциями.
Как создавать разные менеджеры транзакций и как они связаны со связанными ресурсами которые необходимо синхронизировать с транзакциями (например, DataSourceTransactionManager` в JDBC DataSource, HibernateTransactionManager в Hibernate SessionFactory, и так далее) теперь должно быть ясно.
В этом разделе описывается, как код приложения (прямо или косвенно, используя API сохранения, такой как JDBC, Hibernate или JPA) гарантирует, что эти ресурсы создаются, повторно используются и очищаются должным образом.
Раздел также обсуждается, как синхронизация транзакций (необязательно) инициируется через соответствующий `TransactionManager`.
Высокоуровневый подход к синхронизации.
Предпочтительный подход — использовать сохраняемость Spring на основе шаблонов самого высокого уровня.
API-интерфейсы интеграции или использовать собственные API-интерфейсы ORM с фабричными компонентами, учитывающими транзакции, или прокси для управления собственными фабриками ресурсов.
Эти решения с учетом транзакций внутренняя обработка создания и повторного использования ресурсов, очистка, необязательные транзакции синхронизация ресурсов и отображение исключений.
Таким образом, код доступа к пользовательским данным не нужно решать эти задачи, а можно сосредоточиться исключительно на нестандартных задачах. логика постоянства.
Как правило, вы используете собственный ORM API или шаблонный подход. для доступа к JDBC с помощью JdbcTemplate.
Эти решения подробно описаны в последующих разделы настоящей справочной документации.
Подход низкоуровневой синхронизации.

Такие классы, как DataSourceUtils (для JDBC), EntityManagerFactoryUtils (для JPA), `SessionFactoryUtils` (для Hibernate) и т. д. существуют на более низком уровне.
Когда вы хотите код приложения для прямой работы с типами ресурсов собственных API-интерфейсов персистентности, вы используете эти классы, чтобы гарантировать получение правильных экземпляров, управляемых Spring Framework, транзакции (необязательно) синхронизируются, а исключения, возникающие в процессе, правильно сопоставлен с согласованным API.
Подход низкоуровневой синхронизации.
Например, в случае JDBC вместо традиционного подхода JDBC вызова метод getConnection() в DataSource, вместо этого вы можете использовать метод Spring `org.springframework.jdbc.datasource.DataSourceUtils`, как показано ниже:
	Connection conn = DataSourceUtils.getConnection(dataSource);
Подход низкоуровневой синхронизации.
Если существующая транзакция уже имеет синхронизированное (связанное) с ней соединение, это экземпляр возвращается.
В противном случае вызов метода инициирует создание нового соединение, которое (опционально) синхронизируется с любой существующей транзакцией и выполняется доступен для последующего повторного использования в той же транзакции.
Как уже говорилось ранее, любой `SQLException` заключено в Spring Framework `CannotGetJdbcConnectionException`, один иерархии Spring Framework непроверенных типов DataAccessException.
Этот подход дает вам больше информации, чем можно легко получить из `SQLException` и обеспечивает переносимость между базами данных и даже между различными технологиями сохранения.
Подход низкоуровневой синхронизации.

Этот подход также работает без управления транзакциями Spring (транзакция синхронизация не является обязательной), поэтому вы можете использовать ее независимо от того, используете ли вы Spring для управление транзакциями.
Подход низкоуровневой синхронизации.
Конечно, если вы воспользовались поддержкой Spring JDBC, JPA или Hibernate, вы обычно предпочитаете не использовать DataSourceUtils или другие вспомогательные классы, потому что вам гораздо приятнее работать с абстракцией Spring, чем напрямую с соответствующими API.
Например, если вы используете Spring `JdbcTemplate` или Пакет `jdbc.object` для упрощения использования JDBC, происходит правильное получение соединения. за кулисами, и вам не нужно писать какой-либо специальный код.
`TransactionAwareDataSourceProxy`.
На самом нижнем уровне существует класс TransactionAwareDataSourceProxy.
Это прокси для целевого DataSource, который обертывает целевой DataSource, чтобы добавить осведомленность о Транзакции, управляемые Spring.
В этом отношении он похож на транзакционный JNDI. `DataSource`, предоставленный сервером Jakarta EE.
`TransactionAwareDataSourceProxy`.
Вам почти никогда не понадобится или не захочется использовать этот класс, за исключением тех случаев, когда он уже существует. код должен быть вызван и передан стандартной реализации интерфейса DataSource JDBC.
В этом случае вполне возможно, что этот код можно использовать, но он участвует в управляемом Spring транзакции.
Вы можете написать свой новый код, используя более высокий уровень абстракции, упомянутые ранее.

<tx:advice/> Настройки.
В этом разделе суммированы различные настройки транзакций, которые вы можете указать с помощью тег `<tx:advice/>`.
Настройки `<tx:advice/>` по умолчанию:
* Параметр настройка распространения является `ОБЯЗАТЕЛЬНЫМ`.
* Уровень изоляции — «ПО УМОЛЧАНИЮ».
* Транзакция является чтение-запись.
* Тайм-аут транзакции по умолчанию равен тайм-ауту по умолчанию базовой транзакции.
<tx:advice/> Настройки. system или none, если таймауты не поддерживаются.
* Любое исключение RuntimeException вызывает откат, а любое отмеченное исключение — нет.
<tx:advice/> Настройки.
Вы можете изменить эти настройки по умолчанию.
В следующей таблице приведены различные атрибуты тегов `<tx:method/>`. которые вложены в теги `<tx:advice/>` и `<tx:attributes/>`:
.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `имя` | Да | | Имена методов, с которыми должны быть связаны атрибуты транзакции.

Подстановочный знак ({звездочка}) может использоваться для связи одного и того же атрибута транзакции. настройки с помощью нескольких методов (например, `get*`, `handle*`, `on*Event` и т. д. далее).
.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `распространение` | Нет | `ОБЯЗАТЕЛЬНО` | Поведение распространения транзакций.
.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `изоляция` | Нет | `ПО УМОЛЧАНИЮ` | Уровень изоляции транзакции.
Применимо только к настройкам распространения REQUIRED или REQUIRES_NEW.
.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `тайм-аут` | Нет | -1 | Таймаут транзакции (секунды).
Применимо только к распространению REQUIRED или REQUIRES_NEW.
.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `только для чтения` | Нет | ложный | Транзакция чтения-записи в сравнении с транзакцией только чтения.
Применяется только к `REQUIRED` или `REQUIRES_NEW`.

.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `откат-для` | Нет | | Список экземпляров исключений, разделенных запятыми, которые вызывают откат.
Например, `com.foo.MyBusinessException,ServletException`.
.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `без отката` | Нет | | Список экземпляров исключений, разделенных запятыми, которые не вызывают откат.
Например, `com.foo.MyBusinessException,ServletException`. |===

Преобразование типа.
Некоторые аннотированные аргументы метода контроллера, которые представляют входные данные запроса на основе строки (например, `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable` и `@CookieValue`) может потребоваться преобразование типа, если аргумент объявлен как нечто отличное от `String`.
Преобразование типа.
В таких случаях преобразование типов применяется автоматически на основе настроенных преобразователей.
По умолчанию поддерживаются простые типы (такие как int, long, Date и другие).
Преобразование типов можно настроить с помощью WebDataBinder (см. ссылку:web/webflux/controller/ann-initbinder.adoc[`DataBinder`]). или зарегистрировав «Форматтеры» в «FormattingConversionService» (см.
Преобразование типа.
Практической проблемой преобразования типов является обработка пустого исходного значения String.
Такое значение считается отсутствующим, если оно становится нулевым в результате преобразования типа.
Это может относиться к «Long», «UUID» и другим типам целей.
Если вы хотите разрешить `null` для внедрения, либо используйте флаг `required` в аннотации аргумента, либо объявите аргумент как `@Nullable`.

Типы.
Вы можете использовать специальный оператор `T`, чтобы указать экземпляр `java.lang.Class` (тип).
Статические методы также вызываются с использованием этого оператора.
StandardEvaluationContext использует TypeLocator для поиска типов, а `StandardTypeLocator` (который можно заменить) создан с учетом пакет `java.lang`.
Это означает, что `T()` ссылается на типы в `java.lang`. пакет не обязательно должен быть полным, но все остальные ссылки на типы должны быть указаны.
В следующем примере показано, как использовать оператор `T`:
Java
	Class dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class.class);
	Class stringClass = parser.parseExpression("T(String)").getValue(Class.class);
	boolean trueValue = parser.parseExpression(
			"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR")
			.getValue(Boolean.class);
Типы. [ПРИМЕЧАНИЕ] = Если ваше приложение или платформа управляет собственным «EvaluationContext», вам может потребоваться вручную настройте StandardTypeLocator с определенным ClassLoader, чтобы гарантировать, что анализатор выражений SpEL способен надежно определять типы пользователей.
Типы.
Например, StandardBeanExpressionResolver в модуле Spring-context. настраивает StandardTypeLocator, используя bean-компонент ClassLoader соответствующего `БинФабрика`.

URI-ссылки.
В этом разделе описаны различные параметры, доступные в Spring Framework для подготовки URI.

Использование AspectJ с приложениями Spring.
Все, что мы рассмотрели до сих пор в этой главе, — это чистый Spring AOP.
В этом разделе мы рассмотрим, как можно использовать компилятор AspectJ или Weaver вместо или в дополнение к Spring AOP, если ваши потребности выходят за рамки возможностей Spring AOP. один.
Использование AspectJ с приложениями Spring.
Spring поставляется с небольшой библиотекой аспектов AspectJ, которая доступна отдельно в вашем распространение как `spring-aspect.jar`.
Вам нужно добавить это в свой путь к классам, чтобы использовать аспекты в нем. и Другие аспекты Spring для AspectJ обсудите содержимое этой библиотеки и то, как вы можете ее использовать. обсуждается, как внедрить зависимости в аспекты AspectJ, созданные с помощью компилятора AspectJ.
Наконец, содержит введение в переплетение во время загрузки для приложений Spring, использующих AspectJ.
Использование AspectJ с приложениями Spring.
Использование AspectJ для внедрения зависимостей в объекты домена с помощью Spring
Использование AspectJ с приложениями Spring.
Контейнер Spring создает экземпляры и настраивает bean-компоненты, определенные в вашем приложении. контекст.
Также можно попросить фабрику компонентов настроить уже существующую объект, которому присвоено имя определения компонента, содержащего конфигурацию, которую необходимо применить. `spring-aspects.jar` содержит аспект, управляемый аннотациями, который использует это возможность разрешить внедрение зависимостей любого объекта.
Поддержка предназначена для использоваться для объектов, созданных вне контроля какого-либо контейнера.

Объекты домена часто попадают в эту категорию, потому что они часто создаются программно с помощью оператором `new` или инструментом ORM в результате запроса к базе данных.
Использование AspectJ с приложениями Spring.
Аннотация `@Configurable` отмечает класс как имеющий право на управление Spring. конфигурация.
В простейшем случае вы можете использовать его исключительно как аннотацию маркера, поскольку следующий пример показывает:
Java
	package com.xyz.domain;
	import org.springframework.beans.factory.annotation.Configurable;
	@Configurable
	public class Account {
	package com.xyz.domain
	@Configurable
	class Account {
Использование AspectJ с приложениями Spring.
При таком использовании в качестве интерфейса маркера Spring настраивает новые экземпляры аннотированный тип (в данном случае «Account») с использованием определения bean-компонента (обычно в области прототипа) с тем же именем, что и полное имя типа. (`com.xyz.domain.Account`).
Поскольку именем по умолчанию для bean-компонента, определенного через XML, является полное имя своего типа, удобный способ объявить определение прототипа заключается в том, чтобы опустить атрибут `id`, как показано в следующем примере:
	<bean class="com.xyz.domain.Account" scope="prototype">
		<property name="fundsTransferService" ref="fundsTransferService"/>
	</bean>
Использование AspectJ с приложениями Spring.

Если вы хотите явно указать имя используемого определения прототипа bean-компонента, вы можно сделать это непосредственно в аннотации, как показано в следующем примере:
Java
	package com.xyz.domain;
	import org.springframework.beans.factory.annotation.Configurable;
	@Configurable("account")
	public class Account {
	package com.xyz.domain
	@Configurable("account")
	class Account {
Использование AspectJ с приложениями Spring.
Spring теперь ищет определение компонента с именем «account» и использует его в качестве определение для настройки новых экземпляров `Account`.
Использование AspectJ с приложениями Spring.
Вы также можете использовать автоматическое связывание, чтобы избежать необходимости указывать определение выделенного компонента в все.
Чтобы Spring применял автоматическое связывание, используйте свойство autowire в @Configurable. аннотация.
Вы можете указать либо `@Configurable(autowire=Autowire.BY_TYPE)`, либо `@Configurable(autowire=Autowire.BY_NAME)` для автоматического подключения по типу или по имени, соответственно.
В качестве альтернативы предпочтительно указать явный, управляемый аннотациями внедрение зависимостей для ваших bean-компонентов `@Configurable` через `@Autowired` или `@Inject` на уровне поля или метода (дополнительную информацию см. в Конфигурация контейнера на основе аннотаций).
Использование AspectJ с приложениями Spring.

Наконец, вы можете включить проверку зависимостей Spring для ссылок на объекты в новом файле. созданный и настроенный объект с помощью атрибута dependencyCheck (например, `@Configurable(autowire=Autowire.BY_NAME,dependentCheck=true)`).
Если этот атрибут установлено значение true, Spring после настройки проверяет, что все свойства (которые не являются примитивами или коллекциями).
Использование AspectJ с приложениями Spring.
Обратите внимание, что использование аннотации само по себе ничего не дает.
Это AnnotationBeanConfigurerAspect в Spring-aspects.jar, который действует при наличии аннотация.
По сути, аспект говорит: «после возврата из инициализации новый объект типа, помеченного `@Configurable`, настройте вновь созданный объект используя Spring в соответствии со свойствами аннотации».
В этом контексте «инициализация» относится к вновь созданным объектам (например, к объектам, созданным с оператором `new`), а также к `Serializable` объектам, которые подвергаются десериализация (например, через {java-api}/java.base/java/io/Serializable.html[readResolve()]).
Использование AspectJ с приложениями Spring. [ПРИМЕЧАНИЕ] = Одна из ключевых фраз в приведенном выше абзаце — «по существу».
В большинстве случаев точная семантика «после возврата из инициализации нового объекта» хорошо.
В этом контексте «после инициализации» означает, что зависимости вводится после того, как объект был построен.

Это означает, что зависимости недоступны для использования в телах конструкторов класса.
Если вы хотите зависимости, которые необходимо внедрить до запуска тел конструктора и, таким образом, доступен для использования в теле конструкторов, вам необходимо определить это в Объявление `@Configurable`, следующее:
Java
	@Configurable(preConstruction = true)
Использование AspectJ с приложениями Spring.
Вы можете найти дополнительную информацию о языковой семантике различных Pointcut. типы в AspectJ {aspectj-docs-progguide}/semantics-joinPoints.html[в этом приложении] {aspectj-docs-progguide}/index.html[Руководство по программированию AspectJ].
Использование AspectJ с приложениями Spring.
Чтобы это работало, аннотированные типы должны быть сплетены с помощью AspectJ weaver.
Вы можете либо используйте для этого задачу Ant или Maven во время сборки (см., например, {aspectj-docs-devguide}/antTasks.html[Разработка AspectJ Руководство по среде]) или переплетение во время загрузки (см.
Переплетение во время загрузки с AspectJ в Spring Framework).
Сам AnnotationBeanConfigurerAspect должен быть настроен Spring (чтобы получить ссылка на фабрику компонентов, которая будет использоваться для настройки новых объектов).
Вы можете определить соответствующая конфигурация выглядит следующим образом: См. пример кода в исходном документе.
Использование AspectJ с приложениями Spring.

Экземпляры объектов @Configurable, созданные до настройки аспекта. в результате в журнал отладки будет выдано сообщение, а настройка конфигурации не будет выполнена. происходит объект.
Примером может быть bean-компонент в конфигурации Spring, который создает объекты домена, когда он инициализируется Spring.
В этом случае вы можете использовать Атрибут bean-компонента `dependents-on`, чтобы вручную указать, что bean-компонент зависит от аспект конфигурации.
В следующем примере показано, как использовать атрибут «зависит от»:
	<bean id="myService"
			class="com.xyz.service.MyService"
			depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect">
	</bean>
Использование AspectJ с приложениями Spring.
ПРИМЕЧАНИЕ.
Не активируйте обработку @Configurable через конфигуратор компонента, если только вы не на самом деле означает полагаться на его семантику во время выполнения.
В частности, убедитесь, что вы делаете не используйте @Configurable для классов компонентов, которые зарегистрированы как обычные компоненты Spring. с контейнером.
Это приведет к двойной инициализации, один раз через контейнер и один раз через аспект.
Модульное тестирование объектов `@Configurable`.
Одна из целей поддержки @Configurable — обеспечить независимое модульное тестирование. объектов домена без трудностей, связанных с жестко запрограммированным поиском.
Если типы @Configurable не были созданы AspectJ, аннотация не оказывает никакого влияния. во время модульного тестирования.

Вы можете установить ссылки на свойства макета или заглушки в объекте в разделе протестируйте и действуйте как обычно.
Если типы @Configurable были созданы с помощью AspectJ, вы по-прежнему можете выполнять модульное тестирование вне контейнера, как обычно, но вы увидите предупреждение сообщение каждый раз, когда вы создаете объект `@Configurable`, указывающий, что он имеет не настроен Spring.
Работа с несколькими контекстами приложения.
AnnotationBeanConfigurerAspect, используемый для реализации поддержки @Configurable. является одноэлементным аспектом AspectJ.
Область действия синглтонного аспекта такая же, как и область действия. статических членов: для каждого ClassLoader существует один экземпляр аспекта, определяющий тип.
Это означает, что если вы определите несколько контекстов приложения в одном ClassLoader иерархии, вам нужно подумать, где определить bean-компонент `@EnableSpringConfigured` и где разместить `spring-aspects.jar` в пути к классам.
Работа с несколькими контекстами приложения.
Рассмотрим типичную конфигурацию веб-приложения Spring с общим родительским приложением. контекст, определяющий общие бизнес-услуги, все необходимое для поддержки этих услуг, и один контекст дочернего приложения для каждого сервлета (который содержит определения конкретных этому сервлету).
Все эти контексты сосуществуют в одной и той же иерархии ClassLoader. и поэтому AnnotationBeanConfigurerAspect может содержать ссылку только на один из них.
В этом случае мы рекомендуем определить bean-компонент @EnableSpringConfigured в общем (родительский) контекст приложения.

Это определяет услуги, которые вы, вероятно, захотите внедрить в объекты домена.
Следствием этого является то, что вы не можете настраивать объекты домена. со ссылками на bean-компоненты, определенные в дочерних (специфичных для сервлета) контекстах с помощью @Конфигурируемый механизм (который, вероятно, в любом случае вам не нужен).
Работа с несколькими контекстами приложения.
При развертывании нескольких веб-приложений в одном контейнере убедитесь, что каждое веб-приложение загружает типы в Spring-aspects.jar, используя собственный ClassLoader. (например, поместив Spring-aspects.jar в WEB-INF/lib).
Если `spring-aspects.jar` добавляется только в путь к классам всего контейнера (и, следовательно, загружается общим родительским элементом `ClassLoader`), все веб-приложения используют один и тот же экземпляр аспекта (что, вероятно, не то, что вы хотите).
Другие аспекты Spring для AspectJ.
В дополнение к аспекту @Configurable, Spring-aspects.jar содержит AspectJ. аспект, который вы можете использовать для управления транзакциями Spring для типов и методов. помеченный аннотацией `@Transactional`.
Это в первую очередь предназначено для пользователей, которые хотите использовать поддержку транзакций Spring Framework за пределами контейнера Spring.
Другие аспекты Spring для AspectJ.
Аспект, который интерпретирует аннотации `@Transactional`, - это `АннотацияТранзакцияАспект`.

Когда вы используете этот аспект, вы должны аннотировать класс реализации (или методы внутри этого класса или оба), а не интерфейс (если любой), который реализует класс.
AspectJ следует правилу Java, согласно которому аннотации на интерфейсы не наследуются.
Другие аспекты Spring для AspectJ.
Аннотация `@Transactional` в классе определяет семантику транзакции по умолчанию для выполнение любой публичной операции в классе.
Другие аспекты Spring для AspectJ.
Аннотация `@Transactional` для метода внутри класса переопределяет значение по умолчанию. семантика транзакции, заданная аннотацией класса (если присутствует).
Методы любые видимость может быть аннотирована, включая частные методы.
Аннотирование закрытых методов напрямую — единственный способ получить разграничение транзакций для выполнения таких методов.
Другие аспекты Spring для AspectJ.
СОВЕТ: Начиная с Spring Framework 4.2, Spring-aspects предоставляет аналогичный аспект, который предлагает точно такие же функции для стандартной аннотации `jakarta.transaction.Transactional`.
Проверить `JtaAnnotationTransactionAspect` для более подробной информации.
Другие аспекты Spring для AspectJ.
Для программистов AspectJ, которые хотят использовать конфигурацию и транзакции Spring. поддержка управления, но вы не хотите (или не можете) использовать аннотации, `spring-aspect.jar` также содержит «абстрактные» аспекты, которые вы можете расширить, чтобы создать свой собственный pointcut. определения.
См. исходники для `AbstractBeanConfigurerAspect` и Аспекты «AbstractTransactionAspect» для получения дополнительной информации.

В качестве примера можно привести следующее отрывок показывает, как можно написать аспект для настройки всех экземпляров объектов. определенные в модели предметной области с использованием определений прототипов bean-компонентов, которые соответствуют полные имена классов:
	public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {
		public DomainObjectConfiguration() {
			setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
		// создание нового bean-компонента (любого объекта в модели предметной области)
		protected pointcut beanCreation(Object beanInstance) :
			initialization(new(..)) &&
			CommonPointcuts.inDomainModel() &&
			this(beanInstance);
Настройка аспектов AspectJ с помощью Spring IoC.
Когда вы используете аспекты AspectJ с приложениями Spring, естественно одновременно хотеть и ожидайте, что сможете настроить такие аспекты с помощью Spring.
Сама среда выполнения AspectJ отвечает за создание аспекта и средства настройки созданного AspectJ аспекты через Spring зависят от модели создания экземпляра AspectJ (предложение per-xxx). используется аспектом.
Настройка аспектов AspectJ с помощью Spring IoC.
Большинство аспектов AspectJ являются одноэлементными аспектами.
Конфигурация этих аспекты — это легко.
Вы можете создать определение компонента, которое ссылается на тип аспекта как нормальный и включите атрибут bean-компонента `factory-method="aspectOf"`.
Это гарантирует, что Spring получает экземпляр аспекта, запрашивая его у AspectJ, а не пытаясь создать сам экземпляр.
В следующем примере показано, как использовать атрибут Factory-method="aspectOf"`:

<bean id="profiler" class="com.xyz.profiler.Profiler"
			factory-method="aspectOf"> <1>
		<property name="profilingStrategy" ref="jamonProfilingStrategy"/>
	</bean>
Настройка аспектов AspectJ с помощью Spring IoC. <1> Обратите внимание на атрибут `factory-method="aspectOf"`.
Настройка аспектов AspectJ с помощью Spring IoC.
Аспекты, не являющиеся одноэлементными, сложнее настроить.
Однако это можно сделать, создание определений прототипов bean-компонентов и использование поддержки @Configurable из `spring-aspects.jar` для настройки экземпляров аспектов после того, как они будут созданы bean-компонентом среда выполнения AspectJ.
Настройка аспектов AspectJ с помощью Spring IoC.
Если у вас есть некоторые аспекты @AspectJ, которые вы хотите объединить с AspectJ (например, использование переплетения во время загрузки для типов моделей предметной области) и другие аспекты @AspectJ, которые вы хотите для использования с Spring AOP, и все эти аспекты настраиваются в Spring, вы необходимо сообщить поддержке автоматического проксирования Spring AOP @AspectJ, какое именно подмножество Аспекты @AspectJ, определенные в конфигурации, следует использовать для автоматического проксирования.
Вы можете сделайте это, используя один или несколько элементов `<include/>` внутри `<aop:aspectj-autoproxy/>` декларация.

Каждый элемент `<include/>` определяет шаблон имени, и только компоненты с имена, соответствующие хотя бы одному из шаблонов, используются для автоматического прокси Spring AOP. конфигурация.
В следующем примере показано, как использовать элементы `<include/>`:
	<aop:aspectj-autoproxy>
		<aop:include name="thisBean"/>
		<aop:include name="thatBean"/>
	</aop:aspectj-autoproxy>
Настройка аспектов AspectJ с помощью Spring IoC.
ПРИМЕЧАНИЕ.
Пусть вас не вводит в заблуждение имя элемента `<aop:aspectj-autoproxy/>`.
Используя его приводит к созданию прокси Spring AOP.
Стиль аспекта @AspectJ Здесь используется декларация, но среда выполнения AspectJ не задействована.
Переплетение во время загрузки с помощью AspectJ в Spring Framework.
Переплетение во время загрузки (LTW) относится к процессу объединения аспектов AspectJ в файлы классов приложения по мере их загрузки в виртуальную машину Java (JVM).
В этом разделе основное внимание уделяется настройке и использованию LTW в конкретном контексте Весенний фреймворк.
Этот раздел не является общим введением в LTW.
Для получения полной информации о особенности LTW и настройка LTW только с помощью AspectJ (при этом Spring не используется). вообще участвует), см. {aspectj-docs-devguide}/ltw.html[раздел LTW в AspectJ Руководство по среде разработки].

Переплетение во время загрузки с помощью AspectJ в Spring Framework.
Ценность, которую Spring Framework привносит в AspectJ LTW, заключается в возможности более детальный контроль над процессом плетения. «Ванильный» AspectJ LTW осуществляется с помощью агент Java (5+), который включается указанием аргумента виртуальной машины при запуске JVM.
Таким образом, это настройка всей JVM, которая может быть удобна в некоторых ситуациях, но часто является немного слишком грубо.
LTW с поддержкой Spring позволяет включать LTW на для каждого ClassLoader, который является более детальным и позволяет сделать больше смысл в среде «одного JVM-множества приложений» (например, в типичной среду сервера приложений).
Переплетение во время загрузки с помощью AspectJ в Spring Framework.
Кроме того, эта поддержка позволяет переплетение во время загрузки без внесения каких-либо изменений в запуск сервера приложений скрипт, который необходим для добавления `-javaagent:path/to/aspectjweaver.jar` или (как мы описываем далее в этом разделе) `-javaagent:path/to/spring-instrument.jar`.
Разработчики настраивают контекст приложения, чтобы включить переплетение во время загрузки вместо того, чтобы полагаться на администраторов которые обычно отвечают за конфигурацию развертывания, например за сценарий запуска.
Переплетение во время загрузки с помощью AspectJ в Spring Framework.
Теперь, когда коммерческое предложение закончено, давайте сначала рассмотрим краткий пример AspectJ.

LTW, использующий Spring, с последующими подробностями об элементах, представленных в пример.
Полный пример см. {petclinic-github-org}/spring-framework-petclinic [пример приложения Petclinic на основе Spring Framework].
Первый пример.
Предположим, вы разработчик приложения, которому поручена диагностика причина некоторых проблем с производительностью системы.
Вместо того, чтобы вырвать инструмент профилирования, мы собираемся включить простой аспект профилирования, который позволит нам быстро получить некоторые показатели производительности.
Затем мы можем применить более детальное профилирование. инструмент в эту конкретную область сразу после этого.
Первый пример.
ПРИМЕЧАНИЕ.
В представленном здесь примере используется конфигурация XML.
Вы также можете настроить и используйте @AspectJ с конфигурация Java.
В частности, вы можете использовать Аннотация `@EnableLoadTimeWeaving` как альтернатива `<context:load-time-weaver/>` (подробности см. в ниже).
Первый пример.
В следующем примере показан аспект профилирования, который не является чем-то необычным.
Это профилировщик, основанный на времени, который использует @AspectJ-стиль объявления аспектов:
Java
	package com.xyz;
	import org.aspectj.lang.ProceedingJoinPoint;
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Around;
	import org.aspectj.lang.annotation.Pointcut;
	import org.springframework.util.StopWatch;

import org.springframework.core.annotation.Order;
	@Aspect
	public class ProfilingAspect {
		@Around("methodsToBeProfiled()")
		public Object profile(ProceedingJoinPoint pjp) throws Throwable {
			StopWatch sw = new StopWatch(getClass().getSimpleName());
			try {
				sw.start(pjp.getSignature().getName());
				return pjp.proceed();
			} finally {
				sw.stop();
				System.out.println(sw.prettyPrint());
		@Pointcut("execution(public * com.xyz..*.*(..))")
		public void methodsToBeProfiled(){}
	package com.xyz
	@Aspect
	class ProfilingAspect {
Первый пример.
Нам также необходимо создать файл META-INF/aop.xml, чтобы сообщить ткачу AspectJ, что мы хотим встроить наш «ProfilingAspect» в наши классы.
Это соглашение о файлах, а именно наличие файла (или файлов) в пути к классам Java с именем `META-INF/aop.xml` является стандартный аспектJ.
В следующем примере показан файл aop.xml:
	<!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd">
	<aspectj>
		<weaver>

<!-- only weave classes in our application-specific packages and sub-packages -->
			<include within="com.xyz..*"/>
		</weaver>
		<aspects>
			<!-- weave in just this aspect -->
			<aspect name="com.xyz.ProfilingAspect"/>
		</aspects>
	</aspectj>
Первый пример.
ПРИМЕЧАНИЕ.
Рекомендуется объединять только определенные классы (обычно те, которые находятся в пакеты приложений, как показано в примере `aop.xml` выше) в порядке чтобы избежать побочных эффектов, таких как файлы дампа AspectJ и предупреждения.
Это также лучшая практика с точки зрения эффективности.
Первый пример.
Теперь мы можем перейти к части конфигурации, специфичной для Spring.
Нам нужен для настройки LoadTimeWeaver (объясняется позже).
Этот ткач во время загрузки является важный компонент, отвечающий за вплетение конфигурации аспекта в один или больше файлов META-INF/aop.xml в классы вашего приложения.
Хороший дело в том, что он не требует большой настройки (есть еще несколько параметры, которые вы можете указать, но они подробно описаны позже), как видно на следующий пример:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">
		<!-- a service object; we will be profiling its methods -->
		<bean id="entitlementCalculationService"
				class="com.xyz.StubEntitlementCalculationService"/>
		<!-- this switches on the load-time weaving -->
		<context:load-time-weaver/>
	</beans>
Первый пример.
Теперь, когда все необходимые артефакты (аспект `META-INF/aop.xml` файл и конфигурация Spring) на месте, мы можем создать следующее класс драйвера с методом `main(..)` для демонстрации LTW в действии:
Java
	package com.xyz;
	// импорт
	public class Main {
		public static void main(String[] args) {

ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
			EntitlementCalculationService service =
					ctx.getBean(EntitlementCalculationService.class);
			// аспект профилирования «вплетен» в выполнение этого метода
			service.calculateEntitlement();
	package com.xyz
	// импорт
		// аспект профилирования «вплетен» в выполнение этого метода
		service.calculateEntitlement()
Первый пример.
Нам осталось сделать последнее дело.
Во введении к этому разделу говорилось, что можно включайте LTW выборочно для каждого ClassLoader с помощью Spring, и это правда.
Однако в этом примере мы используем агент Java (поставляемый вместе со Spring) для включения LTW.
Мы используем следующую команду для запуска класса Main, показанного ранее:
java -javaagent:C:/projects/xyz/lib/spring-instrument.jar com.xyz.Main. `-javaagent` — это флаг для указания и включения {java-api}/java.instrument/java/lang/instrument/package-summary.html[агенты для инструментирования программ, работающих на JVM].
Spring Framework поставляется с таким агент, InstrumentSavingAgent, который упакован в пакет `spring-instrument.jar`, который был предоставлен как значение аргумента `-javaagent` в предыдущий пример.
java -javaagent:C:/projects/xyz/lib/spring-instrument.jar com.xyz.Main.

Результат выполнения программы Main выглядит примерно так, как показано в следующем примере. (Я добавил оператор `Thread.sleep(..)` в `calculateEntitlement()` реализацию, чтобы профилировщик фактически фиксировал что-то отличное от 0 миллисекунды (миллисекунды «01234» не являются накладными расходами, вносимыми АОП).
В следующем листинге показаны выходные данные, которые мы получили при запуске нашего профилировщика:
Calculating entitlement.
StopWatch 'ProfilingAspect': running time (millis) = 1234 ------ ----- ---------------------------- ms % Task name ------ ----- ---------------------------- 01234 100% calculateEntitlement
Calculating entitlement.
Поскольку это LTW осуществляется с помощью полноценного AspectJ, мы не ограничиваемся только советами.
Весенняя фасоль.
Следующая небольшая вариация программы Main дает тот же результат: результат:
Java
	package com.xyz;
	// импорт
	public class Main {
		public static void main(String[] args) {
			new ClassPathXmlApplicationContext("beans.xml");
			EntitlementCalculationService service =
					new StubEntitlementCalculationService();

// аспект профилирования будет «вплетен» в выполнение этого метода
			service.calculateEntitlement();
	package com.xyz
	// импорт
		// аспект профилирования будет «вплетен» в выполнение этого метода
		service.calculateEntitlement()
Calculating entitlement.
Обратите внимание, как в предыдущей программе мы загружаем контейнер Spring и затем создайте новый экземпляр StubEntitlementCalculationService полностью за пределами контекст весны.
Советы по профилированию все еще вплетены.
Calculating entitlement.
Согласитесь, пример упрощенный.
Однако основы поддержки LTW в Spring все они были представлены в предыдущем примере, а остальная часть этого раздела объясняет «Почему» за каждым битом конфигурации и использования в деталях.
Calculating entitlement.
ПРИМЕЧАНИЕ.
Используемый в этом примере параметр «ProfilingAspect» может быть простым, но он весьма полезен.
Это хороший пример аспекта времени разработки, который разработчики могут использовать во время разработки а затем легко исключить из сборок развертываемого приложения в UAT или производство.
Аспекты, которые вы используете в LTW, должны быть аспектами AspectJ.
Вы можете написать их в либо сам язык AspectJ, либо вы можете писать свои аспекты в стиле @AspectJ.
Тогда ваши аспекты являются действительными аспектами AspectJ и Spring AOP.
Более того, скомпилированные классы аспектов должны быть доступны в пути к классам.
`META-INF/aop.xml`.

Инфраструктура AspectJ LTW настраивается с использованием одного или нескольких `META-INF/aop.xml` файлы, находящиеся в пути к классам Java (либо напрямую, либо, что чаще, в файлах jar).
Например:
	<!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd">
	<aspectj>
		<weaver>
			<!-- only weave classes in our application-specific packages and sub-packages -->
			<include within="com.xyz..*"/>
		</weaver>
	</aspectj>
`META-INF/aop.xml`.
ПРИМЕЧАНИЕ.
Рекомендуется объединять только определенные классы (обычно те, которые находятся в пакеты приложений, как показано в примере `aop.xml` выше) в порядке чтобы избежать побочных эффектов, таких как файлы дампа AspectJ и предупреждения.
Это также лучшая практика с точки зрения эффективности.
`META-INF/aop.xml`.
Структура и содержимое этого файла подробно описаны в разделе LTW. {aspectj-docs-devguide}/ltw-configuration.html[ссылка на AspectJ документация].
Поскольку файл aop.xml на 100% состоит из AspectJ, мы не описываем его здесь далее.
Необходимые библиотеки (JARS).

Для использования поддержки Spring Framework вам потребуются как минимум следующие библиотеки: для AspectJ LTW:
* `spring-aop.jar`
* `aspectjweaver.jar`
Необходимые библиотеки (JARS).
Если вы используете агент, предоставленный Spring для включения инструментов, вам также понадобится:
* `spring-instrument.jar`
Весенняя конфигурация.
Ключевым компонентом поддержки LTW в Spring является интерфейс LoadTimeWeaver (в `org.springframework.instrument.classloading`) и многочисленные реализации из них он поставляется с дистрибутивом Spring.
LoadTimeWeaver отвечает за добавление одного или нескольких `java.lang.instrument.ClassFileTransformers` к `ClassLoader` в среда выполнения, которая открывает двери для всевозможных интересных приложений, одно из которых оказывается LTW аспектов.
Весенняя конфигурация.
СОВЕТ: Если вы не знакомы с идеей преобразования файлов классов во время выполнения, см.
Прежде чем продолжить, прочтите документацию по API javadoc для пакета `java.lang.instrument`.
Хотя эта документация не является исчерпывающей, по крайней мере, вы можете увидеть ключевые интерфейсы. и классы (для справки при чтении этого раздела).
Весенняя конфигурация.
Настроить LoadTimeWeaver для конкретного ApplicationContext может быть так же просто, как добавление одной строки. (Обратите внимание, что вам почти наверняка придется использовать `ApplicationContext` в качестве контейнера Spring.
Обычно `BeanFactory` не является достаточно, потому что поддержка LTW использует BeanFactoryPostProcessors.)
Весенняя конфигурация.

Чтобы включить поддержку LTW Spring Framework, вам необходимо настроить LoadTimeWeaver следующим образом: См. пример кода в исходном документе.
Весенняя конфигурация.
Предыдущая конфигурация автоматически определяет и регистрирует ряд специфичных для LTW инфраструктурные компоненты, такие как LoadTimeWeaver и AspectJWeavingEnabler.
По умолчанию LoadTimeWeaver — это класс DefaultContextLoadTimeWeaver, который пытается для оформления автоматически обнаруженного `LoadTimeWeaver`.
Точный тип LoadTimeWeaver. то, что «обнаружено автоматически», зависит от вашей среды выполнения.
В следующей таблице приведены различные реализации LoadTimeWeaver:
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | Запуск в https://eclipse-ee4j.github.io/glassfish/[GlassFish] (ограничено развертываниями EAR) | `GlassFishLoadTimeWeaver`
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | Запуск в Red Hat https://www.jboss.org/jbossas/[JBoss AS] или https://www.wildfly.org/[WildFly] | `JBossLoadTimeWeaver`
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | JVM началась с Spring `InstrumentationSavingAgent` (`java -javaagent:path/to/spring-instrument.jar`) | `ИнструментацияLoadTimeWeaver`

| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | Резервный вариант, ожидающий, что базовый ClassLoader будет следовать общим соглашениям. (а именно `addTransformer` и, возможно, метод `getThrowawayClassLoader`) | `ReflectiveLoadTimeWeaver` |===
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`.
Обратите внимание, что в таблице перечислены только те `LoadTimeWeavers`, которые автоматически определяются при используйте `DefaultContextLoadTimeWeaver`.
Вы можете точно указать, какой именно `LoadTimeWeaver` реализация для использования.
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`.
Чтобы настроить конкретный `LoadTimeWeaver`, реализуйте Интерфейс LoadTimeWeavingConfigurer и переопределить метод getLoadTimeWeaver(). (или используйте эквивалент XML).
В следующем примере указывается ReflectiveLoadTimeWeaver: См. пример кода в исходном документе.
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. `LoadTimeWeaver`, определенный и зарегистрированный в конфигурации, может быть позже извлекается из контейнера Spring с использованием хорошо известного имени loadTimeWeaver.
Помните, что LoadTimeWeaver существует только как механизм Spring LTW. инфраструктура для добавления одного или нескольких ClassFileTransformers.

Фактический ClassFileTransformer, выполняющий LTW, — это ClassPreProcessorAgentAdapter (из пакет `org.aspectj.weaver.loadtime`).
См.
Javadoc уровня класса ClassPreProcessorAgentAdapter для получения более подробной информации, поскольку особенности того, как фактическое плетение выходит за рамки данного документа.
| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`.
Остался обсудить еще один последний атрибут конфигурации: aspectjWeaving. атрибут (или «aspectj-weaving», если вы используете XML).
Этот атрибут определяет, будет ли LTW включен или нет.
Он принимает одно из трех возможных значений, значением по умолчанию является `autodetect`, если атрибут отсутствует.
В следующей таблице суммированы три возможные значения:
Значения атрибутов переплетения.AspectJ |=== | Значение аннотации | XML-значение| Объяснение. | `ВКЛЮЧЕНО` | `вкл` | Переплетение AspectJ включено, и аспекты переплетаются во время загрузки по мере необходимости.
Значения атрибутов переплетения.AspectJ |=== | Значение аннотации | XML-значение| Объяснение. | `ОТКЛЮЧЕН` | `выключено` | ЛТВ выключен.
Ни один аспект не переплетается во время загрузки.

Значения атрибутов переплетения.AspectJ |=== | Значение аннотации | XML-значение| Объяснение. | `АВТООБНАРУЖЕНИЕ` | `автоопределение` | Если инфраструктура Spring LTW может найти хотя бы один файл META-INF/aop.xml, затем включается плетение AspectJ.
В противном случае он выключен.
Это значение по умолчанию. |===
Конфигурация, специфичная для окружающей среды.
Этот последний раздел содержит любые дополнительные настройки и конфигурации, которые вам нужны. когда вы используете поддержку Spring LTW в таких средах, как серверы приложений и веб-сайты. контейнеры.
Томкэт, JBoss, WildFly.
Tomcat и JBoss/WildFly предоставляют общее приложение ClassLoader, способное локально приборы.
Собственный LTW Spring может использовать эти реализации ClassLoader. обеспечить плетение AspectJ.
Вы можете просто включить переплетение во время загрузки, как описано ранее.
В частности, вам не нужно изменять сценарий запуска JVM, чтобы добавить `-javaagent:путь/к/spring-instrument.jar`.
Томкэт, JBoss, WildFly.
Обратите внимание, что в JBoss вам может потребоваться отключить сканирование сервера приложений, чтобы предотвратить его загрузка классов до фактического запуска приложения.
Быстрый обходной путь — добавить к вашему артефакту файл с именем WEB-INF/jboss-scanning.xml со следующим содержимым:
	<scanning xmlns="urn:jboss:scanning:1.0"/>
Общие Java-приложения.

Когда инструментарий класса требуется в средах, которые не поддерживаются В конкретных реализациях LoadTimeWeaver общим решением является агент JVM.
Для таких случаев Spring предоставляет InstrumentationLoadTimeWeaver, для которого требуется Специальный для Spring (но очень общий) агент JVM, `spring-instrument.jar`, обнаруживается автоматически с помощью общих настроек `@EnableLoadTimeWeaving` и `<context:load-time-weaver/>`.
Общие Java-приложения.
Чтобы использовать его, вы должны запустить виртуальную машину с агентом Spring, указав следующие параметры JVM:
-javaagent:/path/to/spring-instrument.jar.
Обратите внимание, что для этого требуется модификация сценария запуска JVM, что может помешать вам от использования этого в средах серверов приложений (в зависимости от вашего сервера и вашего операционная политика).
Тем не менее, для развертываний с одним приложением на JVM, таких как автономные Приложения Spring Boot в любом случае обычно вы контролируете всю настройку JVM.

1. Введение. `validation` отвечает за декларативную и программную проверку входных данных, доменных объектов и конфигурации.
- снижает число дефектов на ранних этапах;
- стандартизирует ошибки валидации;
- упрощает защиту API и внутренних команд.
```xml
```java
    @NotBlank(message = "username must not be blank")
    private String username;
    @Email(message = "email has invalid format")
    private String email;
    @Min(value = 18, message = "age must be >= 18")
    private int age;
    // getters/setters omitted for brevity
```java
    private final Validator validator;
    public UserService(Validator validator) {
        this.validator = validator;
    public void register(RegisterUserRequest request) {
        ValidationResult result = validator.validate(request);
        if (!result.isValid()) {
            // В проде лучше возвращать структурированный список нарушений.
            throw new IllegalArgumentException("Validation failed: " + result.errors());
        // Сохраняем пользователя.
```yaml
    fail-fast: false
    max-errors: 50
    locale: ru-RU
    sanitize-strings: true
- Всегда валидируйте входные DTO до начала бизнес-операций.
- Проверяйте, что `max-errors` ограничен, чтобы исключить избыточную нагрузку.
- Не доверяйте данным из очередей/внешних API без повторной валидации.

- Для денежных и идентификационных полей добавляйте доменные кастомные валидаторы.
- Не маскируйте ошибки валидации generic-исключением без деталей.
- `ConstraintDefinitionException`: неверно настроен кастомный constraint.
- `ValidationOverflowException`: превышено `max-errors`.
- `MessageInterpolationException`: проблема локализации текста ошибок.
```java
    @Override
    public boolean isValid(String value, ConstraintContext context) {
        if (value == null) {
            context.addError("orderId must not be null");
            return false;
        boolean ok = value.matches("ORD-[0-9]{10}");
        if (!ok) {
            context.addError("orderId must match pattern ORD-##########");
        return ok;
- Используйте fail-fast только для latency-critical путей.
- Для публичных API возвращайте machine-readable ошибки (`code`, `field`, `message`).
- Группируйте правила валидации по use-case (create/update/import).
- Пишите unit-тесты на каждый кастомный validator.
- Не смешивайте валидацию и бизнес-логику в одном классе.

Проверка с использованием интерфейса валидатора Spring.
Spring имеет интерфейс «Валидатор», который можно использовать для проверки объектов.
Интерфейс «Валидатор» работает с использованием объекта «Ошибки», поэтому при проверке валидаторы могут сообщать об ошибках проверки объекту «Errors».
Java
	public class Person {
		private String name;
		private int age;
		// обычные геттеры и сеттеры...
Рассмотрим следующий пример небольшого объекта данных:.
В следующем примере показано поведение проверки для класса Person путем реализации следующие два метода интерфейса `org.springframework.validation.Validator`:
* `supports(Class)`: может ли этот `Validator` проверять экземпляры предоставленного `Class`?
* `validate(Object, org.springframework.validation.Errors)`: проверяет заданный объект.
Рассмотрим следующий пример небольшого объекта данных:. и, в случае ошибок проверки, регистрирует их с помощью данного объекта «Errors».
Рассмотрим следующий пример небольшого объекта данных:.
Реализация «Валидатора» довольно проста, особенно если вы знаете о Вспомогательный класс ValidationUtils, который также предоставляет Spring Framework.
Следующие пример реализует `Validator` для экземпляров `Person`:
Java
	public class PersonValidator implements Validator {
		 * Этот валидатор проверяет только экземпляры Person.
		public boolean supports(Class clazz) {
			return Person.class.equals(clazz);
		public void validate(Object obj, Errors e) {

ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
			Person p = (Person) obj;
			if (p.getAge() < 0) {
				e.rejectValue("age", "negativevalue");
			} else if (p.getAge() > 110) {
				e.rejectValue("age", "too.darn.old");
	class PersonValidator : Validator {
Рассмотрим следующий пример небольшого объекта данных:.
Статический метод `rejectIfEmpty(..)` в классе `ValidationUtils` используется для отклонить свойство name, если оно имеет значение null или пустую строку.
Взгляните на {spring-framework-api}/validation/ValidationUtils.html[`ValidationUtils`] javadoc чтобы увидеть, какие функции он предоставляет помимо примера, показанного ранее.
Рассмотрим следующий пример небольшого объекта данных:.
Хотя, безусловно, можно реализовать один класс Validator для проверки каждого вложенных объектов в расширенный объект, возможно, лучше инкапсулировать проверку логика для каждого вложенного класса объекта в своей собственной реализации «Валидатора».
Простой примером «богатого» объекта может быть объект «Клиент», состоящий из двух строк. свойства (имя и второе имя) и сложный объект «Адрес».
Объекты `Адрес` может использоваться независимо от объектов Customer, поэтому отдельный объект AddressValidator был реализован.

Если вы хотите, чтобы ваш CustomerValidator повторно использовал содержащуюся логику внутри класса AddressValidator, не прибегая к копированию и вставке, вы можете внедрить зависимость или создать экземпляр AddressValidator внутри вашего CustomerValidator, как показано в следующем примере:
Java
	public class CustomerValidator implements Validator {
		private final Validator addressValidator;
		public CustomerValidator(Validator addressValidator) {
			if (addressValidator == null) {
				throw new IllegalArgumentException("The supplied [Validator] is " +
					"required and must not be null.");
			if (!addressValidator.supports(Address.class)) {
				throw new IllegalArgumentException("The supplied [Validator] must " +
					"support the validation of [Address] instances.");
			this.addressValidator = addressValidator;
		 * Этот Валидатор проверяет экземпляры Клиента, а также любые подклассы Клиента.
		public boolean supports(Class clazz) {
			return Customer.class.isAssignableFrom(clazz);
		public void validate(Object target, Errors errors) {
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
			Customer customer = (Customer) target;
			try {
				errors.pushNestedPath("address");
				ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
			} finally {
				errors.popNestedPath();

Рассмотрим следующий пример небольшого объекта данных:.
Об ошибках проверки сообщается объекту «Errors», передаваемому валидатору.
В случае Spring Web MVC вы можете использовать тег `<spring:bind/>` для проверки сообщений об ошибках, но вы также можете проверить объект «Ошибки» самостоятельно.
Более подробная информация о Предлагаемые им методы можно найти в файле {spring-framework-api}/validation/Errors.html[javadoc].
Рассмотрим следующий пример небольшого объекта данных:.
Валидаторы также могут вызываться локально для немедленной проверки данного объекта. без обязательного процесса.
Начиная с версии 6.1, это было упрощено за счет нового Метод `Validator.validateObject(Object)`, который теперь доступен по умолчанию, возвращает простое представление `Errors`, которое можно проверить: обычно вызывая `hasErrors()` или новый методfailOnError для превращения сводного сообщения об ошибке в исключение. (например, `validator.validateObject(myObject).failOnError(IllegalArgumentException::new)`).

Java
	@Component
	public class MovieRecommender {
		private final String catalog;
		public MovieRecommender(@Value("${catalog.name}") String catalog) {
			this.catalog = catalog;
Java
	@Configuration
	@PropertySource("classpath:application.properties")
	public class AppConfig { }
	@Configuration
	@PropertySource("classpath:application.properties")
	class AppConfig
	catalog.name=MovieCatalog
И следующий файл application.properties:.
В этом случае параметр и поле «catalog» будут равны значению MovieCatalog.
И следующий файл application.properties:.
Мягкий встроенный преобразователь значений по умолчанию предоставляется Spring.
Он попытается решить значение свойства и, если его невозможно разрешить, имя свойства (например, `${catalog.name}`) будет введено как значение.
Если вы хотите сохранить строгий контроль над несуществующим значения, вам следует объявить bean-компонент PropertySourcesPlaceholderConfigurer, как показано ниже. пример показывает:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
			return new PropertySourcesPlaceholderConfigurer();
	@Configuration
	class AppConfig {
И следующий файл application.properties:.
ПРИМЕЧАНИЕ.
При настройке PropertySourcesPlaceholderConfigurer с помощью JavaConfig Метод `@Bean` должен быть `статическим`.
И следующий файл application.properties:.
Использование приведенной выше конфигурации гарантирует сбой инициализации Spring, если есть `${}` заполнитель не может быть разрешен.

Также можно использовать такие методы, как `setPlaceholderPrefix()`, `setPlaceholderSuffix()`, `setValueSeparator()` или `setEscapeCharacter()` для настройки синтаксиса заполнителя.
Кроме того, по умолчанию escape-символ можно изменить или отключить глобально, установив параметр `spring.placeholder.escapeCharacter.default` через системное свойство JVM (или через механизм SpringProperties[`SpringProperties`]).
И следующий файл application.properties:.
ПРИМЕЧАНИЕ.
Spring Boot по умолчанию настраивает bean-компонент PropertySourcesPlaceholderConfigurer, который получит свойства из файлов application.properties и application.yml.
И следующий файл application.properties:.
Встроенная поддержка конвертеров, предоставляемая Spring, позволяет выполнять простое преобразование типов (в Integer). или, например, `int`) для автоматической обработки.
Можно указать несколько значений, разделенных запятыми. автоматически преобразуется в массив String без дополнительных усилий.
Java
	@Component
	public class MovieRecommender {
		private final String catalog;
		public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
			this.catalog = catalog;
Можно указать значение по умолчанию следующим образом:.
Spring `BeanPostProcessor` использует ConversionService за кулисами для обработки процесс преобразования значения `String` в `@Value` в целевой тип.

Если вы хотите обеспечить поддержку преобразования для вашего собственного типа, вы можете предоставить свой собственный Экземпляр bean-компонента `ConversionService`, как показано в следующем примере:
Java
	@Configuration
	public class AppConfig {
		@Bean
		public ConversionService conversionService() {
			DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
			conversionService.addConverter(new MyCustomConverter());
			return conversionService;
	@Configuration
	class AppConfig {
Можно указать значение по умолчанию следующим образом:.
Если `@Value` содержит выражение `SpEL`, значение будет динамическим. вычисляется во время выполнения, как показано в следующем примере:
Java
	@Component
	public class MovieRecommender {
		private final String catalog;
		public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
			this.catalog = catalog;
Java
	@Component
	public class MovieRecommender {
		private final Map<String, Integer> countOfMoviesPerCatalog;
		public MovieRecommender(
				@Value("#{{'Thriller': 100, 'Comedy': 300}}") Map<String, Integer> countOfMoviesPerCatalog) {
			this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;

Вызовы Варарга.
Язык выражений Spring поддерживает https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html[varargs] вызовы для constructors,
Вызовы Варарга.
В следующем примере показано, как вызвать `java.lang.String#formatted(Object...)` _varargs_ внутри выражения, предоставляя список аргументов переменной как отдельный аргументы (`'синий', 1`).
Java
	// оценивается как «синий — цвет №1»
	String expression = "'%s is color #%d'.formatted('blue', 1)";
	String message = parser.parseExpression(expression).getValue(String.class);
Вызовы Варарга.
Список переменных аргументов также может быть предоставлен в виде массива, как показано в следующий пример (`new Object[] {'blue', 1}`).
Java
	// оценивается как «синий — цвет №1»
	String expression = "'%s is color #%d'.formatted(new Object[] {'blue', 1})";
	String message = parser.parseExpression(expression).getValue(String.class);
Вызовы Варарга.

В качестве альтернативы список переменных аргументов может быть предоставлен как `java.util.List` – для например, в виде встроенный список (`{'синий', 1}`).
В следующем примере показано, как это сделать.
Java
	// оценивается как «синий — цвет №1»
	String expression = "'%s is color #%d'.formatted({'blue', 1})";
	String message = parser.parseExpression(expression).getValue(String.class);
Преобразование типов переменных аргументов.
В отличие от стандартной поддержки вызовов с переменным числом аргументов в Java, применяется к отдельным аргументам при вызове конструкторов, методов или функции в SpEL.
Преобразование типов переменных аргументов.
Например, если мы зарегистрировали пользовательский под именем #reverseStrings для метода с сигнатурой `StringverseStrings(String... strings)`, мы можем вызвать эту функцию внутри SpEL. выражение с любым аргументом, который можно преобразовать в строку, как показано в следующий пример.
Java
	// оценивается как «3.0, 2.0, 1, SpEL»
	String expression = "#reverseStrings('SpEL', 1, 10F / 5, 3.0000)";
	String message = parser.parseExpression(expression)
			.getValue(evaluationContext, String.class);
Преобразование типов переменных аргументов.

Аналогично, любой массив, тип компонента которого является подтипом требуемого типа varargs, может быть предоставлен в качестве списка переменных аргументов для вызова varargs.
Например, Массив `String[]` может быть передан в вызов varargs, который принимает `Object...` список аргументов.
Преобразование типов переменных аргументов.
Следующий листинг показывает, что мы можем передать массив `String[]` в `java.lang.String#formatted(Object...)` метод _varargs_.
Также подчеркивается, что `1` будет автоматически преобразован в `"1"`.
Java
	// оценивается как «синий — цвет №1»
	String expression = "'%s is color #%s'.formatted(new String[] {'blue', 1})";
	String message = parser.parseExpression(expression).getValue(String.class);

Переменные.
Вы можете ссылаться на переменные в выражении, используя синтаксис #variableName.
Переменные устанавливаются с помощью метода setVariable() в реализациях EvaluationContext.
Переменные. [ПРИМЕЧАНИЕ] = Имена переменных должны начинаться с буквы (как определено ниже), подчеркивания или доллара. знак.
Переменные.
Имена переменных должны состоять из одного или нескольких следующих поддерживаемых типов: персонажи.
* буква: любой символ, для которого `java.lang.Character.isLetter(char)` возвращает `true`
Переменные. – Сюда входят такие буквы, как от «A» до «Z», от «a» до «z», «ü», «ñ» и «é», а также
    буквы из других наборов символов, таких как китайский, японский, кириллица и т. д.
* цифра: от `0` до `9`
* подчеркивание: `_`
* знак доллара: `$`
Переменные. [СОВЕТ] = При установке переменной или объекта корневого контекста в EvaluationContext рекомендуется чтобы тип переменной или объекта корневого контекста был «публичным».
Переменные.
В противном случае некоторые типы выражений SpEL, включающие переменную или объект корневого контекста. с закрытым типом может не выполниться или скомпилироваться.
Переменные. [ВНИМАНИЕ] = Поскольку переменные имеют общее пространство имен с необходимо следить за тем, чтобы имена переменных и имена функций не перекрывались.
Переменные.

В следующем примере показано, как использовать переменные.
Java
	Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
	context.setVariable("newName", "Mike Tesla");
	parser.parseExpression("name = #newName").getValue(context, tesla);
	System.out.println(tesla.getName());  // "Mike Tesla"
	parser.parseExpression("name = #newName").getValue(context, tesla)
	println(tesla.name) // «Майк Тесла»
Переменные `#this` и `#root`.
Переменная `#this` всегда определена и ссылается на текущий объект оценки. (против которых разрешаются неквалифицированные ссылки).
Переменная `#root` всегда определен и ссылается на корневой объект контекста.
Хотя `#this` может варьироваться в зависимости от компонентов выражения оцениваются, `#root` всегда относится к корню.
Переменные `#this` и `#root`.
В следующем примере показано, как использовать переменную #this в сочетании с
Java
	// Создайте список простых целых чисел.
	List<Integer> primes = List.of(2, 3, 5, 7, 11, 13, 17);

// Создаём парсер и устанавливаем переменные «простые числа» в качестве списка целых чисел.
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
	context.setVariable("primes", primes);
	// Выберите из списка все простые числа > 10 (используя выделение ?{...}).
	String expression = "#primes.?[#this > 10]";
	// Возвращает список, содержащий [11, 13, 17].
	List<Integer> primesGreaterThanTen =
			parser.parseExpression(expression).getValue(context, List.class);
Переменные `#this` и `#root`.
В следующем примере показано, как использовать переменные `#this` и `#root` вместе в сочетании с
Java
	// Создайте контекст синтаксического анализатора и оценки.
	ExpressionParser parser = new SpelExpressionParser();
	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
	// Создание изобретателя для использования в качестве объекта корневого контекста.
	Inventor tesla = new Inventor("Nikola Tesla");
	tesla.setInventions("Telephone repeater", "Tesla coil transformer");
	// Перебираем все изобретения Inventor, на которые ссылается #root
	// объект и генерируем список строк, содержимое которых имеет вид

// «<имя изобретателя> изобрел <изобретение>». (с использованием проекции !{...}).
	String expression = "#root.inventions.![#root.name + ' invented the ' + #this + '.']";
	// Возвращает список, содержащий:
	// «Никола Тесла изобрел телефонный ретранслятор».
	// «Никола Тесла изобрел катушечный трансформатор Теслы».
	List<String> results = parser.parseExpression(expression)
			.getValue(context, tesla, List.class);

Просмотр контроллеров.
Это ярлык для определения ParameterizableViewController, который немедленно пересылает к представлению при вызове.
Вы можете использовать его в статических случаях, когда нет Java-контроллера. логика, которая будет запущена до того, как представление сгенерирует ответ.
Просмотр контроллеров.
В следующем примере запрос `/` перенаправляется в представление под названием `home`: См. пример кода в исходном документе.
Просмотр контроллеров.
Если метод @RequestMapping сопоставлен с URL-адресом любого метода HTTP, то представление контроллер не может использоваться для обработки одного и того же URL-адреса.
Это связано с тем, что совпадение по URL-адресу с аннотированный контроллер считается достаточно убедительным признаком владения конечной точкой, поэтому что ответ 405 (METHOD_NOT_ALLOWED), 415 (UNSUPPORTED_MEDIA_TYPE) или аналогичный может быть отправлен клиенту для помощи в отладке.
По этой причине рекомендуется избегать разделение обработки URL-адресов между аннотированным контроллером и контроллером представления.

Посмотреть резольверы.
Конфигурация MVC упрощает регистрацию преобразователей представлений.
Посмотреть резольверы.
В следующем примере настраивается разрешение представления согласования содержимого с использованием JSP и Jackson в качестве по умолчанию `View` для рендеринга JSON: См. пример кода в исходном документе.
Посмотреть резольверы.
Однако обратите внимание, что для FreeMarker, Groovy Markup и шаблонов сценариев также требуется конфигурация базовой технологии просмотра.
Следующий пример работает с FreeMarker: См. пример кода в исходном документе.

КОРС.
Spring WebFlux позволяет обрабатывать CORS (совместное использование ресурсов между источниками).
Этот раздел описывает, как это сделать.
Введение.
По соображениям безопасности браузеры запрещают вызовы AJAX к ресурсам за пределами текущего источника.
Например, ваш банковский счет может находиться на одной вкладке, а сайт evil.com — на другой.
Скрипты от evil.com не должен иметь возможности отправлять AJAX-запросы к API вашего банка с помощью вашего учетные данные - например, снятие денег со своего счета!
Введение.
Совместное использование ресурсов между источниками (CORS) — это https://www.w3.org/TR/cors/[спецификация W3C] реализовано https://caniuse.com/#feat=cors[большинством браузеров], что позволяет вам указать какие междоменные запросы разрешены, вместо использования менее безопасных и менее мощные обходные пути на основе IFRAME или JSONP.
Обработка.
Спецификация CORS различает предполетные, простые и фактические запросы.
Чтобы узнать, как работает CORS, вы можете прочитать https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[эта статья], среди многие другие или см. спецификацию для получения более подробной информации.
Обработка.
Реализации Spring WebFlux HandlerMapping предоставляют встроенную поддержку CORS.
После успешного сопоставление запроса с обработчиком, HandlerMapping проверяет конфигурацию CORS на наличие данный запрос и обработчик и предпринимает дальнейшие действия.

Предполетные запросы обрабатываются напрямую, в то время как простые и актуальные запросы CORS перехватываются, проверяются и имеют установлен требуемый набор заголовков ответа CORS.
Обработка.
Чтобы включить запросы между источниками (то есть заголовок «Origin» присутствует и отличается от хоста запроса), вам необходимо иметь явно объявленный CORS. конфигурация.
Если соответствующая конфигурация CORS не найдена, заголовки CORS не добавляются. ответы на предполетные, простые и актуальные запросы CORS и, следовательно, браузеры отвергнуть их.
Обработка.
Каждое HandlerMapping может быть {spring-framework-api}/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations(java.util.Map)[настроено] индивидуально с сопоставлениями CorsConfiguration на основе шаблонов URL.
В большинстве случаев приложения используйте конфигурацию Java WebFlux для объявления таких сопоставлений, что приводит к созданию одного глобальная карта передается во все реализации HandlerMapping.
Обработка.
Вы можете комбинировать глобальную конфигурацию CORS на уровне HandlerMapping с другими детальная конфигурация CORS на уровне обработчика.
Например, аннотированные контроллеры могут использовать Аннотации `@CrossOrigin` на уровне класса или метода (другие обработчики могут реализовать `CorsConfigurationSource`).
Обработка.
Правила объединения глобальной и локальной конфигурации обычно аддитивны, например: все глобальное и все локальное происхождение.
Для тех атрибутов, где может быть указано только одно значение принимаются, например, «allowCredentials» и «maxAge», локальное значение переопределяет глобальное значение.

См. {spring-framework-api}/web/cors/CorsConfiguration.html#combine(org.springframework.web.cors.CorsConfiguration)[`CorsConfiguration#combine(CorsConfiguration)`] для более подробной информации.
Обработка. [СОВЕТ] = Чтобы узнать больше из источника или выполнить расширенную настройку, см.:
* `КорсКонфигурация`
* `CorsProcessor` и `DefaultCorsProcessor`
* `AbstractHandlerMapping`
Сертифицированные запросы.
Использование CORS с запросами с учетными данными требует включения `allowedCredentials`.
Имейте в виду, что эта опция устанавливает высокий уровень доверия с настроенными доменами, а также увеличивает поверхность атаки веб-приложения путем раскрытия конфиденциальной информации, специфичной для пользователя такие как файлы cookie и токены CSRF.
Сертифицированные запросы.
Включение учетных данных также влияет на обработку настроенных подстановочных знаков `"*"` CORS:
* Подстановочные знаки не разрешены в `allowOrigins`, но альтернативно
Сертифицированные запросы.
СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.
* Если установлено значение `allowedHeaders` или `allowedMethods`, `Access-Control-Allow-Headers`
Сертифицированные запросы. и заголовки ответов `Access-Control-Allow-Methods` обрабатываются путем копирования связанных заголовки и метод, указанные в предполетном запросе CORS.
* Если установлено значение `exposeHeaders`, устанавливается заголовок ответа `Access-Control-Expose-Headers`.

Сертифицированные запросы. либо к настроенному списку заголовков, либо к подстановочному знаку.
Хотя спецификация CORS не разрешает использование подстановочного знака, если для параметра «Access-Control-Allow-Credentials» установлено значение `true`, большинство браузеров поддерживают его, и не все заголовки ответов доступны во время Обработка CORS, поэтому подстановочный знак является значением заголовка, используемым при указывается независимо от значения свойстваallowCredentials.
Сертифицированные запросы.
ВНИМАНИЕ: Хотя такая конфигурация с подстановочными знаками может быть удобной, рекомендуется, если это возможно, настроить вместо этого используется конечный набор значений для обеспечения более высокого уровня безопасности.
`@CrossOrigin`. {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`] аннотация позволяет выполнять запросы между источниками к аннотированным методам контроллера, поскольку следующий пример показывает:
Java
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@CrossOrigin
		@GetMapping("/{id}")
		public Mono<Account> retrieve(@PathVariable Long id) {
		@DeleteMapping("/{id}")
		public Mono<Void> remove(@PathVariable Long id) {
	@RestController
	@RequestMapping("/account")
	class AccountController {
* Все происхождение.
* Все заголовки.
* Все методы HTTP, с которыми сопоставлен метод контроллера.

По умолчанию @CrossOrigin позволяет:. `allowCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.
Когда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `"*"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.
По умолчанию @CrossOrigin позволяет:. `maxAge` установлен на 30 минут.
По умолчанию @CrossOrigin позволяет:. `@CrossOrigin` также поддерживается на уровне класса и наследуется всеми методами.
В следующем примере указывается определенный домен и для параметра maxAge устанавливается значение часа:
Java
	@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@GetMapping("/{id}")
		public Mono<Account> retrieve(@PathVariable Long id) {
		@DeleteMapping("/{id}")
		public Mono<Void> remove(@PathVariable Long id) {
	@CrossOrigin("https://domain2.com", maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	class AccountController {
По умолчанию @CrossOrigin позволяет:.

Вы можете использовать @CrossOrigin как на уровне класса, так и на уровне метода. как показано в следующем примере:
Java
	@CrossOrigin(maxAge = 3600) // <1>
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@CrossOrigin("https://domain2.com") // <2>
		@GetMapping("/{id}")
		public Mono<Account> retrieve(@PathVariable Long id) {
		@DeleteMapping("/{id}")
		public Mono<Void> remove(@PathVariable Long id) {
По умолчанию @CrossOrigin позволяет:. <1> Использование `@CrossOrigin` на уровне класса. <2> Использование `@CrossOrigin` на уровне метода.
	@CrossOrigin(maxAge = 3600) // <1>
	@RestController
	@RequestMapping("/account")
	class AccountController {
По умолчанию @CrossOrigin позволяет:. <1> Использование `@CrossOrigin` на уровне класса. <2> Использование `@CrossOrigin` на уровне метода.
Глобальная конфигурация.
В дополнение к детальной настройке на уровне методов контроллера вы, вероятно, захотите также определите некоторую глобальную конфигурацию CORS.
Вы можете установить CorsConfiguration на основе URL-адреса. сопоставления индивидуально для любого HandlerMapping.
Однако большинство приложений используют Конфигурация Java WebFlux для этого.
* Все происхождение.
* Все заголовки.

* Методы GET, HEAD и POST.
По умолчанию глобальная конфигурация позволяет следующее:. `allowedCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.
Когда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `"*"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.
По умолчанию глобальная конфигурация позволяет следующее:. `maxAge` установлен на 30 минут.
По умолчанию глобальная конфигурация позволяет следующее:.
Чтобы включить CORS в конфигурации Java WebFlux, вы можете использовать обратный вызов CorsRegistry: как показано в следующем примере:
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Override
		public void addCorsMappings(CorsRegistry registry) {
			registry.addMapping("/api/**")
				.allowedOrigins("https://domain2.com")
				.allowedMethods("PUT", "DELETE")
				.allowedHeaders("header1", "header2", "header3")
				.exposedHeaders("header1", "header2")
				.allowCredentials(true).maxAge(3600);
			// Добавить больше сопоставлений...
	@Configuration
	class WebConfig : WebFluxConfigurer {

registry.addMapping("/api/**")
					.allowedOrigins("https://domain2.com")
					.allowedMethods("PUT", "DELETE")
					.allowedHeaders("header1", "header2", "header3")
					.exposedHeaders("header1", "header2")
					.allowCredentials(true).maxAge(3600)
			// Добавить больше сопоставлений...
CORS `WebFilter`.
Вы можете применить поддержку CORS через встроенный {spring-framework-api}/web/cors/reactive/CorsWebFilter.html[`CorsWebFilter`], который представляет собой хорошо подходит для функциональные конечные точки.
CORS `WebFilter`.
ПРИМЕЧАНИЕ.
Если вы попытаетесь использовать CorsFilter с Spring Security, имейте в виду, что Spring Безопасность имеет {docs-spring-security}/servlet/integrations/cors.html[встроенную поддержку] для КОРС.
CORS `WebFilter`.
Чтобы настроить фильтр, вы можете объявить bean-компонент CorsWebFilter и передать `CorsConfigurationSource` в свой конструктор, как показано в следующем примере:
Java
	@Bean
	CorsWebFilter corsFilter() {
		CorsConfiguration config = new CorsConfiguration();
		// Возможно...
		// config.applyPermitDefaultValues()
		config.setAllowCredentials(true);
		config.addAllowedOrigin("https://domain1.com");

config.addAllowedHeader("*");
		config.addAllowedMethod("*");
		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		source.registerCorsConfiguration("/**", config);
		return new CorsWebFilter(source);
		// Возможно...
		// config.applyPermitDefaultValues()
		config.allowCredentials = true
		config.addAllowedOrigin("https://domain1.com")
		config.addAllowedHeader("*")
		config.addAllowedMethod("*")

Функциональные конечные точки.
Spring WebFlux включает WebFlux.fn, облегченную модель функционального программирования, в которой функции используются для маршрутизации и обработки запросов, а контракты разработаны с учетом неизменяемости.
Это альтернатива модели программирования на основе аннотаций, но в остальном она работает на тот же фундамент [Reactive Core].
Обзор.
В WebFlux.fn HTTP-запрос обрабатывается с помощью HandlerFunction: функции, которая принимает `ServerRequest` и возвращает задержанный `ServerResponse` (т. е. `Mono<ServerResponse>`).
И объект запроса, и объект ответа имеют неизменяемые контракты, которые обеспечивают совместимость с JDK 8. доступ к HTTP-запросу и ответу.
HandlerFunction — это эквивалент тела метода @RequestMapping в модель программирования на основе аннотаций.
Обзор.
Входящие запросы направляются в функцию-обработчик с помощью RouterFunction: функции, которая принимает `ServerRequest` и возвращает задержанную `HandlerFunction` (т. е. `Mono<HandlerFunction>`).
Когда функция маршрутизатора совпадает, возвращается функция-обработчик; в противном случае пустой Mono.
RouterFunction — это эквивалент аннотации @RequestMapping, но с основным Разница в том, что функции маршрутизатора предоставляют не только данные, но и поведение.
Обзор. `RouterFunctions.route()` предоставляет конструктор маршрутизаторов, который упрощает создание маршрутизаторов. как показано в следующем примере:
Java
	import static org.springframework.http.MediaType.APPLICATION_JSON;

import static org.springframework.web.reactive.function.server.RequestPredicates.*;
	import static org.springframework.web.reactive.function.server.RouterFunctions.route;
	PersonRepository repository = ...
	PersonHandler handler = new PersonHandler(repository);
	RouterFunction<ServerResponse> route = route() <1>
		.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
		.GET("/person", accept(APPLICATION_JSON), handler::listPeople)
		.POST("/person", handler::createPerson)
		.build();
	public class PersonHandler {
		public Mono<ServerResponse> listPeople(ServerRequest request) {
		public Mono<ServerResponse> createPerson(ServerRequest request) {
		public Mono<ServerResponse> getPerson(ServerRequest request) {
Обзор. <1> Создайте маршрутизатор с помощью `route()`.
Обзор. <1> Создайте маршрутизатор с помощью маршрутизатора Coroutines DSL; Реактивная альтернатива также доступна через `router { }`.
Обзор.
Один из способов запустить RouterFunction — превратить его в HttpHandler и установить. через один из встроенных адаптеры сервера:
* `RouterFunctions.toHttpHandler(RouterFunction)`
* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`
Обзор.
Большинство приложений могут работать через конфигурацию Java WebFlux, см.
Запуск сервера.

ОбработчикФункция. `ServerRequest` и `ServerResponse` — это неизменяемые интерфейсы, совместимые с JDK 8. доступ к HTTP-запросу и ответу.
И запрос, и ответ оказывают обратное давление на {reactive-streams-site}[Reactive Streams]. против потоков тела.
Тело запроса представлено Reactor Flux или Mono.
Тело ответа представлено любым издателем Reactive Streams, включая Flux и Mono.
Подробнее об этом см.
Реактивные библиотеки.
Серверный запрос. `ServerRequest` обеспечивает доступ к методу HTTP, URI, заголовкам и параметрам запроса. в то время как доступ к телу предоставляется через методы body.
Java
Flux<Person> people = request.bodyToFlux(Person.class);.
Предыдущие примеры представляют собой ярлыки, использующие более общий вариант ServerRequest.body(BodyExtractor). который принимает интерфейс функциональной стратегии BodyExtractor.
Класс полезности BodyExtractors предоставляет доступ к ряду экземпляров.
Например, предыдущие примеры могут также записать так:
Java
Flux<Person> people = request.bodyToFlux(Person.class);.
Mono<String> string = request.body(BodyExtractors.toMono(String.class)); Flux<Person> people = request.body(BodyExtractors.toFlux(Person.class));
Java
Mono<MultiValueMap<String, String>> map = request.formData();.

В следующем примере показано, как получить доступ к составным данным в виде карты:
Java
Mono<MultiValueMap<String, Part>> map = request.multipartData();.
В следующем примере показано, как получить доступ к составным данным по одному в потоковом режиме: См. пример кода в исходном документе.
Mono<MultiValueMap<String, Part>> map = request.multipartData();.
ПРИМЕЧАНИЕ.
Содержимое тела объектов PartEvent должно быть полностью использовано, передано или освобождено во избежание утечек памяти.
Mono<MultiValueMap<String, Part>> map = request.multipartData();.
Ниже показано, как связать параметры запроса, переменные URI или заголовки с помощью DataBinder. а также показывает, как настроить DataBinder: См. пример кода в исходном документе.
Ответ сервера. `ServerResponse` обеспечивает доступ к HTTP-ответу, и, поскольку он неизменяем, вы можете использовать метод `build` для его создания.
Вы можете использовать конструктор, чтобы установить статус ответа, добавить ответ заголовки или предоставить тело.
В следующем примере создается ответ 200 (ОК) с JSON. содержание: См. пример кода в исходном документе.
Ответ сервера.
В следующем примере показано, как создать ответ 201 (CREATED) с заголовком Location и без тела:
Java
URI location =... return ServerResponse.created(location).build();.

В зависимости от используемого кодека можно передавать параметры подсказки, чтобы настроить способ тело сериализуется или десериализуется.
Например, чтобы указать {baeldung-blog}/jackson-json-view-annotation[представление JSON Джексона]:
Java
Классы обработчиков.
Мы можем написать функцию-обработчик в виде лямбды, как показано в следующем примере:
Java
Классы обработчиков.
HandlerFunction<ServerResponse> helloWorld = request -> ServerResponse.ok().bodyValue("Hello World");
Классы обработчиков.
Это удобно, но в приложении нам нужно несколько функций и несколько встроенных лямбда может запутаться.
Поэтому полезно сгруппировать связанные функции-обработчики в класс обработчиков, который имеет ту же роль, что и `@Controller` в приложении на основе аннотаций.
Например, следующий класс предоставляет реактивный репозиторий Person: См. пример кода в исходном документе.
Валидация.
Функциональная конечная точка может использовать Spring средства проверки для применить проверку к телу запроса.
Например, учитывая пользовательский Spring См. пример кода в исходном документе.
Валидация.
Обработчики также могут использовать стандартный API проверки компонентов (JSR-303), создавая и внедряя глобальный экземпляр Validator, основанный на LocalValidatorFactoryBean.
См.
Spring Validation.
`RouterFunction`.
Функции маршрутизатора используются для маршрутизации запросов к соответствующей функции HandlerFunction.

Обычно вы не пишете функции маршрутизатора самостоятельно, а используете метод на Утилита RouterFunctions для его создания. `RouterFunctions.route()` (без параметров) предоставляет вам удобный конструктор для создания маршрутизатора. функция, тогда как RouterFunctions.route(RequestPredicate, HandlerFunction) предлагает прямой путь создать роутер.
`RouterFunction`.
Как правило, рекомендуется использовать построитель `route()`, поскольку он обеспечивает удобные ярлыки для типичных сценариев картографии, не требующие сложного обнаружения статический импорт.
Например, построитель функций маршрутизатора предлагает метод GET(String, HandlerFunction) создать сопоставление для GET-запросов; и POST(String, HandlerFunction) для POST.
`RouterFunction`.
Помимо сопоставления на основе HTTP-метода, построитель маршрутов предлагает способ введения дополнительных предикаты при сопоставлении с запросами.
Для каждого метода HTTP существует перегруженный вариант, который принимает RequestPredicate в качестве параметр, через который могут быть выражены дополнительные ограничения.
Предикаты.
Вы можете написать свой собственный RequestPredicate, но служебный класс RequestPredicates предлагает встроенные возможности для общих нужд сопоставления на основе метода HTTP, запроса путь, заголовки, версия API и многое другое.
Предикаты.
В следующем примере используется заголовок Accept, предикат запроса: См. пример кода в исходном документе.
* `RequestPredicate.and(RequestPredicate)` -- оба должны совпадать.
* `RequestPredicate.or(RequestPredicate)` — любой из них может совпадать.

Вы можете составить несколько предикатов запроса вместе, используя:.
Многие предикаты из RequestPredicates являются составными.
Например, RequestPredicates.GET(String)` состоит из RequestPredicates.method(HttpMethod)` и `RequestPredicates.path(String)`.
В приведенном выше примере также используются два предиката запроса, поскольку построитель использует `RequestPredicates.GET` внутренне и объединяет его с предикатом `accept`.
Маршруты.
Функции маршрутизатора оцениваются по порядку: если первый маршрут не совпадает, то оценивается второй и так далее.
Поэтому имеет смысл объявлять более конкретные маршруты перед общими.
Это также важно при регистрации функций маршрутизатора в качестве bean-компонентов Spring. быть описаны позже.
Обратите внимание, что это поведение отличается от модели программирования на основе аннотаций, где «Наиболее конкретный» метод контроллера выбирается автоматически.
Маршруты.
При использовании конструктора функций маршрутизатора все определенные маршруты объединяются в один. `RouterFunction`, возвращаемая из `build()`.
Существуют и другие способы объединения нескольких функций маршрутизатора:
* `add(RouterFunction)` в конструкторе `RouterFunctions.route()`
* `RouterFunction.and(RouterFunction)`
* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` -- ярлык для
Маршруты. `RouterFunction.and()` с вложенным `RouterFunctions.route()`.
Маршруты.
В следующем примере показан состав четырех маршрутов: См. пример кода в исходном документе.

Вложенные маршруты.
Обычно группа функций маршрутизатора имеет общий предикат, например общий путь.
В приведенном выше примере общий предикат будет предикатом пути, который соответствует `/person`, используемому тремя маршрутами.
При использовании аннотаций вы должны удалить это дублирование с помощью аннотации @RequestMapping на уровне типа, которая сопоставляется с `/человек`.
В WebFlux.fn предикаты пути могут быть разделены с помощью метода path на построитель функций маршрутизатора.
Например, последние несколько строк приведенного выше примера могут быть улучшено следующим образом за счет использования вложенных маршрутов:
Java
	.path("/person", builder -> builder // <1>
		.GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
		.GET(accept(APPLICATION_JSON), handler::listPeople)
		.POST(handler::createPerson))
	.build();
RouterFunction<ServerResponse> route = route(). <1> Обратите внимание, что второй параметр `path` — это потребитель, который принимает сборщик маршрутизатора.
RouterFunction<ServerResponse> route = route(). <1> Создайте маршрутизатор с помощью маршрутизатора Coroutines DSL; Реактивная альтернатива также доступна через `router { }`.
RouterFunction<ServerResponse> route = route().
Хотя вложение на основе пути является наиболее распространенным, вы можете вложить любой тип предиката, используя метод `nest` в конструкторе.

Вышеупомянутое все еще содержит некоторое дублирование в виде общего предиката заголовка Accept.
Мы можем улучшить ситуацию, используя метод «nest» вместе с «accept»:
Java
	RouterFunction<ServerResponse> route = route()
		.path("/person", b1 -> b1
			.nest(accept(APPLICATION_JSON), b2 -> b2
				.GET("/{id}", handler::getPerson)
				.GET(handler::listPeople))
			.POST(handler::createPerson))
		.build();
Версия API.
Функции маршрутизатора поддерживают сопоставление по версии API.
Версия API.
Сначала включите управление версиями API в используйте `version` predicate следующим образом:
Java
	RouterFunction<ServerResponse> route = RouterFunctions.route()
		.GET("/hello-world", version("1.2"),
			request -> ServerResponse.ok().bodyValue("Hello World")).build();
- Фиксированная версия ("1.2") — соответствует только данной версии.
- Базовая версия ("1.2+") — соответствует данной версии и выше, вплоть до самой высокой.
Предикат `version` может быть:.
См.
Версии API для получения более подробной информации об основных инфраструктура и поддержка управления версиями API.
Обслуживание ресурсов.
WebFlux.fn предоставляет встроенную поддержку обслуживания ресурсов.

Обслуживание ресурсов.
ПРИМЕЧАНИЕ.
В дополнение к возможностям, описанным ниже, можно реализовать еще более гибкое управление ресурсами благодаря {spring-framework-api}++/web/reactive/function/server/RouterFunctions.html#resources(java.util.function.Function)++[`RouterFunctions#resource(java.util.function.Function)`].
Перенаправление на ресурс.
Можно перенаправить запросы, соответствующие указанному предикату, на ресурс.
Это может быть полезно, например, для обработки перенаправлений в одностраничных приложениях.
Java
	ClassPathResource index = new ClassPathResource("static/index.html");
	RequestPredicate spaPredicate = path("/api/**").or(path("/error")).negate();
	RouterFunction<ServerResponse> redirectToIndex = route()
		.resource(spaPredicate, index)
		.build();
Обслуживание ресурсов из корневого расположения.
Также возможно маршрутизировать запросы, соответствующие заданному шаблону, к ресурсам относительно заданного корневого местоположения.
Java
    Resource location = new FileUrlResource("public-resources/");
    RouterFunction<ServerResponse> resources = RouterFunctions.resources("/resources/**", location);
Запуск сервера.
Как запустить функцию маршрутизатора на HTTP-сервере?
Простой вариант — переделать роутер функцию для `HttpHandler`, используя одно из следующих действий:

* `RouterFunctions.toHttpHandler(RouterFunction)`
* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`
Запуск сервера.
Затем вы можете использовать возвращенный HttpHandler с рядом серверных адаптеров, выполнив следующие действия:
Запуск сервера.
Более типичный вариант, также используемый Spring Boot, — запуск с помощью компоненты, необходимые для обработки запросов.
Конфигурация Java WebFlux объявляет следующее: компоненты инфраструктуры для поддержки функциональных конечных точек:
* `RouterFunctionMapping`: обнаруживает один или несколько bean-компонентов `RouterFunction<?>` в Spring.
Запуск сервера. конфигурация, упорядочивает их, объединяет их посредством RouterFunction.andOther и направляет запросы в результирующую функцию RouterFunction.
* HandlerFunctionAdapter: простой адаптер, позволяющий вызывать DispatcherHandler.
Запуск сервера.
HandlerFunction, сопоставленный с запросом.
* `ServerResponseResultHandler`: обрабатывает результат вызова
Запуск сервера.
HandlerFunction, вызвав метод writeTo для ServerResponse.
Запуск сервера.
Предыдущие компоненты позволяют функциональным конечным точкам соответствовать запросу DispatcherHandler. жизненный цикл обработки, а также (потенциально) запускаться параллельно с аннотированными контроллерами, если любые объявлены.
Именно так функциональные конечные точки включаются с помощью Spring Boot WebFlux. стартер.
Запуск сервера.
В следующем примере показана конфигурация Java WebFlux (см.
Java
	@Configuration
	public class WebConfig implements WebFluxConfigurer {
		@Bean
		public RouterFunction<?> routerFunctionA() {
		@Bean
		public RouterFunction<?> routerFunctionB() {
		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {

// настроить преобразование сообщений...
		@Override
		public void addCorsMappings(CorsRegistry registry) {
			// настроить CORS...
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			// настраиваемое разрешение просмотра для рендеринга HTML...
	@Configuration
	class WebConfig : WebFluxConfigurer {
Фильтрация функций-обработчиков.
Вы можете фильтровать функции обработчика, используя методы «before», «after» или «filter» в маршрутизации. конструктор функций.
С помощью аннотаций вы можете добиться аналогичной функциональности, используя @ControllerAdvice, ServletFilter или оба.
Фильтр будет применяться ко всем маршрутам, построенным строителем.
Это означает, что фильтры, определенные во вложенных маршрутах, не применяются к маршрутам «верхнего уровня».
Например, рассмотрим следующий пример:
Java
	RouterFunction<ServerResponse> route = route()
		.path("/person", b1 -> b1
			.nest(accept(APPLICATION_JSON), b2 -> b2
				.GET("/{id}", handler::getPerson)
				.GET(handler::listPeople)
				.before(request -> ServerRequest.from(request) // <1>
					.header("X-RequestHeader", "Value")
					.build()))
			.POST(handler::createPerson))
		.after((request, response) -> logResponse(response)) // <2>

.build();
Фильтрация функций-обработчиков. <1> Фильтр «before», который добавляет пользовательский заголовок запроса, применяется только к двум маршрутам GET. <2> Фильтр «after», регистрирующий ответ, применяется ко всем маршрутам, включая вложенные.
Фильтрация функций-обработчиков.
Метод filter в конструкторе маршрутизатора принимает HandlerFilterFunction: функция, которая принимает ServerRequest и HandlerFunction и возвращает ServerResponse.
Параметр функции-обработчика представляет следующий элемент в цепочке.
Обычно это обработчик, на который перенаправляется, но это также может быть другой фильтровать, если применено несколько.
Фильтрация функций-обработчиков.
Теперь мы можем добавить к нашему маршруту простой фильтр безопасности, предполагая, что у нас есть SecurityManager, который может определить, разрешен ли конкретный путь.
В следующем примере показано, как это сделать: См. пример кода в исходном документе.
Фильтрация функций-обработчиков.
Предыдущий пример демонстрирует, что вызов next.handle(ServerRequest) не является обязательным.
Мы разрешаем запуск функции-обработчика только тогда, когда доступ разрешен.
Фильтрация функций-обработчиков.
Помимо использования метода фильтра в конструкторе функций маршрутизатора, можно применить отфильтровать существующую функцию маршрутизатора через `RouterFunction.filter(HandlerFilterFunction)`.

HTTP-клиент службы.
Spring Frameworks позволяет определить службу HTTP как интерфейс Java с HTTP. методы обмена.
Затем вы можете создать прокси, реализующий этот интерфейс, и осуществляет обмены.
Это помогает упростить удаленный доступ по HTTP и предоставляет дополнительные возможности. гибкость в выборе стиля API, например синхронного или реактивного.
HTTP-клиент службы.
Подробности см. в Клиенты службы HTTP.

Реактивные библиотеки. `spring-webflux` зависит от `reactor-core` и использует его внутри себя для создания асинхронных логику и обеспечить поддержку Reactive Streams.
Обычно API WebFlux возвращают Flux или `Mono` (поскольку они используются внутри) и снисходительно принимать любые реактивные потоки.
Реализация `Publisher` в качестве входных данных.
Если указан «Издатель», его можно рассматривать только как поток с неизвестной семантикой (0..N).
Однако, если семантика известна, вместо этого вам следует обернуть ее с помощью Flux или Mono.from(Publisher). передачи необработанного `Publisher`.
Использование «Flux» вместо «Mono» важно, потому что оно помогает выразить кардинальность. например, ожидается ли одно или несколько асинхронных значений, и это может быть важно для принятия решений (например, при кодировании или декодировании HTTP-сообщений).

Тестирование.
Модуль Spring-test предоставляет макет реализации ServerHttpRequest, «ServerHttpResponse» и «ServerWebExchange».
См.
Spring Web Reactive для обсуждение макетов объектов.
Тестирование. объекты ответа для обеспечения поддержки тестирования приложений WebFlux без HTTP сервер.
Вы также можете использовать WebTestClient для комплексных интеграционных тестов.

Управление версиями API.
Spring WebFlux поддерживает управление версиями API.
В этом разделе представлен обзор поддержки и лежащие в основе стратегии.
- Настройте ссылку:web/webflux/config.adoc#webflux-config-api-version[версии API]
- Запросы карты
- Запросы маршрутизации
к функциональным конечным точкам с версией API.
Поддержка клиента для управления версиями API доступна также в RestClient, WebClient и для тестирования в `WebTestClient`.
ApiVersionStrategy.
Это центральная стратегия управления версиями API, которая сохраняет все настроенные предпочтения. связанные с управлением версиями.
Он делает следующее:
- Разрешает версии из запросов через ApiVersionResolver
- Анализирует необработанные значения версии в `Comparable<?>` с помощью ApiVersionParser
- Проверяет версии запроса
ApiVersionStrategy помогает сопоставлять запросы с методами контроллера @RequestMapping. и инициализируется конфигурацией WebFlux.
Обычно приложения не взаимодействуют непосредственно с ним.
Апиверсионрезольвер.
Эта стратегия определяет версию API из запроса.
Конфигурация WebFlux предоставляет встроенный параметры для разрешения из заголовка, параметра запроса, параметра типа носителя, или из URL-пути.
Вы также можете использовать собственный ApiVersionResolver.
Апиверсионрезольвер.
ПРИМЕЧАНИЕ.
Сопоставитель пути всегда разрешает версию из указанного сегмента пути или в противном случае вызывает InvalidApiVersionException, и поэтому он не может уступить место другим резольверы.
ApiVersionParser.
Эта стратегия помогает анализировать необработанные значения версий в `Comparable<?>`, что помогает сравнивайте, сортируйте и выбирайте версии.

По умолчанию встроенный SemanticApiVersionParser. анализирует версию на целочисленные значения `major`, `minor` и `patWebFluxch`.
Минор и патч значения устанавливаются на 0, если они отсутствуют.
Валидация.
Если версия запроса не поддерживается, возникает исключение InvalidApiVersionException. в ответе 400.
По умолчанию список поддерживаемых версий инициализируется из объявленного версии в аннотированных сопоставлениях контроллеров, но вы можете отключить это с помощью флага в WebFlux и используйте только версии, явно настроенные в конфигурации.
Валидация.
По умолчанию версия требуется, если включено управление версиями API.
Вызывается MissingApiVersionException, что приводит к ответу 400, если его нет.
Вы можете сделать его необязательным, и в этом случае будет использоваться самая последняя версия.
Вы также можете указать версию по умолчанию для использования.
ApiVersionDeprecationHandler.
Эту стратегию можно настроить на отправку подсказок и информации об устаревших версиях клиентов через заголовки ответов.
Встроенный `StandardApiVersionDeprecationHandler` можно установить заголовки «Устаревание», «Закат» и «Ссылка», как определено в https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].
Вы также можете настроить индивидуальный обработчик для разных заголовков.
Запросить сопоставление. `ApiVersionStrategy` поддерживает сопоставление запросов с аннотированными методами контроллера.

См. ссылку:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-version[Версии API] для более подробной информации.

Посмотреть технологии.
Рендеринг представлений в Spring WebFlux является подключаемым.
Если вы решите использование Thymeleaf, FreeMarker или какой-либо другой технологии просмотра — это, прежде всего, вопрос изменение конфигурации.
В этой главе рассматриваются технологии представления, интегрированные со Spring.
ВебФлюкс.
Посмотреть технологии.
Дополнительную информацию о рендеринге представления см. в Разрешение просмотра.
Посмотреть технологии.
ВНИМАНИЕ: представления приложения Spring WebFlux находятся внутри внутренних границ доверия. приложения.
Представления имеют доступ к компонентам в контексте приложения, и, поскольку поэтому мы не рекомендуем использовать поддержку шаблонов Spring WebFlux в приложениях, где шаблоны доступны для редактирования из внешних источников, поскольку это может иметь последствия для безопасности.
Тимелиф.
Thymeleaf — это современный серверный механизм шаблонов Java, который подчеркивает естественный HTML. шаблоны, которые можно просмотреть в браузере двойным щелчком мыши, что очень удобно. полезно для самостоятельной работы над шаблонами пользовательского интерфейса (например, дизайнером) без необходимости работающий сервер.
Thymeleaf предлагает обширный набор функций и активно развивается. и поддерживается.
Более полное введение см. https://www.thymeleaf.org/Домашняя страница проекта [Thymeleaf].
Тимелиф.
Интеграция Thymeleaf с Spring WebFlux управляется проектом Thymeleaf. конфигурация включает в себя несколько объявлений bean-компонентов, таких как SpringResourceTemplateResolver, SpringWebFluxTemplateEngine и `ThymeleafReactiveViewResolver`.

Более подробную информацию см. https://www.thymeleaf.org/documentation.html[Thymeleaf+Spring] и интеграция WebFlux https://web.archive.org/web/20210623051330/http%3A//forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html[объявление].
FreeMarker. https://freemarker.apache.org/[Apache FreeMarker] — это шаблонизатор для создания любых вид вывода текста из HTML на электронную почту и другие.
Spring Framework имеет встроенный интеграция для использования Spring WebFlux с шаблонами FreeMarker.
Просмотр конфигурации.
В следующем примере показано, как настроить FreeMarker в качестве технологии просмотра:
Java
	@Configuration
	public class WebConfiguration implements WebFluxConfigurer {
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();
		// Настроить FreeMarker...
		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("classpath:/templates/freemarker");
			return configurer;
	@Configuration
	class WebConfiguration : WebFluxConfigurer {
		// Настроить FreeMarker...
Просмотр конфигурации.
Ваши шаблоны должны храниться в каталоге, указанном в `FreeMarkerConfigurer`. показано в предыдущем примере.

Учитывая предыдущую конфигурацию, если ваш контроллер возвращает имя представления, `добро пожаловать`, преобразователь ищет `classpath:/templates/freemarker/welcome.ftl` шаблон.
Конфигурация FreeMarker.
Вы можете передать «Настройки» и «SharedVariables» FreeMarker непосредственно во FreeMarker.
Объект `Configuration` (который управляется Spring), установив соответствующий bean-компонент свойства bean-компонента FreeMarkerConfigurer.
Для свойства freemarkerSettings требуется объект `java.util.Properties`, а свойство `freemarkerVariables` требует `java.util.Map`.
В следующем примере показано, как использовать FreeMarkerConfigurer:
Java
	@Configuration
	public class WebConfiguration implements WebFluxConfigurer {
		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			Map<String, Object> variables = new HashMap<>();
			variables.put("xml_escape", new XmlEscape());
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("classpath:/templates");
			configurer.setFreemarkerVariables(variables);
			return configurer;
	@Configuration
	class WebConfiguration : WebFluxConfigurer {
Конфигурация FreeMarker.
Подробную информацию о настройках и переменных см. в документации FreeMarker. объект «Конфигурация».
Обработка формы.
Spring предоставляет библиотеку тегов для использования в JSP, которая содержит, среди прочего, Элемент `<spring:bind/>`.

Этот элемент в первую очередь позволяет формам отображать значения из объекты поддержки формы и отображать результаты неудачных проверок со стороны «Валидатора» в веб- или бизнес-уровень.
Spring также поддерживает ту же функциональность в FreeMarker. с дополнительными удобными макросами для генерации самих элементов ввода формы.
Макросы привязки.
Стандартный набор макросов поддерживается в файле Spring-webflux.jar для FreeMarker, поэтому они всегда доступны для соответствующим образом настроенного приложения.
Макросы привязки.
Некоторые макросы, определенные в библиотеках шаблонов Spring, считаются внутренними. (частный), но в определениях макросов такой области действия не существует, что делает все макросы видимыми. к вызывающему коду и пользовательским шаблонам.
Следующие разделы посвящены только макросам. вам нужно напрямую позвонить из ваших шаблонов.
Если вы хотите просмотреть код макроса напрямую, файл называется `spring.ftl` и находится в папке Пакет `org.springframework.web.reactive.result.view.freemarker`.
Макросы привязки.
Дополнительные сведения о поддержке привязки см. в статье Simple Binding. для Spring MVC.
Формировать макросы.
Подробную информацию о поддержке макросов форм Spring для шаблонов FreeMarker см. по следующему адресу. разделы документации Spring MVC.
* Входные макросы
* Поля ввода
* Поля выбора
* Эскейпирование HTML
Представления сценариев.
Spring Framework имеет встроенную интеграцию для использования Spring WebFlux с любыми библиотека шаблонов, которая может работать поверх {JSR}223[JSR-223] Механизм сценариев Java.

В следующей таблице показаны библиотеки шаблонов, которые мы тестировали на различных механизмах сценариев:
Представления сценариев. [%заголовок] |=== |Библиотека сценариев |Скриптовый механизм |https://docs.ruby-lang.org/en/master/ERB.html[ERB] |https://www.jruby.org[JRuby] |https://docs.python.org/2/library/string.html#template-strings[Шаблоны строк] |https://www.jython.org/[Jython] |===
Представления сценариев.
СОВЕТ: Основное правило интеграции любого другого механизма сценариев заключается в том, что он должен реализовать Интерфейсы `ScriptEngine` и `Invocable`.
Требования.
Вам необходимо иметь механизм сценариев в вашем пути к классам, детали которого зависят от механизма сценариев:
* https://www.jruby.org[JRuby] следует добавить в качестве зависимости для поддержки Ruby.
* https://www.jython.org[Jython] следует добавить в качестве зависимости для поддержки Python.
Шаблоны сценариев.
Вы можете объявить bean-компонент `ScriptTemplateConfigurer`, чтобы указать используемый механизм сценариев: файлы сценариев для загрузки, какую функцию вызывать для рендеринга шаблонов и т. д.
В следующем примере используется движок Jython Python:
Java
	@Configuration
	public class WebConfiguration implements WebFluxConfigurer {
		@Override

public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.scriptTemplate();
		@Bean
		public ScriptTemplateConfigurer configurer() {
			ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
			configurer.setEngineName("jython");
			configurer.setScripts("render.py");
			configurer.setRenderFunction("render");
			return configurer;
	@Configuration
	class WebConfiguration : WebFluxConfigurer {
* `Шаблон строки`: содержимое шаблона.
* `Модель карты`: модель представления.
* `RenderingContext renderingContext`:
Функция рендеринга вызывается со следующими параметрами:. {spring-framework-api}/web/servlet/view/script/RenderingContext.html[`RenderingContext`] который предоставляет доступ к контексту приложения, локали, загрузчику шаблонов и URL-адрес
Функция рендеринга вызывается со следующими параметрами:.
Ознакомьтесь с модульными тестами Spring Framework, {spring-framework-code}/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script[Java] и {spring-framework-code}/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script[resources], дополнительные примеры конфигурации.

HTML-фрагмент. https://htmx.org/[HTMX] и https://turbo.hotwired.dev/[Hotwire Turbo] подчеркивают Подход «HTML по сети», при котором клиенты получают обновления сервера в формате HTML, а не в формате JSON.
Это позволяет использовать преимущества SPA (одностраничного приложения) без необходимости писать много или даже любой JavaScript.
Для получения хорошего обзора и получения дополнительной информации посетите соответствующие веб-сайты.
HTML-фрагмент.
В Spring WebFlux рендеринг представления обычно включает указание одного представления и одной модели.
Однако в HTML-по-проводной связи общей возможностью является отправка нескольких фрагментов HTML, которые браузер может использовать для обновления различных частей страницы.
Для этого методы контроллера может вернуть `Collection<Fragment>`.
Например:
Java
	@GetMapping
	List<Fragment> handle() {
		return List.of(Fragment.create("posts"), Fragment.create("comments"));
Java
	@GetMapping
	FragmentsRendering handle() {
		return FragmentsRendering.fragment("posts").fragment("comments").build();
То же самое можно сделать, вернув выделенный тип FragmentsRendering:.
Каждый фрагмент может иметь независимую модель, и эта модель наследует атрибуты от общая модель для запроса.
То же самое можно сделать, вернув выделенный тип FragmentsRendering:.

HTMX и Hotwire Turbo поддерживают потоковую передачу обновлений через SSE (события, отправляемые сервером).
Контроллер может создать FragmentsRendering с помощью Flux<Fragment> или любого другого реактивный производитель, адаптируемый к «Издателю» Reactive Streams через «ReactiveAdapterRegistry».
Также возможно вернуть Flux<Fragment> напрямую без FragmentsRendering. обертка.
JSON и XML.
Для ссылки:web/webflux/dispatcher-handler.adoc#webflux-multiple-representations[Согласование контента] Для целей полезно иметь возможность чередовать рендеринг модели с помощью HTML-шаблона. или в других форматах (например, JSON или XML), в зависимости от типа контента, запрошенного клиентом.
Для поддержки этого Spring WebFlux предоставляет HttpMessageWriterView, который вы можете использовать для подключите любой из доступных Codecs из «spring-web», например «JacksonJsonEncoder», «JacksonSmileEncoder» или «Jaxb2XmlEncoder».
JSON и XML.
В отличие от других технологий просмотра, HttpMessageWriterView не требует ViewResolver, но вместо этого в качестве представления по умолчанию используется настроено.
Вы можете настроить одно или несколько таких представлений по умолчанию, обернув разные экземпляры HttpMessageWriter. или экземпляры `Encoder`.
Тот, который соответствует запрошенному типу контента, используется во время выполнения.
JSON и XML.
В большинстве случаев модель содержит несколько атрибутов.
Чтобы определить, какой из них сериализовать, вы можете настроить HttpMessageWriterView с именем атрибута модели, который будет использоваться для рендеринг.

Если модель содержит только один атрибут, используется именно он.

Веб-клиент.
Spring WebFlux включает клиент для выполнения HTTP-запросов. `WebClient` имеет функциональный, свободный API на основе Reactor (см.
Reactive Libraries) что позволяет декларативную композицию асинхронной логики без необходимости иметь дело с потоки или параллелизм.
Он полностью неблокирующий, поддерживает потоковую передачу и опирается на те же ссылки:web/webflux/reactive-spring.adoc#webflux-codecs[кодеки], которые также используются для кодирования и декодировать содержимое запроса и ответа на стороне сервера.
Веб-клиент. `WebClient` нуждается в клиентской библиотеке HTTP для выполнения запросов.
Есть встроенный поддержка следующего:
* {reactor-github-org}/reactor-netty[Reactor Netty]
* {java-api}/java.net.http/java/net/http/HttpClient.html[JDK HttpClient]
* Jetty Reactive HttpClient: https://github.com/jetty-project/jetty-reactive-httpclient
* https://hc.apache.org/index.html[Apache HttpComponents]
* Остальные можно подключить через ClientHttpConnector.

Вебсокеты.
В этой части справочной документации рассматривается поддержка WebSocket с реактивным стеком. обмен сообщениями.
API веб-сокетов.
Spring Framework предоставляет API WebSocket, который можно использовать для написания клиентских и серверные приложения, обрабатывающие сообщения WebSocket.
Сервер.
Чтобы создать сервер WebSocket, вы можете сначала создать WebSocketHandler.
В следующем примере показано, как это сделать:
Java
	import org.springframework.web.reactive.socket.WebSocketHandler;
	import org.springframework.web.reactive.socket.WebSocketSession;
	public class MyWebSocketHandler implements WebSocketHandler {
		@Override
		public Mono<Void> handle(WebSocketSession session) {
	class MyWebSocketHandler : WebSocketHandler {
Java
	@Configuration
	class WebConfig {
		@Bean
		public HandlerMapping handlerMapping() {
			Map<String, WebSocketHandler> map = new HashMap<>();
			map.put("/path", new MyWebSocketHandler());
			int order = -1; // before annotated controllers
			return new SimpleUrlHandlerMapping(map, order);
	@Configuration
	class WebConfig {
			return SimpleUrlHandlerMapping(map, order)
Затем вы можете сопоставить его с URL-адресом:.
При использовании WebFlux Config ничего не происходит. что делать дальше, или иначе, если вы не используете конфигурацию WebFlux, вам нужно будет объявить `WebSocketHandlerAdapter`, как показано ниже:
Java
	@Configuration
	class WebConfig {
		@Bean
		public WebSocketHandlerAdapter handlerAdapter() {
			return new WebSocketHandlerAdapter();
	@Configuration

class WebConfig {
`WebSocketHandler`.
Метод handle объекта WebSocketHandler принимает WebSocketSession и возвращает Mono<Void>. чтобы указать, когда обработка сеанса приложением завершена.
Сессия обрабатывается через два потока: один для входящих и один для исходящих сообщений.
Следующая таблица описывает два метода, которые обрабатывают потоки:
[options="заголовок"] |=== | Метод `WebSocketSession` | Описание. | `Flux<WebSocketMessage> get()` | Предоставляет доступ к потоку входящих сообщений и завершается при закрытии соединения.
[options="заголовок"] |=== | Метод `WebSocketSession` | Описание. | `Mono<Void> send(Publisher<WebSocketMessage>)` | Берет источник исходящих сообщений, записывает сообщения и возвращает `Mono<Void>`, который завершается, когда исходный код завершается и запись завершается.
[options="заголовок"] |=== | Метод `WebSocketSession` | Описание. `WebSocketHandler` должен объединить входящие и исходящие потоки в единый поток и верните `Mono<Void>`, который отражает завершение этого потока.
В зависимости от применения требований, единый поток завершается, когда:
* Завершается либо входящий, либо исходящий поток сообщений.
* Входящий поток завершается (то есть соединение закрывается), а исходящий поток бесконечен.
* В выбранной точке с помощью метода close метода WebSocketSession.

[options="заголовок"] |=== | Метод `WebSocketSession` | Описание.
Когда потоки входящих и исходящих сообщений объединены вместе, нет необходимости проверьте, открыто ли соединение, поскольку Reactive Streams сигнализирует о завершении активности.
Входящий поток получает сигнал завершения или ошибки, а исходящий поток получает сигнал отмены.
[options="заголовок"] |=== | Метод `WebSocketSession` | Описание.
Самая базовая реализация обработчика — это та, которая обрабатывает входящий поток. следующий пример показывает такую реализацию:
Java
	class ExampleHandler implements WebSocketHandler {
		@Override
		public Mono<Void> handle(WebSocketSession session) {
			return session.receive()			// <1>
					.doOnNext(message -> {
						// ...					// <2>
					.concatMap(message -> {
						// ...					// <3>
					.then();					// <4>
[options="заголовок"] |=== | Метод `WebSocketSession` | Описание. <1> Доступ к потоку входящих сообщений. <2> Сделайте что-нибудь с каждым сообщением. <3> Выполнять вложенные асинхронные операции, использующие содержимое сообщения. <4> Возвращает `Mono<Void>`, который завершается после завершения приема.
	class ExampleHandler : WebSocketHandler {

[options="заголовок"] |=== | Метод `WebSocketSession` | Описание. <1> Доступ к потоку входящих сообщений. <2> Сделайте что-нибудь с каждым сообщением. <3> Выполнять вложенные асинхронные операции, использующие содержимое сообщения. <4> Возвращает `Mono<Void>`, который завершается после завершения приема.
[options="заголовок"] |=== | Метод `WebSocketSession` | Описание.
СОВЕТ: Для вложенных асинхронных операций вам может потребоваться вызвать `message.retain()` на базовом уровне. серверы, использующие объединенные буферы данных (например, Netty).
В противном случае буфер данных может быть выпущен до того, как вы успели прочитать данные.
Дополнительную информацию см.
Java
	class ExampleHandler implements WebSocketHandler {
		@Override
		public Mono<Void> handle(WebSocketSession session) {
			Flux<WebSocketMessage> output = session.receive()				// <1>
					.doOnNext(message -> {
					.concatMap(message -> {
					.map(value -> session.textMessage("Echo " + value));	// <2>
			return session.send(output);									// <3>

Следующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Создайте исходящее сообщение, создав комбинированный поток. <3> Возвращает `Mono<Void>`, который не завершается, пока мы продолжаем получать.
	class ExampleHandler : WebSocketHandler {
			return session.send(output)							// <3>
Следующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Создайте исходящее сообщение, создав комбинированный поток. <3> Возвращает `Mono<Void>`, который не завершается, пока мы продолжаем получать.
Следующая реализация объединяет входящие и исходящие потоки:.
Входящие и исходящие потоки могут быть независимыми и объединяться только для завершения. как показано в следующем примере:
Java
	class ExampleHandler implements WebSocketHandler {
		@Override
		public Mono<Void> handle(WebSocketSession session) {
			Mono<Void> input = session.receive()								<1>
					.doOnNext(message -> {
					.concatMap(message -> {
					.then();
			Flux<String> source = ... ;
			Mono<Void> output = session.send(source.map(session::textMessage));	<2>
			return input.and(output);											<3>

Следующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Отправка исходящих сообщений. <3> Объедините потоки и верните `Mono<Void>`, который завершится, когда любой из потоков закончится.
	class ExampleHandler : WebSocketHandler {
			return input.and(output)										// <3>
Следующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Отправка исходящих сообщений. <3> Объедините потоки и верните `Mono<Void>`, который завершится, когда любой из потоков закончится.
`Буфер данных`. `DataBuffer` — это представление байтового буфера в WebFlux.
Часть Spring Core в ссылке есть дополнительная информация об этом в разделе, посвященном на таких серверах, как Netty, байтовые буферы объединяются в пул, подсчитываются ссылки и должны быть освобождены. при потреблении, чтобы избежать утечек памяти.
`Буфер данных`.
При работе на Netty приложения должны использовать DataBufferUtils.retain(dataBuffer), если они хотите сохранить буферы входных данных, чтобы гарантировать, что они не будут освобождены, и впоследствии используйте `DataBufferUtils.release(dataBuffer)`, когда буферы будут использованы.
Рукопожатие. `WebSocketHandlerAdapter` делегирует `WebSocketService`.
По умолчанию это экземпляр HandshakeWebSocketService, который выполняет базовые проверки запроса WebSocket и затем использует RequestUpgradeStrategy для используемого сервера.

На данный момент имеется встроенный поддержка Reactor Netty, Tomcat и Jetty.
Рукопожатие.
HandshakeWebSocketService предоставляет свойство sessionAttributePredicate, которое позволяет установка `Predicate<String>` для извлечения атрибутов из `WebSession` и вставки их в атрибуты WebSocketSession.
Конфигурация сервера. `RequestUpgradeStrategy` для каждого сервера предоставляет конфигурацию, специфичную для базовый механизм сервера WebSocket.
При использовании конфигурации Java WebFlux вы можете настроить такие свойства, как показано в соответствующем разделе не используя конфигурацию WebFlux, используйте следующее:
Java
	@Configuration
	class WebConfig {
		@Bean
		public WebSocketHandlerAdapter handlerAdapter() {
			return new WebSocketHandlerAdapter(webSocketService());
		@Bean
		public WebSocketService webSocketService() {
			TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
			strategy.setMaxSessionIdleTimeout(0L);
			return new HandshakeWebSocketService(strategy);
	@Configuration
	class WebConfig {
Конфигурация сервера.
Проверьте стратегию обновления вашего сервера, чтобы узнать, какие варианты доступны.
В настоящее время только Tomcat и Jetty предоставляют такие возможности.
КОРС.
Самый простой способ настроить CORS и ограничить доступ к конечной точке WebSocket — это пусть ваш WebSocketHandler реализует CorsConfigurationSource и возвращает `CorsConfiguration` с разрешенными источниками, заголовками и другими деталями.
Если вы не можете сделать то вы также можете установить для свойства corsConfigurations в SimpleUrlHandler значение укажите настройки CORS по шаблону URL.
Если указаны оба, они объединяются с помощью метод объединения в CorsConfiguration.
Клиент.

Spring WebFlux предоставляет абстракцию WebSocketClient с реализациями для Reactor Netty, Tomcat, Jetty и стандартная Java (то есть JSR-356).
Клиент.
ПРИМЕЧАНИЕ.
Клиент Tomcat по сути является расширением стандартного Java-клиента с некоторыми дополнительными возможностями. функциональность в обработке `WebSocketSession`, чтобы воспользоваться преимуществами специфичной для Tomcat API для приостановки получения сообщений из-за противодавления.
Клиент.
Чтобы запустить сеанс WebSocket, вы можете создать экземпляр клиента и использовать его команду «execute». методы:
Java
	WebSocketClient client = new ReactorNettyWebSocketClient();
	URI url = new URI("ws://localhost:8080/path");
	client.execute(url, session ->
			session.receive()
					.doOnNext(System.out::println)
					.then());
Клиент.
Некоторые клиенты, такие как Jetty, реализуют «жизненный цикл», и их необходимо останавливать и запускать. прежде чем вы сможете их использовать.
У всех клиентов есть параметры конструктора, связанные с конфигурацией. базового клиента WebSocket.

Весенний WebFlux.
Исходная веб-платформа, включенная в Spring Framework, Spring Web MVC, была специально созданный для API сервлетов и контейнеров сервлетов.
Веб-фреймворк реактивного стека, Spring WebFlux был добавлен позже в версии 5.0.
Он полностью неблокирующий, поддерживает {reactive-streams-site}/[Reactive Streams] обратное давление и работает на таких серверах, как Контейнеры Netty и Servlet.
Весенний WebFlux.
Обе веб-платформы отражают имена своих исходных модулей. ({spring-framework-code}/spring-webmvc[spring-webmvc] и {spring-framework-code}/spring-webflux[spring-webflux]) и сосуществовать бок о бок в Весенний фреймворк.
Каждый модуль является дополнительным.
Приложения могут использовать тот или иной модуль или, в некоторых случаях и то, и другое — например, контроллеры Spring MVC с реактивным WebClient.

REST-клиенты.
В этом разделе описаны параметры клиентского доступа к конечным точкам REST.
`РестКлиент`.
RestClient — это синхронный HTTP-клиент, предоставляющий современный гибкий API.
`РестКлиент`.
Дополнительную информацию см. в `RestClient`.
`Вебклиент`. «WebClient» — это реактивный клиент для выполнения HTTP-запросов с помощью гибкого API.
`Вебклиент`.
Дополнительную информацию см. в `WebClient`.
`RestTemplate`.
RestTemplate — это синхронный клиент для выполнения HTTP-запросов.
Это оригинал Spring REST-клиент и предоставляет простой API-интерфейс шаблонного метода поверх базового HTTP-клиента. библиотеки.
`RestTemplate`.
Подробности см. в `RestTemplate`.
HTTP-клиент службы.
Spring Framework позволяет определить службу HTTP как интерфейс Java с HTTP. методы обмена.
Затем вы можете создать прокси, реализующий этот интерфейс, и осуществляет обмены.
Это помогает упростить удаленный доступ по HTTP и предоставляет дополнительные возможности. гибкость выбора стиля API, например синхронного или реактивного.
HTTP-клиент службы.
Подробности см. в клиент службы HTTP.

КОРС.
Spring MVC позволяет обрабатывать CORS (совместное использование ресурсов между источниками).
Этот раздел описывает, как это сделать.
Введение.
По соображениям безопасности браузеры запрещают вызовы AJAX к ресурсам за пределами текущего источника.
Например, ваш банковский счет может находиться на одной вкладке, а сайт evil.com — на другой.
Скрипты от evil.com не должен иметь возможности отправлять AJAX-запросы к API вашего банка с помощью вашего учетные данные — например, снятие денег со своего счета!
Введение.
Совместное использование ресурсов между источниками (CORS) — это https://www.w3.org/TR/cors/[спецификация W3C] реализовано https://caniuse.com/#feat=cors[большинством браузеров], что позволяет вам указать какие междоменные запросы разрешены, вместо использования менее безопасных и менее мощные обходные пути на основе IFRAME или JSONP.
Сертифицированные запросы.
Использование CORS с запросами с учетными данными требует включения `allowedCredentials`.
Имейте в виду, что эта опция устанавливает высокий уровень доверия с настроенными доменами, а также увеличивает поверхность атаки веб-приложения путем раскрытия конфиденциальной информации, специфичной для пользователя такие как файлы cookie и токены CSRF.
Сертифицированные запросы.
Включение учетных данных также влияет на обработку настроенных подстановочных знаков `"*"` CORS:
* Подстановочные знаки не разрешены в `allowOrigins`, но альтернативно
Сертифицированные запросы.

СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.
* Если установлено значение `allowedHeaders` или `allowedMethods`, `Access-Control-Allow-Headers`
Сертифицированные запросы. и заголовки ответов `Access-Control-Allow-Methods` обрабатываются путем копирования связанных заголовки и метод, указанные в предполетном запросе CORS.
* Если установлено значение `exposeHeaders`, устанавливается заголовок ответа `Access-Control-Expose-Headers`.
Сертифицированные запросы. либо к настроенному списку заголовков, либо к подстановочному знаку.
Хотя спецификация CORS не разрешает использование подстановочного знака, если для параметра «Access-Control-Allow-Credentials» установлено значение `true`, большинство браузеров поддерживают его, и не все заголовки ответов доступны во время Обработка CORS, поэтому подстановочный знак является значением заголовка, используемым при указывается независимо от значения свойстваallowCredentials.
Сертифицированные запросы.
ВНИМАНИЕ: Хотя такая конфигурация с подстановочными знаками может быть удобной, рекомендуется, если это возможно, настроить вместо этого используется конечный набор значений для обеспечения более высокого уровня безопасности.
Обработка.
Спецификация CORS различает предполетные, простые и фактические запросы.
Чтобы узнать, как работает CORS, вы можете прочитать https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[эта статья], среди многие другие или см. спецификацию для получения более подробной информации.
Обработка.
Реализации Spring MVC HandlerMapping предоставляют встроенную поддержку CORS.

После успешного сопоставление запроса с обработчиком, реализации HandlerMapping проверяют конфигурацию CORS на наличие данный запрос и обработчик и предпринять дальнейшие действия.
Предполетные запросы обрабатываются напрямую, в то время как простые и актуальные запросы CORS перехватываются, проверяются и обрабатываются. установлен требуемый набор заголовков ответа CORS.
Обработка.
Чтобы включить запросы между источниками (то есть заголовок «Origin» присутствует и отличается от хоста запроса), вам необходимо иметь явно объявленный CORS. конфигурация.
Если соответствующая конфигурация CORS не найдена, заголовки CORS не добавляются. ответы на предполетные, простые и актуальные запросы CORS и, следовательно, браузеры отвергнуть их.
Обработка.
Каждое HandlerMapping может быть {spring-framework-api}/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations(java.util.Map)[настроено] индивидуально с сопоставлениями CorsConfiguration на основе шаблонов URL.
В большинстве случаев приложения используйте конфигурацию MVC Java или пространство имен XML для объявления таких сопоставлений, что приводит к в одной глобальной карте, передаваемой всем экземплярам HandlerMapping.
Обработка.
Вы можете комбинировать глобальную конфигурацию CORS на уровне HandlerMapping с другими детальная конфигурация CORS на уровне обработчика.
Например, аннотированные контроллеры могут использовать Аннотации `@CrossOrigin` на уровне класса или метода (другие обработчики могут реализовать `CorsConfigurationSource`).
Обработка.
Правила объединения глобальной и локальной конфигурации обычно аддитивны, например: все глобальное и все локальное происхождение.

Для тех атрибутов, где может быть указано только одно значение принимаются, например, `allowCredentials` и `maxAge`, локальное значение переопределяет глобальное значение.
См. {spring-framework-api}/web/cors/CorsConfiguration.html#combine(org.springframework.web.cors.CorsConfiguration)[`CorsConfiguration#combine(CorsConfiguration)`] для более подробной информации.
Обработка. [СОВЕТ] = Чтобы узнать больше из исходного кода или выполнить расширенные настройки, проверьте код:
* `КорсКонфигурация`
* `CorsProcessor`, `DefaultCorsProcessor`
* `AbstractHandlerMapping`
`@CrossOrigin`. {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`] аннотация позволяет выполнять запросы между источниками к аннотированным методам контроллера, как показано в следующем примере:
Java
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@CrossOrigin
		@GetMapping("/{id}")
		public Account retrieve(@PathVariable Long id) {
		@DeleteMapping("/{id}")
		public void remove(@PathVariable Long id) {
	@RestController
	@RequestMapping("/account")
	class AccountController {
* Все происхождение.
* Все заголовки.
* Все методы HTTP, с которыми сопоставлен метод контроллера.

По умолчанию @CrossOrigin позволяет:. `allowCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.
Когда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `"*"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.
По умолчанию @CrossOrigin позволяет:. `maxAge` установлен на 30 минут.
По умолчанию @CrossOrigin позволяет:. `@CrossOrigin` также поддерживается на уровне класса и наследуется всеми методами. как показано в следующем примере:
Java
По умолчанию @CrossOrigin позволяет:. @CrossOrigin(origins = "https://domain2.com", maxAge = 3600) @RestController @RequestMapping("/account") public class AccountController {
	@GetMapping("/{id}")
	public Account retrieve(@PathVariable Long id) {
	@DeleteMapping("/{id}")
	public void remove(@PathVariable Long id) {
	@CrossOrigin(origins = ["https://domain2.com"], maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	class AccountController {
По умолчанию @CrossOrigin позволяет:.

Вы можете использовать @CrossOrigin как на уровне класса, так и на уровне метода. как показано в следующем примере:
Java
	@CrossOrigin(maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	public class AccountController {
		@CrossOrigin("https://domain2.com")
		@GetMapping("/{id}")
		public Account retrieve(@PathVariable Long id) {
		@DeleteMapping("/{id}")
		public void remove(@PathVariable Long id) {
	@CrossOrigin(maxAge = 3600)
	@RestController
	@RequestMapping("/account")
	class AccountController {
Глобальная конфигурация.
В дополнение к детальной настройке уровня метода контроллера вы, вероятно, захотите также определите некоторую глобальную конфигурацию CORS.
Вы можете установить CorsConfiguration на основе URL-адреса. сопоставления индивидуально для любого HandlerMapping.
Однако большинство приложений используют Конфигурация MVC Java или пространство имен MVC XML для этого.
* Все происхождение.
* Все заголовки.
* Методы GET, HEAD и POST.
По умолчанию глобальная конфигурация позволяет следующее:. `allowCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.

Когда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `"*"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.
По умолчанию глобальная конфигурация позволяет следующее:. `maxAge` установлен на 30 минут.
По умолчанию глобальная конфигурация позволяет следующее:.
Вы можете включить CORS в конфигурации Spring MVC, как показано в следующем примере: См. пример кода в исходном документе.
КОРС-фильтр.
Вы можете применить поддержку CORS через встроенный {spring-framework-api}/web/filter/CorsFilter.html[`CorsFilter`].
КОРС-фильтр.
ПРИМЕЧАНИЕ.
Если вы попытаетесь использовать CorsFilter с Spring Security, имейте в виду, что Spring Безопасность имеет {docs-spring-security}/servlet/integrations/cors.html[встроенную поддержку] для КОРС.
КОРС-фильтр.
Чтобы настроить фильтр, передайте CorsConfigurationSource его конструктору, поскольку следующий пример показывает:
Java
	CorsConfiguration config = new CorsConfiguration();
	// Возможно...
	// config.applyPermitDefaultValues()
	config.setAllowCredentials(true);
	config.addAllowedOrigin("https://domain1.com");
	config.addAllowedHeader("*");
	config.addAllowedMethod("*");
	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();

source.registerCorsConfiguration("/**", config);
	CorsFilter filter = new CorsFilter(source);
	// Возможно...
	// config.applyPermitDefaultValues()
	config.allowCredentials = true
	config.addAllowedOrigin("https://domain1.com")
	config.addAllowedHeader("*")
	config.addAllowedMethod("*")

Функциональные конечные точки.
Spring Web MVC включает WebMvc.fn, облегченную модель функционального программирования, в которой функции используются для маршрутизации и обработки запросов, а контракты разработаны с учетом неизменяемости.
Это альтернатива модели программирования на основе аннотаций, но в остальном она работает на тот же DispatcherServlet.
Обзор.
В WebMvc.fn HTTP-запрос обрабатывается с помощью HandlerFunction: функции, которая принимает `ServerRequest` и возвращает `ServerResponse`.
И объект запроса, и объект ответа имеют неизменяемые контракты, которые обеспечивают совместимость с JDK 8. доступ к HTTP-запросу и ответу.
HandlerFunction — это эквивалент тела метода @RequestMapping в модель программирования на основе аннотаций.
Обзор.
Входящие запросы направляются в функцию-обработчик с помощью RouterFunction: функции, которая принимает `ServerRequest` и возвращает необязательную `HandlerFunction` (т. е. `Optional<HandlerFunction>`).
Когда функция маршрутизатора совпадает, возвращается функция-обработчик; в противном случае пустой Необязательный.
RouterFunction — это эквивалент аннотации @RequestMapping, но с основным Разница в том, что функции маршрутизатора предоставляют не только данные, но и поведение.
Обзор. `RouterFunctions.route()` предоставляет конструктор маршрутизаторов, который упрощает создание маршрутизаторов. как показано в следующем примере:
Java
	import static org.springframework.http.MediaType.APPLICATION_JSON;
	import static org.springframework.web.servlet.function.RequestPredicates.*;

import static org.springframework.web.servlet.function.RouterFunctions.route;
	PersonRepository repository = ...
	PersonHandler handler = new PersonHandler(repository);
	RouterFunction<ServerResponse> route = route() // <1>
		.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
		.GET("/person", accept(APPLICATION_JSON), handler::listPeople)
		.POST("/person", handler::createPerson)
		.build();
	public class PersonHandler {
		public ServerResponse listPeople(ServerRequest request) {
		public ServerResponse createPerson(ServerRequest request) {
		public ServerResponse getPerson(ServerRequest request) {
Обзор. <1> Создайте маршрутизатор с помощью `route()`.
Обзор. <1> Создайте маршрутизатор, используя DSL маршрутизатора.
Обзор.
Если вы зарегистрируете RouterFunction как компонент, например, выставив его в `@Configuration`, он будет автоматически обнаружен сервлетом, как описано в разделе
ОбработчикФункция. `ServerRequest` и `ServerResponse` — это неизменяемые интерфейсы, совместимые с JDK 8. доступ к HTTP-запросу и ответу, включая заголовки, тело, метод и код состояния.
Серверный запрос. `ServerRequest` обеспечивает доступ к методу HTTP, URI, заголовкам и параметрам запроса. в то время как доступ к телу предоставляется через методы body.
Java

String string = request.body(String.class);.
В следующем примере тело извлекается в `List<Person>`, где объекты Person декодируются из сериализованной формы, например JSON или XML:
Java
MultiValueMap<String, String> params = request.params();.
Ниже показано, как связать параметры запроса, переменные URI или заголовки с помощью DataBinder. а также показывает, как настроить DataBinder:
Java
Ответ сервера. `ServerResponse` обеспечивает доступ к HTTP-ответу, и, поскольку он неизменяем, вы можете использовать метод `build` для его создания.
Вы можете использовать конструктор, чтобы установить статус ответа, добавить ответ заголовки или предоставить тело.
В следующем примере создается ответ 200 (ОК) с JSON. содержание:
Java
Person person =...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);.
В следующем примере показано, как создать ответ 201 (CREATED) с заголовком Location и без тела:
Java
URI location =...
ServerResponse.created(location).build();.
Вы также можете использовать асинхронный результат в качестве тела в форме CompletableFuture. `Publisher` или любой другой тип, поддерживаемый `ReactiveAdapterRegistry`.
Например:
Java
URI location =...
ServerResponse.created(location).build();.

Mono<Person> person = webClient.get().retrieve().bodyToMono(Person.class); ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);
URI location =...
ServerResponse.created(location).build();.
Если не только тело, но и статус или заголовки основаны на асинхронном типе, вы можете использовать статический метод async для ServerResponse, который принимает `CompletableFuture<ServerResponse>`, `Publisher<ServerResponse>` или любой другой асинхронный тип, поддерживаемый ReactiveAdapterRegistry.
Например:
Java
URI location =...
ServerResponse.created(location).build();.
Mono<ServerResponse> asyncResponse = webClient.get().retrieve().bodyToMono(Person.class).map(p -> ServerResponse.ok().header("Name", p.name()).body(p)); ServerResponse.async(asyncResponse);
URI location =...
ServerResponse.created(location).build();. https://html.spec.whatwg.org/multipage/server-sent-events.html[Отправленные сервером события] можно предоставить через статический метод sse для ServerResponse.
Строитель, предоставленный этим методом позволяет отправлять строки или другие объекты в формате JSON.
Например:
Java

public RouterFunction<ServerResponse> sse() {
		return route(GET("/sse"), request -> ServerResponse.sse(sseBuilder -> {
					// Сохраняем где-нибудь объект sseBuilder..
	// В каком-то другом потоке отправка строки
	sseBuilder.send("Hello world");
	// Или объект, который будет преобразован в JSON
	Person person = ...
	sseBuilder.send(person);
	// Настраиваем событие, используя другие методы
	sseBuilder.id("42")
			.event("sse event")
			.data(person);
	// и сделано в какой-то момент
	sseBuilder.complete();
	// В каком-то другом потоке отправка строки
	sseBuilder.send("Hello world")
	// Настраиваем событие, используя другие методы
	sseBuilder.id("42")
			.event("sse event")
			.data(person)
	// и сделано в какой-то момент
	sseBuilder.complete()
Классы обработчиков.
Мы можем написать функцию-обработчик в виде лямбды, как показано в следующем примере:
Java
HandlerFunction<ServerResponse> helloWorld = request -> ServerResponse.ok().body("Hello World");.
Это удобно, но в приложении нам нужно несколько функций и несколько встроенных лямбда может запутаться.

Поэтому полезно сгруппировать связанные функции-обработчики в класс обработчиков, который имеет ту же роль, что и `@Controller` в приложении на основе аннотаций.
Например, следующий класс предоставляет реактивный репозиторий Person:
Java
HandlerFunction<ServerResponse> helloWorld = request -> ServerResponse.ok().body("Hello World");. import static org.springframework.http.MediaType.APPLICATION_JSON; import static org.springframework.web.reactive.function.server.ServerResponse.ok;
	private final PersonRepository repository;
	public PersonHandler(PersonRepository repository) {
		this.repository = repository;
	public ServerResponse listPeople(ServerRequest request) { // <1>
		List<Person> people = repository.allPeople();
		return ok().contentType(APPLICATION_JSON).body(people);
	public ServerResponse createPerson(ServerRequest request) throws Exception { // <2>
		Person person = request.body(Person.class);
		repository.savePerson(person);
		return ok().build();
	public ServerResponse getPerson(ServerRequest request) { // <3>
		int personId = Integer.parseInt(request.pathVariable("id"));
		Person person = repository.getPerson(personId);
		if (person != null) {
			return ok().contentType(APPLICATION_JSON).body(person);
		else {

return ServerResponse.notFound().build();
public class PersonHandler {. <1> `listPeople` — это функция-обработчик, которая возвращает все объекты `Person`, найденные в репозитории, в виде JSON. <2> `createPerson` — это функция-обработчик, которая сохраняет новое `Person`, содержащееся в теле запроса. <3> `getPerson` — это функция-обработчик, которая возвращает одного человека, идентифицируемого по пути `id`. переменная.
Мы извлекаем этого «Человека» из репозитория и создаем ответ JSON, если он есть. нашел.
Если он не найден, мы возвращаем ответ 404 Not Found.
Валидация.
Функциональная конечная точка может использовать Spring средства проверки для применить проверку к телу запроса.
Например, учитывая пользовательский Spring
Java
	public class PersonHandler {
		private final Validator validator = new PersonValidator(); // <1>
		public ServerResponse createPerson(ServerRequest request) {
			Person person = request.body(Person.class);
			validate(person); // <2>
			repository.savePerson(person);
			return ok().build();
		private void validate(Person person) {
			Errors errors = new BeanPropertyBindingResult(person, "person");
			validator.validate(person, errors);
			if (errors.hasErrors()) {

throw new ServerWebInputException(errors.toString()); // <3>
Валидация. <1> Создать экземпляр «Валидатора». <2> Применить проверку. <3> Вызов исключения для ответа 400.
Валидация.
Обработчики также могут использовать стандартный API проверки компонентов (JSR-303), создавая и внедряя глобальный экземпляр Validator, основанный на LocalValidatorFactoryBean.
См.
Spring Validation.
`RouterFunction`.
Функции маршрутизатора используются для маршрутизации запросов к соответствующей функции HandlerFunction.
Обычно вы не пишете функции маршрутизатора самостоятельно, а используете метод на Утилита RouterFunctions для его создания. `RouterFunctions.route()` (без параметров) предоставляет вам удобный конструктор для создания маршрутизатора. функция, тогда как RouterFunctions.route(RequestPredicate, HandlerFunction) предлагает прямой путь создать роутер.
`RouterFunction`.
Как правило, рекомендуется использовать построитель `route()`, поскольку он обеспечивает удобные ярлыки для типичных сценариев картографии, не требующие сложного обнаружения статический импорт.
Например, построитель функций маршрутизатора предлагает метод GET(String, HandlerFunction) создать сопоставление для GET-запросов; и POST(String, HandlerFunction) для POST.
`RouterFunction`.
Помимо сопоставления на основе HTTP-метода, построитель маршрутов предлагает способ введения дополнительных предикаты при сопоставлении с запросами.
Для каждого метода HTTP существует перегруженный вариант, который принимает RequestPredicate в качестве параметр, посредством которого могут быть выражены дополнительные ограничения.
Предикаты.

Вы можете написать свой собственный RequestPredicate, но служебный класс RequestPredicates предлагает встроенные возможности для общих нужд сопоставления на основе метода HTTP, запроса путь, заголовки, версия API и многое другое.
Java
	RouterFunction<ServerResponse> route = RouterFunctions.route()
		.GET("/hello-world", accept(MediaType.TEXT_PLAIN),
			request -> ServerResponse.ok().body("Hello World")).build();
* `RequestPredicate.and(RequestPredicate)` -- оба должны совпадать.
* `RequestPredicate.or(RequestPredicate)` — любой из них может совпадать.
Вы можете составить несколько предикатов запроса вместе, используя:.
Многие предикаты из RequestPredicates являются составными.
Например, RequestPredicates.GET(String)` состоит из RequestPredicates.method(HttpMethod)` и `RequestPredicates.path(String)`.
В приведенном выше примере также используются два предиката запроса, поскольку построитель использует `RequestPredicates.GET` внутренне и объединяет его с предикатом `accept`.
Маршруты.
Функции маршрутизатора оцениваются по порядку: если первый маршрут не совпадает, то оценивается второй и так далее.
Поэтому имеет смысл объявлять более конкретные маршруты перед общими.
Это также важно при регистрации функций маршрутизатора в качестве bean-компонентов Spring. быть описаны позже.

Обратите внимание, что это поведение отличается от модели программирования на основе аннотаций, где «Наиболее конкретный» метод контроллера выбирается автоматически.
Маршруты.
При использовании конструктора функций маршрутизатора все определенные маршруты объединяются в один. `RouterFunction`, возвращаемая из `build()`.
Существуют и другие способы объединения нескольких функций маршрутизатора:
* `add(RouterFunction)` в конструкторе `RouterFunctions.route()`
* `RouterFunction.and(RouterFunction)`
* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` -- ярлык для
Маршруты. `RouterFunction.and()` с вложенным `RouterFunctions.route()`.
Java
	import static org.springframework.http.MediaType.APPLICATION_JSON;
	import static org.springframework.web.servlet.function.RequestPredicates.*;
	PersonRepository repository = ...
	PersonHandler handler = new PersonHandler(repository);
	RouterFunction<ServerResponse> otherRoute = ...
	RouterFunction<ServerResponse> route = route()
		.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) // <1>
		.GET("/person", accept(APPLICATION_JSON), handler::listPeople) // <2>
		.POST("/person", handler::createPerson) // <3>
		.add(otherRoute) // <4>

.build();
В следующем примере показан состав четырех маршрутов:. <1> pass:q[`GET /person/{id}`] с заголовком `Accept`, который соответствует JSON, направляется на `PersonHandler.getPerson` <2> `GET /person` с заголовком `Accept`, соответствующим JSON, перенаправляется на `PersonHandler.listPeople` <3> `POST /person` без дополнительных предикатов сопоставляется с `PersonHandler.createPerson` и <4> `otherRoute` — это функция маршрутизатора, которая создается где-то еще и добавляется к построенному маршруту.
Вложенные маршруты.
Обычно группа функций маршрутизатора имеет общий предикат, например общий путь.
В приведенном выше примере общий предикат будет предикатом пути, соответствующим `/person`, используется тремя маршрутами.
При использовании аннотаций вы должны удалить это дублирование, используя @RequestMapping на уровне типа. аннотация, которая отображается в `/person`.
В WebMvc.fn предикаты пути могут использоваться совместно с помощью метода path в конструкторе функций маршрутизатора.
Например, последние несколько строк приведенного выше примера можно улучшить следующим образом, используя вложенные маршруты:
Java
	.path("/person", builder -> builder // <1>
		.GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)

.GET(accept(APPLICATION_JSON), handler::listPeople)
		.POST(handler::createPerson))
	.build();
RouterFunction<ServerResponse> route = route(). <1> Обратите внимание, что второй параметр `path` — это потребитель, который принимает сборщик маршрутизатора.
RouterFunction<ServerResponse> route = route(). <1> Использование `nest` DSL.
RouterFunction<ServerResponse> route = route().
Хотя вложение на основе пути является наиболее распространенным, вы можете вложить любой тип предиката, используя метод `nest` в конструкторе.
Вышеупомянутое все еще содержит некоторое дублирование в виде общего предиката заголовка Accept.
Мы можем улучшить ситуацию, используя метод «nest» вместе с «accept»:
Java
	RouterFunction<ServerResponse> route = route()
		.path("/person", b1 -> b1
			.nest(accept(APPLICATION_JSON), b2 -> b2
				.GET("/{id}", handler::getPerson)
				.GET(handler::listPeople))
			.POST(handler::createPerson))
		.build();
Версия API.
Функции маршрутизатора поддерживают сопоставление по версии API.
Java
	RouterFunction<ServerResponse> route = RouterFunctions.route()
		.GET("/hello-world", version("1.2"),

request -> ServerResponse.ok().body("Hello World")).build();
- Фиксированная версия ("1.2") — соответствует только данной версии.
- Базовая версия ("1.2+") — соответствует данной версии и выше, вплоть до самой высокой.
Предикат `version` может быть:.
См.
Версии API для получения более подробной информации об основных инфраструктура и поддержка управления версиями API.
Обслуживание ресурсов.
WebMvc.fn предоставляет встроенную поддержку обслуживания ресурсов.
Обслуживание ресурсов.
ПРИМЕЧАНИЕ.
В дополнение к возможностям, описанным ниже, можно реализовать еще более гибкое управление ресурсами благодаря {spring-framework-api}++/web/servlet/function/RouterFunctions.html#resources(java.util.function.Function)++[`RouterFunctions#resource(java.util.function.Function)`].
Перенаправление на ресурс.
Можно перенаправить запросы, соответствующие указанному предикату, на ресурс.
Это может быть полезно, например, для обработки перенаправлений в одностраничных приложениях.
Java
	ClassPathResource index = new ClassPathResource("static/index.html");
	List<String> extensions = List.of("js", "css", "ico", "png", "jpg", "gif");

RequestPredicate spaPredicate = path("/api/**").or(path("/error")).negate();
	RouterFunction<ServerResponse> redirectToIndex = route()
		.resource(spaPredicate, index)
		.build();
Обслуживание ресурсов из корневого расположения.
Также возможно маршрутизировать запросы, соответствующие заданному шаблону, к ресурсам относительно заданного корневого местоположения.
Java
	Resource location = new FileUrlResource("public-resources/");
	RouterFunction<ServerResponse> resources = RouterFunctions.resources("/resources/**", location);
Запуск сервера.
Обычно вы запускаете функции маршрутизатора в настройке на основе `DispatcherHandler` через компоненты, необходимые для обработки запросов.
Конфигурация MVC Java объявляет следующее компоненты инфраструктуры для поддержки функциональных конечных точек:
* `RouterFunctionMapping`: обнаруживает один или несколько bean-компонентов `RouterFunction<?>` в Spring.
Запуск сервера. конфигурация, упорядочивает их, объединяет их посредством RouterFunction.andOther и направляет запросы в результирующую функцию RouterFunction.
* HandlerFunctionAdapter: простой адаптер, позволяющий вызывать DispatcherHandler.
Запуск сервера.
HandlerFunction, сопоставленный с запросом.
Запуск сервера.
Предыдущие компоненты позволяют функциональным конечным точкам соответствовать запросу DispatcherServlet. жизненный цикл обработки, а также (потенциально) запускаться параллельно с аннотированными контроллерами, если любые объявлены.
Именно так функциональные конечные точки активируются с помощью Spring Boot Web. стартер.
Запуск сервера.

В следующем примере показана связанная конфигурация Spring MVC: См. пример кода в исходном документе.
Фильтрация функций-обработчиков.
Вы можете фильтровать функции обработчика, используя методы «before», «after» или «filter» в маршрутизации. конструктор функций.
С помощью аннотаций вы можете добиться аналогичной функциональности, используя @ControllerAdvice, ServletFilter или оба.
Фильтр будет применяться ко всем маршрутам, построенным строителем.
Это означает, что фильтры, определенные во вложенных маршрутах, не применяются к маршрутам «верхнего уровня».
Например, рассмотрим следующий пример:
Java
	RouterFunction<ServerResponse> route = route()
		.path("/person", b1 -> b1
			.nest(accept(APPLICATION_JSON), b2 -> b2
				.GET("/{id}", handler::getPerson)
				.GET(handler::listPeople)
				.before(request -> ServerRequest.from(request) // <1>
					.header("X-RequestHeader", "Value")
					.build()))
			.POST(handler::createPerson))
		.after((request, response) -> logResponse(response)) // <2>
		.build();

Фильтрация функций-обработчиков. <1> Фильтр «before», который добавляет пользовательский заголовок запроса, применяется только к двум маршрутам GET. <2> Фильтр «after», регистрирующий ответ, применяется ко всем маршрутам, включая вложенные.
Фильтрация функций-обработчиков.
Метод filter в конструкторе маршрутизатора принимает HandlerFilterFunction: функция, которая принимает ServerRequest и HandlerFunction и возвращает ServerResponse.
Параметр функции-обработчика представляет следующий элемент в цепочке.
Обычно это обработчик, на который перенаправляется, но это также может быть другой фильтровать, если применено несколько.
Фильтрация функций-обработчиков.
Теперь мы можем добавить к нашему маршруту простой фильтр безопасности, предполагая, что у нас есть SecurityManager, который может определить, разрешен ли конкретный путь.
В следующем примере показано, как это сделать:
Java
	SecurityManager securityManager = ...
	RouterFunction<ServerResponse> route = route()
		.path("/person", b1 -> b1
			.nest(accept(APPLICATION_JSON), b2 -> b2
				.GET("/{id}", handler::getPerson)
				.GET(handler::listPeople))
			.POST(handler::createPerson))
		.filter((request, next) -> {
			if (securityManager.allowAccessTo(request.path())) {
				return next.handle(request);
			else {

return ServerResponse.status(UNAUTHORIZED).build();
		.build();
Фильтрация функций-обработчиков.
Предыдущий пример демонстрирует, что вызов next.handle(ServerRequest) не является обязательным.
Мы разрешаем запуск функции-обработчика только тогда, когда доступ разрешен.
Фильтрация функций-обработчиков.
Помимо использования метода фильтра в конструкторе функций маршрутизатора, можно применить отфильтровать существующую функцию маршрутизатора через `RouterFunction.filter(HandlerFilterFunction)`.

Тестирование.
В этом разделе суммированы параметры, доступные в Spring-test для приложений Spring MVC.
* Моки API сервлетов: макеты реализации контрактов API сервлетов для контроллеров модульного тестирования,
Тестирование. фильтры и другие веб-компоненты.
См. ссылку:testing/unit.adoc#mock-objects-servlet[API сервлетов]. макетируйте объекты для получения более подробной информации.
* TestContext Framework: поддержка загрузки конфигурации Spring в тестах JUnit и TestNG,
Тестирование. включая эффективное кэширование загруженной конфигурации в различных методах тестирования и поддержку загрузка WebApplicationContext с помощью MockServletContext.
Дополнительную информацию см. в TestContext Framework.
* Spring MVC Test: платформа, также известная как MockMvc, для тестирования аннотированных контроллеров.
Тестирование. через DispatcherServlet (то есть поддерживающий аннотации), в комплекте с Инфраструктура Spring MVC, но без HTTP-сервера.
Дополнительную информацию см. в Spring MVC Test.
* REST на стороне клиента: Spring-test предоставляет MockRestServiceServer, который вы можете использовать в качестве
Тестирование. макетный сервер для тестирования клиентского кода, который внутри использует RestTemplate.
Дополнительную информацию см. в Клиентские тесты REST.
* `WebTestClient`: создан для тестирования приложений WebFlux, но его также можно использовать для
Тестирование. сквозное интеграционное тестирование на любом сервере через HTTP-соединение.
Это неблокирующий, реактивный клиент и хорошо подходит для тестирования асинхронных и потоковых сервисов. сценарии.
Дополнительную информацию см. в `WebTestClient`.

Управление версиями API.
Spring MVC поддерживает управление версиями API.
В этом разделе представлен обзор поддержки и лежащие в основе стратегии.
- Настройте версии API в конфигурации MVC.
- запросы карты
- Запросы маршрутизации
к функциональным конечным точкам с версией API.
Поддержка клиента для управления версиями API доступна также в RestClient, WebClient и для тестирования в MockMvc и WebTestClient.
ApiVersionStrategy.
Это центральная стратегия управления версиями API, которая сохраняет все настроенные предпочтения. связанные с управлением версиями.
Он делает следующее:
- Анализирует необработанные значения версии в `Comparable<?>` с помощью ApiVersionParser
- Проверяет версии запроса
- Отправляет подсказки об устаревании в ответах.
— Разрешает версии из запросов через ApiVersionResolver.
ApiVersionStrategy помогает сопоставлять запросы с методами контроллера @RequestMapping. и инициализируется конфигурацией MVC.
Обычно приложения не взаимодействуют непосредственно с ним.
Апиверсионрезольвер.
Эта стратегия определяет версию API из запроса.
Конфигурация MVC предоставляет встроенные параметры для разрешения из заголовка, параметра запроса, параметра типа носителя, или из URL-пути.
Вы также можете использовать собственный ApiVersionResolver.
Апиверсионрезольвер.
ПРИМЕЧАНИЕ.
Сопоставитель пути всегда разрешает версию из указанного сегмента пути или в противном случае вызывает InvalidApiVersionException, и поэтому он не может уступить место другим резольверы.
ApiVersionParser.
Эта стратегия помогает анализировать необработанные значения версий в `Comparable<?>`, что помогает сравнивайте, сортируйте и выбирайте версии.

По умолчанию встроенный SemanticApiVersionParser. анализирует версию на целочисленные значения `major`, `minor` и `patch`.
Минор и патч значения устанавливаются на 0, если они отсутствуют.
Валидация.
Если версия запроса не поддерживается, возникает исключение InvalidApiVersionException. в ответе 400.
По умолчанию список поддерживаемых версий инициализируется из объявленного версии в аннотированных сопоставлениях контроллеров, но вы можете отключить это с помощью флага в MVC и используйте только версии, явно настроенные в конфигурации.
Валидация.
По умолчанию версия требуется, если включено управление версиями API.
Вызывается MissingApiVersionException, что приводит к ответу 400, если его нет.
Вы можете сделать его необязательным, и в этом случае будет использоваться самая последняя версия.
Вы также можете указать версию по умолчанию для использования.
ApiVersionDeprecationHandler.
Эту стратегию можно настроить на отправку подсказок и информации об устаревших версиях клиентов через заголовки ответов.
Встроенный `StandardApiVersionDeprecationHandler` можно установить заголовки «Устаревание», «Закат» и «Ссылка», как определено в https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].
Вы также можете настроить индивидуальный обработчик для разных заголовков.
Запросить сопоставление. `ApiVersionStrategy` поддерживает сопоставление запросов с аннотированными методами контроллера.

См. ссылку:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-version [Версия API] для более подробной информации.

Посмотреть технологии.
Рендеринг представлений в Spring MVC является подключаемым.
Если вы решите использовать Thymeleaf, шаблоны разметки Groovy, JSP или другие технологии — это прежде всего вопрос изменение конфигурации.
В этой главе рассматриваются технологии представления, интегрированные с Spring MVC.
Посмотреть технологии.
Дополнительную информацию о рендеринге представления см. в документе Разрешение представления.
Посмотреть технологии.
ВНИМАНИЕ: представления приложения Spring MVC находятся в пределах внутренних границ доверия. этого приложения.
Представления имеют доступ ко всем компонентам контекста вашего приложения.
Как например, не рекомендуется использовать поддержку шаблонов Spring MVC в приложениях, где шаблоны доступны для редактирования из внешних источников, поскольку это может иметь последствия для безопасности.

Весенний веб-MVC.
Spring Web MVC — это оригинальная веб-платформа, построенная на API сервлетов и включенная в нее. в Spring Framework с самого начала.
Официальное название «Spring Web MVC». происходит от имени исходного модуля ({spring-framework-code}/spring-webmvc[`spring-webmvc`]), но он более известен как «Spring MVC».
Весенний веб-MVC.
Параллельно Spring Web MVC в Spring Framework 5.0 был представлен веб-фреймворк с реактивным стеком. чье имя «Spring WebFlux» также основано на его исходном модуле. ({spring-framework-code}/spring-webflux[`spring-webflux`]).
В этой главе рассматривается Spring Web MVC.
Информацию о веб-приложениях с реактивным стеком см.
Весенний веб-MVC.
Базовая информация и совместимость с контейнером сервлетов и версией Jakarta EE. диапазоны, см.
Spring Framework {spring-framework-wiki}/Spring-Framework-Versions[Вики].

Вебсокеты.
В этой части справочной документации рассматривается поддержка стека сервлетов, WebSocket. обмен сообщениями, включающий необработанные взаимодействия WebSocket, эмуляцию WebSocket через SockJS и Обмен сообщениями публикации-подписки через STOMP в качестве подпротокола через WebSocket.

Создание XML-схемы.
Начиная с версии 2.0, в Spring реализован механизм добавления расширений на основе схемы в базовый формат Spring XML для определения и настройки bean-компонентов.
Этот раздел охватывает как написать свои собственные синтаксические анализаторы определений XML-компонентов и интегрируйте такие парсеры в контейнер Spring IoC.
Создание XML-схемы.
Чтобы облегчить создание файлов конфигурации, использующих XML-редактор с поддержкой схемы, Расширяемый механизм конфигурации XML Spring основан на схеме XML.
Если вы не знакомы с текущими расширениями конфигурации XML Spring, которые поставляются со стандартом Spring, вам следует сначала прочитать предыдущий раздел XML Schemas.
Чтобы создать новые расширения конфигурации XML:. .
Автор XML-схема для описания ваших пользовательских элементов..
Код — пользовательская реализация NamespaceHandler..
Code одна или несколько реализаций BeanDefinitionParser (здесь и делается настоящая работа)..
Зарегистрируйте свои новые артефакты с помощью Spring.
Чтобы создать новые расширения конфигурации XML:.
Для унифицированного примера мы создаем Расширение XML (пользовательский элемент XML), позволяющее нам настраивать объекты типа SimpleDateFormat (из пакета java.text).
Когда мы закончим, мы сможем определить определения bean-компонентов типа SimpleDateFormat следующим образом:
	<myns:dateformat id="dateFormat"
		pattern="yyyy-MM-dd HH:mm"
		lenient="true"/>

Чтобы создать новые расширения конфигурации XML:. (Мы включаем гораздо более подробную примеры приведены далее в этом приложении.
Цель этого первого простого примера — показать вам через основные этапы создания собственного расширения.)
Создание схемы.
Создание расширения конфигурации XML для использования с контейнером IoC Spring начинается с создание XML-схемы для описания расширения.
Для нашего примера мы используем следующую схему для настройки объектов SimpleDateFormat:
	<!-- myns.xsd (inside package org/springframework/samples/xml) -->
	<?xml version="1.0" encoding="UTF-8"?>
	<xsd:schema xmlns="http://www.mycompany.example/schema/myns"
			xmlns:xsd="http://www.w3.org/2001/XMLSchema"
			xmlns:beans="http://www.springframework.org/schema/beans"
			targetNamespace="http://www.mycompany.example/schema/myns"
			elementFormDefault="qualified"
			attributeFormDefault="unqualified">
		<xsd:import namespace="http://www.springframework.org/schema/beans"/>
		<xsd:element name="dateformat">
			<xsd:complexType>
				<xsd:complexContent>
					<xsd:extension base="beans:identifiedType"> <1>

<xsd:attribute name="lenient" type="xsd:boolean"/>
						<xsd:attribute name="pattern" type="xsd:string" use="required"/>
					</xsd:extension>
				</xsd:complexContent>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
Создание схемы. <1> Указанная строка содержит базу расширения для всех идентифицируемых тегов. (это означает, что у них есть атрибут `id`, который мы можем использовать в качестве идентификатора компонента в контейнер).
Мы можем использовать этот атрибут, поскольку мы импортировали предоставленный Spring пространство имен `beans`.
Создание схемы.
Предыдущая схема позволяет нам настраивать объекты SimpleDateFormat непосредственно в XML-файл контекста приложения с помощью элемента `<myns:dateformat/>`, как показано ниже. пример показывает:
	<myns:dateformat id="dateFormat"
		pattern="yyyy-MM-dd HH:mm"
		lenient="true"/>
Создание схемы.
Обратите внимание, что после того, как мы создали классы инфраструктуры, предыдущий фрагмент XML имеет вид по сути то же самое, что и следующий фрагмент XML:
	<bean id="dateFormat" class="java.text.SimpleDateFormat">

<constructor-arg value="yyyy-MM-dd HH:mm"/>
		<property name="lenient" value="true"/>
	</bean>
Создание схемы.
Второй из двух предыдущих фрагментов создает bean-компонент в контейнере (идентифицируемый именем dateFormat типа `SimpleDateFormat`) с несколькими установленными свойствами.
Создание схемы.
ПРИМЕЧАНИЕ.
Подход к созданию формата конфигурации на основе схемы обеспечивает тесную интеграцию. с IDE, которая имеет XML-редактор с поддержкой схемы.
Используя правильно разработанную схему, вы может использовать автозаполнение, чтобы позволить пользователю выбирать между несколькими вариантами конфигурации определенные в перечислении.
Кодирование NamespaceHandler.
В дополнение к схеме нам нужен NamespaceHandler для анализа всех элементов это конкретное пространство имен, с которым Spring сталкивается при анализе файлов конфигурации.
Для этого примера NamespaceHandler должен позаботиться о синтаксическом анализе myns:dateformat. элемент.
* `init()`: позволяет инициализировать `NamespaceHandler` и вызывается
Интерфейс NamespaceHandler имеет три метода:.
Spring перед использованием обработчика.
* `BeanDefinition parse(Element, ParserContext)`: вызывается, когда Spring обнаруживает
Интерфейс NamespaceHandler имеет три метода:. элемент верхнего уровня (не вложенный в определение компонента или другое пространство имен).
Этот метод сам может регистрировать определения bean-компонентов, возвращать определение bean-компонента или и то, и другое.
* `BeanDefinitionHolder украсить(Node, BeanDefinitionHolder, ParserContext)`: Вызывается

Интерфейс NamespaceHandler имеет три метода:. когда Spring встречает атрибут или вложенный элемент другого пространства имен.
Украшение одного или нескольких определений компонента используется (например) с помощью Начнем с выделения простого примера, без использования декораций, после чего мы показываем украшение на несколько более продвинутом примере.
Интерфейс NamespaceHandler имеет три метода:.
Хотя вы можете написать свой собственный NamespaceHandler для всего пространство имен (и, следовательно, предоставить код, который анализирует каждый элемент в пространстве имен), часто бывает, что каждый элемент XML верхнего уровня в файле конфигурации Spring XML приводит к одному определению bean-компонента (как в нашем случае, где один `<myns:dateformat/>` приводит к одному определению bean-компонента SimpleDateFormat).
Весна отличается количество удобных классов, поддерживающих этот сценарий.
В следующем примере мы используйте класс NamespaceHandlerSupport:
Java
	package org.springframework.samples.xml;
	import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
	public class MyNamespaceHandler extends NamespaceHandlerSupport {
		public void init() {
			registerBeanDefinitionParser("dateformat", new SimpleDateFormatBeanDefinitionParser());
	package org.springframework.samples.xml
	class MyNamespaceHandler : NamespaceHandlerSupport {
Интерфейс NamespaceHandler имеет три метода:.
Вы можете заметить, что на самом деле логики синтаксического анализа не так много. в этом классе.
Действительно, класс NamespaceHandlerSupport имеет встроенное понятие делегация.

Он поддерживает регистрацию любого количества BeanDefinitionParser. экземпляры, которым он делегирует свои полномочия, когда ему необходимо проанализировать элемент в своем пространство имен.
Такое чистое разделение задач позволяет NamespaceHandler обрабатывать оркестровка анализа всех пользовательских элементов в своем пространстве имен, в то время как делегирование BeanDefinitionParsers выполнения тяжелой работы по анализу XML.
Это означает, что каждый BeanDefinitionParser содержит только логику для анализа одного пользовательский элемент, как мы увидим на следующем шаге.
Использование BeanDefinitionParser. `BeanDefinitionParser` используется, если `NamespaceHandler` встречает XML-код. элемент типа, который был сопоставлен с конкретным анализатором определения компонента (в данном случае «dateformat»).
Другими словами, BeanDefinitionParser отвечает за анализ одного отдельного XML-элемента верхнего уровня, определенного в схеме.
В синтаксического анализатора, у нас есть доступ к элементу XML (и, следовательно, к его подэлементам), так что мы можем проанализировать наш собственный XML-контент, как вы можете видеть в следующем примере:
Java
	package org.springframework.samples.xml;
	import org.springframework.beans.factory.support.BeanDefinitionBuilder;
	import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
	import org.springframework.util.StringUtils;
	import org.w3c.dom.Element;
	import java.text.SimpleDateFormat;
	public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { // <1>
		protected Class getBeanClass(Element element) {

return SimpleDateFormat.class; // <2>
		protected void doParse(Element element, BeanDefinitionBuilder bean) {
			// это значение никогда не будет нулевым, поскольку схема явно требует указания значения
			String pattern = element.getAttribute("pattern");
			bean.addConstructorArgValue(pattern);
			// однако это необязательное свойство
			String lenient = element.getAttribute("lenient");
			if (StringUtils.hasText(lenient)) {
				bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
Использование BeanDefinitionParser. <1> Мы используем предоставленный Spring `AbstractSingleBeanDefinitionParser` для обработки большого количества основная тяжелая работа по созданию одного BeanDefinition. <2> Мы предоставляем суперклассу `AbstractSingleBeanDefinitionParser` тип, который соответствует нашему представляет собой одиночный `BeanDefinition`.
	package org.springframework.samples.xml
	class SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { // <1>
Использование BeanDefinitionParser. <1> Мы используем предоставленный Spring `AbstractSingleBeanDefinitionParser` для обработки большого количества основная тяжелая работа по созданию одного BeanDefinition. <2> Мы предоставляем суперклассу `AbstractSingleBeanDefinitionParser` тип, который соответствует нашему представляет собой одиночный `BeanDefinition`.
Использование BeanDefinitionParser.
В этом простом случае это все, что нам нужно сделать.
Создание нашего сингла `BeanDefinition` обрабатывается суперклассом `AbstractSingleBeanDefinitionParser`, как — это извлечение и установка уникального идентификатора определения компонента.
Регистрация обработчика и схемы.
Кодирование закончено.

Все, что осталось сделать, это сделать Spring XML инфраструктура синтаксического анализа знает наш пользовательский элемент.
Мы делаем это, регистрируя наш собственный `namespaceHandler` и пользовательский файл XSD в двух файлах свойств специального назначения.
Эти файлы свойств размещаются в каталоге `META-INF` вашего приложения и может, например, распространяться вместе с вашими двоичными классами в файле JAR.
Весна Инфраструктура синтаксического анализа XML автоматически подхватывает ваше новое расширение, потребляя эти файлы специальных свойств, форматы которых подробно описаны в следующих двух разделах.
Написание `META-INF/spring.handlers`.
Файл свойств под названием «spring.handlers» содержит сопоставление URI XML-схемы с классы обработчиков пространства имен.
Для нашего примера нам нужно написать следующее:
http\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler. (Символ `:` является допустимым разделителем в формате свойств Java, поэтому Символ `:` в URI необходимо экранировать обратной косой чертой.)
http\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler.
Первая часть (ключ) пары «ключ-значение» — это URI, связанный с вашим пользовательским расширение пространства имен и должно точно совпадать со значением targetNamespace. атрибут, как указано в вашей пользовательской схеме XSD.

Написание «META-INF/spring.schemas».
Файл свойств под названием «spring.schemas» содержит сопоставление местоположений XML-схемы. (упоминается вместе с объявлением схемы в файлах XML, которые используют схему как часть атрибута `xsi:schemaLocation`) к ресурсам пути к классам.
Этот файл необходим чтобы предотвратить необходимость использования Spring EntityResolver по умолчанию, который требует Доступ в Интернет для получения файла схемы.
Если вы укажете сопоставление в этом файл свойств, Spring ищет схему (в данном случае myns.xsd в пакете org.springframework.samples.xml) в пути к классам.
В следующем фрагменте показана строка, которую нам нужно добавить для нашей пользовательской схемы:
(Помните, что символ `:` должен быть экранирован.).
Вам рекомендуется развернуть файл (или файлы) XSD рядом с классы NamespaceHandler и BeanDefinitionParser в пути к классам.
Использование специального расширения в конфигурации Spring XML.
Использование собственного расширения, которое вы сами реализовали, ничем не отличается от использования одно из «пользовательских» расширений, предоставляемых Spring.
Следующие в примере используется пользовательский элемент `<dateformat/>`, разработанный на предыдущих шагах. в файле конфигурации Spring XML:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:myns="http://www.mycompany.example/schema/myns"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd">
		<!-- as a top-level bean -->
		<myns:dateformat id="defaultDateFormat" pattern="yyyy-MM-dd HH:mm" lenient="true"/> <1>
		<bean id="jobDetailTemplate" abstract="true">
			<property name="dateFormat">
				<!-- as an inner bean -->
				<myns:dateformat pattern="HH:mm MM-dd-yyyy"/>
			</property>
		</bean>
	</beans>
Использование специального расширения в конфигурации Spring XML. <1> Наш собственный компонент.
Более подробные примеры.
В этом разделе представлены некоторые более подробные примеры пользовательских расширений XML.
Вложение пользовательских элементов в пользовательские элементы.

Пример, представленный в этом разделе, показывает, как писать различные необходимые артефакты. для удовлетворения цели следующей конфигурации:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:foo="http://www.foo.example/schema/component"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd">
		<foo:component id="bionic-family" name="Bionic-1">
			<foo:component name="Mother-1">
				<foo:component name="Karate-1"/>
				<foo:component name="Sport-1"/>
			</foo:component>
			<foo:component name="Rock-1"/>
		</foo:component>
	</beans>

Вложение пользовательских элементов в пользовательские элементы.
Предыдущая конфигурация вкладывает пользовательские расширения друг в друга.
Класс который на самом деле настраивается элементом `<foo:comComponent/>`, является `Component` класс (показан в следующем примере).
Обратите внимание, что класс `Component` не предоставляет метод установки для свойства `comments`.
Это затрудняет (или, скорее, делает невозможным) чтобы настроить определение компонента для класса Component с помощью внедрения установщика.
В следующем листинге показан класс Component:
Java
	package com.foo;
	import java.util.ArrayList;
	import java.util.List;
	public class Component {
		private String name;
		private List<Component> components = new ArrayList<Component> ();
		// для «компонентов» не существует метода установки
		public void addComponent(Component component) {
			this.components.add(component);
		public List<Component> getComponents() {
			return components;
		public String getName() {
			return name;
		public void setName(String name) {
			this.name = name;
	package com.foo
	class Component {
Вложение пользовательских элементов в пользовательские элементы.
Типичным решением этой проблемы является создание собственного FactoryBean, который предоставляет Свойство установки для свойства `comments`.
В следующем листинге показан такой обычай `ФабрикаБин`:
Java
	package com.foo;
	import org.springframework.beans.factory.FactoryBean;

import java.util.List;
	public class ComponentFactoryBean implements FactoryBean<Component> {
		private Component parent;
		private List<Component> children;
		public void setParent(Component parent) {
			this.parent = parent;
		public void setChildren(List<Component> children) {
			this.children = children;
		public Component getObject() throws Exception {
			if (this.children != null && this.children.size() > 0) {
				for (Component child : children) {
					this.parent.addComponent(child);
			return this.parent;
		public Class<Component> getObjectType() {
			return Component.class;
		public boolean isSingleton() {
			return true;
	package com.foo
	class ComponentFactoryBean : FactoryBean<Component> {
Вложение пользовательских элементов в пользовательские элементы.
Это работает хорошо, но конечному пользователю открывается большая часть возможностей Spring.
Что мы собираюсь написать собственное расширение, которое скроет всю эту сантехнику Spring.
Если мы будем придерживаться шаги, описанные ранее, мы начнем создав схему XSD для определения структуры нашего пользовательского тега, как показано ниже. листинг показывает:
	<?xml version="1.0" encoding="UTF-8" standalone="no"?>
	<xsd:schema xmlns="http://www.foo.example/schema/component"

xmlns:xsd="http://www.w3.org/2001/XMLSchema"
			targetNamespace="http://www.foo.example/schema/component"
			elementFormDefault="qualified"
			attributeFormDefault="unqualified">
		<xsd:element name="component">
			<xsd:complexType>
				<xsd:choice minOccurs="0" maxOccurs="unbounded">
					<xsd:element ref="component"/>
				</xsd:choice>
				<xsd:attribute name="id" type="xsd:ID"/>
				<xsd:attribute name="name" use="required" type="xsd:string"/>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
Java
	package com.foo;
	import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
	public class ComponentNamespaceHandler extends NamespaceHandlerSupport {
		public void init() {
			registerBeanDefinitionParser("component", new ComponentBeanDefinitionParser());
	package com.foo
	class ComponentNamespaceHandler : NamespaceHandlerSupport() {
Снова следуя процесс, описанный ранее, затем мы создаем собственный NamespaceHandler:.
Далее идет пользовательский BeanDefinitionParser.
Помните, что мы создаем `BeanDefinition`, который описывает `ComponentFactoryBean`.
Следующие В листинге показана наша собственная реализация BeanDefinitionParser:
Java
	package com.foo;

import org.springframework.beans.factory.config.BeanDefinition;
	import org.springframework.beans.factory.support.AbstractBeanDefinition;
	import org.springframework.beans.factory.support.BeanDefinitionBuilder;
	import org.springframework.beans.factory.support.ManagedList;
	import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
	import org.springframework.beans.factory.xml.ParserContext;
	import org.springframework.util.xml.DomUtils;
	import org.w3c.dom.Element;
	import java.util.List;
	public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {
		protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
			return parseComponentElement(element);
		private static AbstractBeanDefinition parseComponentElement(Element element) {
			BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
			factory.addPropertyValue("parent", parseComponent(element));
			List<Element> childElements = DomUtils.getChildElementsByTagName(element, "component");
			if (childElements != null && childElements.size() > 0) {
				parseChildComponents(childElements, factory);
			return factory.getBeanDefinition();
		private static BeanDefinition parseComponent(Element element) {
			BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
			component.addPropertyValue("name", element.getAttribute("name"));
			return component.getBeanDefinition();

private static void parseChildComponents(List<Element> childElements, BeanDefinitionBuilder factory) {
			ManagedList<BeanDefinition> children = new ManagedList<>(childElements.size());
			for (Element element : childElements) {
				children.add(parseComponentElement(element));
			factory.addPropertyValue("children", children);
	package com.foo
	class ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() {
			return factory.getBeanDefinition()
Снова следуя процесс, описанный ранее, затем мы создаем собственный NamespaceHandler:.
Наконец, различные артефакты необходимо зарегистрировать в инфраструктуре Spring XML. изменив файлы META-INF/spring.handlers и META-INF/spring.schemas следующим образом:
Пользовательские атрибуты для «обычных» элементов.
Написать собственный синтаксический анализатор и связанные с ним артефакты несложно.
Однако, иногда это неправильно.
Рассмотрим сценарий, в котором вам необходимо добавить метаданные к уже существующим определениям компонентов.
В этом случае вы наверняка не хотите писать свое собственное расширение.
Скорее, вы просто хотите добавить дополнительный атрибут к существующему элементу определения компонента.
Пользовательские атрибуты для «обычных» элементов.
В качестве другого примера предположим, что вы определяете определение компонента для объект службы, который (неизвестно ему) обращается к кластерному {JSR}107[JCache], и вы хотите убедиться, что именованный экземпляр JCache быстро запускается в окружающем кластере.
В следующем листинге показано такое определение:

<bean id="checkingAccountService" class="com.foo.DefaultCheckingAccountService"
			jcache:cache-name="checking.account">
		<!-- other dependencies here... -->
	</bean>
Пользовательские атрибуты для «обычных» элементов.
Затем мы можем создать еще одно BeanDefinition, когда Атрибут `'jcache:cache-name'` анализируется.
Затем этот `BeanDefinition` инициализирует для нас именованный JCache.
Мы также можем изменить существующее `BeanDefinition` для `'checkingAccountService'`, чтобы он зависел от этого нового JCache-инициализация `BeanDefinition`.
В следующем листинге показан наш JCacheInitializer:
Java
	package com.foo;
	public class JCacheInitializer {
		private final String name;
		public JCacheInitializer(String name) {
			this.name = name;
		public void initialize() {
			// множество вызовов API JCache для создания именного кеша...
	package com.foo
Пользовательские атрибуты для «обычных» элементов.
Теперь мы можем перейти к пользовательскому расширению.
Во-первых, нам нужно написать схема XSD, описывающая настраиваемый атрибут, следующим образом:
	<?xml version="1.0" encoding="UTF-8" standalone="no"?>
	<xsd:schema xmlns="http://www.foo.example/schema/jcache"

xmlns:xsd="http://www.w3.org/2001/XMLSchema"
			targetNamespace="http://www.foo.example/schema/jcache"
			elementFormDefault="qualified">
		<xsd:attribute name="cache-name" type="xsd:string"/>
	</xsd:schema>
Java
	package com.foo;
	import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
	public class JCacheNamespaceHandler extends NamespaceHandlerSupport {
		public void init() {
			super.registerBeanDefinitionDecoratorForAttribute("cache-name",
				new JCacheInitializingBeanDefinitionDecorator());
	package com.foo
	class JCacheNamespaceHandler : NamespaceHandlerSupport() {
Далее нам нужно создать связанный NamespaceHandler следующим образом:.
Далее нам нужно создать парсер.
Обратите внимание, что в данном случае, поскольку мы собираемся анализировать атрибут XML, мы пишем BeanDefinitionDecorator, а не BeanDefinitionParser.
В следующем листинге показана реализация BeanDefinitionDecorator:
Java
	package com.foo;
	import org.springframework.beans.factory.config.BeanDefinitionHolder;
	import org.springframework.beans.factory.support.AbstractBeanDefinition;
	import org.springframework.beans.factory.support.BeanDefinitionBuilder;
	import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
	import org.springframework.beans.factory.xml.ParserContext;
	import org.w3c.dom.Attr;

import org.w3c.dom.Node;
	import java.util.ArrayList;
	import java.util.Arrays;
	import java.util.List;
	public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {
		private static final String[] EMPTY_STRING_ARRAY = new String[0];
		public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,
				ParserContext ctx) {
			String initializerBeanName = registerJCacheInitializer(source, ctx);
			createDependencyOnJCacheInitializer(holder, initializerBeanName);
			return holder;
		private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,
				String initializerBeanName) {
			AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
			String[] dependsOn = definition.getDependsOn();
			if (dependsOn == null) {
				dependsOn = new String[]{initializerBeanName};
			} else {
				List dependencies = new ArrayList(Arrays.asList(dependsOn));
				dependencies.add(initializerBeanName);
				dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
			definition.setDependsOn(dependsOn);
		private String registerJCacheInitializer(Node source, ParserContext ctx) {
			String cacheName = ((Attr) source).getValue();
			String beanName = cacheName + "-initializer";
			if (!ctx.getRegistry().containsBeanDefinition(beanName)) {
				BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
				initializer.addConstructorArg(cacheName);

ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
			return beanName;
	package com.foo
	class JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator {
Далее нам нужно создать связанный NamespaceHandler следующим образом:.
Наконец, нам нужно зарегистрировать различные артефакты в инфраструктуре Spring XML. изменив файлы META-INF/spring.handlers и META-INF/spring.schemas следующим образом:

XML-схемы.
В этой части приложения перечислены XML-схемы, относящиеся к основному контейнеру.
Схема `util`.
Как следует из названия, теги `util` имеют дело с общей конфигурацией утилит. такие вопросы, как настройка коллекций, ссылки на константы и т. д.
Чтобы использовать теги в схеме `util`, вам необходимо иметь следующую преамбулу вверху: вашего файла конфигурации Spring XML (текст во фрагменте ссылается на исправить схему, чтобы теги в пространстве имен `util` были вам доступны):
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:util="http://www.springframework.org/schema/util"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd">
			<!-- bean definitions here -->
	</beans>

<bean id="..." class="...">
		<property name="isolation">
			<bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
					class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		</property>
	</bean>
Рассмотрим следующее определение компонента:.
В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `FieldRetrivingFactoryBean`), чтобы установить значение свойства `isolation` для bean-компонента. значению константы `java.sql.Connection.TRANSACTION_SERIALIZABLE`.
Это все это хорошо, но это многословно и (без необходимости) раскрывает внутреннюю структуру Spring. водопровод до конечного потребителя.
Рассмотрим следующее определение компонента:.
Следующая версия на основе XML-схемы является более краткой и четко выражает намерение разработчика («ввести это постоянное значение»), и это читается лучше:
	<bean id="..." class="...">
		<property name="isolation">
			<util:constant static-field="java.sql.Connection.TRANSACTION_SERIALIZABLE"/>
		</property>
	</bean>

Установка свойства компонента или аргумента конструктора на основе значения поля. {spring-framework-api}/beans/factory/config/FieldRetrivingFactoryBean.html[`FieldRetrivingFactoryBean`] представляет собой FactoryBean, который извлекает статическое или нестатическое значение поля.
Обычно это используется для получения `public` `static` `final` констант, которые затем можно использовать для установки значение свойства или аргумент конструктора для другого компонента.
Установка свойства компонента или аргумента конструктора на основе значения поля.
В следующем примере показано, как отображается статическое поле с помощью метода {spring-framework-api}/beans/factory/config/FieldRetrivingFactoryBean.html#setStaticField(java.lang.String)[`staticField`] имущество:
	<bean id="myField"
			class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean">
		<property name="staticField" value="java.sql.Connection.TRANSACTION_SERIALIZABLE"/>
	</bean>
Установка свойства компонента или аргумента конструктора на основе значения поля.
Существует также удобная форма использования, в которой поле static указывается как bean-компонент. имя, как показано в следующем примере:
	<bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
			class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/>
Установка свойства компонента или аргумента конструктора на основе значения поля.

Это означает, что больше нет никакого выбора в отношении идентификатора компонента (поэтому любой другой компонент, который ссылается на него, также должен использовать это более длинное имя), но эта форма очень лаконично определить и очень удобно использовать в качестве внутреннего компонента, поскольку `id` не имеет необходимо указать для ссылки на компонент, как показано в следующем примере:
	<bean id="..." class="...">
		<property name="isolation">
			<bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
					class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		</property>
	</bean>
Установка свойства компонента или аргумента конструктора на основе значения поля.
Вы также можете получить доступ к нестатическому полю (экземпляра) другого компонента, например описано в документации API для {spring-framework-api}/beans/factory/config/FieldRetrivingFactoryBean.html[`FieldRetrivingFactoryBean`] класс.
Установка свойства компонента или аргумента конструктора на основе значения поля.
Внедрение значений перечисления в bean-компоненты в качестве аргументов свойства или конструктора легко сделать Spring.
На самом деле вам не нужно ничего делать или знать что-либо о внутреннее устройство Spring (или даже о таких классах, как FieldRetrivingFactoryBean).
Следующий пример перечисления показывает, насколько легко ввести значение перечисления:
Java
	package jakarta.persistence;

public enum PersistenceContextType {
		TRANSACTION,
		EXTENDED
	package jakarta.persistence
	enum class PersistenceContextType {
		TRANSACTION,
		EXTENDED
Установка свойства компонента или аргумента конструктора на основе значения поля.
Теперь рассмотрим следующий установщик типа PersistenceContextType и соответствующее определение bean-компонента:
Java
	package example;
	public class Client {
		private PersistenceContextType persistenceContextType;
		public void setPersistenceContextType(PersistenceContextType type) {
			this.persistenceContextType = type;
	package example
	class Client {
	<bean class="example.Client">
		<property name="persistenceContextType" value="TRANSACTION"/>
	</bean>
	<!-- target bean to be referenced by name -->
	<bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype">
		<property name="age" value="10"/>
		<property name="spouse">
			<bean class="org.springframework.beans.TestBean">
				<property name="age" value="11"/>
			</bean>
		</property>
	</bean>
	<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->
	<bean id="testBean.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
Рассмотрим следующий пример:.

В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `PropertyPathFactoryBean`) для создания bean-компонента (типа `int`) с именем `testBean.age`, который имеет значение, равное свойству age компонента testBean.
	<!-- target bean to be referenced by name -->
	<bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype">
		<property name="age" value="10"/>
		<property name="spouse">
			<bean class="org.springframework.beans.TestBean">
				<property name="age" value="11"/>
			</bean>
		</property>
	</bean>
	<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->
	<util:property-path id="name" path="testBean.age"/>
Теперь рассмотрим следующий пример, в котором добавляется элемент `<util:property-path/>`:.
Значение атрибута `path` элемента `<property-path/>` имеет форму `beanName.beanProperty`.
В этом случае он берет свойство age компонента с именем `testBean`.
Значение этого свойства age равно 10.

Использование `<util:property-path/>` для установки свойства компонента или аргумента конструктора. `PropertyPathFactoryBean` — это `FactoryBean`, который оценивает путь к свойству по заданному целевой объект.
Целевой объект можно указать напрямую или по имени компонента.
Затем вы можете использовать это значение в другом определении bean-компонента как значение свойства или конструктор аргумент.
Использование `<util:property-path/>` для установки свойства компонента или аргумента конструктора.
В следующем примере показан путь, используемый для другого компонента по имени:
	<!-- target bean to be referenced by name -->
	<bean id="person" class="org.springframework.beans.TestBean" scope="prototype">
		<property name="age" value="10"/>
		<property name="spouse">
			<bean class="org.springframework.beans.TestBean">
				<property name="age" value="11"/>
			</bean>
		</property>
	</bean>
	<!-- results in 11, which is the value of property 'spouse.age' of bean 'person' -->
	<bean id="theAge"
			class="org.springframework.beans.factory.config.PropertyPathFactoryBean">

<property name="targetBeanName" value="person"/>
		<property name="propertyPath" value="spouse.age"/>
	</bean>
	<!-- results in 12, which is the value of property 'age' of the inner bean -->
	<bean id="theAge"
			class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
		<property name="targetObject">
			<bean class="org.springframework.beans.TestBean">
				<property name="age" value="12"/>
			</bean>
		</property>
		<property name="propertyPath" value="age"/>
	</bean>
В следующем примере путь оценивается по внутреннему компоненту:.
Существует также сокращенная форма, в которой имя компонента является путем к свойству.
В следующем примере показана форма быстрого доступа:
	<!-- results in 10, which is the value of property 'age' of bean 'person' -->
	<bean id="person.age"
			class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
В следующем примере путь оценивается по внутреннему компоненту:.
Эта форма означает, что нет выбора имени компонента.

Любая ссылка на него также должен использовать тот же идентификатор, который является путем.
Если используется в качестве внутреннего bean, вообще нет необходимости ссылаться на него, как показывает следующий пример:
	<bean id="..." class="...">
		<property name="age">
			<bean id="person.age"
					class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
		</property>
	</bean>
В следующем примере путь оценивается по внутреннему компоненту:.
Вы можете специально установить тип результата в фактическом определении.
Это не обязательно для большинства случаев использования, но иногда это может быть полезно.
Дополнительную информацию см. в javadoc. эта функция.
	<!-- creates a java.util.Properties instance with values loaded from the supplied location -->
	<bean id="jdbcConfiguration" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
		<property name="location" value="classpath:com/foo/jdbc-production.properties"/>
	</bean>
Рассмотрим следующий пример:.
В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `PropertiesFactoryBean`) для создания экземпляра `java.util.Properties` со значениями загружается из предоставленного местоположения (`Resource`).

<!-- creates a java.util.Properties instance with values loaded from the supplied location -->
	<util:properties id="jdbcConfiguration" location="classpath:com/foo/jdbc-production.properties"/>
	<!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' -->
	<bean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean">
		<property name="sourceList">
			<list>
				<value>pechorin@hero.org</value>
				<value>raskolnikov@slums.org</value>
				<value>stavrogin@gov.org</value>
				<value>porfiry@gov.org</value>
			</list>
		</property>
	</bean>
Рассмотрим следующий пример:.
В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `ListFactoryBean`), чтобы создать экземпляр `java.util.List` и инициализировать его взятыми значениями. из предоставленного `sourceList`.
	<!-- creates a java.util.List instance with the supplied values -->
	<util:list id="emails">
		<value>pechorin@hero.org</value>
		<value>raskolnikov@slums.org</value>

<value>stavrogin@gov.org</value>
		<value>porfiry@gov.org</value>
	</util:list>
В следующем примере используется элемент `<util:list/>` для более краткого представления:.
Вы также можете явно контролировать точный тип списка, который создается и заполняется с помощью атрибута list-class в элементе <util:list/>.
Для Например, если нам действительно нужно создать экземпляр `java.util.LinkedList`, мы могли бы использовать следующая конфигурация:
	<util:list id="emails" list-class="java.util.LinkedList">
		<value>jackshaftoe@vagabond.org</value>
		<value>eliza@thinkingmanscrumpet.org</value>
		<value>vanhoek@pirate.org</value>
		<value>d'Arcachon@nemesis.org</value>
	</util:list>
В следующем примере используется элемент `<util:list/>` для более краткого представления:.
Если атрибут list-class не указан, контейнер выбирает реализацию List.
	<!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' -->
	<bean id="emails" class="org.springframework.beans.factory.config.MapFactoryBean">

<property name="sourceMap">
			<map>
				<entry key="pechorin" value="pechorin@hero.org"/>
				<entry key="raskolnikov" value="raskolnikov@slums.org"/>
				<entry key="stavrogin" value="stavrogin@gov.org"/>
				<entry key="porfiry" value="porfiry@gov.org"/>
			</map>
		</property>
	</bean>
Рассмотрим следующий пример:.
В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `MapFactoryBean`) для создания экземпляра `java.util.Map`, инициализированного парами ключ-значение. взято из предоставленного `'sourceMap'`.
	<!-- creates a java.util.Map instance with the supplied key-value pairs -->
	<util:map id="emails">
		<entry key="pechorin" value="pechorin@hero.org"/>
		<entry key="raskolnikov" value="raskolnikov@slums.org"/>
		<entry key="stavrogin" value="stavrogin@gov.org"/>
		<entry key="porfiry" value="porfiry@gov.org"/>
	</util:map>

В следующем примере используется элемент `<util:map/>` для более краткого представления:.
Вы также можете явно контролировать точный тип `Map`, который создается и заполняется с помощью атрибута Map-class элемента <util:map/>.
Для Например, если нам действительно нужно создать экземпляр `java.util.TreeMap`, мы могли бы использовать следующая конфигурация:
	<util:map id="emails" map-class="java.util.TreeMap">
		<entry key="pechorin" value="pechorin@hero.org"/>
		<entry key="raskolnikov" value="raskolnikov@slums.org"/>
		<entry key="stavrogin" value="stavrogin@gov.org"/>
		<entry key="porfiry" value="porfiry@gov.org"/>
	</util:map>
В следующем примере используется элемент `<util:map/>` для более краткого представления:.
Если атрибут Map-class не указан, контейнер выбирает реализацию Map.
	<!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' -->
	<bean id="emails" class="org.springframework.beans.factory.config.SetFactoryBean">
		<property name="sourceSet">

<set>
				<value>pechorin@hero.org</value>
				<value>raskolnikov@slums.org</value>
				<value>stavrogin@gov.org</value>
				<value>porfiry@gov.org</value>
			</set>
		</property>
	</bean>
Рассмотрим следующий пример:.
В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `SetFactoryBean`) для создания экземпляра `java.util.Set`, инициализированного взятыми значениями. из предоставленного `sourceSet`.
	<!-- creates a java.util.Set instance with the supplied values -->
	<util:set id="emails">
		<value>pechorin@hero.org</value>
		<value>raskolnikov@slums.org</value>
		<value>stavrogin@gov.org</value>
		<value>porfiry@gov.org</value>
	</util:set>
В следующем примере используется элемент `<util:set/>` для более краткого представления:.
Вы также можете явно контролировать точный тип `Set`, который создается и заполняется с помощью атрибута `set-class` в элементе `<util:set/>`.

Для Например, если нам действительно нужно создать экземпляр `java.util.TreeSet`, мы могли бы использовать следующая конфигурация:
	<util:set id="emails" set-class="java.util.TreeSet">
		<value>pechorin@hero.org</value>
		<value>raskolnikov@slums.org</value>
		<value>stavrogin@gov.org</value>
		<value>porfiry@gov.org</value>
	</util:set>
В следующем примере используется элемент `<util:set/>` для более краткого представления:.
Если атрибут set-class не указан, контейнер выбирает реализацию Set.
Схема «аоп».
Теги `aop` предназначены для настройки всех элементов AOP в Spring, включая Spring. собственная платформа АОП на основе прокси и интеграция Spring со структурой АОП AspectJ.
Эти теги подробно описаны в главе под названием Аспектно-ориентированное программирование с помощью Spring..
Схема «аоп».
В целях полноты, чтобы использовать теги в схеме `aop`, вам необходимо иметь следующую преамбулу в верхней части файла конфигурации Spring XML (текст в фрагмент ссылается на правильную схему, поэтому теги в пространстве имен `aop` доступны вам):
	<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">
		<!-- bean definitions here -->
	</beans>
Схема «контекста».
Теги `context` имеют дело с конфигурацией `ApplicationContext`, которая относится к сантехнике.
- то есть обычно не компоненты, которые важны для конечного пользователя, а скорее компоненты, которые
Схема «контекста». в Spring много «ворчащих» работ, таких как BeanfactoryPostProcessors.
Следующие фрагмент ссылается на правильную схему, так что элементы в пространстве имен `context` вам доступны:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
		<!-- bean definitions here -->
	</beans>
Использование `<property-placeholder/>`.
Этот элемент активирует замену заполнителей `${...}`, которые разрешаются относительно указанный файл свойств (как файл расположение ресурса Spring).
Этот элемент — это удобный механизм, настраивающий файл PropertySourcesPlaceholderConfigurer. для тебя.
Если вам нужен больший контроль над конкретным При настройке PropertySourcesPlaceholderConfigurer вы можете самостоятельно явно определить его как bean-компонент.
Использование `<property-placeholder/>`. [ВНИМАНИЕ] = Для данного приложения должен быть определен только один такой элемент со свойствами что это нужно.
Можно настроить несколько заполнителей свойств, если они имеют отдельные синтаксис заполнителя (`${...}`).

Использование `<property-placeholder/>`.
Если вам необходимо модулировать источник свойств, используемых для замены, вам следует не создавать несколько заполнителей свойств.
Скорее, каждый модуль должен внести свой вклад «PropertySource» в «Среду».
Альтернативно, вы можете создать свой собственный Компонент `PropertySourcesPlaceholderConfigurer`, который собирает используемые свойства.
Использование `<annotation-config/>`.
Этот элемент активирует инфраструктуру Spring для обнаружения аннотаций в классах компонентов:
* Модель Spring:core/beans/basics.adoc#beans-factory-metadata[`@Configuration`]
* `@Autowired`/`@Inject`, `@Value` и `@Lookup`
* JSR-250 `@Resource`, `@PostConstruct` и `@PreDestroy` (если доступно)
* `@WebServiceRef` в JAX-WS и `@EJB` в EJB 3 (если доступно).
* JPA `@PersistenceContext` и `@PersistenceUnit` (если доступны)
* внешняя ссылка Spring:core/beans/context-introduction.adoc#context-functionality-events-annotation[`@EventListener`]
Использование `<annotation-config/>`.
Альтернативно, вы можете явно активировать отдельные `BeanPostProcessors` для этих аннотаций.
Использование `<annotation-config/>`.
ПРИМЕЧАНИЕ.

Этот элемент не активирует обработку Spring. вы можете использовать <<data-access.adoc#tx-decl-explained, `<tx:annotation-driven/>`>> элемент для этой цели.
Аналогично, Весна
Использование `<Component-scan/>`.
Этот элемент подробно описан в разделе конфигурация контейнера на основе аннотаций.
Использование `<load-time-weaver/>`.
Этот элемент подробно описан в разделе переплетение во время загрузки с AspectJ в Spring Framework.
Использование `<spring-configured/>`.
Этот элемент подробно описан в разделе использование AspectJ для внедрения зависимостей в объекты домена с помощью Spring.
Использование `<mbean-export/>`.
Этот элемент подробно описан в разделе настройка экспорта MBean на основе аннотаций.
Схема бинов.
И последнее, но не менее важное: у нас есть элементы в схеме beans.
Эти элементы были Spring с самого зарождения фреймворка.
Примеры различных элементов в схеме beans здесь не показаны, поскольку они достаточно подробно описаны. в подробное описание зависимостей и конфигурации (и, действительно, во всем этом документе).
Схема бинов.
Обратите внимание, что вы можете добавить ноль или более пар ключ-значение в определения XML `<bean/>`.

Что будет сделано с этими дополнительными метаданными, полностью зависит от ваших предпочтений. логика (и поэтому обычно используется только в том случае, если вы пишете свои собственные элементы, как описано в приложении под названием Разработка XML-схемы).
Схема бинов.
В следующем примере показан элемент `<meta/>` в контексте окружающего `<bean/>`. (обратите внимание, что без какой-либо логики для их интерпретации метаданные фактически бесполезны. в нынешнем виде).
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
		<bean id="foo" class="x.y.Foo">
			<meta key="cacheName" value="foo"/> <1>
			<property name="name" value="Rick"/>
		</bean>
	</beans>
Схема бинов. <1> Это пример элемента `meta`.
Схема бинов.

В случае предыдущего примера вы могли бы предположить, что существует некоторая логика, которая потребляет определение компонента и настраивает некоторую инфраструктуру кэширования, которая использует предоставленные метаданные.
