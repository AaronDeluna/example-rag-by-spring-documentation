# Lilipup Security Module

## 1. Введение
`security` реализует аутентификацию, авторизацию, шифрование и политики доступа на уровне endpoint, сервиса и данных.

Зачем нужен:
- предотвращает несанкционированный доступ;
- унифицирует security-конфигурацию;
- обеспечивает аудит безопасности и соответствие требованиям.

## 2. Подключение модуля
```xml
<dependency>
  <groupId>io.lilipup</groupId>
  <artifactId>lilipup-security</artifactId>
  <version>1.2.0</version>
</dependency>
```

```java
import io.lilipup.security.annotation.EnableLilipupSecurity;

@EnableLilipupSecurity
public class SecurityConfig {}
```

## 3. Использование в коде
### Авторизация через аннотации
```java
import io.lilipup.security.annotation.RequiresRole;
import io.lilipup.security.annotation.RequiresPermission;

public class PayrollController {

    @RequiresRole("PAYROLL_ADMIN")
    public void recalculatePayroll() {
        // Доступ только для роли PAYROLL_ADMIN.
    }

    @RequiresPermission("employee:read")
    public String getEmployee(String id) {
        return "employee:" + id;
    }
}
```

### Работа с шифрованием
```java
import io.lilipup.security.crypto.CryptoService;

public class SecretTokenStore {
    private final CryptoService cryptoService;

    public SecretTokenStore(CryptoService cryptoService) {
        this.cryptoService = cryptoService;
    }

    public String encryptToken(String rawToken) {
        return cryptoService.encrypt(rawToken);
    }

    public String decryptToken(String encryptedToken) {
        return cryptoService.decrypt(encryptedToken);
    }
}
```

## 4. Конфигурация
```yaml
lilipup:
  security:
    auth:
      provider: jwt
      jwt:
        issuer: lilipup-auth
        audience: internal-services
        public-key-path: classpath:keys/public.pem
        clock-skew-sec: 30
    authorization:
      default-policy: deny
      cache-ttl-sec: 60
    crypto:
      algorithm: AES_GCM
      key-source: env
      key-env-name: LILIPUP_MASTER_KEY
    audit:
      enabled: true
      include-request-body: false
```

## 5. Обязательные проверки
- Всегда используйте `default-policy: deny` как безопасный baseline.
- Проверяйте срок действия JWT и `issuer/audience` при каждом запросе.
- Никогда не храните master key в plaintext-конфиге.
- Проверяйте, что аудит включен для критичных операций.
- Не используйте симметричное шифрование без ротации ключей.

## 6. Ошибки и их обработка
### Частые ошибки
- `AuthenticationException`: невалидный токен или отсутствует credential.
- `AccessDeniedException`: недостаточно ролей/permission.
- `CryptoOperationException`: ошибка шифрования/дешифрования.

### Пример централизованного обработчика
```java
import io.lilipup.security.exception.AccessDeniedException;
import io.lilipup.security.exception.AuthenticationException;

public class SecurityErrorMapper {

    public int mapToHttpStatus(Exception ex) {
        if (ex instanceof AuthenticationException) {
            return 401;
        }
        if (ex instanceof AccessDeniedException) {
            return 403;
        }
        return 500;
    }
}
```

## 7. Best Practices
- Применяйте principle of least privilege для ролей и permission.
- Разделяйте machine-to-machine и user-токены.
- Включайте key rotation и проверяйте обратную совместимость ключей.
- Маскируйте PII и секреты в логах.
- Проводите security regression tests для каждого релиза.
