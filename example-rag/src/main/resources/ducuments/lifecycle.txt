# Lilipup Lifecycle Module

## 1. Введение
`lifecycle` управляет фазами жизни компонентов: создание, инициализация, готовность к трафику, graceful shutdown и очистка ресурсов.

Зачем нужен:
- предсказуемый запуск сервиса;
- корректное завершение без потери данных;
- контроль готовности инфраструктурных зависимостей.

## 2. Подключение модуля
```xml
<dependency>
  <groupId>io.lilipup</groupId>
  <artifactId>lilipup-lifecycle</artifactId>
  <version>1.2.0</version>
</dependency>
```

```java
import io.lilipup.lifecycle.annotation.EnableLifecycle;

@EnableLifecycle
public class LifecycleConfig {}
```

## 3. Использование в коде
```java
import io.lilipup.core.annotation.Component;
import io.lilipup.lifecycle.annotation.OnStart;
import io.lilipup.lifecycle.annotation.OnReady;
import io.lilipup.lifecycle.annotation.OnStop;

@Component
public class CacheWarmup {

    @OnStart(order = 10)
    public void initCaches() {
        // Выполняется до открытия внешнего трафика.
        System.out.println("Warming up cache...");
    }

    @OnReady
    public void signalReady() {
        // Точка, когда компонент готов обслуживать запросы.
        System.out.println("Component is ready");
    }

    @OnStop(timeoutMs = 5000)
    public void flushAndClose() {
        // Корректно закрываем ресурсы.
        System.out.println("Flushing and closing resources");
    }
}
```

## 4. Конфигурация
```yaml
lilipup:
  lifecycle:
    startup-timeout-ms: 30000
    shutdown-timeout-ms: 20000
    readiness:
      enabled: true
      require-all-components: true
    shutdown:
      graceful: true
      await-jobs: true
```

## 5. Обязательные проверки
- Всегда ставьте таймауты на `@OnStart` и `@OnStop`, чтобы избежать зависания процесса.
- Проверяйте readiness внешних зависимостей (БД, Kafka, кэш) до `@OnReady`.
- Не публикуйте трафик, пока не завершились критичные `@OnStart` хуки.
- Всегда освобождайте сетевые/файловые ресурсы в `@OnStop`.
- Для background-задач проверяйте, что при shutdown они либо завершены, либо безопасно прерваны.

## 6. Ошибки и их обработка
### Частые ошибки
- `LifecycleTimeoutException`: хук превысил таймаут.
- `ReadinessCheckException`: не выполнена проверка готовности.
- `ShutdownInterruptedException`: процесс завершения был прерван.

### Обработка неготовности
```java
import io.lilipup.lifecycle.ReadinessProbe;
import io.lilipup.lifecycle.ReadinessState;

public class DbReadinessProbe implements ReadinessProbe {
    @Override
    public ReadinessState check() {
        boolean dbReachable = pingDb();
        return dbReachable
            ? ReadinessState.ready("db_ok")
            : ReadinessState.notReady("db_unreachable");
    }

    private boolean pingDb() {
        // Здесь реальная проверка соединения.
        return true;
    }
}
```

## 7. Best Practices
- Разделяйте быстрые и тяжелые `@OnStart` действия по `order`.
- Делайте shutdown идемпотентным: повторный вызов не должен ломать состояние.
- Логируйте длительность каждого lifecycle-hook.
- Используйте readiness-пробы как контракт между сервисом и orchestrator.
- Тестируйте сценарий «kill во время старта» и «kill во время long-running job».
