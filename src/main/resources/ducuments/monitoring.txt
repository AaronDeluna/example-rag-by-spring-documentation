# Lilipup Monitoring Module

## 1. Введение
`monitoring` предоставляет единые хуки для метрик, структурированных логов и интеграции с Prometheus/Alerting.

Зачем нужен:
- наблюдаемость производительности и надежности;
- быстрый root-cause анализ инцидентов;
- единый стандарт telemetry для всех модулей.

## 2. Подключение модуля
```xml
<dependency>
  <groupId>io.lilipup</groupId>
  <artifactId>lilipup-monitoring</artifactId>
  <version>1.2.0</version>
</dependency>
```

```java
import io.lilipup.monitoring.annotation.EnableLilipupMonitoring;

@EnableLilipupMonitoring
public class MonitoringConfig {}
```

## 3. Использование в коде
### Метрики через MetricsHook
```java
import io.lilipup.monitoring.MetricsHook;

public class PaymentService {
    private final MetricsHook metrics;

    public PaymentService(MetricsHook metrics) {
        this.metrics = metrics;
    }

    public void processPayment(String paymentId) {
        long startedAt = System.nanoTime();
        try {
            // Бизнес-операция.
            metrics.counter("payments_processed_total").increment();
        } catch (Exception ex) {
            metrics.counter("payments_failed_total").increment();
            throw ex;
        } finally {
            long durationMs = (System.nanoTime() - startedAt) / 1_000_000;
            metrics.timer("payments_duration_ms").record(durationMs);
        }
    }
}
```

### Структурированный лог
```java
import io.lilipup.monitoring.LogHook;
import java.util.Map;

public class OrderLogger {
    private final LogHook log;

    public OrderLogger(LogHook log) {
        this.log = log;
    }

    public void logOrderEvent(String orderId, String status) {
        log.info("order_event", Map.of(
            "orderId", orderId,
            "status", status,
            "component", "order-service"
        ));
    }
}
```

## 4. Конфигурация
```yaml
lilipup:
  monitoring:
    metrics:
      enabled: true
      export:
        prometheus:
          enabled: true
          endpoint: /internal/metrics
    logging:
      format: json
      include-trace-id: true
      redact-fields:
        - password
        - accessToken
        - cardNumber
    tracing:
      enabled: true
      sampler: 0.2
```

## 5. Обязательные проверки
- Всегда проверяйте, что endpoint метрик защищен и недоступен публично.
- Не логируйте чувствительные поля: токены, пароли, PAN/PII.
- Проверяйте наличие `trace-id` в логах для распределенной трассировки.
- Для каждой критичной операции добавляйте минимум одну success и одну failure метрику.
- Убедитесь, что cardinality label-ов ограничена (не используйте userId как label).

## 6. Ошибки и их обработка
### Частые ошибки
- `MetricRegistryOverflowException`: слишком много уникальных label-комбинаций.
- `PrometheusExportException`: ошибка публикации метрик.
- `LogSerializationException`: проблема сериализации structured-log payload.

### Пример guard для label cardinality
```java
import io.lilipup.monitoring.MetricsHook;

public class SafeMetricPublisher {
    private final MetricsHook metrics;

    public SafeMetricPublisher(MetricsHook metrics) {
        this.metrics = metrics;
    }

    public void publishRequestMetric(String endpoint, int statusCode) {
        String normalizedEndpoint = endpoint.replaceAll("/[0-9]+", "/{id}");
        metrics.counter("http_requests_total")
            .tag("endpoint", normalizedEndpoint)
            .tag("status", String.valueOf(statusCode))
            .increment();
    }
}
```

## 7. Best Practices
- Стройте SLI/SLO на основе latency, error-rate и saturation.
- Используйте единый naming convention для метрик (`<domain>_<metric>_<unit>`).
- Сохраняйте баланс между детализацией логов и стоимостью хранения.
- Делайте алерты action-oriented, чтобы было понятно, что делать on-call инженеру.
- Регулярно проводите game-day с проверкой мониторинга и alert-routing.
