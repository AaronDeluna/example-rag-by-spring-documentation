# Lilipup Scheduler Module

## 1. Введение
`scheduler` предоставляет планировщик фоновых задач с cron/interval триггерами, ограничением конкуренции и управлением повторными попытками.

Зачем нужен:
- автоматизирует регулярные процессы;
- снижает риск ручных операций;
- позволяет управлять SLA для batch/jobs.

## 2. Подключение модуля
```xml
<dependency>
  <groupId>io.lilipup</groupId>
  <artifactId>lilipup-scheduler</artifactId>
  <version>1.2.0</version>
</dependency>
```

```java
import io.lilipup.scheduler.annotation.EnableLilipupScheduler;

@EnableLilipupScheduler
public class SchedulerConfig {}
```

## 3. Использование в коде
### Cron-задача
```java
import io.lilipup.scheduler.annotation.LilipupCron;
import io.lilipup.scheduler.annotation.DisallowParallel;

public class InvoiceCleanupJob {

    @LilipupCron("0 */15 * * * *")
    @DisallowParallel
    public void cleanupExpiredDrafts() {
        // Выполняется каждые 15 минут.
        System.out.println("Cleaning up expired invoice drafts");
    }
}
```

### Interval-задача с retry
```java
import io.lilipup.scheduler.annotation.LilipupEvery;
import io.lilipup.scheduler.annotation.RetryableJob;

public class SyncJob {

    @LilipupEvery("30s")
    @RetryableJob(maxAttempts = 3, backoffMs = 2000)
    public void syncRemoteCatalog() {
        // Внешний вызов должен быть timeout-ограничен.
        System.out.println("Sync remote catalog");
    }
}
```

## 4. Конфигурация
```yaml
lilipup:
  scheduler:
    enabled: true
    timezone: UTC
    worker-pool-size: 8
    max-concurrent-jobs: 16
    misfire-policy: fire-now
    default-timeout-ms: 30000
```

## 5. Обязательные проверки
- Не используйте scheduler-методы без `@LilipupCron` или `@LilipupEvery`.
- Всегда ограничивайте параллелизм для неидемпотентных задач (`@DisallowParallel`).
- Проверяйте timeout и circuit breaker на внешних вызовах внутри job.
- Не запускайте критичные задачи без retry-политики или DLQ-аналогичного механизма.
- Проверяйте timezone: cron в local timezone часто приводит к инцидентам.

## 6. Ошибки и их обработка
### Частые ошибки
- `ScheduleParseException`: некорректное cron/interval выражение.
- `JobExecutionTimeoutException`: задача превысила лимит выполнения.
- `JobConcurrencyViolationException`: нарушено правило параллелизма.

### Пример защитного исполнения
```java
import io.lilipup.scheduler.JobContext;

public class SafeJob {
    public void run(JobContext ctx) {
        try {
            doWork();
            ctx.markSuccess();
        } catch (Exception ex) {
            ctx.markFailure(ex.getMessage());
            throw ex;
        }
    }

    private void doWork() {
        // Business logic
    }
}
```

## 7. Best Practices
- Делайте задачи идемпотентными и re-entrant.
- Храните checkpoint/offset для долгих jobs.
- Разделяйте CPU-bound и IO-bound jobs по разным пулам.
- Добавляйте jitter для периодических задач во избежание thundering herd.
- Тестируйте переход на летнее/зимнее время для cron-задач.
