{"id": 1, "text": "API рекомендаций Spring.\nТеперь мы можем изучить, как Spring AOP обрабатывает советы.\nЖизненный цикл рекомендаций.\nКаждый совет — это компонент Spring.\nЭкземпляр совета может быть общим для всех рекомендуемых объектов или быть уникальным для каждого рекомендуемого объекта.\nЭто соответствует классу или консультации по каждому экземпляру.\nЖизненный цикл рекомендаций.\nЧаще всего используются индивидуальные консультации.\nПодходит для общих советов, таких как консультанты по сделкам.\nОни не зависят от состояния проксируемого объекта и не добавляют новые. государство.\nОни просто действуют в соответствии с методом и аргументами.\nЖизненный цикл рекомендаций.\nСоветы по каждому экземпляру подходят для ознакомления и поддержки миксинов.\nВ этом случае совет добавляет состояние к проксируемому объекту.\nЖизненный цикл рекомендаций.\nВы можете использовать сочетание общих и индивидуальных рекомендаций в одном прокси-сервере AOP.\nТипы рекомендаций Spring.\nSpring предоставляет несколько типов советов и может быть расширен для поддержки. произвольные типы советов.\nВ этом разделе описаны основные понятия и стандартные типы советов.\nПерехват вокруг советов.\nСамый фундаментальный тип совета в Spring — это _перехват вокруг совета_.\nПерехват вокруг советов.\nSpring совместим с интерфейсом AOP Alliance для рекомендаций, использующих метод. перехват.\nПоэтому классы, реализующие рекомендации, должны реализовывать следующий интерфейс MethodInterceptor из пакета org.aopalliance.intercept:\n	public interface MethodInterceptor extends Interceptor {\n		Object invoke(MethodInvocation invocation) throws Throwable;\nПерехват вокруг советов."}
{"id": 2, "text": "Аргумент `MethodInvoke` метода `invoke()` раскрывает используемый метод. вызываемый, целевую точку соединения, прокси-сервер AOP и аргументы метода.\nМетод `invoke()` должен возвращать результат вызова: обычно возвращаемое значение точка соединения.\nJava\n	public class DebugInterceptor implements MethodInterceptor {\n		public Object invoke(MethodInvocation invocation) throws Throwable {\n			System.out.println(\"Before: invocation=[\" + invocation + \"]\");\n			Object result = invocation.proceed();\n			System.out.println(\"Invocation returned\");\n			return result;\n	class DebugInterceptor : MethodInterceptor {\nВ следующем примере показана простая реализация MethodInterceptor:.\nОбратите внимание на вызов метода proceed() метода MethodInvocacy.\nЭто происходит вниз по цепочка перехватчиков к точке соединения.\nБольшинство перехватчиков вызывают этот метод и вернуть его возвращаемое значение.\nОднако `MethodInterceptor`, как и любой другой совет, может верните другое значение или создайте исключение, а не вызывайте метод continue.\nОднако не стоит этого делать без уважительной причины.\nВ следующем примере показана простая реализация MethodInterceptor:.\nПРИМЕЧАНИЕ.\nРеализации MethodInterceptor обеспечивают совместимость с другими AOP, совместимыми с AOP Alliance. реализации.\nДругие типы советов, обсуждаемые в оставшейся части этого раздела. реализовать общие концепции АОП, но специфичным для Spring способом."}
{"id": 3, "text": "Хотя есть преимущество при использовании наиболее конкретного типа совета придерживайтесь `MethodInterceptor` вокруг совета, если вы, вероятно, захотите запустить этот аспект в другой среде АОП.\nОбратите внимание, что точечные разрезы в настоящее время несовместимы между собой, и Альянс АОП не в настоящее время определяют интерфейсы pointcut.\nПеред советом.\nБолее простой тип совета — это «перед советом».\nДля этого не требуется `MethodInvocacy` объект, поскольку он вызывается только перед входом в метод.\nПеред советом.\nОсновное преимущество совета before заключается в том, что нет необходимости вызывать `proceed()`. метод и, следовательно, отсутствие возможности случайно не пройти вниз по цепочка перехватчиков.\n	public interface MethodBeforeAdvice extends BeforeAdvice {\n		void before(Method m, Object[] args, Object target) throws Throwable;\nВ следующем листинге показан интерфейс MethodBeforeAdvice:.\nОбратите внимание, что тип возвращаемого значения — void.\nПрежде чем совет может вставить пользовательское поведение перед объединением точка запускается, но не может изменить возвращаемое значение.\nЕсли совет перед выдает исключение, оно останавливает дальнейшее выполнение цепочки перехватчиков.\nИсключение распространяется обратно по цепочке перехватчиков.\nЕсли флажок снят или в подписи вызванный метод, он передается непосредственно клиенту.\nВ противном случае это завернутый в непроверенное исключение прокси-сервером AOP.\nВ следующем листинге показан интерфейс MethodBeforeAdvice:.\nВ следующем примере показан совет before в Spring, который подсчитывает все вызовы методов:\nJava\n	public class CountingBeforeAdvice implements MethodBeforeAdvice {"}
{"id": 4, "text": "private int count;\n		public void before(Method m, Object[] args, Object target) throws Throwable {\n			++count;\n		public int getCount() {\n			return count;\n	class CountingBeforeAdvice : MethodBeforeAdvice {\nВ следующем листинге показан интерфейс MethodBeforeAdvice:.\nСОВЕТ: Совет Before можно использовать с любым точечным вырезом.\nБросает совет. _Совет по выбрасыванию_ вызывается после возврата точки соединения, если точка соединения выдала исключение.\nВесна предлагает типизированные советы.\nОбратите внимание, что это означает, что Интерфейс `org.springframework.aop.ThrowsAdvice` не содержит никаких методов.\nЭто интерфейс маркера, определяющий, что данный объект реализует один или несколько типизированных бросков методы консультирования.\nОни должны быть в следующей форме:\n	afterThrowing([Метод, аргументы, цель], subclassOfThrowable)\nБросает совет.\nТребуется только последний аргумент.\nСигнатуры метода могут иметь одну или четыре аргументы, в зависимости от того, заинтересован ли в методе совет и аргументы.\nВ следующих двух листингах показаны классы, являющиеся примерами советов по броскам.\nJava\n	public class RemoteThrowsAdvice implements ThrowsAdvice {\n		public void afterThrowing(RemoteException ex) throws Throwable {\n			// Сделайте что-нибудь с удаленным исключением\n	class RemoteThrowsAdvice : ThrowsAdvice {\nСледующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):."}
{"id": 5, "text": "В отличие от предыдущего совета, в следующем примере объявляются четыре аргумента, поэтому он имеет доступ к вызванному методу, аргументам метода и целевому объекту.\nСледующий совет вызывается, если выдается `ServletException`:\nJava\n	public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {\n		public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {\n			// Сделайте что-нибудь со всеми аргументами\n	class ServletThrowsAdviceWithArguments : ThrowsAdvice {\nСледующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.\nПоследний пример иллюстрирует, как эти два метода можно использовать в одном классе. который обрабатывает как RemoteException, так и ServletException.\nСовет по любому количеству бросков методы могут быть объединены в одном классе.\nВ следующем листинге показан последний пример:\nJava\n	public static class CombinedThrowsAdvice implements ThrowsAdvice {\n		public void afterThrowing(RemoteException ex) throws Throwable {\n			// Сделайте что-нибудь с удаленным исключением\n		public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {\n			// Сделайте что-нибудь со всеми аргументами\n	class CombinedThrowsAdvice : ThrowsAdvice {\nСледующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.\nПРИМЕЧАНИЕ.\nЕсли метод throws-advice сам генерирует исключение, он переопределяет исходное исключение (то есть оно изменяет исключение, выданное пользователю).\nНаиважнейшее значение исключением обычно является RuntimeException, совместимое с любым методом. подпись."}
{"id": 6, "text": "Однако если метод throws-advice выдает проверенное исключение, он должен соответствовать объявленным исключениям целевого метода и, следовательно, в некоторой степени в сочетании с конкретными сигнатурами целевого метода. _Не выбрасывать необъявленную галочку исключение, несовместимое с сигнатурой целевого метода!_\nСледующий совет вызывается, если выдается `RemoteException` (включая подклассы `RemoteException`):.\nСОВЕТ: Совет по броскам можно использовать с любым ударом.\nПосле возвращения совета. _после возврата совета_ в Spring должен реализовать Интерфейс `org.springframework.aop.AfterReturningAdvice`, который показан в следующем листинге:\n	public interface AfterReturningAdvice extends Advice {\n		void afterReturning (Объект returnValue, Метод m, Object[] args, Цель объекта)\n				throws Throwable;\nПосле возвращения совета.\nСовет после возврата имеет доступ к возвращаемому значению (которое он не может изменить). вызванный метод, аргументы метода и цель.\nПосле возвращения совета.\nСледующий после возврата совет подсчитывает все успешные вызовы методов, которые не выброшенные исключения:\nJava\n	public class CountingAfterReturningAdvice implements AfterReturningAdvice {\n		private int count;\n		public void afterReturning(Object returnValue, Method m, Object[] args, Object target)\n				throws Throwable {\n			++count;\n		public int getCount() {\n			return count;\n	class CountingAfterReturningAdvice : AfterReturningAdvice {\nПосле возвращения совета.\nЭтот совет не меняет путь выполнения.\nЕсли он выдает исключение, это выбрасывает цепочку перехватчиков вместо возвращаемого значения.\nПосле возвращения совета."}
{"id": 7, "text": "СОВЕТ: После возврата совет можно использовать с любым pointcut.\nВведение Совет.\nSpring рассматривает _рекомендации по внедрению_ как особый вид рекомендаций по перехвату.\nВведение Совет.\nДля введения требуются `IntroductionAdvisor` и `IntroductionInterceptor`, которые реализовать следующий интерфейс:\n	public interface IntroductionInterceptor extends MethodInterceptor {\n		boolean implementsInterface(Class intf);\nВведение Совет.\nМетод `invoke()`, унаследованный от интерфейса `MethodInterceptor` Альянса АОП, должен реализовать введение.\nТо есть, если вызванный метод находится на введенном интерфейс, за обработку вызова метода отвечает перехватчик введения. не может вызвать `proceed()`.\nВведение Совет.\nСовет по введению не может быть использован ни с каким поинткатом, поскольку он применяется только на занятии. а не метод, уровень.\nВы можете использовать вводный совет только с `IntroductionAdvisor`, который имеет следующие методы:\n	public interface IntroductionAdvisor extends Advisor, IntroductionInfo {\n		ClassFilter getClassFilter();\n		void validateInterfaces() throws IllegalArgumentException;\n	public interface IntroductionInfo {\n		Class<?>[] getInterfaces();\nВведение Совет.\nНет `MethodMatcher` и, следовательно, нет `Pointcut`, связанного с введением. совет.\nЛогична только фильтрация классов.\nВведение Совет.\nМетод getInterfaces() возвращает интерфейсы, представленные этим советником.\nВведение Совет.\nМетод validateInterfaces() используется внутренне, чтобы узнать, действительно ли представленные интерфейсы могут быть реализованы с помощью настроенного `IntroductionInterceptor`.\nВведение Совет."}
{"id": 8, "text": "Рассмотрим пример из набора тестов Spring и предположим, что мы хотим введите следующий интерфейс для одного или нескольких объектов:\nJava\n	public interface Lockable {\n		void lock();\n		void unlock();\n		boolean locked();\nВведение Совет.\nЭто иллюстрирует миксин.\nМы хотим иметь возможность приводить рекомендуемые объекты к «Lockable», независимо от их типа и вызовов методов блокировки и разблокировки.\nЕсли мы вызовем метод lock(), мы хочу, чтобы все методы установки выдавали `LockedException`.\nТаким образом, мы можем добавить аспект, который предоставляет возможность делать объекты неизменяемыми, не зная об этом: хороший пример АОП.\nВведение Совет.\nВо-первых, нам нужен «IntroductionInterceptor», который сделает всю тяжелую работу.\nВ этом В этом случае мы расширяем `org.springframework.aop.support.DelegatingIntroductionInterceptor` класс удобства.\nМы могли бы реализовать «IntroductionInterceptor» напрямую, но используя `DelegatingIntroductionInterceptor` лучше всего подходит для большинства случаев.\nВведение Совет.\nDelegatingIntroductionInterceptor предназначен для делегирования введения в фактическая реализация внедренных интерфейсов, скрывающая использование перехвата сделать это.\nВы можете установить делегата для любого объекта, используя аргумент конструктора.\nДелегат по умолчанию (когда используется конструктор без аргументов) — `this`.\nТаким образом, в следующем примере делегатом является подкласс LockMixin от DelegatingIntroductionInterceptor."}
{"id": 9, "text": "Для делегата (по умолчанию самого себя) создается экземпляр DelegatingIntroductionInterceptor. ищет все интерфейсы, реализованные делегатом (кроме `IntroductionInterceptor`) и поддерживает введение против любого из них.\nПодклассы, такие как `LockMixin`, могут вызывать `suppressInterface(Class intf)` метод для подавления интерфейсов, которые не должны быть раскрыты.\nОднако, сколько бы интерфейсы, которые готов поддерживать `IntroductionInterceptor`, `IntroductionAdvisor` использовал элементы управления, какие интерфейсы фактически доступны.\nАн введенный интерфейс скрывает любую реализацию того же интерфейса целью.\nВведение Совет.\nТаким образом, LockMixin расширяет DelegatingIntroductionInterceptor и реализует Lockable. сам.\nСуперкласс автоматически определяет, что Lockable может поддерживаться. введение, поэтому нам не нужно это указывать.\nМы можем ввести любое количество интерфейсы таким образом.\nВведение Совет.\nОбратите внимание на использование переменной экземпляра `locked`.\nЭто эффективно добавляет дополнительное состояние тому, что содержится в целевом объекте.\nJava\n	public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {\n		private boolean locked;\n		public void lock() {\n			this.locked = true;\n		public void unlock() {\n			this.locked = false;\n		public boolean locked() {\n			return this.locked;\n		public Object invoke(MethodInvocation invocation) throws Throwable {\n			if (locked() && invocation.getMethod().getName().indexOf(\"set\") == 0) {\n				throw new LockedException();"}
{"id": 10, "text": "return super.invoke(invocation);\n	class LockMixin : DelegatingIntroductionInterceptor(), Lockable {\nВ следующем примере показан пример класса LockMixin:.\nЧасто вам не нужно переопределять метод invoke().\nРеализация DelegatingIntroductionInterceptor (которая вызывает метод делегата, если метод вводится, в противном случае продолжается к точке соединения) обычно достаточно.\nВ данном случае нам нужно добавить проверку: ни один метод установки не может быть вызван. если в заблокированном режиме.\nВ следующем примере показан пример класса LockMixin:.\nТребуемое введение должно лишь содержать четкую `LockMixin` и укажите введенные интерфейсы (в данном случае только «Запираемый»).\nБолее сложный пример может потребовать ссылки на введение. перехватчик (который будет определен как прототип).\nВ этом случае нет конфигурация, соответствующая LockMixin, поэтому мы создаем ее, используя new.\nВ следующем примере показан наш класс LockMixinAdvisor:\nJava\n	public class LockMixinAdvisor extends DefaultIntroductionAdvisor {\n		public LockMixinAdvisor() {\n			super(new LockMixin(), Lockable.class);\nВ следующем примере показан пример класса LockMixin:.\nПрименить этот советник можно очень просто, поскольку он не требует настройки. (Однако это невозможно использовать `IntroductionInterceptor` без `IntroductionAdvisor`.) Как обычно при ознакомлении, советник должен быть для каждого экземпляра, поскольку это состояние.\nНам нужен другой экземпляр LockMixinAdvisor, и, следовательно, `LockMixin`, для каждого рекомендуемого объекта.\nСоветник включает в себя часть советуемого объекта государство."}
{"id": 11, "text": "В следующем примере показан пример класса LockMixin:.\nМы можем применить этот советник программно, используя метод Advised.addAdvisor() или (рекомендуемый способ) в конфигурации XML, как и любой другой советник.\nВсе создание прокси варианты, обсуждаемые ниже, в том числе «автоматические создатели прокси», правильно обрабатывают представления. и миксины с сохранением состояния."}
{"id": 12, "text": "Манипулирование рекомендуемыми объектами.\nКак бы вы ни создавали прокси-серверы AOP, вы можете манипулировать ими с помощью Интерфейс `org.springframework.aop.framework.Advised`.\nК этому можно применить любой прокси-сервер AOP. интерфейс, независимо от того, какие другие интерфейсы он реализует.\nЭтот интерфейс включает в себя следующие методы:\nJava\n	Advisor[] getAdvisors();\n	void addAdvice(Advice advice) throws AopConfigException;\n	void addAdvice(int pos, Advice advice) throws AopConfigException;\n	void addAdvisor(Advisor advisor) throws AopConfigException;\n	void addAdvisor(int pos, Advisor advisor) throws AopConfigException;\n	int indexOf(Advisor advisor);\n	boolean removeAdvisor(Advisor advisor) throws AopConfigException;\n	void removeAdvisor(int index) throws AopConfigException;\n	boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;\n	boolean isFrozen();\nМанипулирование рекомендуемыми объектами.\nМетод getAdvisors() возвращает советника для каждого советника, перехватчика или другой тип совета, добавленный на заводе.\nЕсли вы добавили «Советника», Возвращаемый советник по этому индексу — это добавленный вами объект.\nЕсли вы добавили перехватчик или другой тип совета, Spring завернул его в советник с pointcut, который всегда возвращает true.\nТаким образом, если вы добавили «MethodInterceptor», советник для этого индекса возвращается `DefaultPointcutAdvisor`, который возвращает ваш `MethodInterceptor` и pointcut, соответствующий всем классам и методам.\nМанипулирование рекомендуемыми объектами."}
{"id": 13, "text": "Методы addAdvisor() можно использовать для добавления любого советника.\nОбычно советник, держащий Pointcut и совет — это универсальный `DefaultPointcutAdvisor`, который вы можете использовать с любые советы или замечания (но не для ознакомления).\nМанипулирование рекомендуемыми объектами.\nПо умолчанию можно добавлять или удалять советников или перехватчиков даже после прокси-сервера. был создан.\nЕдинственное ограничение – невозможно добавить или удалить советник по внедрению, так как существующие прокси с завода не показывают интерфейс изменить. (Чтобы избежать этой проблемы, вы можете получить новый прокси-сервер с завода.)\nМанипулирование рекомендуемыми объектами.\nВ следующем примере показано приведение прокси-сервера AOP к интерфейсу Advised, а также проверка и манипулируя его советом:\nJava\n	Advised advised = (Advised) myObject;\n	Advisor[] advisors = advised.getAdvisors();\n	int oldAdvisorCount = advisors.length;\n	System.out.println(oldAdvisorCount + \" advisors\");\n	// Добавляем совет типа перехватчика без точечного выреза\n	// Будет соответствовать всем прокси-методам\n	// Можно использовать для перехватчиков до, после возвращения или давать советы.\n	advised.addAdvice(new DebugInterceptor());\n	// Добавьте выборочный совет с помощью pointcut\n	advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));\n	assertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.getAdvisors().length);\n	// Добавляем совет типа перехватчика без точечного выреза"}
{"id": 14, "text": "// Будет соответствовать всем прокси-методам\n	// Можно использовать для перехватчиков до, после возвращения или давать советы.\n	advised.addAdvice(DebugInterceptor())\n	// Добавьте выборочный совет с помощью pointcut\n	advised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice))\n	assertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.advisors.size)\nМанипулирование рекомендуемыми объектами.\nПРИМЕЧАНИЕ.\nСомнительно, целесообразно ли (без каламбура) изменять рекомендации по бизнес-объект в производстве, хотя, без сомнения, существуют законные случаи использования.\nОднако это может быть очень полезно при разработке (например, при тестировании).\nУ нас иногда бывает нашел очень полезным иметь возможность добавлять тестовый код в виде перехватчика или другого совет, проникая внутрь вызова метода, который мы хотим протестировать. (Например, совет может войти в транзакцию, созданную для этого метода, возможно, чтобы запустить SQL и проверить это база данных была правильно обновлена, прежде чем пометить транзакцию для отката.)\nМанипулирование рекомендуемыми объектами.\nВ зависимости от того, как вы создали прокси, вы обычно можете установить флаг «заморозки».\nВ этом В этом случае метод `Advised` `isFrozen()` возвращает `true`, и любые попытки изменить рекомендации по добавлению или удалению приводят к возникновению исключения AopConfigException.\nСпособность заморозить состояние советуемого объекта полезно в некоторых случаях (например, для предотвратить вызывающий код, удалив перехватчик безопасности)."}
{"id": 15, "text": "API советника Spring.\nВ Spring советник — это аспект, который содержит только один объект совета, связанный с с выражением pointcut.\nAPI советника Spring.\nЗа исключением особого случая знакомств, любой советник может быть использован с любым советом. `org.springframework.aop.support.DefaultPointcutAdvisor` является наиболее часто используемым. класс советника.\nЕго можно использовать с MethodInterceptor, BeforeAdvice или `ThrowsAdvice`.\nAPI советника Spring.\nВ Spring можно смешивать типы советников и советов в одном прокси-сервере AOP.\nДля Например, вы можете использовать перехват вокруг советов, выбрасываний советов и перед советом в одна конфигурация прокси.\nSpring автоматически создает необходимый перехватчик цепь."}
{"id": 16, "text": "Совет контроллера.\nОбычно применяются методы `@ExceptionHandler`, `@InitBinder` и `@ModelAttribute`. внутри класса `@Controller` (или иерархии классов), в котором они объявлены.\nЕсли ты хотите, чтобы такие методы применялись более глобально (на всех контроллерах), вы можете объявить их в класс, аннотированный `@ControllerAdvice` или `@RestControllerAdvice`.\nСовет контроллера. `@ControllerAdvice` имеет аннотацию `@Component`, что означает, что такие классы могут быть зарегистрировано как bean-компоненты Spring через сканирование компонентов. `@RestControllerAdvice` — это составленная аннотация, которая аннотирована как с `@ControllerAdvice`, так и с `@ResponseBody`, что по сути означает Методы `@ExceptionHandler` отображаются в теле ответа посредством преобразования сообщения. (по сравнению с разрешением просмотра или рендерингом шаблона).\nСовет контроллера.\nПри запуске классы инфраструктуры для `@RequestMapping` и `@ExceptionHandler` методы обнаруживают bean-компоненты Spring, помеченные `@ControllerAdvice`, а затем применяют их методы во время выполнения.\nГлобальные методы `@ExceptionHandler` (из `@ControllerAdvice`) применил _after_ локальные (из `@Controller`).\nНапротив, глобальный `@ModelAttribute` и методы `@InitBinder` применяются _раньше_ локальных.\nСовет контроллера."}
{"id": 17, "text": "По умолчанию методы @ControllerAdvice применяются к каждому запросу (то есть ко всем контроллерам). но вы можете сузить это до подмножества контроллеров, используя атрибуты в аннотация, как показано в следующем примере:\nJava\n	// Нацеливаемся на все контроллеры, помеченные @RestController\n	@ControllerAdvice(annotations = RestController.class)\n	public class ExampleAdvice1 {}\n	// Нацеливаемся на все контроллеры в определенных пакетах\n	@ControllerAdvice(\"org.example.controllers\")\n	public class ExampleAdvice2 {}\n	// Назначаем все контроллеры, которые можно назначить определенным классам\n	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})\n	public class ExampleAdvice3 {}\n	// Нацеливаемся на все контроллеры в определенных пакетах\n	@ControllerAdvice(\"org.example.controllers\")\n	public class ExampleAdvice2 {}\nСовет контроллера.\nСелекторы в предыдущем примере оцениваются во время выполнения и могут отрицательно повлиять производительность при интенсивном использовании.\nСм. {spring-framework-api}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`] javadoc для более подробной информации."}
{"id": 18, "text": "Исключения.\nКлассы `@Controller` и @ControllerAdvice могут иметь Методы `@ExceptionHandler` для обработки исключений из методов контроллера.\nСледующие пример включает такой метод-обработчик: См. пример кода в исходном документе.\nИсключения.\nИсключение может соответствовать распространяемому исключению верхнего уровня (то есть прямому выдается `IOException`) или против непосредственной причины внутри оболочки верхнего уровня. исключение (например, IOException, завернутое в IllegalStateException).\nИсключения.\nДля сопоставления типов исключений желательно объявить целевое исключение как аргумент метода. как показано в предыдущем примере.\nАльтернативно, объявление аннотации может сузить типы исключений для соответствия.\nОбычно мы рекомендуем указывать как можно более конкретно подпись аргумента и объявить сопоставления основных корневых исключений на `@ControllerAdvice` имеет приоритет в соответствующем порядке.\nПодробности см. в раздел MVC.\nИсключения.\nПРИМЕЧАНИЕ.\nМетод @ExceptionHandler в WebFlux поддерживает те же аргументы метода и возвращаемые значения как метод @RequestMapping, за исключением тела запроса. и аргументы метода, связанные с `@ModelAttribute`.\nИсключения.\nПоддержка методов @ExceptionHandler в Spring WebFlux обеспечивается HandlerAdapter для методов @RequestMapping.\nСм. ссылку:web/webflux/dispatcher-handler.adoc[`DispatcherHandler`] для более подробной информации.\nСопоставление типов носителей.\nПомимо типов исключений, методы @ExceptionHandler также могут объявлять производимые типы мультимедиа."}
{"id": 19, "text": "Это позволяет уточнить ответы об ошибках в зависимости от типов мультимедиа, запрашиваемых HTTP-клиентами, обычно в заголовке HTTP-запроса «Принять».\nСопоставление типов носителей.\nПриложения могут объявлять типы воспроизводимых носителей непосредственно в аннотациях для одного и того же типа исключения: См. пример кода в исходном документе.\nСопоставление типов носителей.\nЗдесь методы обрабатывают один и тот же тип исключения, но не будут отклонены как дубликаты.\nВместо этого клиенты API, запрашивающие «application/json», получат ошибку JSON, а браузеры получат представление об ошибке HTML.\nКаждая аннотация @ExceptionHandler может объявлять несколько типов воспроизводимых носителей: согласование контента на этапе обработки ошибок решит, какой тип контента будет использоваться.\nАргументы метода.\nМетоды @ExceptionHandler поддерживают одни и те же параметры. как методы @RequestMapping, за исключением того, что тело запроса могло уже быть использовано.\nВозвращаемые значения.\nМетоды @ExceptionHandler поддерживают одни и те же значения. как методы @RequestMapping."}
{"id": 20, "text": "`DataBinder`.\nКлассы `@Controller` или `@ControllerAdvice` могут иметь методы `@InitBinder` для инициализировать экземпляры `WebDataBinder`, которые, в свою очередь, могут:\n* Привязка параметров запроса к объекту модели.\n* Преобразование значений запроса из строковых в типы свойств объекта.\n* Свойства объекта модели форматируются как строки при рендеринге HTML-форм.\n`DataBinder`.\nВ @Controller настройки DataBinder применяются локально внутри контроллера. или даже к определенному атрибуту модели, на который ссылается имя в аннотации.\nВ @ControllerAdvice настройки могут применяться ко всем контроллерам или к их подмножеству.\n`DataBinder`.\nВы можете зарегистрировать компоненты PropertyEditor, Converter и Formatter в `DataBinder` для преобразования типов.\nАльтернативно, вы можете использовать Компоненты Converter и Formatter в глобальной общей службе FormattingConversionService.\nJava\n	@Controller\n	public class FormController {\n		@InitBinder // <1>\n		public void initBinder(WebDataBinder binder) {\n			SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n			dateFormat.setLenient(false);\n			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n`DataBinder`. <1> Использование аннотации `@InitBinder`.\n	@Controller\n	class FormController {\n`DataBinder`. <1> Использование аннотации `@InitBinder`.\n`DataBinder`."}
{"id": 21, "text": "Альтернативно, при использовании установки на основе «Форматтера» через общий `FormattingConversionService`, вы можете повторно использовать тот же подход и зарегистрировать экземпляры `Formatter`, специфичные для контроллера, как показано в следующем примере:\nJava\n	@Controller\n	public class FormController {\n		@InitBinder\n		protected void initBinder(WebDataBinder binder) {\n			binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); <1>\n`DataBinder`. <1> Добавление специального средства форматирования (в данном случае DateFormatter).\n	@Controller\n	class FormController {\n`DataBinder`. <1> Добавление специального средства форматирования (в данном случае DateFormatter)."}
{"id": 22, "text": "Методы обработчика.\nМетоды-обработчики `@RequestMapping` имеют гибкую сигнатуру и могут выбирать из ряда поддерживаемые аргументы метода контроллера и возвращаемые значения."}
{"id": 23, "text": "* В ссылке:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[аргумент метода]\nВы можете использовать аннотацию @ModelAttribute:. в методах @RequestMapping для создания или доступа к объекту из модели и его привязки. на запрос через `WebDataBinder`.\n* В качестве аннотации на уровне метода в классах `@Controller` или `@ControllerAdvice`, помогая\nВы можете использовать аннотацию @ModelAttribute:. для инициализации модели перед вызовом любого метода @RequestMapping.\n* В методе @RequestMapping для пометки возвращаемого значения как атрибута модели.\nВы можете использовать аннотацию @ModelAttribute:.\nВ этом разделе обсуждаются методы @ModelAttribute или второй элемент из предыдущего списка.\nКонтроллер может иметь любое количество методов @ModelAttribute.\nВсе подобные методы вызывается перед методами @RequestMapping в том же контроллере. `@ModelAttribute` метод также можно использовать для разных контроллеров через `@ControllerAdvice`.\nСм. раздел о\nВы можете использовать аннотацию @ModelAttribute:.\nМетоды `@ModelAttribute` имеют гибкие сигнатуры методов.\nОни поддерживают многие из тех же аргументы как методы `@RequestMapping` (за исключением самого `@ModelAttribute` и всего остального относительно тела запроса).\nJava\n	@ModelAttribute\n	public void populateModel(@RequestParam String number, Model model) {\n		model.addAttribute(accountRepository.findAccount(number));\n		// добавить еще...\nJava\n	@ModelAttribute"}
{"id": 24, "text": "public Account addAccount(@RequestParam String number) {\n		return accountRepository.findAccount(number);\nВ следующем примере добавляется только один атрибут:.\nПРИМЕЧАНИЕ.\nЕсли имя не указано явно, имя по умолчанию выбирается на основе типа. как описано в javadoc для {spring-framework-api}/core/Conventions.html[`Conventions`].\nВы всегда можете назначить явное имя, используя перегруженный метод addAttribute или через атрибут имени в `@ModelAttribute` (для возвращаемого значения).\nВ следующем примере добавляется только один атрибут:.\nSpring WebFlux, в отличие от Spring MVC, явно поддерживает реактивные типы в модели. (например, Mono<Account> или io.reactivex.Single<Account>).\nТакая асинхронная модель атрибуты могут быть прозрачно разрешены (и обновлена модель) до их фактических значений. во время вызова @RequestMapping при условии, что аргумент @ModelAttribute объявлен без оболочки, как показано в следующем примере:\nJava\n	@ModelAttribute\n	public void addAccount(@RequestParam String number) {\n		Mono<Account> accountMono = accountRepository.findAccount(number);\n		model.addAttribute(\"account\", accountMono);\n	@PostMapping(\"/accounts\")\n	public String handle(@ModelAttribute Account account, BindingResult errors) {\nВ следующем примере добавляется только один атрибут:."}
{"id": 25, "text": "Кроме того, любые атрибуты модели, имеющие оболочку реактивного типа, разрешаются в свои фактические значения (и обновленная модель) непосредственно перед рендерингом просмотра.\nВ следующем примере добавляется только один атрибут:.\nВы также можете использовать @ModelAttribute в качестве аннотации на уровне метода для @RequestMapping. методы, и в этом случае возвращаемое значение метода @RequestMapping интерпретируется как Атрибут модели.\nОбычно это не требуется, поскольку это поведение по умолчанию в HTML. контроллеры, если только возвращаемое значение не является строкой, которая в противном случае была бы интерпретирована в качестве имени представления. `@ModelAttribute` также может помочь настроить имя атрибута модели, как показано в следующем примере:\nJava\n	@GetMapping(\"/accounts/{id}\")\n	@ModelAttribute(\"myAccount\")\n	public Account handle() {\n		return account;"}
{"id": 26, "text": "Сопоставление запросов.\nВ этом разделе обсуждается сопоставление запросов для аннотированных контроллеров.\n`@RequestMapping`.\nАннотация `@RequestMapping` используется для сопоставления запросов с методами контроллеров.\nОн имеет различные атрибуты для сопоставления по URL-адресу, методу HTTP, параметрам запроса, заголовкам и медиафайлам. типы.\nВы можете использовать его на уровне класса для выражения общих сопоставлений или на уровне метода. чтобы сузить список до конкретного сопоставления конечных точек.\n* `@GetMapping`\n* `@PostMapping`\n* `@PutMapping`\n* `@DeleteMapping`\n* `@PatchMapping`\nСуществуют также варианты ярлыков `@RequestMapping`, специфичные для HTTP-метода:.\nПредыдущие аннотации — это [Пользовательские аннотации], которые предоставляются. потому что, возможно, большинство методов контроллера должны быть сопоставлены с конкретным методом HTTP, а не с используя @RequestMapping, который по умолчанию соответствует всем методам HTTP.\nВ то же время, `@RequestMapping` по-прежнему необходим на уровне класса для выражения общих сопоставлений.\nСуществуют также варианты ярлыков `@RequestMapping`, специфичные для HTTP-метода:.\nПРИМЕЧАНИЕ. `@RequestMapping` нельзя использовать вместе с другими `@RequestMapping`. аннотации, объявленные для одного и того же элемента (класса, интерфейса или метода).\nЕсли в одном и том же элементе обнаружено несколько аннотаций `@RequestMapping`, появится предупреждение. регистрироваться, и будет использоваться только первое сопоставление."}
{"id": 27, "text": "Это касается и составных Аннотации `@RequestMapping`, такие как `@GetMapping`, `@PostMapping` и т. д.\nJava\n	@RestController\n	@RequestMapping(\"/persons\")\n	class PersonController {\n		@GetMapping(\"/{id}\")\n		public Person getPerson(@PathVariable Long id) {\n		@PostMapping\n		@ResponseStatus(HttpStatus.CREATED)\n		public void add(@RequestBody Person person) {\n	@RestController\n	@RequestMapping(\"/persons\")\n	class PersonController {\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.\nДоступ к захваченным переменным URI можно получить с помощью `@PathVariable`, как показано в следующем примере:\nJava\n	@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.\nВы можете объявить переменные URI на уровне класса и метода, как показано в следующем примере:\nJava\n	@Controller\n	@RequestMapping(\"/owners/{ownerId}\") // <1>\n	public class OwnerController {\n		@GetMapping(\"/pets/{petId}\") // <2>\n		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {"}
{"id": 28, "text": "Вы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:. <1> Сопоставление URI на уровне класса. <2> Сопоставление URI на уровне метода.\n	@Controller\n	@RequestMapping(\"/owners/{ownerId}\") // <1>\n	class OwnerController {\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:. <1> Сопоставление URI на уровне класса. <2> Сопоставление URI на уровне метода.\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.\nПеременные URI автоматически преобразуются в соответствующий тип или в исключение TypeMismatchException. поднят.\nПростые типы («int», «long», «Date» и т. д.) поддерживаются по умолчанию, и вы можете зарегистрировать поддержку любого другого типа данных.\nСм.\nПреобразование типов и DataBinder.\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.\nПеременные URI могут быть названы явно (например, `@PathVariable(\"customId\")`), но вы можете оставьте эту деталь, если имена одинаковы и вы компилируете свой код с параметрами `-parameters` флаг компилятора.\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.\nСинтаксис `{*varName}` объявляет переменную URI, которая соответствует нулю или более оставшемуся пути. сегменты."}
{"id": 29, "text": "Например, `/resources/{*path}` соответствует всем файлам в `/resources/`, а Переменная `\"path\"` фиксирует полный путь в `/resources`.\nВы можете сопоставить запросы, используя шаблоны glob и подстановочные знаки:.\nСинтаксис `{varName:regex}` объявляет переменную URI с регулярным выражением, имеющим синтаксис: `{varName:regex}`.\nНапример, учитывая URL-адрес `/spring-web-3.0.5.jar`, следующий метод извлекает имя, версию и расширение файла:\nJava\n	@GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\")\n	public void handle(@PathVariable String version, @PathVariable String ext) {\n- Встроенные заполнители `${...}`, которые разрешаются при запуске через\nШаблоны путей URI также могут иметь:. `PropertySourcesPlaceholderConfigurer` для локального, системного, окружения и другие источники собственности.\nЭто полезно, например, для параметризации базового URL-адреса на основе внешняя конфигурация.\n- Выражения SpEL `#{...}`.\nШаблоны путей URI также могут иметь:.\nПРИМЕЧАНИЕ."}
{"id": 30, "text": "Spring WebFlux использует PathPattern и PathPatternParser для поддержки сопоставления путей URI.\nОба класса расположены в Spring-Web и специально предназначены для использования с URL-адресами HTTP. пути в веб-приложениях, где во время выполнения сопоставляется большое количество шаблонов путей URI.\nШаблоны путей URI также могут иметь:.\nSpring WebFlux не поддерживает сопоставление шаблонов суффиксов — в отличие от Spring MVC, где mapping such as `/person` also matches to `/person.{asterisk}`.\nДля контента на основе URL согласования, при необходимости мы рекомендуем использовать параметр запроса, который проще и более явный и менее уязвимый для эксплойтов, основанных на URL-путях.\nСравнение шаблонов.\nЕсли URL-адресу соответствует несколько шаблонов, их необходимо сравнить, чтобы найти наилучшее соответствие.\nЭто сделано с `PathPattern.SPECIFICITY_COMPARATOR`, который ищет более конкретные шаблоны.\nСравнение шаблонов.\nДля каждого шаблона вычисляется оценка на основе количества переменных URI и подстановочных знаков. где переменная URI оценивается ниже, чем подстановочный знак.\nШаблон с меньшим общим баллом побеждает.\nЕсли два паттерна имеют одинаковую оценку, выбирается более длинный.\nСравнение шаблонов.\nВсеобъемлющие шаблоны (например, `**`, `{*varName}`) исключаются из оценки и всегда вместо этого отсортировано последним.\nЕсли оба шаблона являются универсальными, выбирается более длинный.\nТипы расходных материалов."}
{"id": 31, "text": "Вы можете сузить сопоставление запросов на основе «Типа контента» запроса, как показано в следующем примере:\nJava\n	@PostMapping(path = \"/pets\", consumes = \"application/json\")\n	public void addPet(@RequestBody Pet pet) {\nТипы расходных материалов.\nАтрибут Consumers также поддерживает выражения отрицания — например, `!text/plain` означает любое тип контента, отличный от `text/plain`.\nТипы расходных материалов.\nВы можете объявить общий атрибут «consumes» на уровне класса.\nВ отличие от большинства других запросов атрибуты сопоставления, однако при использовании на уровне класса атрибут «consumes» уровня метода переопределяет, а не расширяет объявление уровня класса.\nТипы расходных материалов.\nСОВЕТ: MediaType предоставляет константы для часто используемых типов мультимедиа, например `APPLICATION_JSON_VALUE` и `APPLICATION_XML_VALUE`.\nТипы производимых носителей.\nВы можете сузить сопоставление запросов на основе заголовка запроса Accept и списка типы контента, которые создает метод контроллера, как показано в следующем примере:\nJava\n	@GetMapping(path = \"/pets/{petId}\", produces = \"application/json\")\n	@ResponseBody\n	public Pet getPet(@PathVariable String petId) {\nТипы производимых носителей.\nТип носителя может указывать набор символов.\nПоддерживаются отрицательные выражения, например: `!text/plain` означает любой тип контента, кроме `text/plain`.\nТипы производимых носителей."}
{"id": 32, "text": "Вы можете объявить общий атрибут Produces на уровне класса.\nВ отличие от большинства других запросов атрибуты сопоставления, однако при использовании на уровне класса атрибут \"производит\" на уровне метода переопределяет, а не расширяет объявление уровня класса.\nТипы производимых носителей.\nСОВЕТ: MediaType предоставляет константы для часто используемых типов мультимедиа, например `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE`.\nПараметры и заголовки.\nВы можете сузить сопоставления запросов на основе условий параметров запроса.\nВы можете протестировать наличие параметра запроса (`myParam`), его отсутствие (`!myParam`) или наличие конкретное значение (`myParam=myValue`).\nВ следующих примерах проверяется параметр со значением:\nJava\n	@GetMapping(path = \"/pets/{petId}\", params = \"myParam=myValue\") // <1>\n	public void findPet(@PathVariable String petId) {\nПараметры и заголовки. <1> Убедитесь, что `myParam` равен `myValue`.\nПараметры и заголовки.\nВы также можете использовать то же самое с условиями заголовка запроса, как показано в следующем примере:\nJava\n	@GetMapping(path = \"/pets/{petId}\", headers = \"myHeader=myValue\") // <1>\n	public void findPet(@PathVariable String petId) {\nПараметры и заголовки. <1> Убедитесь, что `myHeader` равен `myValue`.\nВерсия API."}
{"id": 33, "text": "Не существует стандартного способа указать версию API, поэтому при включении управления версиями API в файле WeаbFlux Config, который вам нужен чтобы указать, как разрешить версию.\nКонфигурация WebFlux создает используется для сопоставления запросов.\nВерсия API.\nПосле включения управления версиями API вы можете начать сопоставлять запросы с версиями.\nАтрибут `@RequestMapping` `version` поддерживает следующее:\n- Фиксированная версия (\"1.2\") — соответствует только данной версии.\n- Базовая версия (\"1.2+\") — соответствует данной версии и выше.\n- Нет значения – соответствует любой версии, но заменяется более конкретной версией.\nВерсия API.\nЕсли несколько методов контроллера имеют версию, меньшую или равную версии запроса, рассматривается самая высокая из них и наиболее близкая к версии запроса, фактически заменяя все остальное.\nJava\n	@RestController\n	@RequestMapping(\"/account/{id}\")\n	public class AccountController {\n		@GetMapping // <1>\n		public Account getAccount() {\n		@GetMapping(version = \"1.1\") // <2>\n		public Account getAccount1_1() {\n		@GetMapping(version = \"1.2+\") // <3>\n		public Account getAccount1_2() {\n		@GetMapping(version = \"1.5\") // <4>\n		public Account getAccount1_5() {"}
{"id": 34, "text": "Чтобы проиллюстрировать это, рассмотрим следующие отображения:. <1> соответствует любой версии <2> соответствует версии 1.1 <3> соответствует версии 1.2 и выше <4> соответствует версии 1.5\n- (1) соответствует любой версии\n- (2) не соответствует\n- (3) соответствует версии 1.2 и выше и *выбирается* как максимальное совпадение\n- (4) выше и не соответствует\n- (1) соответствует любой версии\n- (2) не соответствует\n- (3) соответствует версии 1.2 и выше\n- (4) соответствует и *выбирается* как наибольшее совпадение\nДля запроса с версией `\"1.5\"`:.\nЗапрос с версией «1.6» не имеет совпадения. (1) и (3) совпадают, но заменено (4), которое допускает только строгое совпадение и, следовательно, не соответствует.\nВ этом сценарии исключение NotAcceptableApiVersionException приводит к ответу 400.\nДля запроса с версией `\"1.5\"`:.\nМетоды контроллера без версии предназначены для поддержки клиентов, созданных до была представлена версионная альтернатива.\nПоэтому, даже несмотря на то, что неверсионный контроллер метод считается подходящим для любой версии, фактически ему присваивается самый низкий приоритет, и фактически заменяется любым альтернативным методом контроллера с версией.\nДля запроса с версией `\"1.5\"`:.\nПРИМЕЧАНИЕ."}
{"id": 35, "text": "Вышеупомянутое предполагает, что версия запроса является иначе это потерпит неудачу.\nДля запроса с версией `\"1.5\"`:.\nСм.\nВерсии API для получения более подробной информации об основных инфраструктура и поддержка управления версиями API.\nЗАГОЛОВОК HTTP, ОПЦИИ. `@GetMapping` и `@RequestMapping(method=HttpMethod.GET)` поддерживают HTTP HEAD transparently for request mapping purposes.\nМетоды контроллера не должны меняться.\nОболочка ответа, применяемая в серверном адаптере HttpHandler, обеспечивает Content-Length.\nВ заголовке установлено количество байтов, записанных без фактической записи в ответ.\nЗАГОЛОВОК HTTP, ОПЦИИ.\nПо умолчанию HTTP OPTIONS обрабатывается путем установки заголовка ответа «Allow» в список HTTP-параметров. методы, перечисленные во всех методах @RequestMapping с соответствующими шаблонами URL.\nЗАГОЛОВОК HTTP, ОПЦИИ.\nДля `@RequestMapping` без объявлений метода HTTP заголовок `Allow` имеет значение `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`.\nМетоды контроллера всегда должны объявлять поддерживаемые методы HTTP (например, с помощью конкретных вариантов метода HTTP — `@GetMapping`, `@PostMapping` и другие).\nЗАГОЛОВОК HTTP, ОПЦИИ.\nВы можете явно сопоставить метод @RequestMapping с HTTP HEAD и HTTP OPTIONS, но это в обычном случае не требуется.\nПользовательские аннотации.\nSpring WebFlux поддерживает использование составных аннотаций для сопоставления запросов."}
{"id": 36, "text": "Это аннотации, которые сами по себе метааннотированы с помощью `@RequestMapping` и создан для повторного объявления подмножества (или всего) `@RequestMapping` атрибуты с более узкой и конкретной целью.\nПользовательские аннотации. `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` и `@PatchMapping` примеры составленных аннотаций.\nОни предусмотрены, потому что, возможно, большинство методы контроллера должны быть сопоставлены с конкретным методом HTTP, а не с использованием `@RequestMapping`, который по умолчанию соответствует всем методам HTTP.\nЕсли вам нужен пример реализации составленная аннотация, посмотрите, как они объявляются.\nПользовательские аннотации.\nПРИМЕЧАНИЕ. `@RequestMapping` нельзя использовать вместе с другими `@RequestMapping`. аннотации, объявленные для одного и того же элемента (класса, интерфейса или метода).\nЕсли в одном и том же элементе обнаружено несколько аннотаций `@RequestMapping`, появится предупреждение. регистрироваться, и будет использоваться только первое сопоставление.\nЭто касается и составных Аннотации `@RequestMapping`, такие как `@GetMapping`, `@PostMapping` и т. д.\nПользовательские аннотации.\nSpring WebFlux также поддерживает пользовательские атрибуты сопоставления запросов с пользовательским сопоставлением запросов. логика.\nЭто более продвинутый вариант, требующий создания подклассов.\nRequestMappingHandlerMapping и переопределение метода getCustomMethodCondition, где вы можете проверить пользовательский атрибут и вернуть свой собственный RequestCondition.\nЯвные регистрации."}
{"id": 37, "text": "Вы можете программно зарегистрировать методы Handler, которые можно использовать для динамических регистрации или в сложных случаях, например, разные экземпляры одного и того же обработчика под разными URL-адресами.\nВ следующем примере показано, как это сделать:\nJava\n	@Configuration\n	public class MyConfig {\n		@Autowired\n		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>\n				throws NoSuchMethodException {\n			RequestMappingInfo info = RequestMappingInfo\n					.paths(\"/user/{id}\").methods(RequestMethod.GET).build(); // <2>\n			Method method = UserHandler.class.getMethod(\"getUser\", Long.class); // <3>\n			mapping.registerMapping(info, handler, method); // <4>\nЯвные регистрации. <1> Внедрить целевые обработчики и сопоставление обработчиков для контроллеров. <2> Подготовьте метаданные сопоставления запроса. <3> Получите метод-обработчик. <4> Добавьте регистрацию.\n	@Configuration\n	class MyConfig {\n			mapping.registerMapping(info, handler, method) // <4>\nЯвные регистрации. <1> Внедрить целевые обработчики и сопоставление обработчиков для контроллеров. <2> Подготовьте метаданные сопоставления запроса. <3> Получите метод-обработчик. <4> Добавьте регистрацию.\n`@HttpExchange`."}
{"id": 38, "text": "Хотя основная цель `@HttpExchange` — для HTTP-сервиса. интерфейс службы HTTP, в котором размещаются такие аннотации, не зависит от контракта. для использования клиента и сервера.\nПомимо упрощения клиентского кода, есть еще случаи где интерфейс службы HTTP может быть удобным способом для серверов раскрыть свои API для клиентского доступа.\nЭто приводит к усилению связи между клиентом и сервером и часто не является хорошим выбором, особенно для общедоступных API, но может быть именно целью для внутреннего API.\nЭтот подход обычно используется в Spring Cloud, и именно поэтому `@HttpExchange` поддерживается как альтернатива `@RequestMapping` для серверной части. обработка в классах контроллера.\nJava\n	@HttpExchange(\"/persons\")\n	interface PersonService {\n		@GetExchange(\"/{id}\")\n		Person getPerson(@PathVariable Long id);\n		@PostExchange\n		void add(@RequestBody Person person);\n	@RestController\n	class PersonController implements PersonService {\n		public Person getPerson(@PathVariable Long id) {\n		@ResponseStatus(HttpStatus.CREATED)\n		public void add(@RequestBody Person person) {\n	@HttpExchange(\"/persons\")\n	interface PersonService {\n	@RestController\n	class PersonController : PersonService {"}
{"id": 39, "text": "Например:. `@HttpExchange` и `@RequestMapping` имеют различия. `@RequestMapping` может сопоставляться с любым количеством запросов по шаблонам путей, методам HTTP, и многое другое, в то время как `@HttpExchange` объявляет одну конечную точку с конкретным методом HTTP, путь и типы контента.\nНапример:.\nДля параметров метода и возвращаемых значений, как правило, `@HttpExchange` поддерживает подмножество параметров метода, которое выполняет `@RequestMapping`.\nПримечательно, что это исключает любые типы параметров, специфичные для серверной стороны.\nПодробности смотрите в списке"}
{"id": 40, "text": "Реакции на ошибки.\nОбщим требованием к службам REST является включение подробностей в текст ошибки. ответы.\nSpring Framework поддерживает «Подробности проблем для HTTP API». спецификация, {rfc-site}/rfc9457.html[RFC 9457].\n- `ProblemDetail` — представление подробностей проблемы RFC 9457; простой контейнер\nНиже приведены основные абстракции для этой поддержки:. как для стандартных полей, определенных в спецификации, так и для нестандартных.\n- `ErrorResponse` — контракт для предоставления подробностей ответа об ошибке HTTP, включая HTTP.\nНиже приведены основные абстракции для этой поддержки:. статус, заголовки ответа и тело в формате RFC 9457; это позволяет исключениям инкапсулировать и раскрывать подробности того, как они сопоставляются с ответом HTTP.\nВсе Spring WebFlux исключения реализуют это.\n- `ErrorResponseException` -- базовая реализация `ErrorResponse`, которую другие\nНиже приведены основные абстракции для этой поддержки:. можно использовать как удобный базовый класс.\n- `ResponseEntityExceptionHandler` -- удобный базовый класс для\nНиже приведены основные абстракции для этой поддержки:. и любое `ErrorResponseException` и отображает ответ об ошибке с телом.\nРендеринг.\nВы можете вернуть «ProblemDetail» или «ErrorResponse» из любого «@ExceptionHandler» или из любой метод @RequestMapping для обработки ответа RFC 9457.\nЭто обрабатывается следующим образом:\n- Свойство `status` `ProblemDetail` определяет статус HTTP."}
{"id": 41, "text": "- Свойство `instance` для `ProblemDetail` устанавливается на основе текущего URL-пути, если это не так.\nРендеринг. уже установлен.\n- Конвертеры сообщений Jackson JSON и XML используют «application/problem+json» или\nРендеринг. «application/problem+xml» соответственно в качестве типов воспроизводимых носителей для «ProblemDetail». чтобы гарантировать, что им будет отдано предпочтение при обсуждении содержания.\nРендеринг.\nЧтобы включить ответы RFC 9457 для исключений Spring WebFlux и для любых `ErrorResponseException`, расширьте `ResponseEntityExceptionHandler` и объявите его как имеет метод @ExceptionHandler, который обрабатывает любое исключение ErrorResponse, которое включает все встроенные веб-исключения.\nВы можете добавить больше методов обработки исключений и используйте защищенный метод для сопоставления любого исключения с «ProblemDetail».\nРендеринг.\nВы можете зарегистрировать перехватчики `ErrorResponse` через любой ответ RFC 9457 и предпримите какие-либо действия.\nНестандартные поля.\nВы можете расширить ответ RFC 9457 нестандартными полями одним из двух способов.\nНестандартные поля.\nВо-первых, вставьте в «свойства» «Карту» «ProblemDetail».\nПри использовании Джексона библиотека, Spring Framework регистрирует `ProblemDetailJacksonMixin`, который обеспечивает это «Свойства» `Карта` разворачивается и отображается как свойства JSON верхнего уровня в ответ, и аналогично любое неизвестное свойство во время десериализации вставляется в эта `Карта`.\nНестандартные поля.\nВы также можете расширить «ProblemDetail», чтобы добавить специальные нестандартные свойства."}
{"id": 42, "text": "Конструктор копирования в «ProblemDetail» позволяет упростить создание подкласса. из существующего «ProblemDetail».\nЭто можно сделать централизованно, например, из `@ControllerAdvice`, например `ResponseEntityExceptionHandler`, который воссоздает `ProblemDetail` исключения в подкласс с дополнительными нестандартными полями.\nНестандартные поля.\nСОВЕТ: В Spring Boot свойство Spring.webflux.problemdetails.enabled настраивается автоматически. `ResponseEntityExceptionHandler`, который обрабатывает встроенные исключения с подробностями проблемы.\nВ этом случае вы можете предпочесть создать еще один `@ControllerAdvice` вместо расширения `ResponseEntityExceptionHandler`, если вы хотите взять на себя обработку определенного встроенное исключение.\nВам необходимо убедиться, что ваш обработчик заказан раньше, чем тот, который настроенный Spring Boot, порядок которого равен 0.\nКастомизация и i18n.\nОбщепринятым требованием является настройка и интернационализация сведений об ошибках.\nТакже рекомендуется настроить детали проблемы для исключений Spring WebFlux. чтобы не раскрывать детали реализации.\nВ этом разделе описывается поддержка этого.\nКастомизация и i18n. `ErrorResponse` предоставляет коды сообщения для «типа», «заголовка» и «детали», а также Аргументы кода сообщения для поля «подробности». `ResponseEntityExceptionHandler` разрешает это через MessageSource и соответствующим образом обновляет соответствующие поля «ProblemDetail».\n`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. `ErrorResponse` может предоставлять более одного кода сообщения, обычно с добавлением суффикса. к коду сообщения по умолчанию."}
{"id": 43, "text": "В таблице ниже перечислены коды сообщений и аргументы для Исключения Spring WebFlux:\n`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. [cols=\"1,1,2\", options=\"header\"] |=== | Исключение | Код сообщения | Аргументы кода сообщения\n`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `HandlerMethodValidationException` | (по умолчанию) | `+{0}+` выводит список всех ошибок проверки.\nКоды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.\n`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `MethodNotAllowedException` | (по умолчанию) | `+{0}+` текущий метод HTTP, `+{1}+` список поддерживаемых методов HTTP\n`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `MissingRequestValueException` | (по умолчанию) | `+{0}+` метка значения (например, «заголовок запроса», «значение файла cookie»,...), `+{1}+` имя значения"}
{"id": 44, "text": "`problemDetail.[тип|название|деталь].[полное имя класса исключения]`. | `NotAcceptableStatusException` | (по умолчанию) | `+{0}+` список поддерживаемых типов мультимедиа\n| `NotAcceptableStatusException` | (по умолчанию) + «.parseError». | `ServerErrorException` | (по умолчанию) | `+{0}+` причина сбоя, указанная конструктору класса\n| `NotAcceptableStatusException` | (по умолчанию) + «.parseError». | `UnsupportedMediaTypeStatusException` | (по умолчанию) | `+{0}+` тип носителя, который не поддерживается, `+{1}+` список поддерживаемых типов мультимедиа\n| `UnsatisfiedRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра. | `WebExchangeBindException` | (по умолчанию) | `+{0}+` список глобальных ошибок, `+{1}+` список ошибок полей.\nКоды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.\n| `UnsatisfiedRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра. | `NoResourceFoundException` | (по умолчанию) | `+{0}+` путь запроса (или его часть), используемый для поиска ресурса"}
{"id": 45, "text": "| `UnsatisfiedRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра.\nПРИМЕЧАНИЕ.\nВ отличие от других исключений, аргументы сообщения для `WebExchangeBindException` и `HandlerMethodValidationException` основаны на списке Ошибки MessageSourceResolvable, которые также можно настроить с помощью пакет ресурсов.\nСм. для более подробной информации.\nОбработка клиентов.\nКлиентское приложение может перехватить исключение WebClientResponseException при использовании WebClient. или RestClientResponseException при использовании RestTemplate и используйте их `getResponseBodyAs` для декодирования тела ответа об ошибке в любой целевой тип, например `ProblemDetail` или подкласс `ProblemDetail`."}
{"id": 46, "text": "Валидация.\nSpring WebFlux имеет встроенный Validation для Методы `@RequestMapping`, включая Проверка Java Bean.\nВалидация может применяться на одном из двух уровней:\n1. Проверка Java Bean применяется индивидуально к\nВалидация. с аннотацией `@jakarta.validation.Valid` или `@Validated` Spring, если это командный объект, а не контейнер, такой как «Карта» или «Коллекция», он не имеют `Errors` или `BindingResult` сразу после сигнатуры метода и не имеют в противном случае потребуется проверка метода (см. далее). `WebExchangeBindException` — это исключение, возникающее при индивидуальной проверке параметра метода.\n2. Проверка Java Bean применяется к методу, когда аннотации @Constraint, такие как\nВалидация. `@Min`, `@NotBlank` и другие объявляются непосредственно в параметрах метода или в метод для возвращаемого значения, и он заменяет любую проверку, которая будет применяться в противном случае к параметру метода индивидуально, поскольку проверка метода охватывает оба ограничения параметров метода и вложенные ограничения через `@Valid`. `HandlerMethodValidationException` — это исключение, при котором применяется проверка. к методу.\nВалидация.\nПриложения должны обрабатывать как WebExchangeBindException, так и `HandlerMethodValidationException`, поскольку любое из них может быть вызвано в зависимости от контроллера. подпись метода.\nОднако эти два исключения очень похожи и могут быть обрабатывается практически идентичным кодом."}
{"id": 47, "text": "Основное отличие состоит в том, что первый предназначен для одного объект, а последний — для списка параметров метода.\nВалидация.\nПРИМЕЧАНИЕ. `@Valid` — это не аннотация ограничения, а скорее для вложенных ограничений внутри Объект.\nСледовательно, `@Valid` сам по себе не приводит к проверке метода. `@NotNull` с другой стороны, это ограничение, и добавление его к параметру @Valid приводит к методу проверка.\nВ частности, для возможности обнуления вы также можете использовать флаг `required` `@RequestBody` или `@ModelAttribute`.\nВалидация.\nПроверка метода может использоваться в сочетании с методом «Errors» или «BindingResult». параметры.\nОднако метод контроллера вызывается только в том случае, если включены все ошибки проверки. параметры метода с `Errors` сразу после них.\nЕсли есть ошибки проверки на любой другой параметр метода, тогда возникает HandlerMethodValidationException.\nВалидация.\nВы можете настроить «Валидатор» глобально через с помощью метода @InitBinder в `@Controller` или `@ControllerAdvice`.\nВы также можете использовать несколько валидаторов.\nВалидация.\nПРИМЕЧАНИЕ.\nЕсли контроллер имеет уровень класса @Validated, то через прокси-сервер АОП.\nЧтобы воспользоваться встроенной поддержкой Spring MVC для проверка метода добавлена в Spring Framework 6.1, вам необходимо удалить уровень класса Аннотация `@Validated` от контроллера.\nВалидация."}
{"id": 48, "text": "В разделе «Ответы на ошибки» представлена дополнительная информация. подробности о том, как `WebExchangeBindException` и `HandlerMethodValidationException` обрабатываются, а также то, как их рендеринг можно настроить с помощью MessageSource и пакеты ресурсов, специфичные для локали и языка.\nВалидация.\nДля дальнейшей обработки ошибок проверки метода вы можете расширить `ResponseEntityExceptionHandler` или используйте метод `@ExceptionHandler` в контроллере. или в `@ControllerAdvice` и напрямую обрабатывать `HandlerMethodValidationException`.\nИсключение содержит список ParameterValidationResult, которые группируют ошибки проверки. по параметру метода.\nВы можете либо перебрать их, либо предоставить посетителю обратный вызов. методы по типу параметра метода контроллера:\nJava\n	HandlerMethodValidationException ex = ... ;\n	ex.visitResults(new HandlerMethodValidationException.Visitor() {\n		@Override\n		public void requestHeader(RequestHeader requestHeader, ParameterValidationResult result) {\n		@Override\n		public void requestParam(@Nullable RequestParam requestParam, ParameterValidationResult result) {\n		@Override\n		public void modelAttribute(@Nullable ModelAttribute modelAttribute, ParameterErrors errors) {\n		@Override\n		public void other(ParameterValidationResult result) {"}
{"id": 49, "text": "`@Контроллер`.\nВы можете определить bean-компоненты контроллера, используя стандартное определение bean-компонента Spring.\nСтереотип @Controller обеспечивает автоматическое обнаружение и соответствует общей поддержке Spring. для обнаружения классов `@Component` в пути к классам и автоматической регистрации определений компонентов для них.\nОн также действует как стереотип для аннотируемого класса, указывая на его роль как веб-компонент.\n`@Контроллер`.\nЧтобы включить автоматическое обнаружение таких bean-компонентов `@Controller`, вы можете добавить сканирование компонентов в вашей конфигурации Java, как показано в следующем примере:\nJava\n	@Configuration\n	@ComponentScan(\"org.example.web\") // <1>\n	public class WebConfiguration {\n`@Контроллер`. <1> Сканируйте пакет `org.example.web`.\n	@Configuration\n	@ComponentScan(\"org.example.web\") // <1>\n	class WebConfiguration {\n`@Контроллер`. <1> Сканируйте пакет `org.example.web`.\n`@Контроллер`. `@RestController` — это составная аннотация, которая мета-аннотации `@Controller` и `@ResponseBody`, обозначающие контроллер, чей каждый метод наследует аннотацию @ResponseBody уровня типа и, следовательно, записывает непосредственно в тело ответа, а не разрешение просмотра и рендеринг с помощью HTML-шаблона.\nАОП-прокси."}
{"id": 50, "text": "В некоторых случаях вам может потребоваться дополнить контроллер прокси-сервером AOP во время выполнения.\nОдним из примеров является то, что вы решили разместить аннотации @Transactional непосредственно на контроллер.\nВ этом случае, особенно для контроллеров, мы рекомендуем использование проксирования на основе классов.\nЭто автоматически происходит с такими аннотациями. непосредственно на контроллере.\nАОП-прокси.\nЕсли контроллер реализует интерфейс и нуждается в проксировании AOP, вам может потребоваться явно настроить проксирование на основе классов.\nНапример, с помощью `@EnableTransactionManagement` вы можете изменить на `@EnableTransactionManagement(proxyTargetClass = true)`, и с помощью `<tx:annotation-driven/>` вы можете изменить на `<tx:annotation-driven proxy-target-class=\"true\"/>`.\nАОП-прокси.\nПРИМЕЧАНИЕ.\nИмейте в виду, что начиная с версии 6.0 при проксировании интерфейса Spring WebFlux больше не обнаруживает контроллеры, основанные исключительно на аннотации @RequestMapping на уровне типа в интерфейсе.\nПожалуйста, включите проксирование на основе классов, иначе интерфейс также должен иметь Аннотация `@Controller`."}
{"id": 51, "text": "Конфигурация контейнера на основе аннотаций.\nSpring обеспечивает комплексную поддержку конфигурации на основе аннотаций, работая на метаданные в самом классе компонента, используя аннотации соответствующего класса, метод или объявление поля.\nКак упоминалось в Spring использует BeanPostProcessors в сочетании с аннотациями для создания ядра IOC. контейнер знает о конкретных аннотациях.\nКонфигурация контейнера на основе аннотаций.\nНапример, `@Autowired` аннотация предоставляет те же возможности, что описаны в с более детальным контролем и более широкой применимостью.\nКроме того, Spring предоставляет поддержка аннотаций JSR-250, таких как `@PostConstruct` и `@PreDestroy`, а также поддержка аннотаций JSR-330 (внедрение зависимостей для Java), содержащихся в пакет `jakarta.inject`, например `@Inject` и `@Named`.\nПодробности об этих аннотациях можно найти в соответствующий раздел.\nКонфигурация контейнера на основе аннотаций. [ПРИМЕЧАНИЕ] = Внедрение аннотаций выполняется до внедрения внешних свойств.\nТаким образом, внешние конфигурация (например, свойства bean-компонента, указанные в XML) эффективно переопределяет аннотации для объектов недвижимости при использовании смешанных подходов.\nКонфигурация контейнера на основе аннотаций.\nТехнически вы можете зарегистрировать постпроцессоры как отдельные определения компонентов, но они уже неявно зарегистрированы в AnnotationConfigApplicationContext.\nКонфигурация контейнера на основе аннотаций.\nВ настройке Spring на основе XML вы можете включить следующий тег конфигурации, чтобы включить смешивание и сопоставление с конфигурацией на основе аннотаций:"}
{"id": 52, "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<context:annotation-config/>\n	</beans>\n* {spring-framework-api}/context/annotation/ConfigurationClassPostProcessor.html[`ConfigurationClassPostProcessor`]\n* {spring-framework-api}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`]\n* {spring-framework-api}/context/annotation/CommonAnnotationBeanPostProcessor.html[`CommonAnnotationBeanPostProcessor`]\n* {spring-framework-api}/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html[`PersistenceAnnotationBeanPostProcessor`]"}
{"id": 53, "text": "* {spring-framework-api}/context/event/EventListenerMethodProcessor.html[`EventListenerMethodProcessor`]\nЭлемент `<context:annotation-config/>` неявно регистрирует следующие постпроцессоры:. [ПРИМЕЧАНИЕ] = `<context:annotation-config/>` ищет только аннотации к bean-компонентам в одном и том же контекст приложения, в котором он определен.\nЭто означает, что если вы поставите `<context:annotation-config/>` в `WebApplicationContext` для `DispatcherServlet`, он проверяет только bean-компоненты `@Autowired` в ваших контроллерах, а не в ваших службах.\nСм."}
{"id": 54, "text": "Использование `@Transactional`.\nВ дополнение к декларативному подходу к конфигурации транзакций на основе XML вы можете используйте подход, основанный на аннотациях.\nОбъявление семантики транзакции непосредственно в Java исходный код помещает объявления намного ближе к затронутому коду.\nСуществует не так много опасность ненужной связанности, поскольку код, предназначенный для транзакционного использования, В любом случае почти всегда развертывается таким образом.\nИспользование `@Transactional`.\nПРИМЕЧАНИЕ.\nСтандартная аннотация `jakarta.transaction.Transactional` также поддерживается как замена собственной аннотации Spring.\nПожалуйста, обратитесь к документации JTA. для более подробной информации.\nИспользование `@Transactional`.\nПростота использования, обеспечиваемая использованием аннотации @Transactional, является лучшей. иллюстрируется примером, который поясняется в следующем тексте.\nРассмотрим следующее определение класса:\nJava\n	// класс обслуживания, который мы хотим сделать транзакционным\n	@Transactional\n	public class DefaultFooService implements FooService {\n		@Override\n		public Foo getFoo(String fooName) {\n		@Override\n		public Foo getFoo(String fooName, String barName) {\n		@Override\n		public void insertFoo(Foo foo) {\n		@Override\n		public void updateFoo(Foo foo) {\n	// класс обслуживания, который мы хотим сделать транзакционным\n	@Transactional\n	class DefaultFooService : FooService {\nИспользование `@Transactional`.\nИспользуемая на уровне класса, как указано выше, аннотация указывает значение по умолчанию для всех методов. объявляющего класса (а также его подклассов).\nАльтернативно, каждый метод может быть аннотировано индивидуально."}
{"id": 55, "text": "См. для получения более подробной информации о том, какие методы Spring считает транзакционными.\nОбратите внимание, что уровень класса аннотация не применяется к классам-предкам вверх по иерархии классов; в таком сценарии, унаследованные методы необходимо локально переобъявить, чтобы участвовать в аннотация уровня подкласса.\nИспользование `@Transactional`.\nКогда класс POJO, такой как приведенный выше, определяется как компонент в контексте Spring, вы можете сделать экземпляр компонента транзакционным через `@EnableTransactionManagement` аннотация в классе @Configuration.\nСм. {spring-framework-api}/transaction/annotation/EnableTransactionManagement.html[javadoc] для получения полной информации.\n	<!-- from the file 'context.xml' -->\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans"}
{"id": 56, "text": "https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<!-- this is the service object that we want to make transactional -->\n		<bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n		<!-- enable the configuration of transactional behavior based on annotations -->\n		<!-- a TransactionManager is still required -->\n		<tx:annotation-driven transaction-manager=\"txManager\"/> <1>\n		<bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n			<!-- (this dependency is defined somewhere else) -->\n			<property name=\"dataSource\" ref=\"dataSource\"/>\n		</bean>\n		<!-- other <bean/> definitions here -->\n	</beans>"}
{"id": 57, "text": "В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. <1> Строка, которая делает экземпляр компонента транзакционным.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nСОВЕТ: Вы можете опустить атрибут `transaction-manager` в `<tx:annotation-driven/>`. тег, если имя bean-компонента TransactionManager, к которому вы хотите подключиться, имеет имя `Менеджер транзакций`.\nЕсли bean-компонент TransactionManager, в который вы хотите внедрить зависимость, имеет любое другое имя, вам необходимо использовать атрибут `transaction-manager`, как в предыдущий пример.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nРеактивные транзакционные методы используют реактивные типы возврата в отличие от императивных. порядок программирования, как показано в следующем листинге:\nJava\n	// класс реактивного обслуживания, который мы хотим сделать транзакционным\n	@Transactional\n	public class DefaultFooService implements FooService {\n		@Override\n		public Publisher<Foo> getFoo(String fooName) {\n		@Override\n		public Mono<Foo> getFoo(String fooName, String barName) {\n		@Override\n		public Mono<Void> insertFoo(Foo foo) {\n		@Override\n		public Mono<Void> updateFoo(Foo foo) {\n	// класс реактивного обслуживания, который мы хотим сделать транзакционным\n	@Transactional\n	class DefaultFooService : FooService {"}
{"id": 58, "text": "В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nОбратите внимание, что для возвращаемого «Издателя» существуют особые соображения в отношении Сигналы отмены реактивных потоков.\nСм. раздел «Использование TransactionalOperator» для получения более подробной информации.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. .Видимость метода и `@Transactional` в режиме прокси. [ПРИМЕЧАНИЕ] = Аннотация `@Transactional` обычно используется для методов с `публичной` видимостью.\nНачиная с версии 6.0, «защищенные» или видимые для пакета методы также можно сделать транзакционными для прокси на основе классов по умолчанию.\nОбратите внимание, что транзакционные методы в интерфейсах прокси всегда должны быть «публичными» и определены в прокси-интерфейсе.\nДля обоих видов из прокси перехватываются только вызовы внешних методов, поступающие через прокси.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nЕсли вы предпочитаете единообразную обработку видимости метода для различных типов прокси (которые использовались по умолчанию до версии 5.3), рассмотрите возможность указания publicMethodsOnly:\n	 * Зарегистрируйте пользовательский AnnotationTransactionAttributeSource с помощью\n	 * publicMethodsOnly flag set to true to consistently ignore non-public methods.\n	 * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()\n	@Bean\n	TransactionAttributeSource transactionAttributeSource() {\n		return new AnnotationTransactionAttributeSource(true);"}
{"id": 59, "text": "В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. _Spring TestContext Framework_ поддерживает неприватные методы тестирования `@Transactional`. по умолчанию также.\nСм. ссылку:testing/testcontext-framework/tx.adoc [Управление транзакциями]. примеры в главе о тестировании.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nВы можете применить аннотацию @Transactional к определению интерфейса, методу в интерфейсе, определении класса или методе класса.\nОднако само присутствие аннотации @Transactional недостаточно для активации транзакционного поведения.\nАннотация `@Transactional` — это просто метаданные, которые могут использоваться соответствующими инфраструктура времени выполнения, которая использует эти метаданные для настройки соответствующих bean-компонентов с помощью транзакционное поведение.\nВ предыдущем примере элемент `<tx:annotation-driven/>` включает фактическое управление транзакциями во время выполнения.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nСОВЕТ: Команда Spring рекомендует аннотировать методы конкретных классов с помощью Аннотация `@Transactional` вместо того, чтобы полагаться на аннотированные методы в интерфейсах, даже если последний работает для прокси-серверов на основе интерфейса и целевого класса, начиная с версии 5.0."}
{"id": 60, "text": "Поскольку аннотации Java не наследуются от интерфейсов, аннотации, объявленные в интерфейсе по-прежнему не распознаются инфраструктурой плетения при использовании режима AspectJ, поэтому аспект не применяется.\nКак следствие, ваши аннотации транзакций могут быть молча игнорируется: может показаться, что ваш код «работает», пока вы не протестируете сценарий отката.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nПРИМЕЧАНИЕ.\nВ режиме прокси (который используется по умолчанию) через прокси перехватываются.\nЭто означает, что самовызов (по сути, метод внутри целевой объект, вызывающий другой метод целевого объекта) не приводит к фактическому транзакция во время выполнения, даже если вызванный метод помечен `@Transactional`.\nКроме того, прокси-сервер должен быть полностью инициализирован, чтобы обеспечить ожидаемое поведение, поэтому вам не следует используйте эту функцию в своем коде инициализации, например, в методе @PostConstruct.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nРассмотрите возможность использования режима AspectJ (см. атрибут `mode` в следующей таблице), если вы ожидайте, что самовызовы также будут обернуты транзакциями.\nВ этом случае существует вообще нет прокси.\nВместо этого целевой класс вплетается (то есть его байт-код изменен) для поддержки поведения `@Transactional` во время выполнения для любого метода."}
{"id": 61, "text": "В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. .Настройки транзакций, управляемых аннотациями. |=== | XML-атрибут | Атрибут аннотации | По умолчанию| Описание\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `менеджер транзакций` | Н/Д (см. {spring-framework-api}/transaction/annotation/TransactionManagementConfigurer.html[`TransactionManagementConfigurer`] javadoc) | `транзакционный менеджер` | Имя используемого менеджера транзакций.\nТребуется только в том случае, если имя транзакции менеджер не является «transactionManager», как в предыдущем примере.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `режим` | `прокси` | Режим по умолчанию («прокси») обрабатывает аннотированные bean-компоненты для проксирования с использованием Spring AOP. framework (следуя семантике прокси, как обсуждалось ранее, применительно к вызовам методов вход только через прокси).\nАльтернативный режим («aspectj») вместо этого вплетает затронутые классы с аспектом транзакции Spring AspectJ, изменяя целевой класс байт-код для применения к любому вызову метода."}
{"id": 62, "text": "Для плетения AspectJ требуется `spring-aspects.jar` в пути к классам, а также включено переплетение во время загрузки (или переплетение во время компиляции). (Подробную информацию см. в конфигурация Spring). о том, как настроить переплетение во время загрузки.)\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `прокси-целевой класс` | `proxyTargetClass` | `ложь` | Применяется только к режиму «прокси».\nКонтролирует, какой тип транзакционных прокси создается. для классов, помеченных аннотацией @Transactional.\nЕсли `proxy-target-class` атрибуту присвоено значение true, создаются прокси на основе классов.\nЕсли `proxy-target-class` `false` или если атрибут опущен, то стандартные прокси на основе интерфейса JDK создано. (Подробное описание см. в Механизмы проксирования). различных типов прокси.)\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:. | `заказ` | `Упорядочено.LOWEST_PRECEDENCE` | Определяет порядок рекомендаций по транзакции, которые применяются к компонентам, помеченным с помощью `@Transactional`. (Подробнее о правилах заказа АОП совет, см.\nУпорядочение советов.) Отсутствие определенного порядка означает, что подсистема АОП определяет порядок рекомендаций. |==="}
{"id": 63, "text": "В конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nПРИМЕЧАНИЕ.\nРежим рекомендаций по умолчанию для обработки аннотаций `@Transactional` — это `прокси`. что позволяет перехватывать звонки только через прокси.\nМестные звонки в пределах тот же класс не может быть перехвачен таким образом.\nДля более продвинутого режима перехвата рассмотрите возможность переключения в режим aspectj в сочетании с переплетением во время компиляции или во время загрузки.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nПРИМЕЧАНИЕ.\nАтрибут proxy-target-class определяет тип транзакционных прокси. создан для классов, помеченных аннотацией @Transactional.\nЕсли Для `proxy-target-class` установлено значение `true`, создаются прокси на основе классов.\nЕсли `proxy-target-class` имеет значение `false` или, если атрибут опущен, стандартный JDK. создаются прокси на основе интерфейса. (См.\nМеханизмы проксирования для обсуждения различных типов прокси.)\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nПРИМЕЧАНИЕ. `@EnableTransactionManagement` и `<tx:annotation-driven/>` ищут `@Transactional` только для bean-компонентов в том же контексте приложения, в котором они определены."}
{"id": 64, "text": "Это означает, что если вы поместите конфигурацию, управляемую аннотациями, в `WebApplicationContext` для DispatcherServlet он проверяет bean-компоненты @Transactional только в ваших контроллерах. и не в ваших услугах.\nДополнительную информацию см. в MVC.\nВ конфигурации XML тег `<tx:annotation-driven/>` обеспечивает аналогичное удобство:.\nНаиболее производное местоположение имеет приоритет при оценке настроек транзакций. для метода.\nВ следующем примере класс DefaultFooService аннотируется на уровне класса настройками транзакции только для чтения, но Аннотация `@Transactional` для метода `updateFoo(Foo)` в том же классе принимает приоритет над настройками транзакций, определенными на уровне класса.\nJava\n	@Transactional(readOnly = true)\n	public class DefaultFooService implements FooService {\n		public Foo getFoo(String fooName) {\n		// эти настройки имеют приоритет для этого метода\n		@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)\n		public void updateFoo(Foo foo) {\n	@Transactional(readOnly = true)\n	class DefaultFooService : FooService {\n`@Transactional` Настройки.\nАннотация `@Transactional` — это метаданные, указывающие, что интерфейс, класс, или метод должен иметь транзакционную семантику (например, «запустить новый файл только для чтения»). транзакция при вызове этого метода, приостанавливая любую существующую транзакцию\").\nНастройки `@Transactional` по умолчанию следующие:\n* Параметр распространения — PROPAGATION_REQUIRED.\n* Уровень изоляции — `ISOLATION_DEFAULT.`"}
{"id": 65, "text": "* Транзакция является чтение-запись.\n* Тайм-аут транзакции по умолчанию равен тайм-ауту по умолчанию базовой транзакции.\n`@Transactional` Настройки. системе или нет, если таймауты не поддерживаются.\n* Любое `RuntimeException` или `Error` вызывает откат, а любое отмеченное `Exception` вызывает откат.\n`@Transactional` Настройки. нет.\n`@Transactional` Настройки.\nВы можете изменить эти настройки по умолчанию.\nВ следующей таблице суммированы различные свойства аннотации @Transactional:\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | value | `Строка` | Необязательный квалификатор, указывающий используемый менеджер транзакций.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `транзакционный менеджер` | `Строка` | Псевдоним для `value`.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `этикетка` | Массив меток String для добавления выразительного описания транзакции. | Метки могут оцениваться менеджерами транзакций, чтобы связать поведение, специфичное для реализации, с фактической транзакцией.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | распространение | `enum`: `Распространение` | Дополнительная настройка распространения."}
{"id": 66, "text": ".@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `изоляция` | `enum`: `Изоляция` | Дополнительный уровень изоляции.\nПрименяется только к значениям распространения REQUIRED или REQUIRES_NEW.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `тайм-аут` | `int` (детализация в секундах) | Необязательный тайм-аут транзакции.\nПрименяется только к значениям распространения REQUIRED или REQUIRES_NEW.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `timeoutString` | `String` (детализация в секундах) | Альтернатива указанию тайм-аута в секундах в виде значения String, например, в качестве заполнителя.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `только для чтения` | `логическое значение` | Транзакция чтения-записи в сравнении с транзакцией только чтения.\nПрименимо только к значениям REQUIRED или REQUIRES_NEW.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `rollbackFor` | Массив объектов Class, который должен быть производным от Throwable. | Необязательный массив типов исключений, которые должны вызывать откат.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `rollbackForClassName` | Массив шаблонов имен исключений. | Необязательный массив шаблонов имен исключений, которые должны вызывать откат."}
{"id": 67, "text": ".@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `noRollbackFor` | Массив объектов Class, который должен быть производным от Throwable. | Необязательный массив типов исключений, которые не должны вызывать откат.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. | `noRollbackForClassName` | Массив шаблонов имен исключений. | Необязательный массив шаблонов имен исключений, которые не должны вызывать откат. |===\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание.\nСОВЕТ: См. для получения более подробной информации о семантике, шаблонах и предупреждениях правил отката. относительно возможных непреднамеренных совпадений с правилами отката на основе шаблонов.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание. [ПРИМЕЧАНИЕ] = Начиная с версии 6.2, вы можете глобально изменить поведение отката по умолчанию, например, с помощью `@EnableTransactionManagement(rollbackOn=ALL_EXCEPTIONS)`, приводящий к откату для всех исключений, возникших в транзакции, включая любое проверенное исключение.\nДля дальнейшей настройки AnnotationTransactionAttributeSource предоставляет `addDefaultRollbackRule(RollbackRuleAttribute)` для пользовательских правил по умолчанию.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание.\nОбратите внимание, что правила отката для конкретных транзакций переопределяют поведение по умолчанию, но сохраните выбранное значение по умолчанию для неуказанных исключений."}
{"id": 68, "text": "Это относится к Spring `@Transactional`, а также `jakarta.transaction.Transactional` JTA аннотация.\n.@Настройки транзакций |=== | Недвижимость| Тип| Описание.\nВ настоящее время вы не можете явно контролировать имя транзакции, где «имя» означает имя транзакции, которое отображается в мониторе транзакций и в выходных данных журнала.\nДля декларативных транзакций имя транзакции всегда является полным классом. имя транзакционно рекомендуемого класса + `.` + имя метода.\nНапример, если Метод handlePayment(..) класса BusinessService запустил транзакцию, имя транзакции будет `com.example.BusinessService.handlePayment`.\nНесколько менеджеров транзакций с `@Transactional`.\nБольшинству приложений Spring нужен только один менеджер транзакций, но может быть и ситуации, когда вам нужно несколько независимых менеджеров транзакций в одном приложение.\nВы можете использовать атрибут `value` или `transactionManager` Аннотация `@Transactional` для опционального указания личности `TransactionManager`, который будет использоваться.\nЭто может быть имя компонента или значение квалификатора. компонента менеджера транзакций.\nНапример, используя квалификатор, вы можете объедините следующий код Java со следующими объявлениями компонентов менеджера транзакций в контексте приложения:\nJava\n	public class TransactionalService {\n		@Transactional(\"order\")\n		public void setSomething(String name) { ... }\n		@Transactional(\"account\")\n		public void doSomething() { ... }"}
{"id": 69, "text": "@Transactional(\"reactive-account\")\n		public Mono<Void> doSomethingReactive() { ... }\n	class TransactionalService {\n	<tx:annotation-driven/>\n		<bean id=\"transactionManager1\" class=\"org.springframework.jdbc.support.JdbcTransactionManager\">\n			<qualifier value=\"order\"/>\n		</bean>\n		<bean id=\"transactionManager2\" class=\"org.springframework.jdbc.support.JdbcTransactionManager\">\n			<qualifier value=\"account\"/>\n		</bean>\n		<bean id=\"transactionManager3\" class=\"org.springframework.data.r2dbc.connection.R2dbcTransactionManager\">\n			<qualifier value=\"reactive-account\"/>\n		</bean>\nВ следующем листинге показаны объявления bean-компонентов:.\nВ этом случае отдельные методы TransactionalService выполняются под отдельными менеджеры транзакций, различающиеся по «заказу», «счету» и «реактивному счету». отборочные.\nИмя целевого компонента по умолчанию `<tx:annotation-driven>`, `transactionManager`, по-прежнему используется, если не найден специально определенный bean-компонент TransactionManager.\nВ следующем листинге показаны объявления bean-компонентов:. [СОВЕТ] = Если все транзакционные методы одного класса имеют один и тот же квалификатор, рассмотрите объявление уровня типа `org.springframework.beans.factory.annotation.Qualifier` вместо этого аннотация."}
{"id": 70, "text": "Если его значение соответствует значению квалификатора (или имени компонента) конкретный менеджер транзакций, для которого будет использоваться этот менеджер транзакций определения транзакций без специального квалификатора в самом `@Transactional`.\nВ следующем листинге показаны объявления bean-компонентов:.\nТакой квалификатор уровня типа может быть объявлен в конкретном классе, применяясь к определения транзакций из базового класса.\nЭто эффективно переопределяет выбор менеджера транзакций по умолчанию для любых неквалифицированных методов базового класса.\nВ следующем листинге показаны объявления bean-компонентов:.\nИ последнее, но не менее важное: такой квалификатор bean-компонента на уровне типа может служить нескольким целям: например, со значением «order» его можно использовать для целей автоматического подключения (идентификации хранилище заказов), а также выбор менеджера транзакций, если целевые bean-компоненты для автоматического подключения, а также связанный с ним менеджер транзакций определения декларируют одно и то же значение квалификатора.\nТакое значение квалификатора необходимо только быть уникальным в наборе bean-компонентов, соответствующих типам, и не обязательно служить идентификатором.\nПользовательские аннотации.\nЕсли вы обнаружите, что неоднократно используете одни и те же атрибуты с `@Transactional` в разных методах, позволяет вам определять пользовательские аннотации для ваших конкретных случаев использования.\nНапример, рассмотрим следующие определения аннотаций:\nJava\n	@Target({ElementType.METHOD, ElementType.TYPE})\n	@Retention(RetentionPolicy.RUNTIME)"}
{"id": 71, "text": "@Transactional(transactionManager = \"order\", label = \"causal-consistency\")\n	public @interface OrderTx {\n	@Target({ElementType.METHOD, ElementType.TYPE})\n	@Retention(RetentionPolicy.RUNTIME)\n	@Transactional(transactionManager = \"account\", label = \"retryable\")\n	public @interface AccountTx {\n	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\n	@Retention(AnnotationRetention.RUNTIME)\n	@Transactional(transactionManager = \"order\", label = [\"causal-consistency\"])\n	annotation class OrderTx\n	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\n	@Retention(AnnotationRetention.RUNTIME)\n	@Transactional(transactionManager = \"account\", label = [\"retryable\"])\n	annotation class AccountTx\nJava\n	public class TransactionalService {\n		@OrderTx\n		public void setSomething(String name) {\n		@AccountTx\n		public void doSomething() {\n	class TransactionalService {\nПредыдущие аннотации позволяют записать пример из предыдущего раздела следующим образом:.\nВ предыдущем примере мы использовали синтаксис для определения квалификатора менеджера транзакций. и транзакционные метки, но мы могли бы также включить поведение распространения, правила отката, таймауты и другие функции."}
{"id": 72, "text": "Spring AOP API.\nВ предыдущей главе описывалась поддержка АОП в Spring с помощью @AspectJ и схемы на основе схем. определения аспектов.\nВ этой главе мы обсуждаем API-интерфейсы Spring AOP нижнего уровня.\nДля общего приложениях мы рекомендуем использовать Spring AOP с точками AspectJ, как описано в предыдущая глава."}
{"id": 73, "text": "Аспектно-ориентированное программирование с помощью Spring.\nАспектно-ориентированное программирование (АОП) дополняет объектно-ориентированное программирование (ООП). обеспечивая другой способ мышления о структуре программы.\nКлючевой элемент модульности в ООП — это класс, тогда как в АОП единицей модульности является аспект.\nАспекты обеспечить модульность задач (таких как управление транзакциями), которые пересекаются несколько типов и объектов. (Такие проблемы часто называют «сквозными» проблемами. в литературе АОП.)\nАспектно-ориентированное программирование с помощью Spring.\nОдним из ключевых компонентов Spring является платформа АОП.\nВ то время как Spring IoC контейнер не зависит от АОП (это означает, что вам не нужно использовать АОП, если вы не хотите to), АОП дополняет Spring IoC, предоставляя очень эффективное промежуточное программное решение.\nАспектно-ориентированное программирование с помощью Spring. .Spring AOP с точками AspectJ **** Spring предоставляет простые и мощные способы написания пользовательских аспектов с помощью Оба этих стиля предлагают полностью типизированные советы и использование языка pointcut AspectJ. при этом все еще используя Spring AOP для плетения.\nАспектно-ориентированное программирование с помощью Spring.\nВ этой главе обсуждается поддержка АОП на основе схемы и @AspectJ.\nПоддержка АОП нижнего уровня обсуждается в следующая глава. ****\n* Предоставлять декларативные корпоративные услуги. Важнейшим из таких сервисов является\n* Позвольте пользователям реализовывать собственные аспекты, дополняя использование ООП АОП.\nАОП используется в Spring Framework для:.\nПРИМЕЧАНИЕ."}
{"id": 74, "text": "Если вас интересуют только универсальные декларативные службы или другие готовые декларативные службы промежуточного программного обеспечения, такие как пул, вам не нужно работать напрямую с Spring AOP, и можно пропустить большую часть этой главы."}
{"id": 75, "text": "Опережающая оптимизация.\nВ этой главе рассматриваются оптимизации Spring Ahead of Time (AOT).\nОпережающая оптимизация.\nИнформацию о поддержке AOT, специфичной для интеграционных тестов, см. в документе Опереденная поддержка тестов.\nВведение в упреждающую оптимизацию.\nПоддержка оптимизации AOT в Spring предназначена для проверки `ApplicationContext` во время сборки и применения решений и логики обнаружения, которые обычно происходят во время выполнения.\nЭто позволяет создать более простую схему запуска приложения, ориентированную на фиксированный набор функций, основанный главным образом на пути к классам и «Среде».\n* Путь к классам фиксирован и полностью определен во время сборки.\n* Компоненты, определенные в вашем приложении, не могут изменяться во время выполнения, что означает:\nРаннее применение таких оптимизаций подразумевает следующие ограничения:. ** `@Profile`, в частности, конфигурация, специфичная для профиля, должна быть выбрана во время сборки и автоматически включается во время выполнения, когда включен AOT. ** Свойства «Среды», влияющие на наличие компонента («@Conditional»), учитываются только во время сборки.\n* Определения компонентов с поставщиками экземпляров (лямбда-выражения или ссылки на методы) не могут быть преобразованы заранее.\n* Компоненты, зарегистрированные как синглтоны (с использованием `registerSingleton`, обычно из\nРаннее применение таких оптимизаций подразумевает следующие ограничения:. `ConfigurableListableBeanFactory`) также не может быть преобразовано заранее."}
{"id": 76, "text": "* Поскольку мы не можем полагаться на экземпляр, убедитесь, что тип компонента максимально точен.\nРаннее применение таких оптимизаций подразумевает следующие ограничения:. возможно.\nРаннее применение таких оптимизаций подразумевает следующие ограничения:.\nСОВЕТ: См. также раздел.\nРаннее применение таких оптимизаций подразумевает следующие ограничения:.\nКогда эти ограничения действуют, становится возможным выполнять предварительную обработку во время сборки и генерировать дополнительные ресурсы.\nПриложение, обработанное Spring AOT, обычно генерирует:\n* Исходный код Java\n* Байт-код (обычно для динамических прокси)\n* {spring-framework-api}/aot/hint/RuntimeHints.html[`RuntimeHints`] для использования отражения, загрузки ресурсов, сериализации и прокси-серверов JDK.\nРаннее применение таких оптимизаций подразумевает следующие ограничения:.\nПРИМЕЧАНИЕ.\nНа данный момент AOT сосредоточен на том, чтобы разрешить развертывание приложений Spring как собственных образов с использованием GraalVM.\nМы намерены поддерживать больше вариантов использования на основе JVM в будущих поколениях.\nОбзор движка AOT.\nТочкой входа механизма AOT для обработки ApplicationContext является ApplicationContextAotGenerator.\nIt takes care of the following steps, based on a `GenericApplicationContext` that represents the application to optimize and a {spring-framework-api}/aot/generate/GenerationContext.html[`GenerationContext`]:\n* Обновите `ApplicationContext` для обработки AOT. В отличие от традиционного обновления, эта версия создает только определения компонентов, а не экземпляры компонентов."}
{"id": 77, "text": "* Вызовите доступные реализации BeanFactoryInitializationAotProcessor и примените их вклад к GenerationContext.\nОбзор движка AOT.\nНапример, основная реализация перебирает все определения потенциальных компонентов и генерирует необходимый код для восстановления состояния BeanFactory.\nОбзор движка AOT.\nПосле завершения этого процесса GenerationContext будет обновлен сгенерированным кодом, ресурсами и классами, необходимыми для запуска приложения.\nЭкземпляр RuntimeHints также можно использовать для создания соответствующих файлов конфигурации собственного образа GraalVM.\nОбзор движка AOT. `ApplicationContextAotGenerator#processAheadOfTime` returns the class name of the `ApplicationContextInitializer` entry point that allows the context to be started with AOT optimizations.\nОбзор движка AOT.\nЭти шаги более подробно описаны в разделах ниже.\nОбновление для обработки AOT поддерживается во всех реализациях GenericApplicationContext.\nКонтекст приложения создается с любым количеством точек входа, обычно в форме классов, аннотированных `@Configuration`.\nОбновление для обработки AOT.\nДавайте посмотрим на базовый пример: См. пример кода в исходном документе.\nОбновление для обработки AOT.\nЗапуск этого приложения в обычной среде выполнения включает в себя ряд шагов, включая сканирование пути к классам, анализ классов конфигурации, создание экземпляров bean-компонентов и обработку обратного вызова жизненного цикла.\nОбновление для обработки AOT применяет только часть того, что происходит с regular `refresh`.\nОбработку AOT можно запустить следующим образом: См. пример кода в исходном документе.\nОбновление для обработки AOT.\nВ этом режиме реализации BeanFactoryPostProcessor вызываются как обычно."}
{"id": 78, "text": "Сюда входит анализ классов конфигурации, селекторы импорта, сканирование путей к классам и т. д.\nТакие шаги гарантируют, что `BeanRegistry` содержит соответствующие определения bean-компонентов для приложения.\nЕсли определения bean-компонентов защищены условиями (такими как `@Profile`), они оцениваются, и определения компонентов, которые не соответствуют их условиям, на этом этапе отбрасываются.\nОбновление для обработки AOT.\nЕсли пользовательскому коду необходимо программно зарегистрировать дополнительные компоненты, убедитесь, что пользовательский код регистрационный код использует BeanDefinitionRegistry вместо BeanFactory как единственный компонент определения принимаются во внимание.\nХороший шаблон — реализовать `ImportBeanDefinitionRegistrar` и зарегистрируйте его через `@Import` на одном из ваших классы конфигурации.\nОбновление для обработки AOT.\nПоскольку этот режим фактически не создает экземпляры bean-компонентов, реализации BeanPostProcessor не вызываются, за исключением определенных вариантов, которые имеют отношение к обработке AOT.\nЭто:\n* MergedBeanDefinitionPostProcessor реализует определения bean-компонентов постобработки для извлечения дополнительных настроек, таких как методы init и destroy.\n* Реализации SmartInstantiationAwareBeanPostProcessor при необходимости определяют более точный тип компонента.\nОбновление для обработки AOT.\nЭто гарантирует создание любого прокси, который потребуется во время выполнения.\nОбновление для обработки AOT.\nПосле завершения этой части «BeanFactory» будет содержать определения компонентов, необходимые для запуска приложения.\nОн не запускает создание экземпляра компонента, но позволяет механизму AOT проверять компоненты, которые будут созданы во время выполнения.\nВклад AOT в инициализацию Bean Factory."}
{"id": 79, "text": "Компоненты, которые хотят участвовать в этом шаге, могут реализовать интерфейс {spring-framework-api}/beans/factory/aot/BeanFactoryInitializationAotProcessor.html[`BeanFactoryInitializationAotProcessor`].\nКаждая реализация может возвращать вклад AOT в зависимости от состояния фабрики компонентов.\nВклад AOT в инициализацию Bean Factory.\nВклад AOT — это компонент, который вносит сгенерированный код, воспроизводящий определенное поведение.\nОн также может предоставлять RuntimeHints, чтобы указать на необходимость отражения, загрузки ресурсов, сериализации или прокси-серверов JDK.\nВклад AOT в инициализацию Bean Factory.\nРеализация BeanFactoryInitializationAotProcessor может быть зарегистрирована в META-INF/spring/aot.factories с ключом, равным полному имени интерфейса.\nВклад AOT в инициализацию Bean Factory.\nИнтерфейс BeanFactoryInitializationAotProcessor также может быть реализован непосредственно компонентом.\nВ этом режиме компонент обеспечивает вклад AOT, эквивалентный функции, которую он предоставляет в обычной среде выполнения.\nСледовательно, такой компонент автоматически исключается из контекста, оптимизированного для AOT.\nВклад AOT в инициализацию Bean Factory. [ПРИМЕЧАНИЕ] = Если компонент реализует интерфейс BeanFactoryInitializationAotProcessor, компонент и **все** его зависимости будут инициализированы во время обработки AOT.\nОбычно мы рекомендуем, чтобы этот интерфейс реализовывался только инфраструктурными компонентами, такими как BeanFactoryPostProcessor, которые имеют ограниченные зависимости и уже инициализируются на ранних стадиях жизненного цикла фабрики компонентов."}
{"id": 80, "text": "Если такой компонент зарегистрирован с использованием фабричного метода @Bean, убедитесь, что метод является статическим, чтобы не нужно было инициализировать включающий его класс @Configuration.\nРегистрация компонентов AOT.\nБазовая реализация BeanFactoryInitializationAotProcessor отвечает за сбор необходимых вкладов для каждого кандидата BeanDefinition.\nЭто делается с помощью специального BeanRegistrationAotProcessor.\n* Реализовано bean-компонентом BeanPostProcessor для замены его поведения во время выполнения.\nЭтот интерфейс используется следующим образом:.\nНапример, `AutowiredAnnotationBeanPostProcessor` реализует этот интерфейс для генерации кода, который внедряет элементы, помеченные `@Autowired`.\n* Реализовано типом, зарегистрированным в `META-INF/spring/aot.factories` с ключом, равным полному имени интерфейса.\nЭтот интерфейс используется следующим образом:.\nОбычно используется, когда определение компонента необходимо настроить для конкретных функций базовой платформы.\nЭтот интерфейс используется следующим образом:. [ПРИМЕЧАНИЕ] = Если компонент реализует интерфейс `BeanRegistrationAotProcessor`, компонент и **все** его зависимости будут инициализированы во время обработки AOT.\nОбычно мы рекомендуем, чтобы этот интерфейс реализовывался только инфраструктурными компонентами, такими как BeanFactoryPostProcessor, которые имеют ограниченные зависимости и уже инициализируются на ранних стадиях жизненного цикла фабрики компонентов.\nЕсли такой компонент зарегистрирован с использованием фабричного метода @Bean, убедитесь, что метод является статическим, чтобы не нужно было инициализировать включающий его класс @Configuration.\nЭтот интерфейс используется следующим образом:."}
{"id": 81, "text": "Если ни один `BeanRegistrationAotProcessor` не обрабатывает конкретный зарегистрированный компонент, его обрабатывает реализация по умолчанию.\nЭто поведение по умолчанию, поскольку настройка сгенерированного кода для определения компонента должна ограничиваться крайними случаями.\nЭтот интерфейс используется следующим образом:.\nВозьмем наш предыдущий пример и предположим, что `DataSourceConfiguration` выглядит следующим образом:\nJava\n	@Configuration(proxyBeanMethods = false)\n	public class DataSourceConfiguration {\n		@Bean\n		public SimpleDataSource dataSource() {\n			return new SimpleDataSource();\n	@Configuration(proxyBeanMethods = false)\n	class DataSourceConfiguration {\nЭтот интерфейс используется следующим образом:.\nПоскольку для этого класса нет каких-либо особых условий, dataSourceConfiguration и dataSource идентифицируются как кандидаты.\nМеханизм AOT преобразует приведенный выше класс конфигурации в код, аналогичный следующему:\nJava\n	 * Bean definitions for {@link DataSourceConfiguration}\n	@Generated\n	public class DataSourceConfiguration__BeanDefinitions {\n		 * Получите определение bean-компонента для dataSourceConfiguration.\n		public static BeanDefinition getDataSourceConfigurationBeanDefinition() {\n			Class<?> beanType = DataSourceConfiguration.class;\n			RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n			beanDefinition.setInstanceSupplier(DataSourceConfiguration::new);\n			return beanDefinition;\n		 * Получите поставщика экземпляра компонента для dataSource.\n		private static BeanInstanceSupplier<SimpleDataSource> getDataSourceInstanceSupplier() {\n			return BeanInstanceSupplier.<SimpleDataSource>forFactoryMethod(DataSourceConfiguration.class, \"dataSource\")\n					.withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(DataSourceConfiguration.class).dataSource());"}
{"id": 82, "text": "* Получите определение bean-компонента для dataSource.\n		public static BeanDefinition getDataSourceBeanDefinition() {\n			Class<?> beanType = SimpleDataSource.class;\n			RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n			beanDefinition.setInstanceSupplier(getDataSourceInstanceSupplier());\n			return beanDefinition;\nЭтот интерфейс используется следующим образом:.\nПРИМЕЧАНИЕ.\nТочный сгенерированный код может отличаться в зависимости от точного характера определений вашего компонента.\nЭтот интерфейс используется следующим образом:.\nСОВЕТ: Каждый сгенерированный класс помечен с помощью `org.springframework.aot.generate.Generated` для идентифицируйте их, если их необходимо исключить, например, с помощью инструментов статического анализа.\nЭтот интерфейс используется следующим образом:.\nСгенерированный выше код создает определения bean-компонентов, эквивалентные классу @Configuration, но напрямую и, если возможно, вообще без использования отражения.\nСуществует определение компонента для `dataSourceConfiguration` и одно для `dataSourceBean`.\nКогда требуется экземпляр источника данных, вызывается BeanInstanceSupplier.\nЭтот поставщик вызывает метод dataSource() в bean-компоненте dataSourceConfiguration.\nРабота с оптимизацией AOT.\nAOT — обязательный шаг для преобразования приложения Spring в собственный исполняемый файл. автоматически включается при запуске в собственном образе.\nОднако также возможно использовать оптимизацию AOT. на JVM, установив для системного свойства Spring.aot.enabled значение true.\nРабота с оптимизацией AOT.\nПРИМЕЧАНИЕ.\nКогда включена оптимизация AOT, некоторые решения, принятые во время сборки, жестко запрограммированы в настройке приложения."}
{"id": 83, "text": "Например, профили, которые были включены в время сборки также автоматически включается во время выполнения.\nЛучшие практики.\nМеханизм AOT предназначен для обработки как можно большего количества вариантов использования без изменения кода в приложениях.\nОднако имейте в виду, что некоторые оптимизации выполняются во время сборки на основе статического определения компонентов.\nЛучшие практики.\nВ этом разделе перечислены рекомендации, которые помогут убедиться, что ваше приложение готово к AOT.\nПрограммная регистрация компонентов.\nМеханизм AOT заботится о модели @Configuration и любом обратном вызове, который может быть вызывается как часть обработки вашей конфигурации.\nЕсли вам необходимо зарегистрировать доп. beans программно, обязательно используйте BeanDefinitionRegistry для регистрации определения бобов.\nПрограммная регистрация компонентов.\nОбычно это можно сделать с помощью BeanDefinitionRegistryPostProcessor.\nОбратите внимание, что если это зарегистрирован как компонент, он будет вызываться снова во время выполнения, если вы не сделаете обязательно также реализуйте `BeanFactoryInitializationAotProcessor`.\nБолее идиоматический способ — реализовать ImportBeanDefinitionRegistrar и зарегистрировать его с помощью @Import на один из ваших классов конфигурации.\nЭто вызывает ваш собственный код как часть конфигурации. разбор классов.\nПрограммная регистрация компонентов.\nЕсли вы объявляете дополнительные компоненты программно, используя другой обратный вызов, они скорее всего, не будет обрабатываться движком AOT, поэтому никаких подсказок не будет. созданные для них.\nВ зависимости от среды эти бобы могут не быть зарегистрированы на все.\nНапример, сканирование пути к классам не работает в собственном образе, поскольку там нет понятие пути к классам."}
{"id": 84, "text": "В подобных случаях крайне важно, чтобы сканирование происходило в время сборки.\nРаскройте наиболее точный тип компонента.\nХотя ваше приложение может взаимодействовать с интерфейсом, реализуемым компонентом, все равно очень важно объявить наиболее точный тип.\nМеханизм AOT выполняет дополнительные проверки типа компонента, например, обнаруживает наличие членов @Autowired или методов обратного вызова жизненного цикла.\nРаскройте наиболее точный тип компонента.\nДля классов `@Configuration` убедитесь, что тип возвращаемого значения фабричного метода `@Bean` является максимально точным.\nРассмотрим следующий пример:\nJava\n	@Configuration(proxyBeanMethods = false)\n	public class UserConfiguration {\n		@Bean\n		public MyInterface myInterface() {\n			return new MyImplementation();\n	@Configuration(proxyBeanMethods = false)\n	class UserConfiguration {\nРаскройте наиболее точный тип компонента.\nВ приведенном выше примере объявленным типом bean-компонента myInterface является MyInterface.\nВо время обработки AOT ни одна обычная постобработка не будет учитывать MyImplementation.\nНапример, если в MyImplementation существует аннотированный метод-обработчик, который контекст должен зарегистрировать, он не будет обнаружен во время обработки AOT.\nJava\n	@Configuration(proxyBeanMethods = false)\n	public class UserConfiguration {\n		@Bean\n		public MyImplementation myInterface() {\n			return new MyImplementation();\n	@Configuration(proxyBeanMethods = false)\n	class UserConfiguration {\nПоэтому приведенный выше пример следует переписать следующим образом:.\nЕсли вы регистрируете определения bean-компонентов программным способом, рассмотрите возможность использования RootBeanBefinition, поскольку он позволяет указать ResolvableType, который обрабатывает дженерики."}
{"id": 85, "text": "Избегайте использования нескольких конструкторов.\nКонтейнер может выбирать наиболее подходящий для использования конструктор на основе нескольких кандидатов.\nОднако полагаться на это не рекомендуется, и при необходимости предпочтительнее пометить предпочтительный конструктор с помощью `@Autowired`.\nИзбегайте использования нескольких конструкторов.\nЕсли вы работаете с базой кода, которую не можете изменить, вы можете установить {spring-framework-api}/beans/factory/support/AbstractBeanDefinition.html#PREFERRED_CONSTRUCTORS_ATTRIBUTE[`preferredConstructors` атрибут] в определении связанного компонента, чтобы указать, какой конструктор следует использовать.\nИзбегайте сложных структур данных для параметров и свойств конструктора.\nПри программном создании RootBeanDefinition вы не ограничены в типах, которые можете использовать.\nНапример, у вас может быть специальная «запись» с несколькими свойствами, которые ваш компонент принимает в качестве аргумента конструктора.\nИзбегайте сложных структур данных для параметров и свойств конструктора.\nХотя это прекрасно работает в обычной среде выполнения, AOT не знает, как генерировать код вашей пользовательской структуры данных.\nХорошее практическое правило — помнить, что определения компонентов представляют собой абстракцию, лежащую поверх нескольких моделей.\nВместо использования таких структур рекомендуется разложить их на простые типы или обратиться к созданному компоненту как таковому.\nИзбегайте сложных структур данных для параметров и свойств конструктора.\nВ крайнем случае, вы можете реализовать свой собственный `org.springframework.aot.generate.ValueCodeGenerator$Delegate`."}
{"id": 86, "text": "Чтобы использовать его, зарегистрируйте его полное имя в `META-INF/spring/aot.factories`, используя `org.springframework.aot.generate.ValueCodeGenerator$Delegate` в качестве ключа.\nИзбегайте создания компонентов с пользовательскими аргументами.\nSpring AOT определяет, что необходимо сделать для создания компонента, и преобразует это в сгенерированный код, который использует поставщика экземпляра.\nКонтейнер также поддерживает создание bean-компонента с помощью {spring-framework-api}++/beans/factory/BeanFactory.html#getBean(java.lang.String,java.lang.Object...)++[пользовательских аргументов], что может привести к нескольким проблемам с AOT:\nИзбегайте создания компонентов с пользовательскими аргументами. .\nПользовательские аргументы требуют динамического анализа соответствующего конструктора или фабричного метода.\nЭти аргументы не могут быть обнаружены AOT, поэтому необходимые подсказки по отражению придется предоставлять вручную..\nОбход поставщика экземпляра означает, что все остальные оптимизации после создания также пропускаются.\nНапример, автоматическое связывание полей и методов будет пропущено, поскольку они обрабатываются поставщиком экземпляра.\nИзбегайте создания компонентов с пользовательскими аргументами.\nВместо того, чтобы создавать bean-компоненты с областью прототипа с настраиваемыми аргументами, мы рекомендуем использовать фабричный шаблон вручную, в котором bean-компонент отвечает за создание экземпляра.\nИзбегайте циклических зависимостей.\nОпределенные варианты использования могут привести к циклическим зависимостям между одним или несколькими компонентами."}
{"id": 87, "text": "С обычная среда выполнения, возможно, можно будет связать эти циклические зависимости через `@Autowired` по методам или полям установки.\nОднако контекст, оптимизированный для AOT, не сможет начаться с явные циклические зависимости.\nИзбегайте циклических зависимостей.\nПоэтому в приложении, оптимизированном для AOT, следует стараться избегать циклического зависимости.\nЕсли это невозможно, вы можете использовать точки внедрения `@Lazy` или `ObjectProvider` для ленивого доступа или получения необходимых взаимодействующих компонентов.\nСм. для получения дополнительной информации.\nФабрикаБин. «FactoryBean» следует использовать с осторожностью, поскольку он вводит промежуточный уровень с точки зрения разрешения типов компонентов, который может не быть концептуально необходимым.\nКак правило, если экземпляр FactoryBean не сохраняет долгосрочное состояние и не требуется на более позднем этапе во время выполнения, его следует заменить обычным фабричным методом @Bean, возможно, с слоем адаптера FactoryBean сверху (в целях декларативной конфигурации).\nФабрикаБин.\nЕсли ваша реализация FactoryBean не разрешает тип объекта (т. е.\nT), необходима дополнительная осторожность.\nРассмотрим следующий пример:\nJava\n	public class ClientFactoryBean<T extends AbstractClient> implements FactoryBean<T> {\n	class ClientFactoryBean<T : AbstractClient> : FactoryBean<T> {\nФабрикаБин.\nКонкретное объявление клиента должно предоставлять разрешенный универсальный код для клиента, как показано в следующем примере:\nJava\n	@Configuration(proxyBeanMethods = false)\n	public class UserConfiguration {\n		@Bean\n		public ClientFactoryBean<MyClient> myClient() {"}
{"id": 88, "text": "return new ClientFactoryBean<>(...);\n	@Configuration(proxyBeanMethods = false)\n	class UserConfiguration {\nФабрикаБин.\nЕсли определение bean-компонента FactoryBean зарегистрировано программно, обязательно выполните следующие шаги:\n1. Используйте RootBeanDefinition.\n2. Установите для beanClass класс FactoryBean, чтобы AOT знал, что это промежуточный уровень.\n3. Установите для параметра ResolvableType разрешенный универсальный тип, который гарантирует предоставление наиболее точного типа.\nJava\n	RootBeanDefinition beanDefinition = new RootBeanDefinition(ClientFactoryBean.class);\n	beanDefinition.setTargetType(ResolvableType.forClassWithGenerics(ClientFactoryBean.class, MyClient.class));\n	registry.registerBeanDefinition(\"myClient\", beanDefinition);\nСледующий пример демонстрирует базовое определение:.\nДля применения определенных оптимизаций необходимо заранее знать модуль персистентности JPA.\nРассмотрим следующий базовый пример:\nJava\n	@Bean\n	LocalContainerEntityManagerFactoryBean customDBEntityManagerFactory(DataSource dataSource) {\n		LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n		factoryBean.setDataSource(dataSource);\n		factoryBean.setPackagesToScan(\"com.example.app\");\n		return factoryBean;\nСледующий пример демонстрирует базовое определение:.\nЧтобы гарантировать, что сканирование объектов происходит заранее, bean-компонент PersistenceManagedTypes должен быть объявлен и использован определение фабричного компонента, как показано в следующем примере:\nJava\n	@Bean\n	PersistenceManagedTypes persistenceManagedTypes(ResourceLoader resourceLoader) {\n		return new PersistenceManagedTypesScanner(resourceLoader)\n				.scan(\"com.example.app\");\n	@Bean\n	LocalContainerEntityManagerFactoryBean customDBEntityManagerFactory(DataSource dataSource, PersistenceManagedTypes managedTypes) {"}
{"id": 89, "text": "LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n		factoryBean.setDataSource(dataSource);\n		factoryBean.setManagedTypes(managedTypes);\n		return factoryBean;\nПодсказки во время выполнения.\nЗапуск приложения в качестве собственного образа требует дополнительной информации по сравнению с обычной средой выполнения JVM.\nНапример, GraalVM необходимо заранее знать, использует ли компонент отражение.\nАналогично, ресурсы пути к классам не включаются в собственный образ, если это не указано явно.\nСледовательно, если приложению необходимо загрузить ресурс, на него необходимо ссылаться из соответствующего файла конфигурации собственного образа GraalVM.\nПодсказки во время выполнения.\nAPI {spring-framework-api}/aot/hint/RuntimeHints.html[`RuntimeHints`] собирает данные о необходимости отражения, загрузки ресурсов, сериализации и прокси-серверов JDK во время выполнения.\nСледующий пример гарантирует, что `config/app.properties` может быть загружен из пути к классам во время выполнения в собственном образе:\nJava\n	runtimeHints.resources().registerPattern(\"config/app.properties\");\n	runtimeHints.resources().registerPattern(\"config/app.properties\")\nПодсказки во время выполнения.\nРяд контрактов обрабатываются автоматически во время обработки AOT.\nНапример, проверяется возвращаемый тип метода `@Controller` и добавляются соответствующие подсказки по отражению, если Spring обнаруживает, что тип должен быть сериализован (обычно в JSON).\nПодсказки во время выполнения."}
{"id": 90, "text": "В случаях, когда основной контейнер не может определить такие подсказки, вы можете зарегистрировать такие подсказки программно.\nДля общих случаев использования также предусмотрен ряд удобных аннотаций.\n`@ImportRuntimeHints`. {spring-framework-api}/aot/hint/RuntimeHintsRegistrar.html[`RuntimeHintsRegistrar`] реализации позволяют вам получить обратный вызов к экземпляру RuntimeHints, управляемому Двигатель АОТ.\nРеализации этого интерфейса можно зарегистрировать с помощью {spring-framework-api}/context/annotation/ImportRuntimeHints.html[`@ImportRuntimeHints`] для любого bean-компонента Spring или фабричного метода `@Bean`.\nРеализации RuntimeHintsRegistrar обнаруживается и вызывается во время сборки.\nвключаемый код::./SpellCheckService[].\nЕсли это вообще возможно, `@ImportRuntimeHints` следует использовать как можно ближе к компоненту, которому требуются подсказки.\nТаким образом, если компонент не добавлен в BeanFactory, подсказки также не будут добавлены.\nвключаемый код::./SpellCheckService[].\nТакже можно зарегистрировать реализацию статически, добавив запись в META-INF/spring/aot.factories с ключом, равным полному имени интерфейса RuntimeHintsRegistrar.\n`@Reflective`. {spring-framework-api}/aot/hint/annotation/Reflective.html[`@Reflective`] предоставляет идиоматический способ отметить необходимость отражения аннотированного элемента."}
{"id": 91, "text": "Например, `@EventListener` имеет метааннотацию `@Reflective`, поскольку базовая реализация вызывает аннотированный метод с использованием отражения.\n`@Reflective`.\nПо умолчанию рассматриваются только bean-компоненты Spring, но вы можете отказаться от сканирования, используя {spring-framework-api}/context/annotation/ReflectiveScan.html[`@ReflectiveScan`].\nВ В приведенном ниже примере все типы в пакете com.example.app и его подпакетах являются считается:\nвключаемый код::./MyConfiguration[].\nСканирование происходит во время обработки AOT, и для рассмотрения типов в целевых пакетах не обязательно иметь аннотацию уровня класса.\nПри этом выполняется _глубокое сканирование_, и наличие `@Reflective`, напрямую или в виде метааннотации, проверяется в типах, полях, конструкторах, методах и вложенных элементах.\nвключаемый код::./MyConfiguration[].\nПо умолчанию @Reflective регистрирует подсказку вызова для аннотированного элемента.\nЭто можно настроить, указав собственную реализацию ReflectiveProcessor через аннотацию @Reflective.\nвключаемый код::./MyConfiguration[].\nАвторы библиотеки могут повторно использовать эту аннотацию в своих целях.\nПример такой настройки описан в следующем разделе.\n`@RegisterReflection`. {spring-framework-api}/aot/hint/annotation/RegisterReflection.html[`@RegisterReflection`] — это специализация `@Reflective`, которая обеспечивает декларативный способ регистрации отражения для произвольных типов."}
{"id": 92, "text": "`@RegisterReflection`.\nПРИМЕЧАНИЕ.\nБудучи специализацией `@Reflective`, `@RegisterReflection` также обнаруживается, если вы используете `@ReflectiveScan`.\n`@RegisterReflection`.\nВ следующем примере общедоступные конструкторы и общедоступные методы могут быть вызваны посредством отражения в AccountService: См. пример кода в исходном документе.\n`@RegisterReflection` можно применить к любому целевому типу на уровне класса, но его также можно применить непосредственно к методу, чтобы лучше указать, где на самом деле требуются подсказки.\n`@RegisterReflection` можно использовать в качестве метааннотации для удовлетворения более конкретных потребностей. {spring-framework-api}/aot/hint/annotation/RegisterReflectionForBinding.html[`@RegisterReflectionForBinding`] — это составная аннотация, мета-аннотированная с помощью `@RegisterReflection` и регистрирующая необходимость сериализации произвольных типов.\nТипичным вариантом использования является использование DTO, которые контейнер не может вывести, например использование веб-клиента в теле метода.\n`@RegisterReflection`.\nВ следующем примере регистрируется Order для сериализации.\nСм. пример кода в исходном документе.\n`@RegisterReflection`.\nПри этом регистрируются подсказки для конструкторов, полей, свойств и компонентов записи Order.\nПодсказки также регистрируются для типов, транзитивно используемых в свойствах и компонентах записи.\nДругими словами, если Order предоставляет другие типы, подсказки регистрируются и для них.\nПодсказки во время выполнения для преобразования на основе соглашений."}
{"id": 93, "text": "Хотя основной контейнер предоставляет встроенную поддержку автоматического преобразования многих общие типы (см.\nSpring Type Conversion), некоторые преобразования поддерживаются с помощью алгоритма, основанного на соглашениях и основанного на отражении.\nПодсказки во время выполнения для преобразования на основе соглашений.\nВ частности, если в ConversionService не зарегистрирован явный «Конвертер». для конкретной пары типов источник → целевой внутренний `ObjectToObjectConverter` попытается использовать соглашения для преобразования исходного объекта в целевой тип, делегируя к методу исходного объекта или статическому фабричному методу или конструктору тип цели.\nПоскольку этот алгоритм, основанный на соглашениях, можно применять к произвольным типам в во время выполнения основной контейнер не может вывести подсказки времени выполнения, необходимые для поддержки такое размышление.\nПодсказки во время выполнения для преобразования на основе соглашений.\nЕсли вы столкнулись с проблемами преобразования на основе соглашений в собственном изображении, возникшими из-за отсутствие подсказок во время выполнения позволяет зарегистрировать необходимые подсказки программно.\nДля Например, если вашему приложению требуется преобразование из `java.time.Instant` в `java.sql.Timestamp` и использует `ObjectToObjectConverter` для вызова `java.sql.Timestamp.from(Instant)`, используя отражение, вы можете реализовать собственный RuntimeHintsRegitrar для поддержки этого варианта использования в собственном образе, как показано в следующий пример.\nJava\n	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {\n		ReflectionHints reflectionHints = hints.reflection();"}
{"id": 94, "text": "reflectionHints.registerTypeIfPresent(classLoader, \"java.sql.Timestamp\", hint -> hint\n				.withMethod(\"from\", List.of(TypeReference.of(Instant.class)), ExecutableMode.INVOKE)\n				.onReachableType(TypeReference.of(\"java.sql.Timestamp\")));\npublic class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {. `TimestampConversionRuntimeHints` затем можно зарегистрировать декларативно через <<aot.hints.import-runtime-hints>> или статически через `META-INF/spring/aot.factories` файл конфигурации.\npublic class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {. [ПРИМЕЧАНИЕ] = Вышеупомянутый класс TimestampConversionRuntimeHints представляет собой упрощенную версию Класс ObjectToObjectConverterRuntimeHints, включенный в структуру и зарегистрирован по умолчанию.\npublic class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {.\nТаким образом, этот конкретный вариант использования «Мгновенный переход к временной метке» уже обрабатывается платформой.\nТестирование подсказок во время выполнения.\nSpring Core также включает RuntimeHintsPredicates — утилиту для проверки соответствия существующих подсказок конкретному варианту использования.\nЭто можно использовать в ваших собственных тестах для проверки того, что RuntimeHintsRegistrar дает ожидаемые результаты.\nМы можем написать тест для нашей SpellCheckService и убедиться, что мы сможем загрузить словарь во время выполнения: См. пример кода в исходном документе.\nТестирование подсказок во время выполнения.\nС помощью RuntimeHintsPredicates мы можем проверять подсказки по отражению, ресурсам, сериализации или генерации прокси."}
{"id": 95, "text": "Этот подход хорошо работает для модульных тестов, но подразумевает, что поведение компонента во время выполнения хорошо известно.\nТестирование подсказок во время выполнения.\nВы можете узнать больше о глобальном поведении приложения во время выполнения, запустив его набор тестов (или само приложение) с помощью {graalvm-docs}/native-image/metadata/AutomaticMetadataCollection/[агента трассировки GraalVM].\nЭтот агент будет записывать все соответствующие вызовы, требующие подсказок GraalVM во время выполнения, и записывать их в виде файлов конфигурации JSON.\nТестирование подсказок во время выполнения.\nДля более целенаправленного обнаружения и тестирования Spring Framework предоставляет специальный модуль с основными утилитами тестирования AOT, org.springframework:spring-core-test.\nЭтот модуль содержит агент RuntimeHints, агент Java, который записывает все вызовы методов, связанных с подсказками во время выполнения, и помогает вам утверждать, что данный экземпляр RuntimeHints охватывает все записанные вызовы.\nДавайте рассмотрим часть инфраструктуры, для которой мы хотели бы протестировать подсказки, которые мы вносим на этапе обработки AOT.\nвключаемый код::./SampleReflection[].\nЗатем мы можем написать модульный тест (нативная компиляция не требуется), который проверяет предоставленные нами подсказки: См. пример кода в исходном документе.\nвключаемый код::./SampleReflection[].\nЕсли вы забыли добавить подсказку, тест завершится неудачно и предоставит некоторые подробности о вызове:"}
{"id": 96, "text": "включаемый код::./SampleReflection[]. org.springframework.docs.core.aot.hints.testing.SampleReflection performReflection ИНФОРМАЦИЯ: Весенняя версия: 6.2.0.\nвключаемый код::./SampleReflection[].\nMissing <\"ReflectionHints\"> for invocation <java.lang.Class#forName> with arguments [\"org.springframework.core.SpringVersion\",\n    false,\n    jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7].\nвключаемый код::./SampleReflection[].\nStacktrace: <\"org.springframework.util.ClassUtils#forName, Line 284 io.spring.runtimehintstesting.SampleReflection#performReflection, Line 19 io.spring.runtimehintstesting.SampleReflectionRuntimeHintsTests#lambda$shouldRegisterReflectionHints$0, Line 25\nвключаемый код::./SampleReflection[].\nСуществуют различные способы настройки этого Java-агента в вашей сборке, поэтому обратитесь к документации вашего инструмента сборки и плагина выполнения тестов.\nСам агент можно настроить для инструментирования определенных пакетов (по умолчанию инструментируется только org.springframework).\nБолее подробную информацию вы найдете в файле {spring-framework-code}/buildSrc/README.md[Spring Framework `buildSrc` README]."}
{"id": 97, "text": "Версия API.\nЧтобы включить управление версиями API, используйте обратный вызов ApiVersionConfigurer для WebMvcConfigurer: См. пример кода в исходном документе.\nВерсия API.\nВы можете решить версию с помощью одной из встроенных опций, перечисленных ниже, или в качестве альтернативы используйте собственный ApiVersionResolver:\n- Заголовок запроса\n- Параметр запроса\n- Сегмент пути\n- Параметр типа носителя\nВерсия API.\nДля разрешения из сегмента пути необходимо указать индекс ожидаемого сегмента пути. чтобы содержать версию.\nСегмент пути должен быть объявлен как переменная URI, например. «/\\{версия}», «/api/\\{версия}» и т. д., где фактическое имя не имеет значения.\nПоскольку версия обычно находится в начале пути, рассмотрите возможность ее внешней настройки. как общий префикс пути для всех обработчиков через\nВерсия API.\nПо умолчанию версия анализируется с помощью SemanticVersionParser, но вы также можете настроить пользовательская ссылка:web/webmvc-versioning.adoc#mvc-versioning-parser[ApiVersionParser].\nВерсия API.\nПоддерживаемые версии прозрачно определяются из версий, объявленных в сопоставлениях запросов. для удобства, но вы можете отключить это с помощью флага в конфигурации MVC и считайте поддерживаемыми только версии, явно настроенные в конфигурации.\nЗапросы с неподдерживаемой версией отклоняются с помощью `InvalidApiVersionException` приводит к ответу 400.\nВерсия API.\nВы можете установить ApiVersionDeprecationHandler для отправки информации об устаревших версии для клиентов."}
{"id": 98, "text": "Встроенный стандартный обработчик может установить «Устаревание», «Закат» и Заголовки «Ссылки» на основе https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].\nВерсия API.\nПосле настройки управления версиями API вы можете начать сопоставлять запросы с согласно версии запроса."}
{"id": 99, "text": "XML-схемы.\nВ этой части приложения перечислены схемы XML для доступа к данным, включая следующие:\n* Схема `tx`\n* Схема `jdbc`\nСхема `tx`.\nТеги `tx` предназначены для настройки всех этих компонентов в рамках комплексной поддержки Spring. для транзакций.\nЭти теги описаны в главе, озаглавленной\nСхема `tx`.\nСОВЕТ: Мы настоятельно рекомендуем вам просмотреть файл `'spring-tx.xsd'`, который поставляется с Весенняя раздача.\nЭтот файл содержит XML-схему для транзакции Spring. конфигурации и охватывает все различные элементы пространства имен tx, включая значения атрибутов по умолчанию и подобная информация.\nЭтот файл документирован встроенно, и, таким образом, информация здесь не повторяется в интересах соблюдения СУХОГО (Не Повторите себя) принцип.\nСхема `tx`.\nВ целях полноты, чтобы использовать элементы схемы `tx`, вам необходимо иметь следующую преамбулу в верхней части файла конфигурации Spring XML.\nТекст в следующий фрагмент ссылается на правильную схему, поэтому теги в пространстве имен `tx` вам доступны:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""}
{"id": 100, "text": "xmlns:tx=\"http://www.springframework.org/schema/tx\" <1>\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd <2>\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<!-- bean definitions here -->\n	</beans>\nСхема `tx`. <1> Объявить использование пространства имен `tx`. <2> Укажите местоположение (вместе с другими местоположениями схемы).\nСхема `tx`.\nПРИМЕЧАНИЕ.\nЧасто, когда вы используете элементы в пространстве имен `tx`, вы также используете элементы из пространства имен `aop` (поскольку поддержка декларативных транзакций в Spring реализовано с использованием АОП).\nПредыдущий фрагмент XML содержит необходимые строки. для ссылки на схему `aop`, чтобы элементы в пространстве имен `aop` были доступны тебе."}
{"id": 101, "text": "Схема `jdbc`.\nЭлементы `jdbc` позволяют быстро настроить встроенную базу данных или инициализировать существующий источник данных.\nЭти элементы описаны в\nСхема `jdbc`.\nЧтобы использовать элементы схемы `jdbc`, вам необходимо иметь следующую преамбулу в начале: начало вашего XML-файла конфигурации Spring.\nТекст в следующих ссылках на фрагменты правильную схему, чтобы элементы пространства имен jdbc были вам доступны:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" <1>\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/jdbc\n			https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"> <2>\n		<!-- bean definitions here -->\n	</beans>"}
{"id": 102, "text": "Схема `jdbc`. <1> Объявите использование пространства имен `jdbc`. <2> Укажите местоположение (вместе с другими местоположениями схемы)."}
{"id": 103, "text": "Интеграция с конкретным сервером приложений.\nАбстракция транзакций Spring обычно не зависит от сервера приложений.\nКроме того, Класс Spring `JtaTransactionManager` (который может дополнительно выполнять поиск JNDI для объекты JTA UserTransaction и TransactionManager) автоматически определяет местоположение для последний объект, который зависит от сервера приложений.\nИмея доступ к JTA `TransactionManager` позволяет улучшить семантику транзакций, в частности: поддержка приостановки транзакции.\nСм. {spring-framework-api}/transaction/jta/JtaTransactionManager.html[`JtaTransactionManager`] javadoc для получения подробной информации.\nИнтеграция с конкретным сервером приложений.\nSpring `JtaTransactionManager` является стандартным выбором для запуска в приложении Jakarta EE. серверах и, как известно, работает на всех распространенных серверах.\nРасширенные функции, такие как приостановка транзакций, также работает на многих серверах (включая GlassFish, JBoss и Geronimo) без необходимости какой-либо специальной настройки."}
{"id": 104, "text": "Шаги запуска приложения.\nВ этой части приложения перечислены существующие «StartupSteps», которыми оснащен основной контейнер.\nШаги запуска приложения.\nВНИМАНИЕ: Название и подробная информация о каждом этапе запуска не являются частью публичного контракта и может быть изменен; это рассматривается как деталь реализации основного контейнера и будет следовать его поведение меняется.\nШаги запуска приложения, определенные в основном контейнере. |=== | Имя| Описание| Теги\nШаги запуска приложения. | `spring.beans.instantiate` | Создание экземпляра bean-компонента и его зависимостей. | `beanName` — имя компонента, `beanType` — тип, требуемый в точке внедрения.\nШаги запуска приложения. | `spring.beans.smart-initialize` | Инициализация bean-компонентов SmartInitializingSingleton. | `beanName` имя компонента.\nШаги запуска приложения. | `spring.context.base-packages.scan` | Сканирование базовых пакетов. | `packages` массив базовых пакетов для сканирования.\nШаги запуска приложения. | `spring.context.beans.post-process` | Фаза постобработки зерен.\nШаги запуска приложения. | `spring.context.bean-factory.post-process` | Вызов bean-компонентов BeanFactoryPostProcessor. | `postProcessor` текущий постпроцессор."}
{"id": 105, "text": "Шаги запуска приложения. | `spring.context.beandef-registry.post-process` | Вызов bean-компонентов BeanDefinitionRegistryPostProcessor. | `postProcessor` текущий постпроцессор.\nШаги запуска приложения. | `spring.context.comComponent-classes.register` | Регистрация классов компонентов через AnnotationConfigApplicationContext#register. | `classes` массив заданных классов для регистрации.\nШаги запуска приложения. | `spring.context.config-classes.enhance` | Расширение классов конфигурации с помощью прокси CGLIB. | `classCount` — количество расширенных классов.\nШаги запуска приложения. | `spring.context.config-classes.parse` | Фаза анализа классов конфигурации с помощью `ConfigurationClassPostProcessor`. | `classCount` — количество обработанных классов."}
{"id": 106, "text": "Консультирование по транзакционным операциям.\nПредположим, вы хотите выполнить как транзакционные операции, так и некоторые базовые рекомендации по профилированию.\nКак это сделать в контексте `<tx:annotation-driven/>`?\n* Запускается настроенный аспект профилирования.\n* Транзакционный совет работает.\n* Запускается метод рекомендованного объекта.\n* Транзакция фиксируется.\n* Аспект профилирования сообщает точную продолжительность всего вызова транзакционного метода.\nКогда вы вызываете метод updateFoo(Foo)`, вы хотите увидеть следующие действия:.\nПРИМЕЧАНИЕ.\nЭта глава не посвящена подробному объяснению АОП (за исключением применяется к транзакциям).\nСм.\nAOP для подробного описания АОП. конфигурации и АОП в целом.\nJava\n	package x.y;\n	import org.aspectj.lang.ProceedingJoinPoint;\n	import org.springframework.util.StopWatch;\n	import org.springframework.core.Ordered;\n	public class SimpleProfiler implements Ordered {\n		private int order;\n		// позволяет нам контролировать порядок советов\n		public int getOrder() {\n			return this.order;\n		public void setOrder(int order) {\n			this.order = order;\n		// этот метод является универсальным советом\n		public Object profile(ProceedingJoinPoint call) throws Throwable {\n			Object returnValue;\n			StopWatch clock = new StopWatch(getClass().getName());\n			try {\n				clock.start(call.toShortString());\n				returnValue = call.proceed();\n			} finally {\n				clock.stop();"}
{"id": 107, "text": "System.out.println(clock.prettyPrint());\n			return returnValue;\n	package x.y\n	class SimpleProfiler : Ordered {\nСледующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.\nЗаказ консультации управляется через интерфейс Ordered.\nПодробную информацию о заказе консультации см.\nСледующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.\nСледующая конфигурация создает bean-компонент `fooService`, который имеет профилирование и транзакционные аспекты, применяемые к нему в желаемом порядке:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd"}
{"id": 108, "text": "http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n		<!-- this is the aspect -->\n		<bean id=\"profiler\" class=\"x.y.SimpleProfiler\">\n			<!-- run before the transactional advice (hence the lower order number) -->\n			<property name=\"order\" value=\"1\"/>\n		</bean>\n		<tx:annotation-driven transaction-manager=\"txManager\" order=\"200\"/>\n		<aop:config>\n				<!-- this advice runs around the transactional advice -->\n				<aop:aspect id=\"profilingAspect\" ref=\"profiler\">\n					<aop:pointcut id=\"serviceMethodWithReturnValue\"\n							expression=\"execution(!void x.y..*Service.*(..))\"/>\n					<aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/>\n				</aop:aspect>\n		</aop:config>"}
{"id": 109, "text": "<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n			<property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/>\n			<property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/>\n			<property name=\"username\" value=\"scott\"/>\n			<property name=\"password\" value=\"tiger\"/>\n		</bean>\n		<bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n			<property name=\"dataSource\" ref=\"dataSource\"/>\n		</bean>\n	</beans>\nСледующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.\nВы можете настроить любое количество дополнительных аспектов аналогичным образом.\nСледующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.\nВ следующем примере создаются те же настройки, что и в двух предыдущих примерах, но используется чисто XML. декларативный подход:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\""}
{"id": 110, "text": "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n		<!-- the profiling advice -->\n		<bean id=\"profiler\" class=\"x.y.SimpleProfiler\">\n			<!-- run before the transactional advice (hence the lower order number) -->\n			<property name=\"order\" value=\"1\"/>\n		</bean>\n		<aop:config>"}
{"id": 111, "text": "<aop:pointcut id=\"entryPointMethod\" expression=\"execution(* x.y..*Service.*(..))\"/>\n			<!-- runs after the profiling advice (cf. the order attribute) -->\n			<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"entryPointMethod\" order=\"2\"/>\n			<!-- order value is higher than the profiling aspect -->\n			<aop:aspect id=\"profilingAspect\" ref=\"profiler\">\n				<aop:pointcut id=\"serviceMethodWithReturnValue\"\n						expression=\"execution(!void x.y..*Service.*(..))\"/>\n				<aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/>\n			</aop:aspect>\n		</aop:config>\n		<tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n			<tx:attributes>\n				<tx:method name=\"get*\" read-only=\"true\"/>\n				<tx:method name=\"*\"/>\n			</tx:attributes>\n		</tx:advice>\n		<!-- other <bean/> definitions such as a DataSource and a TransactionManager here -->\n	</beans>"}
{"id": 112, "text": "Следующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.\nРезультатом предыдущей конфигурации является bean-компонент `fooService`, имеющий профилирование и транзакционные аспекты, применяемые к нему именно в этом порядке.\nЕсли вам нужен совет по профилированию бежать за транзакционным советом по пути и перед транзакционная консультация по выходу, можно поменять стоимость профилирования свойство \"order\" аспектного компонента, чтобы оно было выше, чем свойство транзакционного совета. стоимость заказа.\nСледующий код демонстрирует простой аспект профилирования, обсуждавшийся ранее:.\nАналогичным образом можно настроить дополнительные аспекты."}
{"id": 113, "text": "Аргументы метода.\nВ следующей таблице показаны поддерживаемые аргументы метода контроллера.\nАргументы метода.\nРеактивные типы (Reactor, RxJava, или другие) являются поддерживается для аргументов, требующих блокировки ввода-вывода (например, чтения тела запроса) для быть решена.\nЭто отмечено в столбце «Описание».\nРеактивные типы не предполагаются по аргументам, не требующим блокировки.\nАргументы метода.\nJava.util.Optional в JDK 1.8 поддерживается как аргумент метода в сочетании с аннотации, имеющие атрибут `required` (например, `@RequestParam`, `@RequestHeader`, и другие) и эквивалентен `required=false`.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `ServerWebExchange` | Доступ к полному контейнеру ServerWebExchange для HTTP-запросов и ответов. атрибуты запроса и сеанса, методы checkNotModified и другие.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `ServerHttpRequest`, `ServerHttpResponse` | Доступ к HTTP-запросу или ответу.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `Веб-сессия` | Доступ к сессии."}
{"id": 114, "text": "Это не приводит к принудительному запуску нового сеанса, если только атрибуты добавляются.\nПоддерживает реактивные типы.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `java.security.Principal` | Текущий аутентифицированный пользователь — возможно, определенный класс реализации Principal, если он известен.\nПоддерживает реактивные типы.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `org.springframework.http.HttpMethod` | HTTP-метод запроса.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `java.util.Locale` | Текущая локаль запроса, определяемая наиболее конкретным доступным LocaleResolver — в эффект, настроенный LocaleResolver/LocaleContextResolver.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `java.util.TimeZone` + `java.time.ZoneId` | Часовой пояс, связанный с текущим запросом, определенный с помощью LocaleContextResolver."}
{"id": 115, "text": "[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@PathVariable` | Для доступа к переменным шаблона URI.\nСм. ссылку:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-uri-templates [Шаблоны URI].\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@MatrixVariable` | Для доступа к парам имя-значение в сегментах пути URI.\nСм. ссылку:web/webflux/controller/ann-methods/matrix-variables.adoc [Матричные переменные].\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@RequestParam` | Для доступа к параметрам запроса.\nЗначения параметров преобразуются в объявленный аргумент метода. тип.\nСм. ссылку:web/webflux/controller/ann-methods/requestparam.adoc[`@RequestParam`].\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание.\nОбратите внимание, что использование @RequestParam не является обязательным — например, для установки его атрибутов."}
{"id": 116, "text": "См. раздел «Любой другой аргумент» ниже в этой таблице.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@RequestHeader` | Для доступа к заголовкам запросов.\nЗначения заголовка преобразуются в объявленный аргумент метода. тип.\nСм. ссылку:web/webflux/controller/ann-methods/requestheader.adoc[`@RequestHeader`].\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@CookieValue` | Для доступа к файлам cookie.\nЗначения файлов cookie преобразуются в объявленный тип аргумента метода.\nСм. ссылку:web/webflux/controller/ann-methods/cookievalue.adoc[`@CookieValue`].\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@RequestBody` | Для доступа к телу HTTP-запроса.\nСодержимое тела преобразуется в объявленный метод. тип аргумента с использованием экземпляров HttpMessageReader.\nПоддерживает реактивные типы.\nСм. ссылку:web/webflux/controller/ann-methods/requestbody.adoc[`@RequestBody`]."}
{"id": 117, "text": "[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `HttpEntity<B>` | Для доступа к заголовкам и телу запроса.\nТело преобразуется с помощью экземпляров HttpMessageReader.\nПоддерживает реактивные типы.\nСм. ссылку:web/webflux/controller/ann-methods/httpentity.adoc[`HttpEntity`].\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@RequestPart` | Для доступа к части запроса multipart/form-data.\nПоддерживает реактивные типы.\nСм.\nМногочастный контент и Многочастные данные.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `java.util.Map` или `org.springframework.ui.Model` | Для доступа к модели, которая используется в контроллерах HTML и предоставляется шаблонам как часть рендеринга представления.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@ModelAttribute` | Для доступа к существующему атрибуту в модели (созданному, если он отсутствует) с помощью применена привязка и проверка данных."}
{"id": 118, "text": "См. также ссылку:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[`@ModelAttribute`] как `Model` и `DataBinder`.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание.\nОбратите внимание, что использование @ModelAttribute не является обязательным — например, для установки его атрибутов.\nСм. раздел «Любой другой аргумент» ниже в этой таблице.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `Ошибки` или `BindingResult` | Для доступа к ошибкам проверки и привязки данных для объекта команды, т.е.\nАргумент `@ModelAttribute`.\nДолжен быть объявлен аргумент `Errors` или `BindingResult`. сразу после проверенного аргумента метода.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `SessionStatus` + `@SessionAttributes` уровня класса | Для маркировки завершения обработки формы, что приводит к очистке атрибутов сеанса. объявлен через аннотацию @SessionAttributes на уровне класса.\nДополнительную информацию см. в `@SessionAttributes`."}
{"id": 119, "text": "[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `UriComponentsBuilder` | Для подготовки URL-адреса относительно хоста, порта, схемы и контекстный путь.\nСм. ссылки URI.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@SessionAttribute` | Для доступа к любому атрибуту сеанса — в отличие от атрибутов модели, хранящихся в сеансе. в результате объявления `@SessionAttributes` на уровне класса.\nСм.\n[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | `@RequestAttribute` | Для доступа к атрибутам запроса.\nДополнительную информацию см. в `@RequestAttribute`."}
{"id": 120, "text": "[cols=\"1,2\", options=\"header\"] |=== | Аргумент метода контроллера | Описание. | Любой другой аргумент | Если аргумент метода не соответствует ни одному из вышеперечисленных, он по умолчанию разрешается как `@RequestParam`, если это простой тип, как определено {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty], или как `@ModelAttribute`, в противном случае. |==="}
{"id": 121, "text": "Построение массива.\nВы можете создавать массивы, используя знакомый синтаксис Java, при необходимости предоставляя инициализатор. чтобы массив был заполнен во время построения.\nВ следующем примере показано, как это сделать:\nJava\n	int[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context);\n	// Массив с инициализатором\n	int[] numbers2 = (int[]) parser.parseExpression(\"new int[] {1, 2, 3}\").getValue(context);\n	// Многомерный массив\n	int[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\nПостроение массива. [ПРИМЕЧАНИЕ] = В настоящее время вы не можете предоставить инициализатор при создании многомерного массива.\nПостроение массива. [ВНИМАНИЕ] = Любое выражение, создающее массив, например, через `new int[4]` или `new int[] {1, 2, 3}` – невозможно скомпилировать.\nСм. для получения подробной информации."}
{"id": 122, "text": "Программное создание прокси @AspectJ.\nВ дополнение к объявлению аспектов в вашей конфигурации с помощью `<aop:config>` или `<aop:aspectj-autoproxy>`, также можно программно создавать прокси которые советуют целевые объекты.\nПолную информацию о Spring AOP API см. создавать прокси, используя аспекты @AspectJ.\nПрограммное создание прокси @AspectJ.\nВы можете использовать класс org.springframework.aop.aspectj.annotation.AspectJProxyFactory. для создания прокси для целевого объекта, которому соответствует один или несколько аспектов @AspectJ.\nБазовое использование этого класса очень просто, как показано в следующем примере:\nJava\n	// создаем фабрику, которая может генерировать прокси для данного целевого объекта\n	AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);\n	// добавьте аспект, класс должен быть аспектом @AspectJ\n	// вы можете вызывать это столько раз, сколько вам нужно с разными аспектами\n	factory.addAspect(SecurityManager.class);\n	// вы также можете добавить существующие экземпляры аспектов, тип предоставленного объекта\n	// должен быть аспектом @AspectJ\n	factory.addAspect(usageTracker);\n	// теперь получите прокси-объект...\n	MyInterfaceType proxy = factory.getProxy();\n	// вы также можете добавить существующие экземпляры аспектов, тип предоставленного объекта\n	// должен быть аспектом @AspectJ\n	factory.addAspect(usageTracker)\nПрограммное создание прокси @AspectJ."}
{"id": 123, "text": "Дополнительную информацию см. в {spring-framework-api}/aop/aspectj/annotation/AspectJProxyFactory.html[javadoc]."}
{"id": 124, "text": "Включение поддержки @AspectJ.\nЧтобы использовать аспекты @AspectJ в конфигурации Spring, вам необходимо включить поддержку Spring для настройка Spring AOP на основе аспектов @AspectJ и автоматических прокси-компонентов на основе независимо от того, советуют ли им эти аспекты.\nПод автоматическим проксированием мы подразумеваем, что если Spring определяет, что компоненту соответствует один или несколько аспектов, он автоматически генерирует прокси-сервер для этого bean-компонента для перехвата вызовов методов и обеспечения выполнения рекомендаций по мере необходимости.\nВключение поддержки @AspectJ.\nПоддержку @AspectJ можно включить с помощью программной конфигурации или конфигурации XML.\nВ любом В этом случае вам также необходимо убедиться, что библиотека AspectJ `org.aspectj:aspectjweaver` находится на путь к классам вашего приложения (версия 1.9 или новее).\nСм. пример кода в исходном документе."}
{"id": 125, "text": "Использование `@Transactional` с AspectJ.\nВы также можете использовать поддержку `@Transactional` Spring Framework вне Spring. контейнер с помощью аспекта AspectJ.\nДля этого сначала аннотируйте свои классы (и, возможно, методы ваших классов) с аннотацией @Transactional, а затем свяжите (свяжите) свое приложение с `org.springframework.transaction.aspectj.AnnotationTransactionAspect`, определенный в файл `spring-aspects.jar`.\nТакже необходимо настроить аспект с транзакцией менеджер.\nВы можете использовать контейнер IoC Spring Framework, чтобы позаботиться о внедрение аспекта зависимости.\nСамый простой способ настройки транзакции аспект управления заключается в использовании элемента `<tx:annotation-driven/>` и указании Атрибут `mode` для `aspectj`, как описано в Поскольку здесь мы фокусируемся на приложениях, которые работают вне контейнера Spring, мы покажем вам, как это сделать программно.\nПРИМЕЧАНИЕ.\nПрежде чем продолжить, вы можете прочитать.\nВ следующем примере показано, как создать диспетчер транзакций и настроить `AnnotationTransactionAspect`, чтобы использовать его:\nJava\n	// создаем соответствующий менеджер транзакций\n	DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());\n	// настройте AnnotationTransactionAspect для его использования; это необходимо сделать перед выполнением любых транзакционных методов\n	AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);\n	// настройте AnnotationTransactionAspect для его использования; это необходимо сделать перед выполнением любых транзакционных методов\n	AnnotationTransactionAspect.aspectOf().transactionManager = txManager"}
{"id": 126, "text": "ПРИМЕЧАНИЕ.\nПрежде чем продолжить, вы можете прочитать.\nПРИМЕЧАНИЕ.\nКогда вы используете этот аспект, вы должны аннотировать класс реализации (или методы внутри этого класса или обоих), а не интерфейс (если таковой имеется), который реализует класс.\nАспектJ следует правилу Java, согласно которому аннотации интерфейсов не наследуются.\nПРИМЕЧАНИЕ.\nПрежде чем продолжить, вы можете прочитать.\nАннотация `@Transactional` в классе определяет семантику транзакции по умолчанию. для выполнения любого публичного метода в классе.\nПРИМЕЧАНИЕ.\nПрежде чем продолжить, вы можете прочитать.\nАннотация `@Transactional` для метода внутри класса переопределяет стандартную аннотацию. семантика транзакции, заданная аннотацией класса (если присутствует).\nВы можете аннотировать любой метод, независимо от видимости.\nПРИМЕЧАНИЕ.\nПрежде чем продолжить, вы можете прочитать.\nЧтобы объединить ваши приложения с AnnotationTransactionAspect, вам необходимо либо создать ваше приложение с помощью AspectJ (см. {aspectj-docs-devguide}/index.html[AspectJ Development Guide]) или используйте переплетение во время загрузки.\nСм. для обсуждения переплетения времени загрузки с AspectJ."}
{"id": 127, "text": "Объявление аспекта.\nЕсли включена поддержка @AspectJ, любой компонент, определенный в контексте вашего приложения с помощью класс, который является аспектом @AspectJ (имеет аннотацию @Aspect), автоматически обнаруживается Spring и используется для настройки Spring AOP.\nСледующие два примера демонстрируют минимальные шаги, необходимые для не очень полезного аспекта.\nОбъявление аспекта.\nВ первом из двух примеров показано определение обычного компонента в контексте приложения. который указывает на класс bean-компонента, помеченный @Aspect: См. пример кода в исходном документе.\nОбъявление аспекта.\nВо втором из двух примеров показано определение класса NotVeryUsefulAspect, которое с аннотацией `@Aspect`: См. пример кода в исходном документе.\nОбъявление аспекта.\nАспекты (классы, помеченные `@Aspect`) могут иметь методы и поля, такие же, как и любые другие. другой класс.\nОни также могут содержать метки, советы и введение (межтиповые). декларации.\nОбъявление аспекта. .Автоопределение аспектов посредством сканирования компонентов ПРИМЕЧАНИЕ.\nВы можете зарегистрировать классы аспектов как обычные bean-компоненты в конфигурации Spring XML. через методы `@Bean` в классах `@Configuration` или заставить Spring автоматически определять их через сканирование пути к классам — то же самое, что и любой другой компонент, управляемый Spring.\nОднако обратите внимание, что Аннотации `@Aspect` недостаточно для автоматического обнаружения в пути к классам."}
{"id": 128, "text": "Для этого Для этой цели вам необходимо добавить отдельную аннотацию `@Component` (или, альтернативно, собственный стереотипная аннотация, которая соответствует правилам сканера компонентов Spring).\nОбъявление аспекта. .Консультируете аспекты с другими аспектами?\nПРИМЕЧАНИЕ.\nВ Spring AOP аспекты сами по себе не могут быть объектом советов от других аспекты.\nАннотация `@Aspect` к классу отмечает его как аспект и, следовательно, исключает это от автопроксирования."}
{"id": 129, "text": "Поддержка @AspectJ. @AspectJ относится к стилю объявления аспектов как обычных классов Java, аннотированных аннотации.\nСтиль @AspectJ был представлен {aspectj-site}[проект AspectJ] как часть версии AspectJ 5.\nВесна интерпретирует те же аннотации, что и AspectJ 5, используя библиотеку, предоставленную AspectJ. для анализа и сопоставления точек.\nОднако среда выполнения AOP по-прежнему представляет собой чистый Spring AOP, и нет зависимости от компилятора AspectJ или weaver.\nПоддержка @AspectJ.\nПРИМЕЧАНИЕ.\nИспользование компилятора AspectJ и программы Weaver позволяет использовать полную версию языка AspectJ и обсуждается в Использование AspectJ с приложениями Spring."}
{"id": 130, "text": "Использование функции «автопрокси».\nДо сих пор мы рассматривали явное создание прокси АОП с помощью ProxyFactoryBean или аналогичный фабричный боб.\nИспользование функции «автопрокси».\nSpring также позволяет нам использовать определения bean-компонентов «автопрокси», которые могут автоматически прокси-определения выбранных компонентов.\nОн построен на основе «постпроцессора bean-компонентов» Spring. инфраструктура, которая позволяет изменять определение любого компонента по мере загрузки контейнера.\nИспользование функции «автопрокси».\nВ этой модели вы настраиваете некоторые специальные определения bean-компонентов в файле определения bean-компонентов XML. для настройки инфраструктуры автопрокси.\nЭто позволяет вам объявить цели имеет право на автоматическое проксирование.\nВам не нужно использовать ProxyFactoryBean.\n* С помощью создателя автоматического прокси, который ссылается на определенные bean-компоненты в текущем контексте.\n* Особый случай создания автопрокси, заслуживающий отдельного рассмотрения:\nЕсть два способа сделать это:. автоматическое создание прокси, управляемое атрибутами метаданных на уровне источника.\nОпределения компонентов автопрокси.\nВ этом разделе описаны создатели автоматических прокси, предоставляемые Пакет `org.springframework.aop.framework.autoproxy`.\n`BeanNameAutoProxyCreator`.\nКласс BeanNameAutoProxyCreator — это BeanPostProcessor, который автоматически создает Прокси-серверы АОП для компонентов с именами, которые соответствуют литеральным значениям или подстановочным знакам.\nСледующие пример показывает, как создать bean-компонент `BeanNameAutoProxyCreator`:\n	<bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">"}
{"id": 131, "text": "<property name=\"beanNames\" value=\"jdk*,onlyJdk\"/>\n		<property name=\"interceptorNames\">\n			<list>\n				<value>myInterceptor</value>\n			</list>\n		</property>\n	</bean>\n`BeanNameAutoProxyCreator`.\nКак и в случае с ProxyFactoryBean, здесь имеется свойство interceptorNames, а не список. перехватчиков, чтобы обеспечить правильное поведение советников-прототипов.\nНазваны «перехватчиками» могут быть советниками или советами любого типа.\n`BeanNameAutoProxyCreator`.\nКак и в случае с автоматическим проксированием, основной смысл использования BeanNameAutoProxyCreator заключается в последовательно применять одну и ту же конфигурацию к нескольким объектам с минимальным объемом конфигурация.\nЭто популярный выбор для применения декларативных транзакций к нескольким объекты.\n`BeanNameAutoProxyCreator`.\nОпределения компонентов, имена которых совпадают, например `jdkMyBean` и `onlyJdk` в предыдущем примере.\nНапример, это простые старые определения bean-компонентов с целевым классом.\nПрокси-сервер АОП — это автоматически создается с помощью BeanNameAutoProxyCreator.\nТот же совет применяется ко всем совпадающим бобам.\nОбратите внимание, что если используются советники (а не перехватчик в предыдущий пример), pointcuts могут по-разному применяться к разным компонентам.\n`DefaultAdvisorAutoProxyCreator`.\nБолее общий и чрезвычайно мощный инструмент автоматического создания прокси — `DefaultAdvisorAutoProxyCreator`.\nЭто автоматически применяет подходящих советников в текущий контекст, без необходимости включать конкретные имена компонентов в автоматический прокси определение компонента советника."}
{"id": 132, "text": "Он предлагает те же преимущества последовательной конфигурации и избежание дублирования как `BeanNameAutoProxyCreator`.\n* Указание определения bean-компонента `DefaultAdvisorAutoProxyCreator`.\n* Указание любого количества советников в том же или связанных контекстах. Обратите внимание, что эти\nИспользование этого механизма предполагает:. должны быть советниками, а не перехватчиками или другими советчиками.\nЭто необходимо, потому что должна быть точка для оценки, проверки приемлемости каждого совета к определениям потенциальных компонентов.\nИспользование этого механизма предполагает:. `DefaultAdvisorAutoProxyCreator` автоматически оценивает содержащийся pointcut. в каждом советнике, чтобы увидеть, какой совет (если таковой имеется) следует применить к каждому бизнес-объекту. (например, businessObject1 и businessObject2 в примере).\nИспользование этого механизма предполагает:.\nЭто означает, что любое количество советников может быть автоматически применено к каждому бизнесу. объект.\nЕсли ни один pointcut ни в одном из советников не соответствует какому-либо методу бизнес-объекта, объект не проксирован.\nПоскольку определения компонентов добавляются для новых бизнес-объектов, при необходимости они автоматически проксируются.\nИспользование этого механизма предполагает:.\nПреимущество автоматического проксирования в целом состоит в том, что оно делает невозможным для вызывающих абонентов или зависимости для получения непредусмотренного объекта.\nВызов `getBean(\"businessObject1\")` для этого `ApplicationContext` возвращает прокси-сервер AOP, а не целевой бизнес-объект. («Внутренний Идиома bean`\", показанная ранее, также предлагает это преимущество.)"}
{"id": 133, "text": "Использование этого механизма предполагает:.\nВ следующем примере создается bean-компонент DefaultAdvisorAutoProxyCreator, а другой — элементы, обсуждаемые в этом разделе:\n	<bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n	<bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\">\n		<property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/>\n	</bean>\n	<bean id=\"customAdvisor\" class=\"com.mycompany.MyAdvisor\"/>\n	<bean id=\"businessObject1\" class=\"com.mycompany.BusinessObject1\">\n		<!-- Properties omitted -->\n	</bean>\n	<bean id=\"businessObject2\" class=\"com.mycompany.BusinessObject2\"/>\nИспользование этого механизма предполагает:. `DefaultAdvisorAutoProxyCreator` очень полезен, если вы хотите применить тот же совет. последовательно для многих бизнес-объектов.\nКак только определения инфраструктуры будут готовы, вы можете добавлять новые бизнес-объекты, не включая специальную конфигурацию прокси.\nВы также можете легко добавить дополнительные аспекты (например, отслеживание или аспекты мониторинга производительности) с минимальными изменениями в конфигурации.\nИспользование этого механизма предполагает:. `DefaultAdvisorAutoProxyCreator` предлагает поддержку фильтрации (с использованием именования). соглашение, согласно которому оцениваются только определенные советники, что позволяет использовать несколько, настроены по-разному, AdvisorAutoProxyCreators на одной фабрике) и упорядочивание."}
{"id": 134, "text": "Консультанты могут реализовать интерфейс org.springframework.core.Ordered, чтобы гарантировать правильный порядок, если это проблема.\nTransactionAttributeSourceAdvisor, используемый в предыдущий пример имеет настраиваемое значение порядка.\nНастройка по умолчанию неупорядочена."}
{"id": 135, "text": "Точная настройка автоматического связывания на основе аннотаций с помощью `@Primary` или `@Fallback`\nПоскольку автоматическое подключение по типу может привести к появлению нескольких кандидатов, часто необходимо иметь больший контроль над процессом выбора.\nОдин из способов добиться этого — использовать Spring Аннотация `@Primary`. `@Primary` указывает, что следует передать конкретный bean-компонент предпочтение, когда несколько bean-компонентов являются кандидатами на автоматическое подключение к однозначному зависимость.\nЕсли среди кандидатов существует ровно один первичный компонент, он становится автоматически устанавливаемое значение.\nРассмотрим следующую конфигурацию, которая определяет `firstMovieCatalog` как основной `MovieCatalog`:\nJava\n	@Configuration\n	public class MovieConfiguration {\n		@Bean\n		@Primary\n		public MovieCatalog firstMovieCatalog() { ... }\n		@Bean\n		public MovieCatalog secondMovieCatalog() { ... }\n	@Configuration\n	class MovieConfiguration {\nВ качестве альтернативы, начиная с версии 6.2, существует аннотация @Fallback для разграничения. любые бобы, кроме обычных, которые нужно вводить.\nЕсли бы только один постоянный bean-компонент остался, он также фактически является первичным:\nJava\n	@Configuration\n	public class MovieConfiguration {\n		@Bean\n		public MovieCatalog firstMovieCatalog() { ... }\n		@Bean\n		@Fallback\n		public MovieCatalog secondMovieCatalog() { ... }\n	@Configuration\n	class MovieConfiguration {\nВ обоих вариантах предыдущей конфигурации следующее «MovieRecommender» автоматически подключается к «firstMovieCatalog»:\nJava\n	public class MovieRecommender {\n		@Autowired\n		private MovieCatalog movieCatalog;"}
{"id": 136, "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<context:annotation-config/>\n		<bean class=\"example.SimpleMovieCatalog\" primary=\"true\">\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n	</beans>"}
{"id": 137, "text": "Точная настройка автоматического связывания на основе аннотаций с квалификаторами. `@Primary` и `@Fallback` — эффективные способы использования автоматического связывания по типу с несколькими случаи, когда может быть определен один основной (или нерезервный) кандидат.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nЕсли вам нужен больший контроль над процессом выбора, вы можете использовать Spring `@Qualifier`. аннотация.\nВы можете связать значения квалификаторов с конкретными аргументами, сужая набор типа совпадает, так что для каждого аргумента выбирается конкретный bean-компонент.\nВ простейшем случае это может быть простое описательное значение, как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		@Autowired\n		@Qualifier(\"main\")\n		private MovieCatalog movieCatalog;\n	class MovieRecommender {\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nВы также можете указать аннотацию @Qualifier для отдельных аргументов конструктора или параметры метода, как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		private final MovieCatalog movieCatalog;\n		private final CustomerPreferenceDao customerPreferenceDao;\n		@Autowired\n		public void prepare(@Qualifier(\"main\") MovieCatalog movieCatalog,\n				CustomerPreferenceDao customerPreferenceDao) {\n			this.movieCatalog = movieCatalog;\n			this.customerPreferenceDao = customerPreferenceDao;\n	class MovieRecommender {\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nВ следующем примере показаны соответствующие определения bean-компонентов.\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>"}
{"id": 138, "text": "<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<context:annotation-config/>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<qualifier value=\"main\"/> <1>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<qualifier value=\"action\"/> <2>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n	</beans>"}
{"id": 139, "text": "Точная настройка автоматического связывания на основе аннотаций с квалификаторами. <1> Компонент со значением квалификатора `main` связан с аргументом конструктора, который квалифицируется с тем же значением. <2> Компонент со значением квалификатора action связан с аргументом конструктора, который квалифицируется с тем же значением.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nДля резервного соответствия имя компонента считается значением квалификатора по умолчанию.\nТаким образом, вы можно определить компонент с идентификатором `main` вместо вложенного квалификатора, что приводит к к тому же результату сопоставления.\nОднако, хотя вы можете использовать это соглашение для ссылки на конкретных bean-компонентов по имени, `@Autowired` по сути представляет собой внедрение на основе типов с помощью необязательные семантические квалификаторы.\nЭто означает, что значения квалификаторов, даже с именем компонента запасной вариант всегда имеет сужающую семантику в наборе совпадений типов.\nОни не семантически выразить ссылку на уникальный идентификатор компонента.\nХорошие значения квалификатора — `main` или «EMEA», или «постоянный», выражающий характеристики конкретного компонента, которые независимо от идентификатора bean-компонента, который может быть сгенерирован автоматически в случае анонимного bean-компонента определение, подобное приведенному в предыдущем примере.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nКвалификаторы также применимы к типизированным коллекциям, как обсуждалось ранее, например, к `Set<MovieCatalog>`."}
{"id": 140, "text": "В этом случае все соответствующие bean-компоненты, согласно заявленному квалификаторы вводятся как коллекция.\nЭто означает, что квалификаторы не обязательно должны быть уникальный.\nСкорее, они представляют собой критерии фильтрации.\nНапример, вы можете определить несколько bean-компонентов `MovieCatalog` с одинаковым значением квалификатора ``action``, все из которых введенный в `Set<MovieCatalog>` с аннотацией `@Qualifier(\"action\")`.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами. [СОВЕТ] = Разрешение значениям квалификатора выбирать имена целевых компонентов в рамках сопоставления типов. кандидатов, не требует аннотации @Qualifier в точке внедрения.\nЕсли нет другого индикатора разрешения (например, квалификатора или основного маркера), для неуникальной ситуации зависимости Spring соответствует имени точки внедрения (то есть имя поля или имя параметра) против имен целевых компонентов и выбирает кандидат с тем же именем, если таковой имеется (либо по имени компонента, либо по связанному псевдониму).\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nНачиная с версии 6.1, для этого требуется наличие флага компилятора Java `-parameters`.\nНачиная с версии 6.2, контейнер применяет быстрое разрешение ярлыков для совпадений имен компонентов. обход алгоритма полного сопоставления типов, когда имя параметра соответствует имени имя компонента и отсутствие типа, квалификатора или основных условий переопределяют совпадение.\nЭто поэтому рекомендуется, чтобы имена ваших параметров соответствовали именам целевых компонентов."}
{"id": 141, "text": "Точная настройка автоматического связывания на основе аннотаций с квалификаторами.\nВ качестве альтернативы внедрению по имени рассмотрите аннотацию JSR-250 `@Resource`. который семантически определен для идентификации конкретного целевого компонента по его уникальному имени, при этом объявленный тип не имеет значения для процесса сопоставления. `@Autowired` имеет скорее различная семантика: после выбора компонентов-кандидатов по типу указанная `String` Значение квалификатора учитывается только среди кандидатов, выбранных по типу (например, сопоставление квалификатора account с компонентами, отмеченными той же меткой квалификатора).\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nДля bean-компонентов, которые сами определены как коллекция, Map или массив, @Resource. является прекрасным решением, ссылающимся на конкретную коллекцию или массив по уникальному имени.\nТем не менее, вы можете сопоставлять типы коллекций, Map и массивов с помощью Spring.\nАлгоритм сопоставления типов `@Autowired` также, если информация о типе элемента сохраняется в сигнатурах возвращаемого типа @Bean или иерархиях наследования коллекций.\nВ этом случае вы можете использовать значения квалификаторов для выбора среди однотипных коллекций. как указано в предыдущем пункте.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами. `@Autowired` также учитывает ссылки на себя для внедрения (то есть ссылки на себя). bean-компонент, который в данный момент внедряется).\nСм. для получения подробной информации."}
{"id": 142, "text": "Точная настройка автоматического связывания на основе аннотаций с квалификаторами. `@Autowired` применяется к полям, конструкторам и методам с несколькими аргументами, позволяя сужение за счет аннотаций квалификаторов на уровне параметра.\nНапротив, `@Resource` поддерживается только для полей и методов установки свойств компонента с одним аргументом.\nКак следствие, вам следует придерживаться квалификаторов, если ваша цель инъекции — конструктор или метод с несколькими аргументами.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nВы можете создавать свои собственные аннотации квалификаторов.\nДля этого определите аннотацию и укажите аннотацию @Qualifier в своем определении, как показано в следующем примере:\nJava\n	@Target({ElementType.FIELD, ElementType.PARAMETER})\n	@Retention(RetentionPolicy.RUNTIME)\n	@Qualifier\n	public @interface Genre {\n		String value();\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nЗатем вы можете указать пользовательский квалификатор для полей и параметров с автоматическим связыванием, как следующий пример показывает:\nJava\n	public class MovieRecommender {\n		@Autowired\n		@Genre(\"Action\")\n		private MovieCatalog actionCatalog;\n		private MovieCatalog comedyCatalog;\n		@Autowired\n		public void setComedyCatalog(@Genre(\"Comedy\") MovieCatalog comedyCatalog) {\n			this.comedyCatalog = comedyCatalog;\n	class MovieRecommender {\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nДалее вы можете предоставить информацию для определений потенциальных компонентов."}
{"id": 143, "text": "Вы можете добавить Теги `<qualifier/>` являются подэлементами тега `<bean/>`, а затем указывают `type` и `value`, чтобы соответствовать вашим пользовательским аннотациям квалификатора.\nТип соответствует полное имя класса аннотации.\nАльтернативно, для удобства, если нет риска существуют конфликтующие имена, вы можете использовать короткое имя класса.\nСледующий пример демонстрирует оба подхода:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<context:annotation-config/>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<qualifier type=\"Genre\" value=\"Action\"/>"}
{"id": 144, "text": "<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<qualifier type=\"example.Genre\" value=\"Comedy\"/>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n	</beans>\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nВ Сканирование путей к классам и управляемые компоненты вы можете увидеть альтернативу на основе аннотаций предоставление метаданных квалификатора в XML.\nВ частности, см.\nПредоставление метаданных квалификаторов с аннотациями.\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами.\nВ некоторых случаях может быть достаточно использования аннотации без значения.\nЭто может быть полезно, когда аннотация служит более общей цели и может применяться ко всем несколько различных типов зависимостей.\nНапример, вы можете предоставить офлайн-версию каталог, в котором можно осуществлять поиск при отсутствии подключения к Интернету.\nСначала определите простая аннотация, как показано в следующем примере:\nJava\n	@Target({ElementType.FIELD, ElementType.PARAMETER})\n	@Retention(RetentionPolicy.RUNTIME)\n	@Qualifier\n	public @interface Offline {\n	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)\n	@Retention(AnnotationRetention.RUNTIME)\n	@Qualifier\n	annotation class Offline\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами."}
{"id": 145, "text": "Затем добавьте аннотацию к полю или свойству, которое необходимо автоматически связать, как показано на рисунке. следующий пример:\nJava\n	public class MovieRecommender {\n		@Autowired\n		@Offline // <1>\n		private MovieCatalog offlineCatalog;\nТочная настройка автоматического связывания на основе аннотаций с квалификаторами. <1> Эта строка добавляет аннотацию `@Offline`.\nclass MovieRecommender {. <1> Эта строка добавляет аннотацию `@Offline`.\nclass MovieRecommender {.\nТеперь для определения bean-компонента требуется только квалификатор type, как показано в следующем примере:\n	<bean class=\"example.SimpleMovieCatalog\">\n		<qualifier type=\"Offline\"/> <1>\n		<!-- inject any dependencies required by this bean -->\n	</bean>\nclass MovieRecommender {. <1> Этот элемент определяет квалификатор.\nclass MovieRecommender {.\nВы также можете определить пользовательские аннотации квалификаторов, которые принимают именованные атрибуты в дополнение или вместо простого атрибута `value`.\nЕсли несколько значений атрибута затем указано в поле или параметре для автоматического подключения, определение компонента должно соответствовать все такие значения атрибутов следует рассматривать как кандидаты для автоматического связывания.\nВ качестве примера: рассмотрим следующее определение аннотации:\nJava\n	@Target({ElementType.FIELD, ElementType.PARAMETER})\n	@Retention(RetentionPolicy.RUNTIME)\n	@Qualifier\n	public @interface MovieQualifier {\n		String genre();\n		Format format();\nJava\n	public enum Format {"}
{"id": 146, "text": "VHS, DVD, BLURAY\n	enum class Format {\n		VHS, DVD, BLURAY\nВ данном случае «Формат» — это перечисление, определенное следующим образом:.\nПоля, подлежащие автоматической привязке, помечаются пользовательским квалификатором и включают значения. для обоих атрибутов: «жанр» и «формат», как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		@Autowired\n		@MovieQualifier(format=Format.VHS, genre=\"Action\")\n		private MovieCatalog actionVhsCatalog;\n		@Autowired\n		@MovieQualifier(format=Format.VHS, genre=\"Comedy\")\n		private MovieCatalog comedyVhsCatalog;\n		@Autowired\n		@MovieQualifier(format=Format.DVD, genre=\"Action\")\n		private MovieCatalog actionDvdCatalog;\n		@Autowired\n		@MovieQualifier(format=Format.BLURAY, genre=\"Comedy\")\n		private MovieCatalog comedyBluRayCatalog;\n	class MovieRecommender {\nВ данном случае «Формат» — это перечисление, определенное следующим образом:.\nНаконец, определения bean-компонентов должны содержать соответствующие значения квалификаторов.\nЭтот пример также демонстрирует, что вы можете использовать метаатрибуты компонента вместо Элементы `<квалификатор/>`.\nЕсли доступен, элемент `<qualifier/>` и его атрибуты принимают приоритет, но механизм автоматического подключения использует значения, указанные в `<meta/>` теги, если такой квалификатор отсутствует, как в двух последних определениях bean-компонентов в следующий пример:"}
{"id": 147, "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<context:annotation-config/>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<qualifier type=\"MovieQualifier\">\n				<attribute key=\"format\" value=\"VHS\"/>\n				<attribute key=\"genre\" value=\"Action\"/>\n			</qualifier>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<qualifier type=\"MovieQualifier\">\n				<attribute key=\"format\" value=\"VHS\"/>"}
{"id": 148, "text": "<attribute key=\"genre\" value=\"Comedy\"/>\n			</qualifier>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<meta key=\"format\" value=\"DVD\"/>\n			<meta key=\"genre\" value=\"Action\"/>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n		<bean class=\"example.SimpleMovieCatalog\">\n			<meta key=\"format\" value=\"BLURAY\"/>\n			<meta key=\"genre\" value=\"Comedy\"/>\n			<!-- inject any dependencies required by this bean -->\n		</bean>\n	</beans>"}
{"id": 149, "text": "Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Аннотацию `@Inject` JSR 330 можно использовать вместо аннотации Spring `@Autowired` в примеры включены в этот раздел.\nДополнительную информацию см. в здесь.\nИспользование `@Autowired`.\nВы можете применить аннотацию @Autowired к конструкторам, как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		private final CustomerPreferenceDao customerPreferenceDao;\n		@Autowired\n		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n			this.customerPreferenceDao = customerPreferenceDao;\nИспользование `@Autowired`. [СОВЕТ] = Аннотация `@Autowired` для такого конструктора не требуется, если целевой компонент определяет только один конструктор.\nОднако если доступно несколько конструкторов и есть нет основного конструктора или конструктора по умолчанию, хотя бы один из конструкторов должен быть аннотирован с `@Autowired`, чтобы указать контейнеру, какой из них использовать.\nПосмотреть обсуждение по ссылке:core/beans/annotation-config/autowired.adoc#beans-autowired-annotation-constructor-solve [разрешение конструктора] для получения подробной информации.\nИспользование `@Autowired`.\nВы можете применить аннотацию `@Autowired` к _традиционным_ методам установки, так как следующий пример показывает:\nJava\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Autowired\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n	class SimpleMovieLister {\nИспользование `@Autowired`."}
{"id": 150, "text": "Вы можете применить `@Autowired` к методам с произвольными именами и несколькими аргументами, как следующий пример показывает:\nJava\n	public class MovieRecommender {\n		private MovieCatalog movieCatalog;\n		private CustomerPreferenceDao customerPreferenceDao;\n		@Autowired\n		public void prepare(MovieCatalog movieCatalog,\n				CustomerPreferenceDao customerPreferenceDao) {\n			this.movieCatalog = movieCatalog;\n			this.customerPreferenceDao = customerPreferenceDao;\n	class MovieRecommender {\nИспользование `@Autowired`.\nВы также можете применить `@Autowired` к полям и даже смешать его с конструкторами, поскольку следующий пример показывает:\nJava\n	public class MovieRecommender {\n		private final CustomerPreferenceDao customerPreferenceDao;\n		@Autowired\n		private MovieCatalog movieCatalog;\n		@Autowired\n		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n			this.customerPreferenceDao = customerPreferenceDao;\nИспользование `@Autowired`. [СОВЕТ] = Убедитесь, что ваши целевые компоненты (например, MovieCatalog или CustomerPreferenceDao) последовательно объявляются по типу, который вы используете для аннотированных `@Autowired` точки инъекции.\nВ противном случае внедрение может завершиться неудачей из-за ошибки «совпадение типа не найдено» в время выполнения.\nИспользование `@Autowired`.\nДля XML-определенных bean-компонентов или классов компонентов, найденных с помощью сканирования пути к классам, контейнер обычно заранее знает тип бетона.\nОднако для фабричных методов `@Bean` вам необходимо чтобы убедиться, что объявленный возвращаемый тип достаточно выразителен."}
{"id": 151, "text": "Для компонентов которые реализуют несколько интерфейсов или для компонентов, потенциально упоминаемых их типа реализации, объявите наиболее конкретный тип возвращаемого значения в вашем фабричном методе (по адресу по крайней мере настолько конкретно, насколько того требуют точки инъекции, относящиеся к вашему компоненту).\nИспользование `@Autowired`. .[[beans-autowired-annotation-self-injection]]Самовнедрение **** `@Autowired` также учитывает ссылки на себя для внедрения (то есть ссылки на себя). bean-компонент, который в данный момент внедряется).\nИспользование `@Autowired`.\nОднако обратите внимание, что самоинъекция — это запасной механизм.\nРегулярная зависимость от других компоненты всегда имеют приоритет.\nВ этом смысле ссылки на себя не участвуют в регулярный выбор кандидатов для автоматического подключения и поэтому никогда не являются первичными.\nВкл. наоборот, они всегда имеют самый низкий приоритет.\nИспользование `@Autowired`.\nНа практике ссылки на себя следует использовать только в крайнем случае – например, для вызов других методов в том же экземпляре через транзакционный прокси компонента.\nКак Альтернативно, рассмотрите возможность выделения затронутых методов в отдельный компонент-делегат в такой сценарий.\nИспользование `@Autowired`.\nДругой альтернативой является использование `@Resource`, который может получить прокси обратно к текущему bean по своему уникальному имени."}
{"id": 152, "text": "Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Попытка внедрить результаты методов `@Bean` в тот же класс `@Configuration` по сути, это также сценарий самореференции.\nЛибо лениво разрешать такие ссылки в сигнатуре метода там, где это действительно необходимо (в отличие от автоматически подключаемого поля в классе конфигурации) или объявить затронутые методы `@Bean` как `статические`, отделение их от содержащего экземпляра класса конфигурации и его жизненного цикла.\nВ противном случае такие bean-компоненты рассматриваются только на резервной фазе с соответствующими bean-компонентами. вместо этого в других классах конфигурации, выбранных в качестве основных кандидатов (если таковые имеются). = ****\nИспользование `@Autowired`.\nВы также можете поручить Spring предоставить все bean-компоненты определенного типа из `ApplicationContext`, добавив аннотацию `@Autowired` к полю или методу, который ожидает массив этого типа, как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		@Autowired\n		private MovieCatalog[] movieCatalogs;\n	class MovieRecommender {\nИспользование `@Autowired`.\nТо же самое относится и к типизированным коллекциям, как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		private Set<MovieCatalog> movieCatalogs;\n		@Autowired\n		public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {\n			this.movieCatalogs = movieCatalogs;\n	class MovieRecommender {"}
{"id": 153, "text": "Использование `@Autowired`. [СОВЕТ] = Ваши целевые bean-компоненты могут реализовать интерфейс org.springframework.core.Ordered или использовать аннотацию @Order или стандартную аннотацию @Priority, если вам нужны элементы в массиве или списке сортироваться в определенном порядке.\nВ противном случае их заказ следует за регистрацией. порядок соответствующих определений целевого компонента в контейнере.\nИспользование `@Autowired`.\nВы можете объявить аннотацию @Order на уровне целевого класса и в методах @Bean. потенциально для отдельных определений bean-компонентов (в случае нескольких определений, которые используйте тот же класс bean-компонента).\nЗначения `@Order` могут влиять на приоритеты в точках ввода, но имейте в виду, что они не влияют на порядок запуска синглтона, который является ортогональная проблема, определяемая отношениями зависимости и объявлениями `@DependsOn`.\nИспользование `@Autowired`.\nОбратите внимание, что аннотации `@Order` в классах конфигурации влияют только на оценку. порядок в общем наборе классов конфигурации при запуске.\nТакой уровень конфигурации значения порядка вообще не влияют на содержащиеся в нем методы `@Bean`.\nДля заказа на уровне компонента: каждый метод `@Bean` должен иметь собственную аннотацию `@Order`, которая применяется внутри набор нескольких совпадений для конкретного типа компонента (возвращаемого фабричным методом).\nИспользование `@Autowired`."}
{"id": 154, "text": "Обратите внимание, что стандартная аннотация `jakarta.annotation.Priority` недоступна на Уровень `@Bean`, поскольку его нельзя объявить в методах.\nЕго семантику можно смоделировать через значения `@Order` в сочетании с `@Primary` для одного bean-компонента для каждого типа.\nИспользование `@Autowired`.\nДаже введенные экземпляры Map могут быть автоматически подключены, если ожидаемый тип ключа — String.\nЗначения карты — это все bean-компоненты ожидаемого типа, а ключи — соответствующие имена компонентов, как показано в следующем примере:\nJava\n	public class MovieRecommender {\n		private Map<String, MovieCatalog> movieCatalogs;\n		@Autowired\n		public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {\n			this.movieCatalogs = movieCatalogs;\n	class MovieRecommender {\nИспользование `@Autowired`.\nПо умолчанию автоматическое связывание завершается неудачно, если для данного объекта не доступны соответствующие компоненты-кандидаты. точка инъекции.\nВ случае объявленного массива, коллекции или карты по крайней мере один ожидается соответствующий элемент.\nИспользование `@Autowired`.\nПоведение по умолчанию — рассматривать аннотированные методы и поля как указывающие на необходимость зависимости.\nВы можете изменить это поведение, как показано в следующем примере: позволяя платформе пропускать невыполнимую точку внедрения, отмечая ее как необязательный (т. е. установив для атрибута `required` в `@Autowired` значение `false`):\nJava\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;"}
{"id": 155, "text": "@Autowired(required = false)\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n	class SimpleMovieLister {\nИспользование `@Autowired`. [ПРИМЕЧАНИЕ] = Необязательный метод вообще не будет вызываться, если его зависимость (или одна из его зависимости, в случае нескольких аргументов) недоступен.\nНеобязательное поле будет в таких случаях вообще не заполняется, оставляя значение по умолчанию.\nИспользование `@Autowired`.\nДругими словами, установка атрибута `required` в значение `false` означает, что соответствующее свойство является _необязательным_ для целей автоматического подключения, и это свойство будет игнорируется, если его нельзя выполнить автоматически.\nЭто позволяет присваивать свойствам значения по умолчанию. это можно при желании переопределить с помощью внедрения зависимостей.\nИспользование `@Autowired`.\nВнедренные аргументы конструктора и фабричного метода являются особым случаем, поскольку `обязательные` атрибут в `@Autowired` имеет несколько иное значение из-за конструктора Spring алгоритм разрешения, который потенциально может иметь дело с несколькими конструкторами.\nКонструктор и аргументы фабричного метода фактически требуются по умолчанию, но с некоторыми особыми правила в сценарии с одним конструктором, например многоэлементные точки внедрения (массивы, коллекции, карты), разрешающие пустые экземпляры, если соответствующие bean-компоненты недоступны.\nЭто допускает общий шаблон реализации, в котором все зависимости могут быть объявлены в уникальный конструктор с несколькими аргументами — например, объявленный как единый общедоступный конструктор без аннотации @Autowired."}
{"id": 156, "text": "Использование `@Autowired`. [ПРИМЕЧАНИЕ] = Только один конструктор любого класса компонента может объявить `@Autowired` с `required`. атрибуту присвоено значение true, что указывает на автоматическое связывание конструктора _the_ при использовании в качестве Spring. боб.\nКак следствие, если атрибут `required` оставить со значением по умолчанию `true`, только один конструктор может быть помечен с помощью `@Autowired`.\nЕсли несколько конструкторов объявить аннотацию, все они должны будут объявить `required=false`, чтобы быть рассматриваются как кандидаты на автоматическое связывание (аналог `autowire=constructor` в XML).\nКонструктор с наибольшим количеством зависимостей, которые можно удовлетворить путем сопоставления будут выбраны бобы в контейнере Spring.\nЕсли ни один из кандидатов не может быть удовлетворен, тогда будет использоваться основной конструктор/конструктор по умолчанию (если он присутствует).\nАналогично, если класс объявляет несколько конструкторов, но ни один из них не имеет аннотации `@Autowired`, тогда Будет использоваться основной конструктор/конструктор по умолчанию (если он присутствует).\nЕсли класс объявляет только один конструктор, он будет использоваться всегда, даже если не аннотирован.\nОбратите внимание, что аннотированный конструктор не обязательно должен быть общедоступным.\nИспользование `@Autowired`.\nВ качестве альтернативы вы можете выразить необязательный характер конкретной зависимости. через `java.util.Optional` Java, как показано в следующем примере:\n	public class SimpleMovieLister {\n		@Autowired"}
{"id": 157, "text": "public void setMovieFinder(Optional<MovieFinder> movieFinder) {\nJava\n	public class SimpleMovieLister {\n		@Autowired\n		public void setMovieFinder(@Nullable MovieFinder movieFinder) {\n	class SimpleMovieLister {\nИспользование `@Autowired`.\nВы также можете использовать `@Autowired` для интерфейсов, которые хорошо известны и являются разрешимыми. зависимости: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`, «ApplicationEventPublisher» и «MessageSource».\nЭти интерфейсы и их расширенные интерфейсы, такие как «ConfigurableApplicationContext» или «ResourcePatternResolver», разрешается автоматически, без необходимости специальной настройки.\nСледующий пример автопроводки объект ApplicationContext:\nJava\n	public class MovieRecommender {\n		@Autowired\n		private ApplicationContext context;\n		public MovieRecommender() {\nclass MovieRecommender {. [ПРИМЕЧАНИЕ] = Аннотации `@Autowired`, `@Inject`, `@Value` и `@Resource` обрабатываются Spring.\nРеализации BeanPostProcessor.\nЭто означает, что вы не можете применить эти аннотации внутри ваших собственных типов BeanPostProcessor или BeanFactoryPostProcessor (если таковые имеются).\nclass MovieRecommender {.\nЭти типы должны быть «подключены» явно с использованием XML или метода Spring `@Bean`."}
{"id": 158, "text": "Основные понятия: @Bean и @Configuration.\nОсновными артефактами поддержки конфигурации Java в Spring являются Классы с аннотациями `@Configuration` и методы с аннотациями `@Bean`.\nАннотация `@Bean` используется для указания того, что метод создает экземпляр, настраивает и инициализирует новый объект, которым будет управлять контейнер Spring IoC.\nДля тех, кто знаком с XML-конфигурацией Spring `<beans/>` аннотация `@Bean` играет ту же роль, что и элемент `<bean/>`.\nВы можете использовать методы с аннотациями `@Bean` с любым Spring `@Компонент`.\nОднако чаще всего они используются с bean-компонентами `@Configuration`.\nАннотация класса с помощью @Configuration указывает, что его основная цель — источник определений компонентов.\nБолее того, классы `@Configuration` позволяют взаимодействовать между компонентами. зависимости определяются путем вызова других методов `@Bean` в том же классе.\nПростейший возможный класс `@Configuration` выглядит следующим образом:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public MyServiceImpl myService() {\n			return new MyServiceImpl();\n	@Configuration\n	class AppConfig {\n	<beans>\n		<bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\"/>\n	</beans>"}
{"id": 159, "text": "Предыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:. .@Классы конфигурации с локальными вызовами между методами @Bean или без них? **** В распространенных сценариях методы @Bean должны быть объявлены внутри классов @Configuration. обеспечение того, чтобы применялась полная обработка класса конфигурации и что перекрестный метод поэтому ссылки перенаправляются в систему управления жизненным циклом контейнера.\nЭто предотвращает случайный вызов того же метода `@Bean` через обычный Вызов метода Java, который помогает уменьшить количество мелких ошибок, которые трудно отследить.\nПредыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:.\nКогда методы `@Bean` объявляются внутри классов, которые не помечены `@Configuration` или когда объявлен `@Configuration(proxyBeanMethods=false)`, они называются обрабатываемыми в «облегченном» режиме.\nВ таких сценариях Методы `@Bean` по сути являются механизмом фабричных методов общего назначения без специальная обработка во время выполнения (то есть без создания для нее подкласса CGLIB).\nПользовательский вызов такого метода Java не будет перехвачен контейнером и поэтому ведет себя так же, как обычный вызов метода, каждый раз создавая новый экземпляр. вместо повторного использования существующего одноэлементного (или ограниченного) экземпляра для данного bean-компонента.\nПредыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:."}
{"id": 160, "text": "Как следствие, методы `@Bean` в классах без проксирования во время выполнения не предназначены для вообще объявлять зависимости между компонентами.\nВместо этого ожидается, что они будут действовать по своим содержащий поля компонента и, необязательно, аргументы, которые может использовать фабричный метод. объявите, чтобы получить участников с автоматическим подключением.\nПоэтому такой метод `@Bean` никогда не требуется вызывать другие методы `@Bean`; каждый такой призыв может быть выражен через вместо этого аргумент фабричного метода.\nПоложительным побочным эффектом здесь является отсутствие CGLIB. создание подклассов должно применяться во время выполнения, что снижает накладные расходы и занимаемую площадь. ****\nПредыдущий класс AppConfig эквивалентен следующему Spring `<beans/>` XML:.\nАннотации `@Bean` и `@Configuration` подробно обсуждаются в следующих разделах.\nОднако сначала мы рассмотрим различные способы создания контейнера Spring с использованием Конфигурация на основе Java."}
{"id": 161, "text": "Обзор контейнера.\nИнтерфейс `org.springframework.context.ApplicationContext` представляет Spring IoC. контейнер и отвечает за создание экземпляров, настройку и сборку компонентов.\nКонтейнер получает инструкции по компонентам для создания, настройки и настройки. собрать, прочитав метаданные конфигурации.\nМетаданные конфигурации могут быть представлены как аннотированные классы компонентов, классы конфигурации с фабричными методами или внешние XML-файлы или сценарии Groovy.\nВ любом формате вы можете составить свое приложение и богатая взаимозависимость между этими компонентами.\nОбзор контейнера.\nНесколько реализаций интерфейса ApplicationContext являются частью ядра Spring.\nВ автономных приложениях обычно создается экземпляр {spring-framework-api}/context/annotation/AnnotationConfigApplicationContext.html[`AnnotationConfigApplicationContext`] или {spring-framework-api}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`].\nОбзор контейнера.\nВ большинстве сценариев приложений явный пользовательский код не требуется для создания экземпляра одного или нескольких приложений. больше экземпляров контейнера Spring IoC.\nНапример, в сценарии простого веб-приложения: достаточно простого стандартного XML-дескриптора веб-дескриптора в файле `web.xml` приложения (см.\nВ сценарии Spring Boot контекст приложения загружается автоматически. на основе общих соглашений по установке.\nОбзор контейнера.\nНа следующей диаграмме показано общее представление о том, как работает Spring."}
{"id": 162, "text": "Ваши классы приложений объединяются с метаданными конфигурации, так что после того, как `ApplicationContext` Созданный и инициализированный, вы получаете полностью настроенную и исполняемую систему или приложение.\nМетаданные конфигурации.\nКак показано на предыдущей диаграмме, контейнер Spring IoC использует форму метаданные конфигурации.\nЭти метаданные конфигурации показывают, как вы, как разработчик приложения, сообщите контейнеру Spring создать экземпляр, настроить, и соберите компоненты в своем приложении.\nМетаданные конфигурации.\nСам контейнер Spring IoC полностью отделен от формата, в котором этот метаданные конфигурации фактически записываются.\nСегодня многие разработчики выбирают\n* Конфигурация на основе аннотаций: определение bean-компонентов с помощью\nМетаданные конфигурации. метаданные конфигурации на основе аннотаций в классах компонентов вашего приложения.\n* конфигурация на основе Java: определите внешние по отношению к вашему приложению bean-компоненты.\nМетаданные конфигурации. классы с помощью классов конфигурации на основе Java.\nЧтобы использовать эти функции, см. {spring-framework-api}/context/annotation/Configuration.html[`@Configuration`], {spring-framework-api}/context/annotation/Bean.html[`@Bean`], {spring-framework-api}/context/annotation/Import.html[`@Import`], и аннотации {spring-framework-api}/context/annotation/DependsOn.html[`@DependsOn`].\nМетаданные конфигурации."}
{"id": 163, "text": "Конфигурация Spring состоит как минимум из одного, а обычно из более чем одного определения компонента. что контейнер должен справиться.\nВ конфигурации Java обычно используются аннотации `@Bean`. методы внутри класса `@Configuration`, каждый из которых соответствует одному определению компонента.\nМетаданные конфигурации.\nЭти определения bean-компонентов соответствуют реальным объектам, из которых состоит ваше приложение.\nОбычно вы определяете объекты уровня обслуживания, объекты уровня персистентности, такие как репозитории или объекты доступа к данным (DAO), объекты представления, такие как веб-контроллеры, объекты инфраструктуры, такие как JPA `EntityManagerFactory`, очереди JMS и т. д.\nОбычно в контейнере не настраиваются детальные объекты домена, поскольку обычно ответственность за создание и загрузку лежит на репозиториях и бизнес-логике. объекты домена.\nXML как DSL внешней конфигурации.\nМетаданные конфигурации на основе XML настраивают эти bean-компоненты как элементы `<bean/>` внутри элемент верхнего уровня `<beans/>`.\nВ следующем примере показана базовая структура Метаданные конфигурации на основе XML:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""}
{"id": 164, "text": "xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean id=\"...\" class=\"...\"> <1> <2>\n			<!-- collaborators and configuration for this bean go here -->\n		</bean>\n		<bean id=\"...\" class=\"...\">\n			<!-- collaborators and configuration for this bean go here -->\n		</bean>\n		<!-- more bean definitions go here -->\n	</beans>\nXML как DSL внешней конфигурации. <1> Атрибут `id` — это строка, которая идентифицирует определение отдельного компонента. <2> Атрибут `class` определяет тип компонента и использует полностью квалифицированный имя класса.\nXML как DSL внешней конфигурации.\nЗначение атрибута id можно использовать для ссылки на взаимодействующие объекты.\nXML для ссылки на взаимодействующие объекты в этом примере не показано.\nСм.\nXML как DSL внешней конфигурации.\nДля создания экземпляра контейнера путь или пути к файлам ресурсов XML. необходимо передать конструктору ClassPathXmlApplicationContext, который позволит метаданные конфигурации загрузки контейнера из различных внешних ресурсов, таких как в качестве локальной файловой системы, Java `CLASSPATH` и так далее.\nJava"}
{"id": 165, "text": "ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\nXML как DSL внешней конфигурации. [ПРИМЕЧАНИЕ] = После того, как вы узнаете о контейнере Spring IoC, возможно, вам захочется узнать больше о Spring.\nАбстракция `Ресурс` (как описано в который обеспечивает удобный механизм для чтения InputStream из определенных мест в синтаксисе URI.\nВ частности, пути «Ресурсы» используются для создания контекстов приложений. как описано в Контексты приложений и пути к ресурсам.\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<!-- services -->\n		<bean id=\"petStore\" class=\"org.springframework.samples.jpetstore.services.PetStoreServiceImpl\">\n			<property name=\"accountDao\" ref=\"accountDao\"/>\n			<property name=\"itemDao\" ref=\"itemDao\"/>"}
{"id": 166, "text": "<!-- additional collaborators and configuration for this bean go here -->\n		</bean>\n		<!-- more bean definitions for services go here -->\n	</beans>\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean id=\"accountDao\"\n			class=\"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\">\n			<!-- additional collaborators and configuration for this bean go here -->\n		</bean>\n		<bean id=\"itemDao\" class=\"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\">\n			<!-- additional collaborators and configuration for this bean go here -->\n		</bean>\n		<!-- more bean definitions for data access objects go here -->\n	</beans>\nВ следующем примере показан файл daos.xml объектов доступа к данным:."}
{"id": 167, "text": "В предыдущем примере уровень обслуживания состоит из класса PetStoreServiceImpl. и два объекта доступа к данным типов JpaAccountDao и JpaItemDao (на основе по стандарту объектно-реляционного сопоставления JPA).\nЭлемент `property name` относится к имя свойства JavaBean, а элемент `ref` относится к имени другого bean-компонента. определение.\nЭта связь между элементами `id` и `ref` выражает зависимость между взаимодействующие объекты.\nПодробную информацию о настройке зависимостей объекта см.\nСоставление метаданных конфигурации на основе XML.\nМожет быть полезно, чтобы определения компонентов охватывали несколько файлов XML.\nЧасто каждый отдельный Файл конфигурации XML представляет собой логический уровень или модуль вашей архитектуры.\nСоставление метаданных конфигурации на основе XML.\nВы можете использовать конструктор ClassPathXmlApplicationContext для загрузки определений bean-компонентов из XML-фрагменты.\nЭтот конструктор принимает несколько местоположений `Resource`, как показано в используйте одно или несколько вхождений элемента `<import/>` для загрузки определений компонентов из другой файл или файлы.\nВ следующем примере показано, как это сделать:\n	<beans>\n		<import resource=\"services.xml\"/>\n		<import resource=\"resources/messageSource.xml\"/>\n		<bean id=\"bean1\" class=\"...\"/>\n		<bean id=\"bean2\" class=\"...\"/>\n	</beans>\nСоставление метаданных конфигурации на основе XML."}
{"id": 168, "text": "В предыдущем примере определения внешних компонентов загружаются из файлов `services.xml` и `messageSource.xml`.\nВсе пути к местоположению относительно файла определения, выполняющего импорт, поэтому `services.xml` должен находиться в тот же каталог или путь к классам, что и файл, выполняющий импорт, в то время как `messageSource.xml` должен находиться в папке `resources` под расположение импортируемого файла.\nКак видите, косая черта в начале игнорируется.\nОднако, учитывая поскольку эти пути относительны, лучше вообще не использовать косую черту. содержимое импортируемых файлов, включая элемент верхнего уровня `<beans/>`, должно быть действительными определениями XML-компонентов в соответствии со схемой Spring.\nСоставление метаданных конфигурации на основе XML. [ПРИМЕЧАНИЕ] = Можно, но не рекомендуется ссылаться на файлы в родительских каталогах с помощью относительный путь \"../\".\nЭто создает зависимость от файла, находящегося за пределами текущего приложение.\nВ частности, эта ссылка не рекомендуется для URL-адресов `classpath:` (для например `classpath:../services.xml`), где процесс разрешения во время выполнения выбирает «`ближайший`» корневой путь к классу, а затем просматривает его родительский каталог.\nПуть к классам изменения конфигурации могут привести к выбору другого, неправильного каталога.\nСоставление метаданных конфигурации на основе XML."}
{"id": 169, "text": "Вы всегда можете использовать полные местоположения ресурсов вместо относительных путей: для например, `file:C:/config/services.xml` или `classpath:/config/services.xml`.\nОднако будьте осознавая, что вы связываете конфигурацию своего приложения с конкретным абсолютным локации.\nОбычно предпочтительнее сохранять косвенность для таких абсолютных значений. местоположения – например, с помощью заполнителей \"${...}\", которые разрешаются с помощью JVM. свойства системы во время выполнения.\nСоставление метаданных конфигурации на основе XML.\nСамо пространство имен предоставляет функцию директив импорта.\nДалее функции конфигурации, выходящие за рамки простых определений компонентов, доступны в некоторых вариантах пространств имен XML, предоставляемых Spring, например, пространств имен context и util.\nИспользование контейнера. «ApplicationContext» — это интерфейс расширенной фабрики, способной поддерживать реестр различных bean-компонентов и их зависимостей.\nИспользуя метод `T getBean(String name, Class<T> requireType)` вы можете получить экземпляры ваших bean-компонентов.\nИспользование контейнера. `ApplicationContext` позволяет вам читать определения bean-компонентов и получать к ним доступ, как показано ниже. пример показывает:\nJava\n	// создавать и настраивать bean-компоненты\n	ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\n	// получить настроенный экземпляр\n	PetStoreService service = context.getBean(\"petStore\", PetStoreService.class);"}
{"id": 170, "text": "// использовать настроенный экземпляр\n	List<String> userList = service.getUsernameList();\nИспользование контейнера.\nВ конфигурации Groovy загрузка выглядит очень похоже.\nУ него другой контекст класс реализации, который поддерживает Groovy (но также понимает определения XML-компонентов).\nВ следующем примере показана конфигурация Groovy:\nJava\n	ApplicationContext context = new GenericGroovyApplicationContext(\"services.groovy\", \"daos.groovy\");\nИспользование контейнера.\nСамый гибкий вариант — GenericApplicationContext в сочетании с считывателем. делегаты - например, с помощью `XmlBeanDefinitionReader` для файлов XML, как показано ниже. пример показывает:\nJava\n	GenericApplicationContext context = new GenericApplicationContext();\n	new XmlBeanDefinitionReader(context).loadBeanDefinitions(\"services.xml\", \"daos.xml\");\n	context.refresh();\nИспользование контейнера.\nВы также можете использовать GroovyBeanDefinitionReader для файлов Groovy, как показано ниже. пример показывает:\nJava\n	GenericApplicationContext context = new GenericApplicationContext();\n	new GroovyBeanDefinitionReader(context).loadBeanDefinitions(\"services.groovy\", \"daos.groovy\");\n	context.refresh();\nИспользование контейнера.\nВы можете смешивать и сопоставлять такие делегаты чтения в одном и том же ApplicationContext, чтение определений компонентов из различных источников конфигурации.\nИспользование контейнера."}
{"id": 171, "text": "Затем вы можете использовать getBean для получения экземпляров ваших bean-компонентов. `Контекст приложения` В интерфейсе есть несколько других методов получения bean-компонентов, но в идеале ваше приложение код никогда не должен их использовать.\nДействительно, код вашего приложения не должен содержать вызовов метода `getBean()` вообще и, таким образом, вообще не зависит от Spring API.\nНапример, Интеграция Spring с веб-фреймворками обеспечивает внедрение зависимостей для различных веб-приложений. компоненты инфраструктуры, такие как контроллеры и компоненты, управляемые JSF, что позволяет вам объявлять зависимость от конкретного компонента через метаданные (например, аннотацию автоматического подключения)."}
{"id": 172, "text": "Использование аннотации `@Bean`. `@Bean` — это аннотация уровня метода и прямой аналог XML-элемента `<bean/>`.\nАннотация поддерживает некоторые атрибуты, предлагаемые `<bean/>`, например:\n* init-method\n* destroy-method\n* autowiring\n* `имя`.\nИспользование аннотации `@Bean`.\nВы можете использовать аннотацию `@Bean` в аннотации `@Configuration` или в Класс с аннотацией `@Component`.\nОбъявление компонента.\nЧтобы объявить компонент, вы можете аннотировать метод аннотацией `@Bean`.\nВы используете это метод для регистрации определения компонента в `ApplicationContext` типа указанный как возвращаемое значение метода.\nПо умолчанию имя компонента такое же, как имя метода.\nВ следующем примере показано объявление метода @Bean:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public TransferServiceImpl transferService() {\n			return new TransferServiceImpl();\n	@Configuration\n	class AppConfig {\n	<beans>\n		<bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/>\n	</beans>\nПредыдущая конфигурация в точности эквивалентна следующему Spring XML:.\nОба объявления делают компонент с именем TransferService доступным в `ApplicationContext`, привязанный к экземпляру объекта типа `TransferServiceImpl`, как следующее текстовое изображение показывает:\ntransferService -> com.acme.TransferServiceImpl.\nВы также можете использовать методы по умолчанию для определения компонентов."}
{"id": 173, "text": "Это позволяет композицию бобов конфигурации путем реализации интерфейсов с определениями компонентов в методах по умолчанию.\nJava\n	public interface BaseConfig {\n		@Bean\n		default TransferServiceImpl transferService() {\n			return new TransferServiceImpl();\n	@Configuration\n	public class AppConfig implements BaseConfig {\ntransferService -> com.acme.TransferServiceImpl.\nВы также можете объявить свой метод `@Bean` с помощью интерфейса (или базового класса). тип возвращаемого значения, как показано в следующем примере:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public TransferService transferService() {\n			return new TransferServiceImpl();\n	@Configuration\n	class AppConfig {\ntransferService -> com.acme.TransferServiceImpl.\nОднако это ограничивает видимость прогнозирования типа опережения указанными значениями. тип интерфейса («TransferService»).\nЗатем с полным типом (`TransferServiceImpl`) известен контейнеру только после того, как был создан экземпляр затронутого одноэлементного компонента.\nНеленивые одноэлементные компоненты создаются в соответствии с порядком их объявления. поэтому вы можете увидеть разные результаты сопоставления типов в зависимости от того, когда другой компонент пытается найти соответствие по необъявленному типу (например, `@Autowired TransferServiceImpl`, который разрешается только после создания экземпляра bean-компонента TransferService).\ntransferService -> com.acme.TransferServiceImpl.\nСОВЕТ: Если вы постоянно ссылаетесь на свои типы через объявленный сервисный интерфейс, ваш Возвращаемые типы `@Bean` могут безопасно присоединиться к этому проектному решению."}
{"id": 174, "text": "Однако для компонентов которые реализуют несколько интерфейсов или для компонентов, потенциально упоминаемых их типа реализации, безопаснее объявить максимально конкретный тип возвращаемого значения. (по крайней мере, настолько конкретно, насколько того требуют точки инъекции, относящиеся к вашему компоненту).\nЗависимости компонентов.\nМетод, аннотированный `@Bean`, может иметь произвольное количество параметров, описывающих зависимости, необходимые для сборки этого компонента.\nНапример, если наш TransferService требуется AccountRepository, мы можем материализовать эту зависимость с помощью метода параметр, как показано в следующем примере:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public TransferService transferService(AccountRepository accountRepository) {\n			return new TransferServiceImpl(accountRepository);\n	@Configuration\n	class AppConfig {\nЗависимости компонентов.\nМеханизм разрешения во многом идентичен зависимостям на основе конструктора. инъекция.\nСм. для более подробной информации.\nПолучение обратных вызовов жизненного цикла.\nЛюбые классы, определенные с помощью аннотации `@Bean`, поддерживают обычные обратные вызовы жизненного цикла. и может использовать аннотации @PostConstruct и @PreDestroy из JSR-250.\nСм. детали.\nПолучение обратных вызовов жизненного цикла.\nОбычные обратные вызовы Spring lifecycle полностью поддерживаются как ну.\nЕсли компонент реализует `InitializingBean`, `DisposableBean` или `Lifecycle`, их соответствующие методы вызываются контейнером.\nСтандартный набор интерфейсов `*Aware` (например, BeanFactoryAware,."}
{"id": 175, "text": "Аннотация `@Bean` поддерживает указание произвольной инициализации и уничтожения. методы обратного вызова, очень похожие на атрибуты Spring XML `init-method` и `destroy-method` на элементе bean, как показано в следующем примере:\nJava\n	public class BeanOne {\n		public void init() {\n			// логика инициализации\n	public class BeanTwo {\n		public void cleanup() {\n			// логика разрушения\n	@Configuration\n	public class AppConfig {\n		@Bean(initMethod = \"init\")\n		public BeanOne beanOne() {\n			return new BeanOne();\n		@Bean(destroyMethod = \"cleanup\")\n		public BeanTwo beanTwo() {\n			return new BeanTwo();\n@Configuration class AppConfig {. [ПРИМЕЧАНИЕ] = По умолчанию bean-компоненты, определенные с конфигурацией Java, имеют общедоступное «закрытие» или «завершение работы». метод автоматически подключается к обратному вызову уничтожения.\nЕсли у вас есть публичный `close` или `shutdown`, и вы не хотите, чтобы он вызывался, когда контейнер выключается, вы можете добавить `@Bean(destroyMethod = \"\")` в определение вашего компонента, чтобы отключить режим по умолчанию `(выведенный)`.\n@Configuration class AppConfig {.\nВозможно, вы захотите сделать это по умолчанию для ресурса, который вы приобретаете с помощью JNDI, поскольку его Жизненный цикл управляется вне приложения."}
{"id": 176, "text": "В частности, обязательно всегда делайте это для DataSource, так как известно, что это проблематично на серверах приложений Jakarta EE.\n@Configuration class AppConfig {.\nВ следующем примере показано, как предотвратить обратный вызов автоматического уничтожения для `Источник данных`:\nJava\n	@Bean(destroyMethod = \"\")\n	public DataSource dataSource() throws NamingException {\n		return (DataSource) jndiTemplate.lookup(\"MyDS\");\n@Configuration class AppConfig {.\nКроме того, с методами `@Bean` вы обычно используете программный поиск JNDI, либо используя помощники Spring `JndiTemplate` или `JndiLocatorDelegate` или прямой JNDI Использование `InitialContext`, но не вариант `JndiObjectFactoryBean` (который заставил бы вы должны объявить тип возвращаемого значения как тип FactoryBean вместо фактической цели типа, что затрудняет использование вызовов перекрестных ссылок в других методах `@Bean`, которые намерен сослаться на предоставленный здесь ресурс).\n@Configuration class AppConfig {.\nВ случае BeanOne из примера выше предыдущего примечания это будет одинаково допустимо вызывать метод init() непосредственно во время построения, так как следующий пример показывает:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public BeanOne beanOne() {\n			BeanOne beanOne = new BeanOne();\n			beanOne.init();\n			return beanOne;\n	@Configuration\n	class AppConfig {\n@Configuration class AppConfig {."}
{"id": 177, "text": "СОВЕТ: Когда вы работаете непосредственно в Java, вы можете делать со своими объектами все, что захотите, и делать не всегда нужно полагаться на жизненный цикл контейнера.\nУказание области действия компонента.\nSpring включает аннотацию @Scope, позволяющую указать область действия bean-компонента.\nИспользование аннотации `@Scope`.\nВы можете указать, что ваши bean-компоненты, определенные с помощью аннотации `@Bean`, должны иметь конкретный объем.\nВы можете использовать любую из стандартных областей, указанных в\nИспользование аннотации `@Scope`.\nОбластью действия по умолчанию является `singleton`, но вы можете переопределить это с помощью аннотации `@Scope`, как показано в следующем примере:\nJava\n	@Configuration\n	public class MyConfiguration {\n		@Bean\n		@Scope(\"prototype\")\n		public Encryptor encryptor() {\n	@Configuration\n	class MyConfiguration {\n`@Scope` и `scoped-proxy`.\nSpring предлагает удобный способ работы с ограниченными зависимостями через таким прокси при использовании конфигурации XML является элемент `<aop:scoped-proxy/>`.\nНастройка ваших bean-компонентов на Java с помощью аннотации @Scope обеспечивает эквивалентную поддержку. с атрибутом proxyMode.\nПо умолчанию используется ScopedProxyMode.DEFAULT. обычно указывает, что не следует создавать прокси-сервер с заданной областью, если не указан другой прокси по умолчанию. настроен на уровне инструкций сканирования компонентов."}
{"id": 178, "text": "Вы можете указать `ScopedProxyMode.TARGET_CLASS`, `ScopedProxyMode.INTERFACES` или `ScopedProxyMode.NO`.\n`@Scope` и `scoped-proxy`.\nЕсли вы портируете пример прокси-сервера с ограниченной областью действия из справочной документации XML (см. это похоже на следующее:\nJava\n	// bean-компонент в области сеанса HTTP, представленный как прокси\n	@Bean\n	@SessionScope\n	public UserPreferences userPreferences() {\n		return new UserPreferences();\n	@Bean\n	public Service userService() {\n		UserService service = new SimpleUserService();\n		// ссылка на прокси-компонент userPreferences\n		service.setUserPreferences(userPreferences());\n		return service;\nНастройка именования компонентов.\nПо умолчанию классы конфигурации используют имя метода @Bean в качестве имени объекта. полученный боб.\nОднако эту функциональность можно переопределить с помощью атрибута `name`. как показано в следующем примере:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean(\"myThing\")\n		public Thing thing() {\n			return new Thing();\n	@Configuration\n	class AppConfig {\nПсевдонимы компонентов.\nКак обсуждалось в Именование компонентов, это иногда желательно дать одному компоненту несколько имен, что также известно как псевдонимы компонентов.\nАтрибут `name` аннотации `@Bean` для этой цели принимает массив String.\nВ следующем примере показано, как установить несколько псевдонимов для компонента:\nJava\n	@Configuration\n	public class AppConfig {"}
{"id": 179, "text": "@Bean({\"dataSource\", \"subsystemA-dataSource\", \"subsystemB-dataSource\"})\n		public DataSource dataSource() {\n			// создать экземпляр, настроить и вернуть компонент DataSource...\n	@Configuration\n	class AppConfig {\nОписание компонента.\nИногда полезно предоставить более подробное текстовое описание компонента.\nЭто может быть особенно полезным, когда bean-компоненты предоставляются (возможно, через JMX) для целей мониторинга.\nОписание компонента.\nЧтобы добавить описание к `@Bean`, вы можете использовать {spring-framework-api}/context/annotation/Description.html[`@Description`] аннотация, как показано в следующем примере:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		@Description(\"Provides a basic example of a bean\")\n		public Thing thing() {\n			return new Thing();\n	@Configuration\n	class AppConfig {"}
{"id": 180, "text": "Ссылки на компоненты.\nЕсли контекст оценки настроен с помощью преобразователя bean-компонентов, вы можете искать bean-компоненты из выражения, используя символ `@` в качестве префикса.\nСледующий пример показывает, как чтобы сделать это:\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	StandardEvaluationContext context = new StandardEvaluationContext();\n	context.setBeanResolver(new MyBeanResolver());\n	// В конечном итоге это приведет к вызову разрешения(контекст, \"someBean\") в MyBeanResolver.\n	// во время оценки.\n	Object bean = parser.parseExpression(\"@someBean\").getValue(context);\nСсылки на компоненты. [ПРИМЕЧАНИЕ] = Если имя компонента содержит точку (`.`) или другие специальные символы, вы должны указать имя компонента в виде _строкового литерала_ – например, `@'order.service'`.\nСсылки на компоненты.\nЧтобы получить доступ к самому фабричному компоненту, вам следует вместо этого добавить к имени компонента префикс `&`. символ.\nВ следующем примере показано, как это сделать:\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	StandardEvaluationContext context = new StandardEvaluationContext();\n	context.setBeanResolver(new MyBeanResolver());\n	// В конечном итоге это приведет к вызову разрешения(контекст, \"&someFactoryBean\") на\n	// MyBeanResolver во время оценки."}
{"id": 181, "text": "Object factoryBean = parser.parseExpression(\"&someFactoryBean\").getValue(context);"}
{"id": 182, "text": "Выражения в определениях компонентов.\nВы можете использовать выражения SpEL с метаданными конфигурации для определения экземпляров компонента.\nВ обоих В некоторых случаях синтаксис определения выражения имеет вид `#{ <строка выражения> }`.\nВыражения в определениях компонентов.\nВсе bean-компоненты в контексте приложения доступны как предопределенные переменные с их общее название компонента.\nСюда входят стандартные контекстные компоненты, такие как `environment` (типа `org.springframework.core.env.Environment`), а также `systemProperties` и `systemEnvironment` (типа `Map<String, Object>`) для доступа к среде выполнения.\nВыражения в определениях компонентов.\nЧтобы указать значение по умолчанию, вы можете разместить аннотацию @Value на полях, методах, и параметры метода или конструктора (или эквивалент XML).\nВыражения в определениях компонентов.\nВ следующем примере задается значение поля по умолчанию: См. пример кода в исходном документе.\nВыражения в определениях компонентов.\nОбратите внимание, что здесь не обязательно добавлять к предопределенной переменной префикс символа `#`.\nВыражения в определениях компонентов.\nВ следующем примере показан эквивалент, но для метода установки свойства: См. пример кода в исходном документе.\nВыражения в определениях компонентов.\nМетоды и конструкторы с автоматическим подключением также могут использовать аннотацию @Value, как показано ниже. примеры показывают: См. пример кода в исходном документе.\nВыражения в определениях компонентов."}
{"id": 183, "text": "Вы также можете обращаться к другим свойствам компонента по имени, как показано в следующем примере: См. пример кода в исходном документе."}
{"id": 184, "text": "API `BeanFactory`.\nAPI BeanFactory обеспечивает базовую основу для функциональности Spring IoC.\nЕго конкретные контракты в основном используются в интеграции с другими частями Spring и связанные сторонние фреймворки и их реализация DefaultListableBeanFactory. является ключевым делегатом в контейнере GenericApplicationContext более высокого уровня.\nAPI `BeanFactory`. `BeanFactory` и связанные с ним интерфейсы (такие как `BeanFactoryAware`, `InitializingBean`, `DisposableBean`) являются важными точками интеграции для других компонентов платформы.\nНе требуя каких-либо аннотаций или даже размышлений, они позволяют очень эффективно взаимодействие между контейнером и его компонентами.\nКомпоненты прикладного уровня могут использовать те же интерфейсы обратного вызова, но обычно предпочитают декларативную зависимость вместо этого внедрение либо посредством аннотаций, либо посредством программной конфигурации.\nAPI `BeanFactory`.\nОбратите внимание, что основной уровень API BeanFactory и его DefaultListableBeanFactory реализации не делайте предположений о формате конфигурации или каких-либо аннотации компонентов, которые будут использоваться.\nВсе эти варианты доступны через расширения. (например, XmlBeanDefinitionReader и AutowiredAnnotationBeanPostProcessor) и работать с общими объектами BeanDefinition в качестве основного представления метаданных.\nВ этом суть того, что делает контейнер Spring таким гибким и расширяемым.\nAPI `BeanFactory`. «BeanFactory» или «ApplicationContext»?\nAPI `BeanFactory`.\nВ этом разделе объясняются различия между BeanFactory и Уровни контейнера `ApplicationContext` и их влияние на начальную загрузку.\nAPI `BeanFactory`."}
{"id": 185, "text": "Вам следует использовать ApplicationContext, если у вас нет веских причин не делать этого.\nGenericApplicationContext и его подкласс AnnotationConfigApplicationContext. как общие реализации для пользовательской начальной загрузки.\nЭто основная запись указывает на основной контейнер Spring для всех распространенных целей: загрузки конфигурации файлы, запуск сканирования пути к классам, программная регистрация определений компонентов и аннотированные классы, а также (начиная с версии 5.0) регистрацию определений функциональных компонентов.\nAPI `BeanFactory`.\nПоскольку ApplicationContext включает в себя все функциональные возможности BeanFactory, он обычно рекомендуется вместо простой BeanFactory, за исключением случаев, когда полный необходим контроль над обработкой бобов.\nВнутри `ApplicationContext` (например, Реализация GenericApplicationContext), обнаружено несколько видов bean-компонентов. по соглашению (то есть по имени или типу компонента — в частности, постпроцессоры), в то время как простой `DefaultListableBeanFactory` не зависит от каких-либо специальных bean-компонентов.\nAPI `BeanFactory`.\nДля многих расширенных функций контейнера, таких как обработка аннотаций и проксирование AOP, необходимая точка расширения `BeanPostProcessor`.\nЕсли вы используете только простой `DefaultListableBeanFactory`, такие постпроцессоры не быть обнаружен и активирован по умолчанию.\nЭта ситуация может сбить с толку, потому что на самом деле в конфигурации вашего компонента все в порядке.\nСкорее, в таком сценарии контейнер необходимо полностью загрузить посредством дополнительной настройки.\nAPI `BeanFactory`.\nВ следующей таблице перечислены функции, предоставляемые BeanFactory и Интерфейсы и реализации ApplicationContext."}
{"id": 186, "text": "API `BeanFactory`. .Матрица функций [cols=\"50%,25%,25%\"] |=== | Особенность | `БинФабрика` | `Контекст приложения`\n| Автоматическая регистрация BeanFactoryPostProcessor. | Нет | Да. | Удобный доступ к MessageSource (для интернационализации) | Нет | Да\n| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===.\nЧтобы явно зарегистрировать постпроцессор компонента с помощью DefaultListableBeanFactory, вам необходимо программно вызвать `addBeanPostProcessor`, как показано в следующем примере:\nJava\n	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n	// заполняем фабрику определениями компонентов\n	// теперь регистрируемые все экземпляры BeanPostProcessor\n	factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());\n	factory.addBeanPostProcessor(new MyBeanPostProcessor());\n	// теперь начните использовать фабрику\n	// теперь регистрируемые все экземпляры BeanPostProcessor\n	factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())\n	factory.addBeanPostProcessor(MyBeanPostProcessor())\n	// теперь начните использовать фабрику\n| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===.\nЧтобы применить BeanFactoryPostProcessor к простому DefaultListableBeanFactory, вам нужно вызвать его метод postProcessBeanFactory, как показано в следующем примере:\nJava\n	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n	reader.loadBeanDefinitions(new FileSystemResource(\"beans.xml\"));\n	// извлекаем некоторые значения свойств из файла свойств\n	PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();"}
{"id": 187, "text": "cfg.setLocation(new FileSystemResource(\"jdbc.properties\"));\n	// теперь собственно займусь заменой\n	cfg.postProcessBeanFactory(factory);\n	// теперь собственно займусь заменой\n	cfg.postProcessBeanFactory(factory)\n| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===.\nВ обоих случаях явные шаги регистрации неудобны, что почему различные варианты ApplicationContext предпочтительнее простого `DefaultListableBeanFactory` в приложениях, поддерживаемых Spring, особенно когда полагаясь на экземпляры BeanFactoryPostProcessor и BeanPostProcessor для расширенного функциональность контейнера в типичной корпоративной настройке.\n| Встроенный механизм публикации ApplicationEvent. | Нет | Да |===. [ПРИМЕЧАНИЕ] = AnnotationConfigApplicationContext имеет все распространенные постпроцессоры аннотаций. зарегистрирован и может привлечь дополнительные процессоры под охватывает через аннотации конфигурации, такие как `@EnableTransactionManagement`.\nНа уровне абстракции модели конфигурации Spring на основе аннотаций: понятие постпроцессоров компонентов становится просто деталью внутреннего контейнера."}
{"id": 188, "text": "IoC-контейнер.\nВ этой главе рассматривается контейнер Spring Inversion of Control (IoC)."}
{"id": 189, "text": "Проверка Java-бина.\nSpring Framework обеспечивает поддержку {bean-validation-site}[Проверка Java Bean] API.\nОбзор проверки компонентов.\nBean Validation обеспечивает общий способ проверки посредством объявления ограничений и метаданные для приложений Java.\nЧтобы использовать его, вы аннотируете свойства модели предметной области с помощью ограничения декларативной проверки, которые затем применяются средой выполнения.\nЕсть встроенные ограничения, а также вы можете определить свои собственные ограничения.\nJava\n	public class PersonForm {\n		private String name;\n		private int age;\nJava\n	public class PersonForm {\n		@NotNull\n		@Size(max=64)\n		private String name;\n		@Min(0)\n		private int age;\nПроверка компонентов позволяет объявлять ограничения, как показано в следующем примере:.\nЗатем валидатор Bean Validation проверяет экземпляры этого класса на основе объявленного ограничения.\nСм. {bean-validation-site}[Bean Validation] для получения общей информации о API.\nСм. документацию https://hibernate.org/validator/[Hibernate Validator] для конкретные ограничения.\nЧтобы узнать, как настроить поставщика проверки компонентов в качестве Spring Блин, продолжай читать.\nНастройка поставщика проверки компонентов.\nSpring обеспечивает полную поддержку API проверки компонентов, включая загрузку Поставщик проверки компонентов как компонент Spring.\nЭто позволяет вам ввести `jakarta.validation.ValidatorFactory` или `jakarta.validation.Validator`, где проверка необходим в вашем приложении.\nНастройка поставщика проверки компонентов."}
{"id": 190, "text": "Вы можете использовать LocalValidatorFactoryBean для настройки валидатора по умолчанию как Spring. bean-компонент, как показано в следующем примере:\nJava\n	import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public LocalValidatorFactoryBean validator() {\n			return new LocalValidatorFactoryBean();\nXML\n	<bean id=\"validator\"\n		class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/>\nНастройка поставщика проверки компонентов.\nБазовая конфигурация в предыдущем примере запускает проверку bean-компонента для инициализации с помощью используя механизм начальной загрузки по умолчанию.\nПоставщик проверки компонентов, например Hibernate.\nОжидается, что валидатор присутствует в пути к классам и обнаруживается автоматически.\nВнедрить валидатор Джакарты.\nLocalValidatorFactoryBean реализует как jakarta.validation.ValidatorFactory, так и `jakarta.validation.Validator`, поэтому вы можете добавить ссылку на последний в применить логику проверки, если вы предпочитаете работать напрямую с API проверки компонентов, как показано в следующем примере:\nJava\n	import jakarta.validation.Validator;\n	@Service\n	public class MyService {\n		@Autowired\n		private Validator validator;\n	import jakarta.validation.Validator;\nВнедрить Spring-валидатор.\nВ дополнение к реализации `jakarta.validation.Validator`, `LocalValidatorFactoryBean` также адаптируется к `org.springframework.validation.Validator`, поэтому вы можете ввести ссылку ко второму, если вашему компоненту требуется API Spring Validation.\nJava\n	import org.springframework.validation.Validator;"}
{"id": 191, "text": "@Service\n	public class MyService {\n		@Autowired\n		private Validator validator;\nНапример:.\nПри использовании как `org.springframework.validation.Validator`, `LocalValidatorFactoryBean` вызывает базовый `jakarta.validation.Validator`, а затем адаптирует от ConstraintViolation до FieldError и регистрирует их с помощью объекта Errors. передается в метод `validate`.\n* Аннотация `@Constraint`, объявляющая ограничение и его настраиваемые свойства.\n* Реализация интерфейса `jakarta.validation.ConstraintValidator`, который реализует\nКаждое ограничение проверки компонента состоит из двух частей:. поведение ограничения.\nКаждое ограничение проверки компонента состоит из двух частей:.\nЧтобы связать объявление с реализацией, каждая аннотация `@Constraint` ссылается на соответствующий класс реализации ConstraintValidator.\nВо время выполнения ConstraintValidatorFactory создает экземпляр реализации, на которую ссылается, когда В вашей доменной модели встречается аннотация ограничения.\nКаждое ограничение проверки компонента состоит из двух частей:.\nПо умолчанию LocalValidatorFactoryBean настраивает SpringConstraintValidatorFactory. который использует Spring для создания экземпляров ConstraintValidator.\nЭто позволяет вашему заказу ConstraintValidators получают преимущества от внедрения зависимостей, как и любой другой bean-компонент Spring.\nКаждое ограничение проверки компонента состоит из двух частей:.\nВ следующем примере показано пользовательское объявление `@Constraint`, за которым следует связанный Реализация ConstraintValidator, использующая Spring для внедрения зависимостей:\nJava\n	@Target({ElementType.METHOD, ElementType.FIELD})\n	@Retention(RetentionPolicy.RUNTIME)"}
{"id": 192, "text": "@Constraint(validatedBy=MyConstraintValidator.class)\n	public @interface MyConstraint {\nJava\n	import jakarta.validation.ConstraintValidator;\n	public class MyConstraintValidator implements ConstraintValidator {\n		@Autowired;\n		private Foo aDependency;\nКаждое ограничение проверки компонента состоит из двух частей:.\nКак показано в предыдущем примере, реализация ConstraintValidator может иметь свои зависимости. `@Autowired`, как и любой другой компонент Spring.\nSpring-управляемая проверка метода.\nВы можете интегрировать функцию проверки метода Bean Validation в Контекст Spring через определение bean-компонента `MethodValidationPostProcessor`: См. пример кода в исходном документе.\nSpring-управляемая проверка метода.\nЧтобы иметь право на проверку метода на основе Spring, целевые классы должны быть аннотированы. с аннотацией Spring `@Validated`, которая при желании также может объявить проверку группы для использования.\nСм. {spring-framework-api}/validation/beanvalidation/MethodValidationPostProcessor.html[`MethodValidationPostProcessor`] подробности настройки можно узнать у поставщиков Hibernate Validator и Bean Validation.\nSpring-управляемая проверка метода. [СОВЕТ] = Проверка метода опирается на AOP Proxy целевые классы, либо динамические прокси JDK для методов интерфейсов, либо прокси CGLIB.\nСуществуют определенные ограничения на использование прокси, некоторые из которых описаны в разделе всегда использовать методы и методы доступа в прокси-классах; прямой доступ к полю не будет работать.\nSpring-управляемая проверка метода."}
{"id": 193, "text": "Spring MVC и WebFlux имеют встроенную поддержку одной и той же проверки базового метода, но без необходимость АОП.\nПоэтому проверьте остальную часть этого раздела, а также посмотрите Spring MVC.\nИсключения проверки метода.\nПо умолчанию jakarta.validation.ConstraintViolationException вызывается с набором ConstraintViolation возвращается jakarta.validation.Validator.\nВ качестве альтернативы, вместо этого вы можете вызвать исключение MethodValidationException с помощью ConstraintViolation. адаптирован к ошибкам MessageSourceResolvable.\nДля включения установите следующий флаг: См. пример кода в исходном документе.\nИсключения проверки метода. `MethodValidationException` содержит список ``ParameterValidationResult``, который группируйте ошибки по параметру метода, и каждая предоставляет `MethodParameter`, аргумент значение и список ошибок MessageSourceResolvable, адаптированный из ``ConstraintViolation``.\nДля параметров метода `@Valid` с каскадными нарушениями полей и свойств, параметр «ParameterValidationResult» — это «ParameterErrors», который реализует `org.springframework.validation.Errors` и выдает ошибки проверки как ``FieldError``.\nНастройка ошибок проверки.\nАдаптированные ошибки MessageSourceResolvable можно превратить в сообщения об ошибках. отображение пользователям через настроенный «MessageSource» с указанием локали и языка. пакеты ресурсов.\nВ этом разделе приведен пример для иллюстрации.\nJava\n	record Person(@Size(min = 1, max = 10) String name) {\n	@Validated\n	public class MyService {\n		void addStudent(@Valid Person person, @Max(2) int degrees) {"}
{"id": 194, "text": "@Validated\n	class MyService {\n- Коды ошибок `\"Size.person.name\"`, `\"Size.name\"`, `\"Size.java.lang.String\"` и `\"Size\"`\nConstraintViolation в Person.name() адаптируется к FieldError следующим образом:. — Аргументы сообщения «имя», «10» и «1» (имя поля и атрибуты ограничения).\n- Сообщение по умолчанию «размер должен быть от 1 до 10».\nConstraintViolation в Person.name() адаптируется к FieldError следующим образом:.\nЧтобы настроить сообщение по умолчанию, вы можете добавить свойства к пакеты ресурсов, используя любой из приведенных выше кодов ошибок и аргументов сообщения.\nОтметим также, что Аргумент сообщения `\"name\"` сам по себе является `MessageSourceResolvable` с кодами ошибок. `\"person.name\"` и `\"name\"` также могут быть настроены.\nНапример:\nСвойства.\nSize.person.name=Please, provide a {0} that is between {2} and {1} characters long person.name=username\nСвойства. «ConstraintViolation» в параметре метода «градусы» адаптирован к `MessageSourceResolvable` со следующим:"}
{"id": 195, "text": "- Коды ошибок `\"Max.myService#addStudent.grades\"`, `\"Max.grades\"`, `\"Max.int\"`, `\"Max\"`\n- Аргументы сообщения «градусы» и 2 (имя поля и атрибут ограничения)\n- Сообщение по умолчанию «должно быть меньше или равно 2»\nСвойства.\nЧтобы настроить приведенное выше сообщение по умолчанию, вы можете добавить такое свойство, как:\nДополнительные параметры конфигурации.\nКонфигурации по умолчанию LocalValidatorFactoryBean достаточно для большинства случаи.\nСуществует несколько вариантов конфигурации для различных проверок компонентов. конструкции, от интерполяции сообщений до разрешения обхода.\nСм. {spring-framework-api}/validation/beanvalidation/LocalValidatorFactoryBean.html[`LocalValidatorFactoryBean`] javadoc для получения дополнительной информации об этих параметрах.\nНастройка DataBinder.\nВы можете настроить экземпляр DataBinder с помощью Validator.\nПосле настройки вы можете вызовите «Валидатор», вызвав «binder.validate()».\nЛюбые «ошибки» проверки автоматически добавляется в `BindingResult` связывателя.\nНастройка DataBinder.\nВ следующем примере показано, как программно использовать DataBinder для вызова проверки. логика после привязки к целевому объекту:\nJava\n	Foo target = new Foo();\n	DataBinder binder = new DataBinder(target);\n	binder.setValidator(new FooValidator());\n	// привязать к целевому объекту\n	binder.bind(propertyValues);\n	// проверить целевой объект"}
{"id": 196, "text": "binder.validate();\n	// получает BindingResult, включающий все ошибки проверок\n	BindingResult results = binder.getBindingResult();\n	// привязать к целевому объекту\n	binder.bind(propertyValues)\n	// проверить целевой объект\n	binder.validate()\nНастройка DataBinder.\nВы также можете настроить DataBinder с несколькими экземплярами Validator через `dataBinder.addValidators` и `dataBinder.replaceValidators`.\nЭто полезно, когда объединение глобально настроенной проверки bean-компонента с настроенным Spring `Validator` локально в экземпляре DataBinder.\nСм.\nВесенняя проверка MVC.\nСм.\nValidation в главе Spring MVC."}
{"id": 197, "text": "HTTP-кэширование может значительно повысить производительность веб-приложения.\nHTTP-кэширование вращается вокруг заголовка ответа Cache-Control и последующего условного запроса. заголовки, такие как Last-Modified и ETag. `Cache-Control` советует приватное (например, браузер) и публичные (например, прокси) кэши, как кэшировать и повторно использовать ответы.\nИспользуется заголовок `ETag`. сделать условный запрос, который может привести к 304 (NOT_MODIFIED) без тела, если содержимое не изменилось. `ETag` можно рассматривать как более продвинутого преемника заголовок «Last-Modified».\nHTTP-кэширование.\nВ этом разделе описаны параметры, связанные с HTTP-кешированием, доступные в Spring WebFlux.\n`КэшКонтроль`. {spring-framework-api}/http/CacheControl.html[`CacheControl`] обеспечивает поддержку настройка параметров, связанных с заголовком Cache-Control и принимаемых в качестве аргумента в ряде мест:\n* Контроллеры\n* Статические ресурсы\n`КэшКонтроль`.\nХотя {rfc-site}/rfc7234#section-5.2.2[RFC 7234] описывает все возможные директивы для заголовка ответа Cache-Control, тип CacheControl принимает используйте подход, ориентированный на конкретные случаи, который фокусируется на общих сценариях, как показано в следующем примере:\nJava\n	// Кэш на час - \"Cache-Control: max-age=3600\""}
{"id": 198, "text": "CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);\n	// Запретить кеширование — «Cache-Control: no-store»\n	CacheControl ccNoStore = CacheControl.noStore();\n	// Кэш на десять дней в публичных и частных тайниках,\n	// публичные кэши не должны трансформировать ответ\n	// «Cache-Control: max-age=864000, общедоступный, без преобразования»\n	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();\nКонтроллеры могут добавлять явную поддержку HTTP-кэширования.\nМы рекомендуем это сделать, поскольку Значение `lastModified` или `ETag` для ресурса необходимо вычислить, прежде чем его можно будет сравнить. против заголовков условных запросов.\nКонтроллер может добавить ETag и Cache-Control. настройки на `ResponseEntity`, как показано в следующем примере:\nJava\n	@GetMapping(\"/book/{id}\")\n	public ResponseEntity<Book> showBook(@PathVariable Long id) {\n		Book book = findBook(id);\n		String version = book.getVersion();\n		return ResponseEntity\n				.ok()\n				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n				.eTag(version) // также доступен LastModified\n				.body(book);\n		return ResponseEntity\n				.ok()\n				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))"}
{"id": 199, "text": ".eTag(version) // также доступен LastModified\n				.body(book)\nКонтроллеры.\nВ предыдущем примере отправляется ответ 304 (NOT_MODIFIED) с пустым телом, если сравнение к заголовкам условного запроса указывает, что содержимое не изменилось.\nВ противном случае К ответу добавляются заголовки `ETag` и `Cache-Control`.\nКонтроллеры.\nВы также можете проверить заголовки условных запросов в контроллере, как показано в следующем примере:\nJava\n	@RequestMapping\n	public String myHandleMethod(ServerWebExchange exchange, Model model) {\n		long eTag = ... // <1>\n		if (exchange.checkNotModified(eTag)) {\n			return null; // <2>\n		model.addAttribute(...); // <3>\n		return \"myViewName\";\nКонтроллеры. <1> Расчет для конкретного приложения. <2> Ответ установлен на 304 (NOT_MODIFIED).\nНикакой дальнейшей обработки. <3> Продолжить обработку запроса.\n		if (exchange.checkNotModified(eTag)) {\n			return null// <2>\n		model.addAttribute(...) // <3>\n		return \"myViewName\"\nКонтроллеры. <1> Расчет для конкретного приложения. <2> Ответ установлен на 304 (NOT_MODIFIED).\nНикакой дальнейшей обработки. <3> Продолжить обработку запроса.\nКонтроллеры."}
{"id": 200, "text": "Существует три варианта проверки условных запросов на соответствие значениям eTag:lastModified. ценности, или и то, и другое.\nДля условных запросов GET и HEAD вы можете установить ответ на 304 (НЕ_МОДИФИЦИРОВАНО).\nДля условных POST, PUT и DELETE вы можете вместо этого установить ответ до 412 (PRECONDITION_FAILED), чтобы предотвратить одновременное изменение.\nСтатические ресурсы.\nВы должны обслуживать статические ресурсы с помощью Cache-Control и заголовков условного ответа. для оптимальной производительности.\nСм. раздел о настройке"}
{"id": 201, "text": "Наследование определения компонента.\nОпределение компонента может содержать много информации о конфигурации, включая конструктор. аргументы, значения свойств и информация, специфичная для контейнера, такая как инициализация. метод, имя статического фабричного метода и т. д.\nОпределение дочернего компонента наследует данные конфигурации из родительского определения.\nДочернее определение может переопределить некоторые значения или добавьте другие по мере необходимости.\nИспользование определений родительских и дочерних компонентов может значительно сэкономить. набора текста.\nПо сути, это форма шаблонизации.\nНаследование определения компонента.\nЕсли вы работаете с интерфейсом ApplicationContext программно, дочерний компонент определения представлены классом ChildBeanDefinition.\nБольшинство пользователей не работают с ними на этом уровне.\nВместо этого они декларативно настраивают определения компонентов в классе. например, ClassPathXmlApplicationContext.\nПри использовании конфигурации на основе XML метаданных, вы можете указать определение дочернего компонента, используя атрибут «parent», указание родительского компонента в качестве значения этого атрибута.\nСледующий пример показывает, как чтобы сделать это:\n	<bean id=\"inheritedTestBean\" abstract=\"true\"\n			class=\"org.springframework.beans.TestBean\">\n		<property name=\"name\" value=\"parent\"/>\n		<property name=\"age\" value=\"1\"/>\n	</bean>\nНаследование определения компонента. <1> Обратите внимание на атрибут «parent».\nНаследование определения компонента."}
{"id": 202, "text": "Определение дочернего компонента использует класс компонента из родительского определения, если ни один из них не используется. указан, но также может переопределить его.\nВ последнем случае дочерний класс компонента должен быть совместим с родительским элементом (то есть он должен принимать значения свойств родительского объекта).\nНаследование определения компонента.\nОпределение дочернего компонента наследует область действия, значения аргументов конструктора, значения свойств и метод переопределяет родительский метод с возможностью добавления новых значений.\nЛюбая область действия, инициализация метод, метод уничтожения или настройки `статического` фабричного метода, которые вы указываете переопределить соответствующие родительские настройки.\nНаследование определения компонента.\nОстальные настройки всегда берутся из дочернего определения: зависит от, режим автоматического подключения, проверка зависимостей, синглтон и отложенная инициализация.\nНаследование определения компонента.\nПредыдущий пример явно помечает определение родительского компонента как абстрактное, используя атрибут `абстрактный`.\nЕсли в родительском определении не указан класс, явно требуется пометить определение родительского компонента как «абстрактное», как показано в следующем примере. показывает:\n	<bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n		<property name=\"name\" value=\"parent\"/>\n		<property name=\"age\" value=\"1\"/>\n	</bean>\nНаследование определения компонента.\nРодительский компонент не может быть создан сам по себе, поскольку он неполный и также явно отмечен как «абстрактный»."}
{"id": 203, "text": "Когда определение является «абстрактным», оно можно использовать только как чистое определение шаблонного компонента, которое служит родительским определением для детские определения.\nПопытка использовать такой «абстрактный» родительский компонент отдельно, ссылаясь на к нему как к свойству ref другого bean-компонента или выполнив явный вызов getBean() с помощью Идентификатор родительского компонента возвращает ошибку.\nАналогично, внутренняя часть контейнера Метод preInstantiateSingletons() игнорирует определения bean-компонентов, которые определены как абстрактно.\nНаследование определения компонента.\nПРИМЕЧАНИЕ. `ApplicationContext` по умолчанию предварительно создает все синглтоны.\nСледовательно, это важно (по крайней мере, для одноэлементных bean-компонентов), что если у вас есть определение (родительского) bean-компонента который вы собираетесь использовать только в качестве шаблона, и это определение определяет класс, который вы необходимо обязательно установить для атрибута __abstract__ значение __true__, иначе приложение context фактически (попытается) предварительно создать экземпляр `абстрактного` bean-компонента."}
{"id": 204, "text": "Выбор подхода к доступу к базе данных JDBC.\nВы можете выбрать один из нескольких подходов, чтобы сформировать основу для доступа к базе данных JDBC.\nВ дополнение к трем вариантам JdbcTemplate, SimpleJdbcInsert и SimpleJdbcCall. подход оптимизирует метаданные базы данных, а стиль объектов РСУБД приводит к более объектно-ориентированный подход.\nНачав использовать один из этих подходов, вы все равно можете смешивать и сопоставьте, чтобы включить функцию из другого подхода.\n* JdbcTemplate — это классический и самый популярный подход Spring JDBC. Это\nВыбор подхода к доступу к базе данных JDBC.\nПодход «самого низкого уровня» и все остальные используют «JdbcTemplate».\n* NamedParameterJdbcTemplate оборачивает JdbcTemplate для предоставления именованных параметров.\nВыбор подхода к доступу к базе данных JDBC. вместо традиционных заполнителей JDBC `?`.\nЭтот подход обеспечивает лучшее документация и простота использования, когда у вас есть несколько параметров для оператора SQL.\n* SimpleJdbcInsert и SimpleJdbcCall оптимизируют метаданные базы данных, чтобы ограничить объем\nВыбор подхода к доступу к базе данных JDBC. необходимой конфигурации.\nЭтот подход упрощает кодирование, так что вам нужно только укажите имя таблицы или процедуры и карту параметров, соответствующих столбцу имена.\nЭто работает только в том случае, если база данных предоставляет адекватные метаданные.\nЕсли база данных делает не предоставлять эти метаданные, вам необходимо предоставить явную настройку параметров.\n* Объекты РСУБД, включая MappingSqlQuery, SqlUpdate и StoredProcedure."}
{"id": 205, "text": "Выбор подхода к доступу к базе данных JDBC. требуют от вас создания многоразовых и потокобезопасных объектов во время инициализации вашего уровень доступа к данным.\nЭтот подход позволяет вам определить строку запроса, объявить параметры и скомпилируйте запрос.\nКак только вы это сделаете, `execute(...)`, `update(...)` и Методы findObject(...)` можно вызывать несколько раз с различными значениями параметров."}
{"id": 206, "text": "Выбор стиля объявления АОП для использования.\nПосле того, как вы решили, что какой-либо аспект является лучшим подходом для реализации данного требование, как вы решаете между использованием Spring AOP или AspectJ и между Стиль аспектного языка (кода), стиль аннотации @AspectJ или стиль Spring XML?\nЭти На решения влияет ряд факторов, включая требования приложения, инструменты разработки и знакомство команды с АОП.\nВыбор стиля объявления АОП для использования.\nSpring AOP или Full AspectJ?\nВыбор стиля объявления АОП для использования.\nИспользуйте самое простое, что может сработать.\nSpring AOP проще, чем использование полного AspectJ, поскольку нет необходимости внедрять в вашу разработку компилятор/weaver AspectJ и строить процессы.\nЕсли вам нужно только посоветовать выполнение операций на Spring beans, Spring AOP — правильный выбор.\nЕсли вам нужно сообщить об объектах, не управляемых контейнер Spring (обычно такой как объекты домена), вам необходимо использовать АспектДж.\nВам также необходимо использовать AspectJ, если вы хотите указать точки соединения, отличные от выполнение простых методов (например, получение или установка точек соединения полей и т. д.).\nВыбор стиля объявления АОП для использования.\nКогда вы используете AspectJ, у вас есть выбор синтаксиса языка AspectJ (также известного как «стиль кода») или стиль аннотации @AspectJ."}
{"id": 207, "text": "Если аспекты играют большую роль роль в вашем дизайне, и вы можете использовать https://www.eclipse.org/ajdt/[AspectJ Инструменты разработки (AJDT)] для Eclipse, синтаксис языка AspectJ является предпочтительный вариант.\nЭто чище и проще, потому что язык был целенаправленно предназначен для написания аспектов.\nЕсли вы не используете Eclipse или у вас всего несколько аспектов которые не играют важной роли в вашем приложении, вы можете рассмотреть возможность использования стиль @AspectJ, придерживаясь обычной компиляции Java в вашей IDE и добавляя этап вплетения аспектов в ваш сценарий сборки.\nВыбор стиля объявления АОП для использования. @AspectJ или XML для Spring AOP?\nВыбор стиля объявления АОП для использования.\nЕсли вы решили использовать Spring AOP, у вас есть выбор: стиль @AspectJ или XML.\nНеобходимо учитывать различные компромиссы.\nВыбор стиля объявления АОП для использования.\nСтиль XML может быть наиболее знаком существующим пользователям Spring, и он поддерживается подлинными POJO.\nПри использовании АОП в качестве инструмента настройки корпоративных служб XML может оказаться хорошим помощником. выбор (хороший тест — считаете ли вы выражение pointcut частью вашего конфигурацию, которую вы, возможно, захотите изменить самостоятельно).\nВ стиле XML это возможно, из вашей конфигурации будет яснее, какие аспекты присутствуют в системе.\nВыбор стиля объявления АОП для использования.\nСтиль XML имеет два недостатка."}
{"id": 208, "text": "Во-первых, он не полностью отражает реализация требования, которое оно адресует, в одном месте.\nПринцип DRY гласит: что должно быть единое, недвусмысленное и авторитетное представление любой части знания внутри системы.\nПри использовании стиля XML знание того, как требование реализуется, разделяется на объявление класса поддерживающего компонента и XML в файл конфигурации.\nКогда вы используете стиль @AspectJ, эта информация инкапсулируется. в одном модуле: аспект.\nВо-вторых, стиль XML немного более ограничен в возможностях. он может выражать стиль @AspectJ: только модель создания экземпляра аспекта «singleton». поддерживается, и невозможно объединить именованные точки, объявленные в XML.\nНапример, в стиле @AspectJ можно написать что-то вроде следующего:\nJava\n	@Pointcut(\"execution(* get*())\")\n	public void propertyAccess() {}\n	@Pointcut(\"execution(com.xyz.Account+ *(..))\")\n	public void operationReturningAnAccount() {}\n	@Pointcut(\"propertyAccess() && operationReturningAnAccount()\")\n	public void accountPropertyAccess() {}\n	<aop:pointcut id=\"propertyAccess\"\n			expression=\"execution(* get*())\"/>\n	<aop:pointcut id=\"operationReturningAnAccount\"\n			expression=\"execution(com.xyz.Account+ *(..))\"/>"}
{"id": 209, "text": "В стиле XML вы можете объявить первые две точки:.\nНедостатком подхода XML является то, что вы не можете определить `accountPropertyAccess` pointcut путем объединения этих определений.\nВ стиле XML вы можете объявить первые две точки:.\nСтиль @AspectJ поддерживает дополнительные модели создания экземпляров и более широкие возможности pointcut. состав.\nЕго преимущество заключается в сохранении аспекта как модульного блока.\nОн также имеет преимущество в том, что аспекты @AspectJ могут быть поняты (и, следовательно, использованы) как Spring AOP и AspectJ.\nИтак, если вы позже решите, что вам нужны возможности AspectJ для реализации дополнительных требований вы можете легко перейти на классическую настройку AspectJ.\nВ целом команда Spring предпочитает стиль @AspectJ для пользовательских аспектов, выходящих за рамки простого. настройка корпоративных сервисов."}
{"id": 210, "text": "Сканирование пути к классам и управляемые компоненты.\nВ большинстве примеров в этой главе используется XML для указания метаданных конфигурации, которые создает каждое определение BeanDefinition внутри контейнера Spring.\nПредыдущий раздел (Конфигурация контейнера на основе аннотаций) демонстрирует, как предоставить множество метаданных конфигурации на уровне исходного кода. аннотации.\nОднако даже в этих примерах определения «базовых» компонентов явно указаны. определены в XML-файле, тогда как аннотации управляют только внедрением зависимостей.\nСканирование пути к классам и управляемые компоненты.\nВ этом разделе описан вариант неявного обнаружения компонентов-кандидатов путем сканирование пути к классам.\nКомпоненты-кандидаты — это классы, соответствующие фильтру. критерии и иметь соответствующее определение компонента, зарегистрированное в контейнере.\nЭто устраняет необходимость использования XML для регистрации компонентов.\nВместо этого вы можете использовать аннотации (например, `@Component`), выражения типа AspectJ или ваши собственные пользовательские критерии фильтра, чтобы выбрать, в каких классах зарегистрированы определения компонентов контейнер.\nСканирование пути к классам и управляемые компоненты. [ПРИМЕЧАНИЕ] = Вы можете определить bean-компоненты, используя Java, а не файлы XML.\nВзгляните на Аннотации `@Configuration`, `@Bean`, `@Import` и `@DependsOn` для примеров. о том, как использовать эти функции.\n`@Component` и дополнительные аннотации стереотипов."}
{"id": 211, "text": "Аннотация `@Repository` — это маркер любого класса, который выполняет роль или _стереотип_ репозитория (также известный как объект доступа к данным или DAO).\nСреди применений этого маркера представляет собой автоматический перевод исключений, как описано в\n`@Component` и дополнительные аннотации стереотипов.\nSpring предоставляет дополнительные аннотации стереотипов: @Component, @Service и `@Контроллер`. `@Component` — это общий стереотип для любого компонента, управляемого Spring. `@Repository`, `@Service` и `@Controller` являются специализациями `@Component` для более конкретные варианты использования (в сохранении, обслуживании и представлении) слои соответственно).\nТаким образом, вы можете аннотировать свои классы компонентов с помощью `@Component`, но путем аннотирования их `@Repository`, `@Service` или `@Controller` вместо этого ваши классы более подходят для обработки с помощью инструментов или связывания с аспектами.\nНапример, эти стереотипные аннотации являются идеальной мишенью для точечные разрезы. `@Repository`, `@Service` и `@Controller` также могут несут дополнительную семантику в будущих выпусках Spring Framework.\nТаким образом, если вы выбирая между использованием `@Component` или `@Service` для вашего уровня обслуживания, `@Service` явно лучший выбор."}
{"id": 212, "text": "Аналогично, как говорилось ранее, `@Repository` уже поддерживается в качестве маркера для автоматического перевода исключений на вашем уровне персистентности.\nИспользование метааннотаций и составных аннотаций.\nМногие из аннотаций, предоставляемых Spring, можно использовать в качестве метааннотаций в вашем проекте. собственный код.\nМетааннотация — это аннотация, которую можно применить к другой аннотации.\nНапример, в аннотации `@Service` упоминается ранее имеет метааннотацию `@Component`, как показано в следующем примере:\nJava\n	@Target(ElementType.TYPE)\n	@Retention(RetentionPolicy.RUNTIME)\n	@Documented\n	@Component // <1>\n	public @interface Service {\nИспользование метааннотаций и составных аннотаций. <1> Метааннотация `@Component` приводит к тому, что `@Service` обрабатывается так же, как `@Component`.\n	@Target(AnnotationTarget.TYPE)\n	@Retention(AnnotationRetention.RUNTIME)\n	@MustBeDocumented\n	@Component // <1>\n	annotation class Service {\nИспользование метааннотаций и составных аннотаций. <1> Метааннотация `@Component` приводит к тому, что `@Service` обрабатывается так же, как `@Component`.\nИспользование метааннотаций и составных аннотаций.\nВы также можете комбинировать метааннотации для создания «составных аннотаций».\nНапример, аннотация `@RestController` из Spring MVC состоит из `@Controller` и `@ResponseBody`.\nИспользование метааннотаций и составных аннотаций."}
{"id": 213, "text": "Кроме того, составные аннотации могут дополнительно переобъявлять атрибуты из метааннотации для настройки.\nЭто может быть особенно полезно, когда вы хотите предоставить только подмножество атрибутов метааннотации.\nНапример, Весна Аннотация `@SessionScope` жестко кодирует имя области в `session`, но по-прежнему позволяет настройка `proxyMode`.\nВ следующем листинге показано определение Аннотация `@SessionScope`:\nJava\n	@Target({ElementType.TYPE, ElementType.METHOD})\n	@Retention(RetentionPolicy.RUNTIME)\n	@Documented\n	@Scope(WebApplicationContext.SCOPE_SESSION)\n	public @interface SessionScope {\n		 * Alias for {@link Scope#proxyMode}.\n		 * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.\n		@AliasFor(annotation = Scope.class)\n		ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;\nJava\n	@Service\n	@SessionScope\n	public class SessionScopedService {\n	@Service\n	@SessionScope\n	class SessionScopedService {\nЗатем вы можете использовать @SessionScope без объявления proxyMode следующим образом:.\nВы также можете переопределить значение ProxyMode, как показано в следующем примере:\nJava\n	@Service\n	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)\n	public class SessionScopedUserService implements UserService {\n	@Service\n	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)\n	class SessionScopedUserService : UserService {\nЗатем вы можете использовать @SessionScope без объявления proxyMode следующим образом:."}
{"id": 214, "text": "Более подробную информацию см. {spring-framework-wiki}/Spring-Annotation-Programming-Model [Модель программирования Spring-аннотаций] вики-страница.\nАвтоматическое обнаружение классов и регистрация определений компонентов.\nSpring может автоматически обнаруживать стереотипные классы и регистрировать соответствующие.\nЭкземпляры BeanDefinition с ApplicationContext.\nНапример, следующие два класса имеют право на такое автоматическое обнаружение:\nJava\n	@Service\n	public class SimpleMovieLister {\n		private final MovieFinder movieFinder;\n		public SimpleMovieLister(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\nJava\n	@Repository\n	public class JpaMovieFinder implements MovieFinder {\n		// реализация опущена для ясности\n	@Repository\n	class JpaMovieFinder : MovieFinder {\n		// реализация опущена для ясности\nАвтоматическое обнаружение классов и регистрация определений компонентов.\nЧтобы автоматически обнаружить эти классы и зарегистрировать соответствующие bean-компоненты, вам необходимо добавить `@ComponentScan` в ваш класс `@Configuration`, где атрибут `basePackages` настроен с общим родительским пакетом для двух классов.\nАльтернативно, вы можете укажите список, разделенный запятыми, точками с запятой или пробелами, который включает родительский пакет каждого класса.\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"org.example\")\n	public class AppConfig  {\n	@Configuration\n	@ComponentScan(basePackages = [\"org.example\"])\n	class AppConfig  {\nАвтоматическое обнаружение классов и регистрация определений компонентов."}
{"id": 215, "text": "СОВЕТ: Для краткости в предыдущем примере можно было бы использовать неявный атрибут value вместо этого используйте аннотацию: `@ComponentScan(\"org.example\")`\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<context:component-scan base-package=\"org.example\"/>\n	</beans>\nВ следующем примере используется конфигурация XML:.\nСОВЕТ: Использование `<context:comComponent-scan>` неявно включает функциональность `<context:annotation-config>`.\nОбычно нет необходимости включать Элемент `<context:annotation-config>` при использовании `<context:comComponent-scan>`."}
{"id": 216, "text": "В следующем примере используется конфигурация XML:. [ПРИМЕЧАНИЕ] = Для сканирования пакетов classpath требуется наличие соответствующего каталога. записи в пути к классам.\nКогда вы создаете JAR-файлы с помощью Ant, убедитесь, что вы не активируйте переключатель «только файлы» задачи JAR.\nКроме того, каталоги путей к классам могут не быть предоставляется на основе политик безопасности в некоторых средах — например, автономные приложения на JDK 1.7.0_45 и выше (для этого требуется настройка Trusted-Library в ваших манифестах — см. {stackoverflow-questions}/19394570/java-jre-7u45-breaks-classloader-getresources).\nВ следующем примере используется конфигурация XML:.\nНа пути к модулю (система модулей Java) сканирование пути к классам Spring обычно работает как ожидаемо.\nОднако убедитесь, что ваши классы компонентов экспортированы в файл `module-info`. дескрипторы.\nЕсли вы ожидаете, что Spring будет вызывать закрытые члены ваших классов, сделайте уверены, что они «открыты» (то есть, что они используют объявление «opens» вместо объявление `exports` в вашем дескрипторе `module-info`).\nВ следующем примере используется конфигурация XML:.\nКроме того, `AutowiredAnnotationBeanPostProcessor` и `CommonAnnotationBeanPostProcessor` оба неявно включаются, когда вы используете Элемент `<context:comComponent-scan>`."}
{"id": 217, "text": "Это означает, что два компонента определяются автоматически. и соединены вместе - и все это без каких-либо метаданных конфигурации bean-компонентов, представленных в XML.\nВ следующем примере используется конфигурация XML:.\nПРИМЕЧАНИЕ.\nВы можете отключить регистрацию `AutowiredAnnotationBeanPostProcessor` и `CommonAnnotationBeanPostProcessor`, включив атрибут `annotation-config` со значением «ложь».\nЗаполнители свойств и шаблоны в стиле Ant.\nАтрибуты `basePackages` и `value` в `@ComponentScan` поддерживают свойство `${...}`. заполнители, которые разрешаются для пакета Environment, а также пакета Ant-style. такие шаблоны, как `\"org.example.++**+++\"`.\nЗаполнители свойств и шаблоны в стиле Ant.\nКроме того, можно указать несколько пакетов или шаблонов отдельно или внутри одна строка — например, `{\"org.example.config\", \"org.example.service.+++**+++\"}` или `\"org.example.config, org.example.service.++++**++++\"`.\nЗаполнители свойств и шаблоны в стиле Ant.\nВ следующем примере указывается заполнитель свойства app.scan.packages для неявный атрибут value в @ComponentScan.\nJava"}
{"id": 218, "text": "<1> Заполнитель свойства `app.scan.packages`, который будет сопоставлен с `Environment`.\nСледующий листинг представляет файл свойств, который определяет app.scan.packages. собственность.\nВ предыдущем примере предполагается, что этот файл свойств был зарегистрированный в «Среде» — например, через «@PropertySource» или аналогичный механизм.\nИспользование фильтров для настройки сканирования.\nПо умолчанию классы, помеченные `@Component`, `@Repository`, `@Service`, `@Controller`, `@Configuration` или пользовательская аннотация, которая сама помечена с помощью `@Component`, являются единственные обнаруженные компоненты-кандидаты.\nОднако вы можете изменить и расширить это поведение. путем применения пользовательских фильтров.\nДобавьте их как атрибуты includeFilters или excludeFilters. аннотация `@ComponentScan` (или как `<context:include-filter />` или `<context:exclude-filter />` дочерние элементы элемента `<context:comComponent-scan>` в XML-конфигурация).\nДля каждого элемента фильтра требуются атрибуты `type` и `expression`.\nВ следующей таблице описаны параметры фильтрации:\n.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | аннотация (по умолчанию) | `org.example.SomeAnnotation` | Аннотация должна быть _присутствующей_ или _метаприсутствующей_ на уровне типа в целевых компонентах."}
{"id": 219, "text": ".Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | назначаемый | `org.example.SomeClass` | Класс (или интерфейс), которому можно назначить (расширить или реализовать) целевые компоненты.\n.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | аспектj | `org.example..*Сервис+` | Выражение типа AspectJ, которому должны соответствовать целевые компоненты.\n.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | регулярное выражение | `org\\.example\\.Default.*` | Выражение регулярного выражения, которое должно соответствовать именам классов целевых компонентов.\n.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание. | обычай | `org.example.MyTypeFilter` | Пользовательская реализация интерфейса org.springframework.core.type.TypeFilter. |===\n.Типы фильтров |=== | Тип фильтра| Пример выражения | Описание.\nВ следующем примере показана конфигурация @ComponentScan, исключающая все Аннотации `@Repository` и вместо них включают репозитории ``Stub``:\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"org.example\",\n			includeFilters = @Filter(type = FilterType.REGEX, pattern = \".*Stub.*Repository\"),"}
{"id": 220, "text": "excludeFilters = @Filter(Repository.class))\n	public class AppConfig {\n	<beans>\n		<context:component-scan base-package=\"org.example\">\n			<context:include-filter type=\"regex\"\n					expression=\".*Stub.*Repository\"/>\n			<context:exclude-filter type=\"annotation\"\n					expression=\"org.springframework.stereotype.Repository\"/>\n		</context:component-scan>\n	</beans>\nВ следующем листинге показан эквивалентный XML:.\nПРИМЕЧАНИЕ.\nВы также можете отключить фильтры по умолчанию, установив `useDefaultFilters=false` в аннотации или указав `use-default-filters=\"false\"` в качестве атрибута Элемент `<comComponent-scan/>`.\nЭто эффективно отключает автоматическое обнаружение классов. аннотированный или метааннотированный с помощью `@Component`, `@Repository`, `@Service`, `@Controller`, `@RestController` или `@Configuration`.\nИменование автоматически обнаруженных компонентов.\nКогда компонент автоматически обнаруживается в процессе сканирования, его имя компонента имеет вид генерируется с помощью стратегии BeanNameGenerator, известной этому сканеру.\nИменование автоматически обнаруженных компонентов.\nПо умолчанию используется AnnotationBeanNameGenerator.\nНа весну если вы укажете имя через атрибут `value` аннотации, это имя будет использоваться как имя в соответствующем определении компонента."}
{"id": 221, "text": "Это соглашение также применяется, когда Вместо аннотаций стереотипов Spring используется аннотация `@jakarta.inject.Named`.\nИменование автоматически обнаруженных компонентов.\nНачиная с Spring Framework 6.1, имя атрибута аннотации, которое используется для указания имя компонента больше не обязательно должно быть «значением».\nПользовательские аннотации стереотипов могут объявить атрибут с другим именем (например, `name`) и аннотировать этот атрибут с `@AliasFor(annotation = Component.class, атрибут = \"value\")`.\nПосмотреть исходный код объявление `ControllerAdvice#name()` для конкретного примера.\nИменование автоматически обнаруженных компонентов. [ВНИМАНИЕ] = Начиная с Spring Framework 6.1, поддержка стереотипных имен на основе соглашений устарела. и будет удалено в будущей версии платформы.\nСледовательно, сложившийся стереотип аннотации должны использовать @AliasFor для объявления явного псевдонима для атрибута value. в `@Component`.\nСм. объявление исходного кода `Repository#value()` и `ControllerAdvice#name()` для конкретных примеров.\nИменование автоматически обнаруженных компонентов.\nЕсли явное имя компонента не может быть получено из такой аннотации или любого другого обнаруженный компонент (например, обнаруженный с помощью пользовательских фильтров), имя компонента по умолчанию Генератор возвращает неполное имя класса без заглавных букв.\nНапример, если были обнаружены следующие классы компонентов, имена будут `myMovieLister` и `movieFinderImpl`.\nJava\n	@Service(\"myMovieLister\")"}
{"id": 222, "text": "public class SimpleMovieLister {\n	@Service(\"myMovieLister\")\n	class SimpleMovieLister {\nJava\n	@Repository\n	public class MovieFinderImpl implements MovieFinder {\n	@Repository\n	class MovieFinderImpl : MovieFinder {\nИменование автоматически обнаруженных компонентов.\nЕсли вы не хотите полагаться на стратегию именования компонентов по умолчанию, вы можете предоставить собственную стратегия именования компонентов.\nВо-первых, реализовать {spring-framework-api}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`] интерфейс и обязательно включите конструктор без аргументов по умолчанию.\nЗатем предоставьте полную квалифицированное имя класса при настройке сканера, как в следующем примере аннотации. и шоу определения компонента.\nИменование автоматически обнаруженных компонентов.\nСОВЕТ: Если вы столкнулись с конфликтом имен из-за того, что несколько автоматически обнаруженных компонентов имеют одно и то же неполное имя класса (т. е. классы с одинаковыми именами, но находящиеся в разные пакеты), вам может потребоваться настроить BeanNameGenerator, который по умолчанию имеет значение полное имя класса для сгенерированного имени компонента. `FullyQualifiedAnnotationBeanNameGenerator` находится в пакете Для таких целей можно использовать `org.springframework.context.annotation`.\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"org.example\", nameGenerator = MyNameGenerator.class)\n	public class AppConfig {\n	<beans>\n		<context:component-scan base-package=\"org.example\"\n			name-generator=\"org.example.MyNameGenerator\" />\n	</beans>"}
{"id": 223, "text": "Именование автоматически обнаруженных компонентов.\nКак правило, рассмотрите возможность указания имени с аннотацией всякий раз, когда другие компоненты могут явно ссылаться на него.\nС другой стороны, автоматически сгенерированные имена подходят, когда контейнер отвечает за проводку.\nПредоставление области для автоматически определяемых компонентов.\nКак и в случае с компонентами, управляемыми Spring, стандартная и наиболее распространенная область действия для автоматически определяемые компоненты — это «singleton».\nОднако иногда вам нужна другая область применения. это можно указать с помощью аннотации `@Scope`.\nВы можете указать название область действия внутри аннотации, как показано в следующем примере:\nJava\n	@Scope(\"prototype\")\n	@Repository\n	public class MovieFinderImpl implements MovieFinder {\n	@Scope(\"prototype\")\n	@Repository\n	class MovieFinderImpl : MovieFinder {\nПредоставление области для автоматически определяемых компонентов.\nПРИМЕЧАНИЕ.\nАннотации `@Scope` анализируются только для конкретного класса bean-компонента (для аннотированных компоненты) или фабричный метод (для методов @Bean).\nВ отличие от XML-компонента определений, нет понятия наследования определений компонентов и наследования иерархии на уровне классов не имеют значения для целей метаданных.\nПредоставление области для автоматически определяемых компонентов.\nПодробную информацию о веб-областях, таких как «запрос» или «сеанс» в контексте Spring, см. см. области запросов, сеансов, приложений и WebSocket."}
{"id": 224, "text": "Как и в случае с предварительно созданными аннотациями для этих областей, вы также можете создать свою собственную область видимости. аннотации с использованием подхода мета-аннотаций Spring: например, пользовательская аннотация мета-аннотация с `@Scope(\"prototype\")`, возможно, также объявляющая собственный режим прокси-сервера с ограниченной областью действия.\nПредоставление области для автоматически определяемых компонентов.\nПРИМЕЧАНИЕ.\nЧтобы предоставить собственную стратегию решения задач, а не полагаться на основанный на аннотациях подход, вы можете реализовать {spring-framework-api}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`] интерфейс.\nОбязательно включите конструктор без аргументов по умолчанию.\nТогда вы можете предоставить полное имя класса при настройке сканера, как показано в следующем примере. аннотация и определение компонента показывают:\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"org.example\", scopeResolver = MyScopeResolver.class)\n	public class AppConfig {\n	<beans>\n		<context:component-scan base-package=\"org.example\" scope-resolver=\"org.example.MyScopeResolver\"/>\n	</beans>\nПредоставление области для автоматически определяемых компонентов.\nПри использовании определенных областей, не являющихся одноэлементными, может потребоваться создание прокси для объекты с ограниченной областью действия.\nОбоснование описано в Для этой цели в компоненте сканирования доступен атрибутscoped-proxy. элемент."}
{"id": 225, "text": "Три возможных значения: «нет», «интерфейсы» и «targetClass».\nНапример, следующая конфигурация приводит к созданию стандартных динамических прокси JDK:\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"org.example\", scopedProxy = ScopedProxyMode.INTERFACES)\n	public class AppConfig {\n	@Configuration\n	@ComponentScan(basePackages = [\"org.example\"], scopedProxy = ScopedProxyMode.INTERFACES)\n	class AppConfig {\n	<beans>\n		<context:component-scan base-package=\"org.example\" scoped-proxy=\"interfaces\"/>\n	</beans>\nПредоставление метаданных квалификаторов с аннотациями.\nАннотация `@Qualifier` обсуждается в Примеры в этом разделе демонстрируют использование аннотации @Qualifier и пользовательские аннотации квалификаторов для обеспечения детального управления при разрешении автоматического связывания. кандидаты.\nПоскольку эти примеры были основаны на определениях XML-компонентов, квалификатор метаданные были предоставлены в определениях компонентов-кандидатов с использованием квалификатора или мета. дочерние элементы элемента bean в XML.\nПолагаясь на сканирование пути к классам для автоматическое обнаружение компонентов, вы можете предоставить метаданные квалификатора на уровне типа. аннотации к классу-кандидату.\nСледующие три примера демонстрируют это. техника:\nJava\n	@Component\n	@Qualifier(\"Action\")\n	public class ActionMovieCatalog implements MovieCatalog {\n	@Component\n	@Qualifier(\"Action\")\n	class ActionMovieCatalog : MovieCatalog\nJava\n	@Component\n	@Genre(\"Action\")\n	public class ActionMovieCatalog implements MovieCatalog {\n	@Component"}
{"id": 226, "text": "@Genre(\"Action\")\n	class ActionMovieCatalog : MovieCatalog {\nJava\n	@Component\n	@Offline\n	public class CachingMovieCatalog implements MovieCatalog {\n@Component @Offline class CachingMovieCatalog: MovieCatalog {.\nПРИМЕЧАНИЕ.\nКак и в случае с большинством альтернатив на основе аннотаций, имейте в виду, что метаданные аннотаций привязан к самому определению класса, в то время как использование XML позволяет использовать несколько bean-компонентов одного и того же типа, чтобы предоставлять варианты метаданных квалификаторов, поскольку это метаданные предоставляются для каждого экземпляра, а не для каждого класса.\nОпределение метаданных компонента внутри компонентов.\nКомпоненты Spring также могут вносить в контейнер метаданные определения компонента.\nВы можете сделать это с той же аннотацией `@Bean`, используемой для определения метаданных компонента в `@Configuration` аннотированные классы.\nВ следующем примере показано, как это сделать:\nJava\n	@Component\n	public class FactoryMethodComponent {\n		@Bean\n		@Qualifier(\"public\")\n		public TestBean publicInstance() {\n			return new TestBean(\"publicInstance\");\n		public void doWork() {\n			// Реализация метода компонента опущена\n	@Component\n	class FactoryMethodComponent {\nОпределение метаданных компонента внутри компонентов.\nПредыдущий класс — это компонент Spring, в котором есть код, специфичный для приложения. метод `doWork()`.\nОднако он также вносит свой вклад в определение компонента, у которого есть фабрика. метод, ссылающийся на метод publicInstance()."}
{"id": 227, "text": "Аннотация `@Bean` идентифицирует фабричный метод и другие свойства определения компонента, такие как значение квалификатора через аннотация `@Qualifier`.\nДругие аннотации уровня метода, которые можно указать: `@Scope`, `@Lazy` и пользовательские аннотации квалификаторов.\nОпределение метаданных компонента внутри компонентов. [СОВЕТ] = В дополнение к его роли для инициализации компонента вы также можете разместить `@Lazy` аннотации к точкам внедрения, отмеченным `@Autowired` или `@Inject`.\nВ этом контексте это приводит к внедрению прокси-сервера с ленивым разрешением.\nОднако такой прокси-подход является довольно ограниченным.\nДля сложных ленивых взаимодействий, особенно в сочетании с дополнительными зависимостями вместо этого мы рекомендуем `ObjectProvider<MyTargetBean>`.\nОпределение метаданных компонента внутри компонентов.\nКак обсуждалось ранее, поддерживаются автоматически связываемые поля и методы с дополнительными поддержка автоматического подключения методов `@Bean`.\nВ следующем примере показано, как это сделать:\nJava\n	@Component\n	public class FactoryMethodComponent {\n		private static int i;\n		@Bean\n		@Qualifier(\"public\")\n		public TestBean publicInstance() {\n			return new TestBean(\"publicInstance\");\n		// использование специального квалификатора и автоматическое связывание параметров метода\n		@Bean\n		protected TestBean protectedInstance(\n				@Qualifier(\"public\") TestBean spouse,\n				@Value(\"#{privateInstance.age}\") String country) {"}
{"id": 228, "text": "TestBean tb = new TestBean(\"protectedInstance\", 1);\n			tb.setSpouse(spouse);\n			tb.setCountry(country);\n			return tb;\n		@Bean\n		private TestBean privateInstance() {\n			return new TestBean(\"privateInstance\", i++);\n		@Bean\n		@RequestScope\n		public TestBean requestScopedInstance() {\n			return new TestBean(\"requestScopedInstance\", 3);\n	@Component\n	class FactoryMethodComponent {\nОпределение метаданных компонента внутри компонентов.\nВ примере автоматически привязывается параметр метода `String` `country` к значению `age`. свойство другого компонента с именем PrivateInstance.\nЭлемент языка выражений Spring определяет значение свойства через обозначение `#{ <выражение> }`.\nДля `@Value` аннотаций, преобразователь выражений предварительно настроен для поиска имен компонентов, когда разрешение текста выражения.\nОпределение метаданных компонента внутри компонентов.\nНачиная с Spring Framework 4.3, вы также можете объявить параметр фабричного метода типа `InjectionPoint` (или его более конкретный подкласс: `DependencyDescriptor`) для получить доступ к запрашивающей точке внедрения, которая запускает создание текущего компонента.\nОбратите внимание, что это относится только к фактическому созданию экземпляров компонента, а не к внедрение существующих экземпляров.\nКак следствие, эта функция имеет наибольший смысл для бобы области прототипа."}
{"id": 229, "text": "Для других областей фабричный метод видит только точка внедрения, которая инициировала создание нового экземпляра компонента в заданной области (например, зависимость, которая вызвала создание ленивого одноэлементного компонента).\nВ таких сценариях вы можете использовать предоставленные метаданные точки внедрения с семантической осторожностью.\nВ следующем примере показано, как использовать InjectionPoint:\nJava\n	@Component\n	public class FactoryMethodComponent {\n		@Bean @Scope(\"prototype\")\n		public TestBean prototypeInstance(InjectionPoint injectionPoint) {\n			return new TestBean(\"prototypeInstance for \" + injectionPoint.getMember());\n	@Component\n	class FactoryMethodComponent {\nОпределение метаданных компонента внутри компонентов.\nМетоды `@Bean` в обычном компоненте Spring обрабатываются иначе, чем их аналоги внутри класса Spring `@Configuration`.\nРазница в том, что `@Component` классы не дополнены CGLIB для перехвата вызова методов и полей.\nПроксирование CGLIB — это средство вызова методов или полей внутри методов `@Bean`. в классах `@Configuration` создает ссылки на метаданные компонента для взаимодействующих объектов.\nТакие методы не вызываются с обычной семантикой Java, а проходят через контейнер для обеспечения обычного управления жизненным циклом и проксирования Spring. bean-компоненты, даже при обращении к другим bean-компонентам посредством программного вызова методов `@Bean`.\nНапротив, вызов метода или поля в методе `@Bean` внутри простого `@Component` класс имеет стандартную семантику Java, без специальной обработки CGLIB или других применение ограничений."}
{"id": 230, "text": "Определение метаданных компонента внутри компонентов. [ПРИМЕЧАНИЕ] = Вы можете объявить методы `@Bean` как `статические`, что позволит вызывать их без создание содержащего их класса конфигурации в качестве экземпляра.\nЭто делает особый смысл при определении bean-компонентов постпроцессора (например, типа BeanFactoryPostProcessor). или `BeanPostProcessor`), поскольку такие bean-компоненты инициализируются на ранней стадии в контейнере. жизненный цикл и не должны запускать другие части конфигурации на этом этапе.\nОпределение метаданных компонента внутри компонентов.\nВызовы статических методов `@Bean` никогда не перехватываются контейнером, даже внутри него.\nКлассы `@Configuration` (как описано ранее в этом разделе) по техническим причинам ограничения: создание подклассов CGLIB может переопределить только нестатические методы.\nКак следствие, прямой вызов другого метода `@Bean` имеет стандартную семантику Java, в результате чего в независимом экземпляре, возвращаемом прямо из самого фабричного метода.\nОпределение метаданных компонента внутри компонентов.\nВидимость методов `@Bean` в языке Java не оказывает непосредственного влияния на полученное определение bean-компонента в контейнере Spring.\nВы можете свободно заявить о своем фабричные методы, которые вы считаете подходящими для классов, отличных от `@Configuration`, а также для статических методы где угодно.\nОднако обычные методы `@Bean` в классах `@Configuration` требуют быть переопределяемыми, то есть их нельзя объявлять как «частные» или «окончательные»."}
{"id": 231, "text": "Определение метаданных компонента внутри компонентов.\nМетоды `@Bean` также обнаруживаются в базовых классах данного компонента или класс конфигурации, а также методы Java по умолчанию, объявленные в интерфейсах реализованный компонентом или классом конфигурации.\nЭто позволяет реализовать множество гибкость в составлении сложных конфигураций, даже с несколькими наследование возможно с помощью методов Java по умолчанию.\nОпределение метаданных компонента внутри компонентов.\nНаконец, один класс может содержать несколько методов @Bean для одного и того же объекта. bean-компонент, как сочетание нескольких фабричных методов, которые можно использовать в зависимости от доступных зависимости во время выполнения.\nЭто тот же алгоритм, что и при выборе «самого жадного» конструктор или фабричный метод в других сценариях конфигурации: вариант с наибольшее количество выполнимых зависимостей выбирается во время построения, аналогично тому, как контейнер выбирает между несколькими конструкторами @Autowired."}
{"id": 232, "text": "Коллекция Проекция.\nПроекция позволяет коллекции управлять вычислением подвыражения, и результатом будет новая коллекция.\nСинтаксис проекции: `.![projectionExpression]`.\nНапример, Предположим, у нас есть список изобретателей, но нам нужен список городов, в которых они родились.\nПо сути, мы хотим оценить «placeOfBirth.city» для каждой записи в изобретателе. список.\nВ следующем примере для этого используется проекция:\nJava\n	// оценивается как [\"Смилян\", \"Идвор\"]\n	List placesOfBirth = parser.parseExpression(\"members.![placeOfBirth.city]\")\n			.getValue(societyContext, List.class);\nКоллекция Проекция.\nПроекция поддерживается для массивов и всего, что реализует java.lang.Iterable или `java.util.Map`.\nПри использовании карты для управления проекцией выражение проекции имеет вид оценивается для каждой записи на карте (представленной как Java `Map.Entry`).\nРезультат проекции на карту — это список, состоящий из оценок проекции выражение против каждой записи карты.\nКоллекция Проекция. [ПРИМЕЧАНИЕ] = Язык выражений Spring также поддерживает безопасную навигацию для проецирования коллекции.\nКоллекция Проекция.\nСм. для получения подробной информации."}
{"id": 233, "text": "Выбор коллекции.\nВыбор — это мощная функция языка выражений, которая позволяет преобразовать исходную коллекцию в другую коллекцию, выбирая из ее записей.\nВыбор коллекции.\nВыбор использует синтаксис `.?[selectionExpression]`.\nОн фильтрует коллекцию и возвращает новую коллекцию, содержащую подмножество исходных элементов.\nНапример, Выборка позволяет нам легко получить список сербских изобретателей, как показывает следующий пример:\nJava\n	List<Inventor> list = (List<Inventor>) parser.parseExpression(\n			\"members.?[nationality == 'Serbian']\").getValue(societyContext);\nВыбор коллекции.\nВыбор поддерживается для массивов и всего, что реализует java.lang.Iterable или `java.util.Map`.\nДля массива или Iterable оценивается выражение выбора. против каждого отдельного элемента.\nНа карте оценивается выражение выбора против каждой записи карты (объекты типа Java `Map.Entry`).\nКаждая запись на карте имеет свое `key` и `value` доступны как свойства для использования при выборе.\nВыбор коллекции.\nУчитывая `Map`, хранящуюся в переменной с именем `#map`, следующее выражение возвращает новый карта, состоящая из тех элементов исходной карты, значение записи которых меньше чем 27:\nJava\n	Map newMap = parser.parseExpression(\"#map.?[value < 27]\").getValue(Map.class);\nВыбор коллекции."}
{"id": 234, "text": "Помимо возврата всех выбранных элементов, вы можете получить только первый или последний элемент.\nЧтобы получить первый элемент, соответствующий выражению выбора, синтаксис: `.^[selectionExpression]`.\nЧтобы получить последний элемент, соответствующий выделенному выражение, синтаксис — `.$[selectionExpression]`.\nВыбор коллекции. [ПРИМЕЧАНИЕ] = Язык выражений Spring также поддерживает безопасную навигацию при выборе коллекции.\nВыбор коллекции.\nСм. для получения подробной информации."}
{"id": 235, "text": "Составление конфигураций на основе Java.\nФункция конфигурации Spring на основе Java позволяет создавать аннотации, что позволяет сократить сложность вашей конфигурации.\nИспользование аннотации `@Import`.\nПодобно тому, как элемент `<import/>` используется в файлах Spring XML для облегчения модульности конфигурации, аннотация `@Import` позволяет загружать определения `@Bean` из другой класс конфигурации, как показано в следующем примере:\nJava\n	@Configuration\n	public class ConfigA {\n		@Bean\n		public A a() {\n			return new A();\n	@Configuration\n	@Import(ConfigA.class)\n	public class ConfigB {\n		@Bean\n		public B b() {\n			return new B();\n	@Configuration\n	class ConfigA {\nИспользование аннотации `@Import`.\nТеперь вместо необходимости указывать ConfigA.class и ConfigB.class при для создания экземпляра контекста необходимо явно указать только `ConfigB`, так как следующий пример показывает:\nJava\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);\n		// теперь оба компонента A и B будут доступны...\n		A a = ctx.getBean(A.class);\n		B b = ctx.getBean(B.class);\nИспользование аннотации `@Import`."}
{"id": 236, "text": "Этот подход упрощает создание экземпляра контейнера, поскольку необходимо иметь дело только с одним классом. вместо того, чтобы требовать от вас запоминания потенциально большого количества Классы `@Configuration` во время сборки.\nИспользование аннотации `@Import`.\nСОВЕТ: Начиная с Spring Framework 4.2, `@Import` также поддерживает ссылки на обычные компоненты. классы, аналогичные методу AnnotationConfigApplicationContext.register.\nЭто особенно полезно, если вы хотите избежать сканирования компонентов, используя несколько классы конфигурации в качестве точек входа для явного определения всех ваших компонентов.\nВнедрение зависимостей в импортированные определения `@Bean`.\nПредыдущий пример работает, но является упрощенным.\nВ большинстве практических сценариев бобы имеют зависимости друг от друга в классах конфигурации.\nПри использовании XML это не проблема, потому что компилятор не задействован, и вы можете объявить `ref=\"someBean\"` и доверите Spring решить эту проблему во время инициализации контейнера.\nПри использовании классов `@Configuration` компилятор Java накладывает ограничения на модель конфигурации, в которой ссылки на другие компоненты должны соответствовать допустимому синтаксису Java.\nВнедрение зависимостей в импортированные определения `@Bean`.\nК счастью, решить эту проблему просто.\nКак метод `@Bean` может иметь произвольное количество параметров, описывающих компонент. зависимости.\nРассмотрим следующий более реалистичный сценарий с несколькими `@Configuration` классы, каждый из которых зависит от bean-компонентов, объявленных в других:\nJava\n	@Configuration\n	public class ServiceConfig {"}
{"id": 237, "text": "@Bean\n		public TransferService transferService(AccountRepository accountRepository) {\n			return new TransferServiceImpl(accountRepository);\n	@Configuration\n	public class RepositoryConfig {\n		@Bean\n		public AccountRepository accountRepository(DataSource dataSource) {\n			return new JdbcAccountRepository(dataSource);\n	@Configuration\n	@Import({ServiceConfig.class, RepositoryConfig.class})\n	public class SystemTestConfig {\n		@Bean\n		public DataSource dataSource() {\n			// вернуть новый источник данных\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);\n		// все связано между классами конфигурации...\n		TransferService transferService = ctx.getBean(TransferService.class);\n		transferService.transfer(100.00, \"A123\", \"C456\");\n	@Configuration\n	class ServiceConfig {\n	@Configuration\n	class RepositoryConfig {\nВнедрение зависимостей в импортированные определения `@Bean`.\nЕсть еще один способ добиться того же результата.\nПомните, что классы `@Configuration` в конечном итоге только еще один компонент в контейнере: это означает, что они могут воспользоваться преимуществами Внедрение `@Autowired` и `@Value` и другие функции такие же, как и у любого другого bean-компонента."}
{"id": 238, "text": "Внедрение зависимостей в импортированные определения `@Bean`. [ВНИМАНИЕ] = Убедитесь, что зависимости, которые вы вводите таким образом, имеют только самый простой вид. `@Конфигурация` классы обрабатываются довольно рано во время инициализации контекста и вызывают зависимость такое внедрение может привести к неожиданной ранней инициализации.\nПо возможности прибегайте к внедрение на основе параметров, как в предыдущем примере.\nВнедрение зависимостей в импортированные определения `@Bean`.\nИзбегайте доступа к локально определенным bean-компонентам в методе @PostConstruct в той же конфигурации. класс.\nЭто фактически приводит к циклической ссылке, поскольку семантически нестатические методы `@Bean` требуют вызова полностью инициализированного экземпляра класса конфигурации.\nС циклическими ссылками запрещено (например, в Spring Boot 2.6+), это может вызвать исключение BeanCurrentlyInCreationException.\nВнедрение зависимостей в импортированные определения `@Bean`.\nКроме того, будьте особенно осторожны с определениями BeanPostProcessor и BeanFactoryPostProcessor. через `@Bean`.\nОбычно их следует объявлять как статические методы @Bean, не запуская создание экземпляра содержащего их класса конфигурации.\nВ противном случае `@Autowired` и `@Value` могут не работать. поработайте над самим классом конфигурации, поскольку его можно создать как экземпляр компонента раньше, чем {spring-framework-api}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`].\nВнедрение зависимостей в импортированные определения `@Bean`."}
{"id": 239, "text": "В следующем примере показано, как один компонент можно автоматически подключить к другому компоненту:\nJava\n	@Configuration\n	public class ServiceConfig {\n		@Autowired\n		private AccountRepository accountRepository;\n		@Bean\n		public TransferService transferService() {\n			return new TransferServiceImpl(accountRepository);\n	@Configuration\n	public class RepositoryConfig {\n		private final DataSource dataSource;\n		public RepositoryConfig(DataSource dataSource) {\n			this.dataSource = dataSource;\n		@Bean\n		public AccountRepository accountRepository() {\n			return new JdbcAccountRepository(dataSource);\n	@Configuration\n	@Import({ServiceConfig.class, RepositoryConfig.class})\n	public class SystemTestConfig {\n		@Bean\n		public DataSource dataSource() {\n			// вернуть новый источник данных\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);\n		// все связано между классами конфигурации...\n		TransferService transferService = ctx.getBean(TransferService.class);\n		transferService.transfer(100.00, \"A123\", \"C456\");\n	@Configuration\n	class ServiceConfig {\nВнедрение зависимостей в импортированные определения `@Bean`.\nСОВЕТ: Обратите внимание, что нет необходимости указывать @Autowired, если целевой компонент определяет только один конструктор.\nВнедрение зависимостей в импортированные определения `@Bean`. [дискретный] Полностью соответствующие импортные компоненты для удобства навигации.\nВнедрение зависимостей в импортированные определения `@Bean`."}
{"id": 240, "text": "В предыдущем сценарии использование @Autowired работает хорошо и обеспечивает желаемый результат. модульность, но определение того, где именно объявляются определения автоматически подключенных компонентов, является все еще несколько двусмысленно.\nНапример, как разработчик, просматривающий ServiceConfig, как вы точно знаете, где объявлен bean-компонент @Autowired AccountRepository?\nЭто не явно в коде, и это может быть нормально.\nОбратите внимание, что {spring-site-tools}[Spring Tools] Поддержка IDE предоставляет инструменты, которые могут отображать графики. показать, как все подключено, и это может быть все, что вам нужно.\nКроме того, ваша Java IDE может легко найти все объявления и использования типа AccountRepository и быстро показать вы указываете расположение методов `@Bean`, которые возвращают этот тип.\nВнедрение зависимостей в импортированные определения `@Bean`.\nВ случаях, когда эта двусмысленность неприемлема и вы хотите иметь прямую навигацию из вашей IDE из одного класса `@Configuration` в другой, рассмотрите возможность автоматического подключения сами классы конфигурации.\nВ следующем примере показано, как это сделать:\nJava\n	@Configuration\n	public class ServiceConfig {\n		@Autowired\n		private RepositoryConfig repositoryConfig;\n		@Bean\n		public TransferService transferService() {\n			// перейдите «через» класс конфигурации к методу @Bean!\n			return new TransferServiceImpl(repositoryConfig.accountRepository());\n@Configuration class ServiceConfig {.\nВ предыдущей ситуации определение AccountRepository совершенно явно.\nОднако ServiceConfig теперь тесно связан с RepositoryConfig."}
{"id": 241, "text": "Это компромисс.\nЭту тесную связь можно несколько смягчить, используя интерфейсы или абстрактные классы `@Configuration` на основе классов.\nРассмотрим следующий пример:\nJava\n	@Configuration\n	public class ServiceConfig {\n		@Autowired\n		private RepositoryConfig repositoryConfig;\n		@Bean\n		public TransferService transferService() {\n			return new TransferServiceImpl(repositoryConfig.accountRepository());\n	@Configuration\n	public interface RepositoryConfig {\n		@Bean\n		AccountRepository accountRepository();\n	@Configuration\n	public class DefaultRepositoryConfig implements RepositoryConfig {\n		@Bean\n		public AccountRepository accountRepository() {\n			return new JdbcAccountRepository(...);\n	@Configuration\n	@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!\n	public class SystemTestConfig {\n		@Bean\n		public DataSource dataSource() {\n			// вернуть источник данных\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);\n		TransferService transferService = ctx.getBean(TransferService.class);\n		transferService.transfer(100.00, \"A123\", \"C456\");\n	@Configuration\n	class ServiceConfig {\n	@Configuration\n	interface RepositoryConfig {\n	@Configuration\n	class DefaultRepositoryConfig : RepositoryConfig {\n@Configuration class ServiceConfig {.\nТеперь ServiceConfig слабо связан с конкретным `DefaultRepositoryConfig`, а встроенные инструменты IDE по-прежнему полезны: вы можете легко получить иерархию типов реализаций RepositoryConfig."}
{"id": 242, "text": "В этом кстати, навигация по классам `@Configuration` и их зависимостям не станет исключением. чем обычный процесс навигации по интерфейсному коду.\nВлияние на запуск синглтонов, определенных `@Bean`.\nЕсли вы хотите повлиять на порядок создания запуска определенных одноэлементных компонентов, рассмотрите объявив некоторые из них как `@Lazy` для создания при первом доступе, а не при запуске.\nВлияние на запуск синглтонов, определенных `@Bean`. `@DependsOn` заставляет сначала инициализировать некоторые другие компоненты, гарантируя, что указанные bean-компоненты создаются до текущего bean-компонента, за пределами того, что у последнего подразумевают прямые зависимости.\nФоновая инициализация.\nНачиная с версии 6.2, есть опция фоновой инициализации: `@Bean(bootstrap=BACKGROUND)` позволяет выделить определенные bean-компоненты для фоновой инициализации, охватывая весь шаг создания компонента для каждого такого компонента при запуске контекста.\nФоновая инициализация.\nЗависимые bean-компоненты с неленивыми точками внедрения автоматически ждут экземпляр bean-компонента. быть завершено.\nВсе обычные фоновые инициализации принудительно завершаются в конце. запуска контекста.\nРазрешается завершать только bean-компоненты, дополнительно помеченные как `@Lazy`. позже (вплоть до первого фактического доступа).\nФоновая инициализация обычно выполняется вместе с `@Lazy` (или `ObjectProvider`).\nТочки инъекции в зависимых bean-компонентах."}
{"id": 243, "text": "В противном случае основной поток начальной загрузки будет блокируется, когда фактический экземпляр bean-компонента, инициализированный в фоновом режиме, необходимо внедрить раньше.\nФоновая инициализация.\nЭта форма одновременного запуска применяется к отдельным компонентам: если такой компонент зависит от другие bean-компоненты, они должны быть уже инициализированы либо просто путем объявленный ранее, или через `@DependsOn`, который обеспечивает инициализацию в основном загрузочный поток до запуска фоновой инициализации затронутого bean-компонента.\nФоновая инициализация. [ПРИМЕЧАНИЕ] = Компонент `bootstrapExecutor` типа `Executor` должен быть объявлен для фона. загрузка, чтобы быть действительно активной.\nВ противном случае фоновые маркеры будут игнорироваться. время выполнения.\nФоновая инициализация.\nИсполнитель начальной загрузки может быть ограниченным исполнителем только для целей запуска или общим пул потоков, который служит и для других целей.\nУсловно включать классы `@Configuration` или методы `@Bean`.\nЧасто бывает полезно условно включить или отключить полный класс @Configuration. или даже отдельные методы `@Bean`, основанные на произвольном состоянии системы.\nОдин общий примером этого является использование аннотации `@Profile` для активации bean-компонентов только тогда, когда определенный профиль включен в Spring `Environment` (см.\nПрофили определения компонентов подробности).\nУсловно включать классы `@Configuration` или методы `@Bean`."}
{"id": 244, "text": "Аннотация `@Profile` на самом деле реализована с использованием гораздо более гибкой аннотации. называется {spring-framework-api}/context/annotation/Conditional.html[`@Conditional`].\nАннотация `@Conditional` указывает на конкретные `org.springframework.context.annotation.Condition` реализации, которые должны быть проконсультироваться перед регистрацией `@Bean`.\nУсловно включать классы `@Configuration` или методы `@Bean`.\nРеализации интерфейса Condition предоставляют функцию match(...)`. метод, который возвращает true или false.\nНапример, следующий листинг показывает фактическое Реализация `Condition`, используемая для `@Profile`:\nJava\n	@Override\n	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n		// Читаем атрибуты аннотации @Profile\n		MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n		if (attrs != null) {\n			for (Object value : attrs.get(\"value\")) {\n				if (context.getEnvironment().matchesProfiles((String[]) value)) {\n					return true;\n			return false;\n		return true;\nУсловно включать классы `@Configuration` или методы `@Bean`.\nСм. {spring-framework-api}/context/annotation/Conditional.html[`@Conditional`] javadoc для более подробной информации."}
{"id": 245, "text": "Объединение конфигурации Java и XML.\nПоддержка класса @Configuration в Spring не претендует на 100% полную замену. для Spring XML.\nНекоторые средства, такие как пространства имен Spring XML, остаются идеальным способом настроить контейнер.\nВ тех случаях, когда XML удобен или необходим, у вас есть выбор: либо создать экземпляр контейнера «XML-ориентированным», используя, например, ClassPathXmlApplicationContext или создайте его экземпляр «Java-ориентированным» способом, используя AnnotationConfigApplicationContext и аннотация @ImportResource для импорта XML. по мере необходимости.\nXML-ориентированное использование классов `@Configuration`.\nВозможно, будет предпочтительнее загрузить контейнер Spring из XML и включить Классы `@Configuration` в специальной форме.\nНапример, в большой существующей базе кода использующий Spring XML, проще создавать классы `@Configuration` на по мере необходимости и включать их из существующих XML-файлов.\nДалее в этом разделе мы рассмотрим варианты использования классов `@Configuration` в подобной ситуации, ориентированной на XML.\n[дискретный] Объявление классов `@Configuration` как простых элементов Spring `<bean/>`.\nПомните, что классы @Configuration в конечном итоге являются определениями компонентов в контейнере.\nВ этой серии примеров мы создаем класс @Configuration с именем AppConfig и включите его в `system-test-config.xml` как определение `<bean/>`."}
{"id": 246, "text": "Потому что `<context:annotation-config/>` включен, контейнер распознает аннотация `@Configuration` и обрабатывает методы `@Bean`, объявленные в `AppConfig` правильно.\nJava\n	@Configuration\n	public class AppConfig {\n		@Autowired\n		private DataSource dataSource;\n		@Bean\n		public AccountRepository accountRepository() {\n			return new JdbcAccountRepository(dataSource);\n		@Bean\n		public TransferService transferService() {\n			return new TransferServiceImpl(accountRepository());\n	@Configuration\n	class AppConfig {\n	<beans>\n		<!-- enable processing of annotations such as @Autowired and @Configuration -->\n		<context:annotation-config/>\n		<context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n		<bean class=\"com.acme.AppConfig\"/>\n		<bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.username}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</bean>\n	</beans>\nJava\n	public static void main(String[] args) {"}
{"id": 247, "text": "ApplicationContext ctx = new ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test-config.xml\");\n		TransferService transferService = ctx.getBean(TransferService.class);\njdbc.url=jdbc:hsqldb:hsql://localhost/xdb jdbc.username=sa jdbc.password=.\nПРИМЕЧАНИЕ.\nВ файле `system-test-config.xml` AppConfig `<bean/>` не объявляет `id`. атрибут.\nХотя это было бы приемлемо, в этом нет необходимости, учитывая, что никакой другой bean-компонент когда-либо ссылается на него, и маловероятно, что оно будет явно получено из контейнера по имени.\nАналогично, компонент DataSource автоматически подключается только по типу, поэтому явный идентификатор компонента не является строго обязательным.\n[дискретный] Использование <context:comComponent-scan/> для выбора классов `@Configuration`.\nПоскольку `@Configuration` имеет мета-аннотацию `@Component`, `@Configuration`-аннотирован классы автоматически становятся кандидатами на сканирование компонентов.\nИспользуя тот же сценарий, что и описанный в предыдущем примере, мы можем переопределить `system-test-config.xml`, чтобы принять преимущество сканирования компонентов."}
{"id": 248, "text": "Обратите внимание, что в этом случае нам не нужно явно объявлять `<context:annotation-config/>`, потому что `<context:comComponent-scan/>` включает то же самое функциональность.\n	<beans>\n		<!-- picks up and registers AppConfig as a bean definition -->\n		<context:component-scan base-package=\"com.acme\"/>\n		<context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n		<bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.username}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</bean>\n	</beans>\n`@Configuration` Классно-ориентированное использование XML с `@ImportResource`.\nВ приложениях, где классы @Configuration являются основным механизмом настройки контейнере, возможно, все равно придется использовать хотя бы немного XML.\nВ таких случаях вы можете использовать @ImportResource и определять столько XML, сколько вам нужно.\nТем самым достигается «Java-ориентированный» подход к настройке контейнера сводит XML к минимуму."}
{"id": 249, "text": "Следующий пример (который включает класс конфигурации, XML-файл, определяющий bean-компонент, файл свойств и метод `main()`) показывает, как использовать `@ImportResource` аннотация для достижения «Java-ориентированной» конфигурации, которая использует XML по мере необходимости:\nJava\n	@Configuration\n	@ImportResource(\"classpath:/com/acme/properties-config.xml\")\n	public class AppConfig {\n		@Value(\"${jdbc.url}\")\n		private String url;\n		@Value(\"${jdbc.username}\")\n		private String username;\n		@Value(\"${jdbc.password}\")\n		private String password;\n		@Bean\n		public DataSource dataSource() {\n			return new DriverManagerDataSource(url, username, password);\n		@Bean\n		public AccountRepository accountRepository(DataSource dataSource) {\n			return new JdbcAccountRepository(dataSource);\n		@Bean\n		public TransferService transferService(AccountRepository accountRepository) {\n			return new TransferServiceImpl(accountRepository);\n	@Configuration\n	@ImportResource(\"classpath:/com/acme/properties-config.xml\")\n	class AppConfig {\n	<beans>\n		<context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n	</beans>\nJava\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);"}
{"id": 250, "text": "TransferService transferService = ctx.getBean(TransferService.class);"}
{"id": 251, "text": "Краткие определения прокси.\nОсобенно при определении транзакционных прокси-серверов вы можете получить множество похожих прокси-серверов. определения.\nИспользование определений родительского и дочернего bean-компонентов, а также внутреннего bean-компонента. определения, могут привести к более чистым и кратким определениям прокси.\nКраткие определения прокси.\nСначала мы создаем родительское определение, шаблон и определение компонента для прокси следующим образом:\n	<bean id=\"txProxyTemplate\" abstract=\"true\"\n			class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\">\n		<property name=\"transactionManager\" ref=\"transactionManager\"/>\n		<property name=\"transactionAttributes\">\n			<props>\n				<prop key=\"*\">PROPAGATION_REQUIRED</prop>\n			</props>\n		</property>\n	</bean>\nКраткие определения прокси.\nЭто никогда не создается само по себе, поэтому на самом деле оно может быть неполным.\nЗатем каждый прокси необходимо создать определение дочернего компонента, который обертывает цель прокси как определение внутреннего компонента, поскольку цель в любом случае никогда не используется сама по себе.\nВ следующем примере показан такой дочерний компонент:\n	<bean id=\"myService\" parent=\"txProxyTemplate\">\n		<property name=\"target\">\n			<bean class=\"org.springframework.samples.MyServiceImpl\">\n			</bean>\n		</property>\n	</bean>\nКраткие определения прокси."}
{"id": 252, "text": "Вы можете переопределить свойства родительского шаблона.\nВ следующем примере мы переопределяем настройки распространения транзакций:\n	<bean id=\"mySpecialService\" parent=\"txProxyTemplate\">\n		<property name=\"target\">\n			<bean class=\"org.springframework.samples.MySpecialServiceImpl\">\n			</bean>\n		</property>\n		<property name=\"transactionAttributes\">\n			<props>\n				<prop key=\"get*\">PROPAGATION_REQUIRED,readOnly</prop>\n				<prop key=\"find*\">PROPAGATION_REQUIRED,readOnly</prop>\n				<prop key=\"load*\">PROPAGATION_REQUIRED,readOnly</prop>\n				<prop key=\"store*\">PROPAGATION_REQUIRED</prop>\n			</props>\n		</property>\n	</bean>\nКраткие определения прокси.\nОбратите внимание, что в примере родительского компонента мы явно пометили определение родительского компонента как быть абстрактным, установив для атрибута `abstract` значение `true`, как описано создан экземпляр.\nКонтексты приложений (но не простые фабрики компонентов) по умолчанию предварительно создать экземпляр всех синглтонов.\nПоэтому важно (по крайней мере, для одноэлементных bean-компонентов) что если у вас есть определение (родительского) компонента, которое вы собираетесь использовать только в качестве шаблона, и это определение указывает класс, вы должны обязательно установить `abstract` атрибут `истина`."}
{"id": 253, "text": "В противном случае контекст приложения фактически пытается предварительно создайте его."}
{"id": 254, "text": "Конфигурация WebFlux.\nКонфигурация Java WebFlux объявляет компоненты, необходимые для обработки запросы с аннотированными контроллерами или функциональными конечными точками, а также предлагает API для настроить конфигурацию.\nЭто означает, что вам не нужно понимать суть bean-компоненты, созданные конфигурацией Java.\nОднако, если вы хотите их понять, вы можете увидеть их в `WebFluxConfigurationSupport` или узнать больше о том, что они собой представляют. в Специальные типы компонентов.\nКонфигурация WebFlux.\nДля более сложных настроек, недоступных в API конфигурации, вы можете получить полный контроль над конфигурацией через\nВключение конфигурации WebFlux.\nВы можете использовать аннотацию @EnableWebFlux в своей конфигурации Java, как показано в следующем примере:\nJava\n	@Configuration\n	@EnableWebFlux\n	public class WebConfig {\n	@Configuration\n	@EnableWebFlux\n	class WebConfig\nВключение конфигурации WebFlux.\nПРИМЕЧАНИЕ.\nПри использовании Spring Boot вы можете использовать классы @Configuration типа WebFluxConfigurer, но без `@EnableWebFlux` для сохранения настроек Spring Boot WebFlux.\nПодробности смотрите в {spring-boot-docs-ref}/web/reactive.html#web.reactive.webflux.auto-configuration [специальная документация по Spring Boot].\nВключение конфигурации WebFlux.\nВ предыдущем примере регистрируется несколько Spring WebFlux. доступен в пути к классам — для JSON, XML и других.\nAPI конфигурации WebFlux.\nВ вашей конфигурации Java вы можете реализовать интерфейс WebFluxConfigurer, как показано в следующем примере:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {"}
{"id": 255, "text": "// Реализация методов настройки...\n	// Реализация методов настройки...\nКонвертация, форматирование.\nПо умолчанию установлены средства форматирования для различных типов чисел и дат, а также поддержка для настройки через `@NumberFormat`, `@DurationFormat` и `@DateTimeFormat` в полях и параметры.\nКонвертация, форматирование.\nЧтобы зарегистрировать пользовательские форматировщики и конвертеры в конфигурации Java, используйте следующее:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void addFormatters(FormatterRegistry registry) {\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nКонвертация, форматирование.\nПо умолчанию Spring WebFlux учитывает запрос Locale при анализе и форматировании даты. ценности.\nЭто работает для форм, где даты представлены как строки с формой «входа». поля.\nОднако для полей формы «дата» и «время» браузеры используют фиксированный формат, определенный в спецификации HTML.\nВ таких случаях форматирование даты и времени можно настроить следующим образом:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void addFormatters(FormatterRegistry registry) {\n			DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();\n			registrar.setUseIsoFormat(true);\n			registrar.registerFormatters(registry);\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nКонвертация, форматирование.\nПРИМЕЧАНИЕ.\nСм. `FormatterRegistrar` SPI и FormattingConversionServiceFactoryBean для получения дополнительной информации о том, когда используйте реализации FormatterRegistrar.\nВалидация."}
{"id": 256, "text": "По умолчанию, если присутствует Bean Validation в пути к классам (например, Hibernate Validator), `LocalValidatorFactoryBean` зарегистрирован как глобальная ссылка:core/validation/validator.adoc[validator] для использования с `@Valid` и `@Validated` для аргументов метода `@Controller`.\nВалидация.\nВ вашей конфигурации Java вы можете настроить глобальный экземпляр Validator, как показано в следующем примере:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public Validator getValidator() {\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nВалидация.\nОбратите внимание, что вы также можете зарегистрировать реализации `Validator` локально, как показано в следующем примере:\nJava\n	@Controller\n	public class MyController {\n		@InitBinder\n		protected void initBinder(WebDataBinder binder) {\n			binder.addValidators(new FooValidator());\n	@Controller\n	class MyController {\nВалидация.\nСОВЕТ: Если вам нужно где-то внедрить LocalValidatorFactoryBean, создайте bean-компонент и отметьте его `@Primary`, чтобы избежать конфликта с объявленным в конфигурации MVC.\nРезолверы типов контента.\nВы можете настроить, как Spring WebFlux определяет запрошенные типы мультимедиа для Экземпляры `@Controller` из запроса.\nПо умолчанию проверяется только заголовок Accept. но вы также можете включить стратегию на основе параметров запроса.\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nКодеки HTTP-сообщений."}
{"id": 257, "text": "В следующем примере показано, как настроить способ чтения и записи тела запроса и ответа:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n			configurer.defaultCodecs().maxInMemorySize(512 * 1024);\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nКодеки HTTP-сообщений. `ServerCodecConfigurer` предоставляет набор средств чтения и записи по умолчанию.\nВы можете использовать его, чтобы добавить больше читателей и писателей, настройте те, которые используются по умолчанию, или полностью замените те, которые используются по умолчанию.\nКодеки HTTP-сообщений.\nДля Джексона рассмотрите возможность использования построителя формата Джексона, например JsonMapper.Builder, для настройки параметров Джексона по умолчанию. свойства.\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureViewResolvers(ViewResolverRegistry registry) {\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nВ следующем примере показано, как настроить разрешение просмотра:.\nViewResolverRegistry содержит ярлыки для технологий просмотра, с помощью которых Spring Framework интегрируется.\nВ следующем примере используется FreeMarker (который также требует настройки базовая технология просмотра FreeMarker):\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureViewResolvers(ViewResolverRegistry registry) {\n			registry.freeMarker();\n		// Настроить Freemarker...\n		@Bean\n		public FreeMarkerConfigurer freeMarkerConfigurer() {\n			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n			configurer.setTemplateLoaderPath(\"classpath:/templates\");\n			return configurer;"}
{"id": 258, "text": "@Configuration\n	class WebConfig : WebFluxConfigurer {\n		// Настроить Freemarker...\nВ следующем примере показано, как настроить разрешение просмотра:.\nВы также можете подключить любую реализацию ViewResolver, как показано в следующем примере:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureViewResolvers(ViewResolverRegistry registry) {\n			ViewResolver resolver = ... ;\n			registry.viewResolver(resolver);\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nВ следующем примере показано, как настроить разрешение просмотра:.\nДля поддержки согласование контента и рендеринга других форматов. посредством разрешения представления (кроме HTML) вы можете настроить одно или несколько представлений по умолчанию на основе в реализации HttpMessageWriterView, которая принимает любой из доступных\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureViewResolvers(ViewResolverRegistry registry) {\n			registry.freeMarker();\n			JacksonJsonEncoder encoder = new JacksonJsonEncoder();\n			registry.defaultViews(new HttpMessageWriterView(encoder));\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nВ следующем примере показано, как настроить разрешение просмотра:.\nСм.\nТехнологии просмотра для получения дополнительной информации о технологиях представления, интегрированных с Spring WebFlux.\nСтатические ресурсы.\nЭта опция обеспечивает удобный способ обслуживания статических ресурсов из списка Местоположение на основе {spring-framework-api}/core/io/Resource.html[`Resource`].\nСтатические ресурсы."}
{"id": 259, "text": "В следующем примере для запроса, начинающегося с `/resources`, относительный путь будет равен используется для поиска и обслуживания статических ресурсов относительно `/static` в пути к классам.\nРесурсы обслуживаются со сроком действия в один год, чтобы обеспечить максимальное использование кэша браузера. и сокращение количества HTTP-запросов, выполняемых браузером.\nЗаголовок Last-Modified также оценивается, и, если он присутствует, возвращается код состояния «304».\nСледующий список показывает пример:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void addResourceHandlers(ResourceHandlerRegistry registry) {\n			registry.addResourceHandler(\"/resources/**\")\n					.addResourceLocations(\"/public\", \"classpath:/static/\")\n					.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nСтатические ресурсы.\nСм. также поддержка HTTP-кэширования для статических ресурсов.\nСтатические ресурсы.\nОбработчик ресурсов также поддерживает цепочку реализации {spring-framework-api}/web/reactive/resource/ResourceResolver.html[`ResourceResolver`] и реализации {spring-framework-api}/web/reactive/resource/ResourceTransformer.html[`ResourceTransformer`], который можно использовать для создания набора инструментов для работы с оптимизированными ресурсами.\nСтатические ресурсы."}
{"id": 260, "text": "Вы можете использовать VersionResourceResolver для URL-адресов ресурсов с поддержкой версий на основе хеша MD5. вычисляется на основе контента, фиксированной версии приложения или другой информации.\nА «ContentVersionStrategy» (хэш MD5) — хороший выбор, за некоторыми заметными исключениями (например, Ресурсы JavaScript, используемые с загрузчиком модулей).\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void addResourceHandlers(ResourceHandlerRegistry registry) {\n			registry.addResourceHandler(\"/resources/**\")\n					.addResourceLocations(\"/public/\")\n					.resourceChain(true)\n					.addResolver(new VersionResourceResolver().addContentVersionStrategy(\"/**\"));\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nВ следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.\nВы можете использовать ResourceUrlProvider для перезаписи URL-адресов и применения полной цепочки преобразователей и трансформеры (например, для вставки версий).\nКонфигурация WebFlux предоставляет ResourceUrlProvider. чтобы его можно было вводить другим.\nВ следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.\nВ отличие от Spring MVC, на данный момент в WebFlux нет возможности прозрачно перезаписывать статические URL-адреса ресурсов, поскольку не существует технологий просмотра, которые могли бы использовать неблокирующую цепочку. резольверов и трансформаторов.\nПри обслуживании только локальных ресурсов обходным путем является использование `ResourceUrlProvider` напрямую (например, через пользовательский элемент) и заблокировать."}
{"id": 261, "text": "В следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.\nОбратите внимание, что при использовании как EncodedResourceResolver (например, Gzip, в кодировке Brotli), так и `VersionedResourceResolver`, они должны быть зарегистрированы именно в этом порядке, чтобы обеспечить версии всегда надежно вычисляются на основе незакодированного файла.\nВ следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.\nДля https://www.webjars.org/documentation[WebJars] URL-адреса с версиями, например `/webjars/jquery/1.2.0/jquery.min.js` — рекомендуемый и наиболее эффективный способ их использования.\nМестоположение связанного ресурса настраивается «из коробки» с помощью Spring Boot (или может быть настроено вручную через `ResourceHandlerRegistry`) и не требует добавления Зависимость `org.webjars:webjars-locator-lite`.\nВ следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.\nURL-адреса без версий, такие как `/webjars/jquery/jquery.min.js`, поддерживаются через `WebJarsResourceResolver`, который автоматически регистрируется при Библиотека `org.webjars:webjars-locator-lite` присутствует в пути к классам."}
{"id": 262, "text": "Резолвер может перезаписать URL-адреса, включающие версию jar, а также могут сопоставляться с входящими URL-адресами без версий. -- например, с `/webjars/jquery/jquery.min.js` на `/webjars/jquery/1.2.0/jquery.min.js`.\nВ следующем примере показано, как использовать VersionResourceResolver в конфигурации Java:.\nСОВЕТ: Конфигурация Java, основанная на ResourceHandlerRegistry, предоставляет дополнительные возможности. для детального контроля, например, поведения последнего изменения и оптимизированного разрешения ресурсов.\nСопоставление путей.\nВы можете настроить параметры, связанные с сопоставлением путей.\nПодробную информацию об отдельных опциях см. {spring-framework-api}/web/reactive/config/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.\nВ следующем примере показано, как использовать PathMatchConfigurer:\nвключаемый код::./WebConfig[]. [СОВЕТ] = Spring WebFlux полагается на проанализированное представление пути запроса, называемое `RequestPath` для доступа к декодированным значениям сегмента пути, с удаленным содержимым точки с запятой. (то есть переменные пути или матрицы).\nЭто означает, что в отличие от Spring MVC вам не нужно указывать декодировать ли путь запроса или удалять содержимое точки с запятой для цели сопоставления путей.\nвключаемый код::./WebConfig[]."}
{"id": 263, "text": "Spring WebFlux также не поддерживает сопоставление шаблонов суффиксов, в отличие от Spring MVC, где мы также отходят от полагаться на это.\nВерсия API.\nЧтобы включить управление версиями API, используйте обратный вызов ApiVersionConfigurer для WebFluxConfigurer:\nJava\n	@Configuration\n	public class WebConfiguration implements WebFluxConfigurer {\n		@Override\n		public void configureApiVersioning(ApiVersionConfigurer configurer) {\n			configurer.useRequestHeader(\"API-Version\");\n	@Configuration\n	class WebConfiguration : WebFluxConfigurer {\nВерсия API.\nВы можете решить версию с помощью одной из встроенных опций, перечисленных ниже, или в качестве альтернативы используйте собственный ApiVersionResolver:\n- Заголовок запроса\n- Параметр запроса\n- Сегмент пути\n- Параметр типа носителя\nВерсия API.\nДля разрешения из сегмента пути необходимо указать индекс ожидаемого сегмента пути. чтобы содержать версию.\nСегмент пути должен быть объявлен как переменная URI, например. «/\\{версия}», «/api/\\{версия}» и т. д., где фактическое имя не имеет значения.\nПоскольку версия обычно находится в начале пути, рассмотрите возможность ее внешней настройки. как общий префикс пути для всех обработчиков через\nВерсия API.\nПо умолчанию версия анализируется с помощью SemanticVersionParser, но вы также можете настроить пользовательская ссылка:web/webflux-versioning.adoc#webflux-versioning-parser[ApiVersionParser].\nВерсия API."}
{"id": 264, "text": "Поддерживаемые версии прозрачно определяются из версий, объявленных в сопоставлениях запросов. для удобства, но вы можете отключить это с помощью флага в конфигурации WebFlux и считайте поддерживаемыми только версии, явно настроенные в конфигурации.\nЗапросы с неподдерживаемой версией отклоняются с помощью `InvalidApiVersionException` приводит к ответу 400.\nВерсия API.\nВы можете установить ApiVersionDeprecationHandler для отправки информации об устаревших версии для клиентов.\nВстроенный стандартный обработчик может установить «Устаревание», «Закат» и Заголовки «Ссылки» на основе https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].\nВерсия API.\nПосле настройки управления версиями API вы можете начать сопоставлять запросы с согласно версии запроса.\nБлокировка выполнения.\nКонфигурация Java WebFlux позволяет вам настроить выполнение блокировки в WebFlux.\nБлокировка выполнения.\nВы можете вызвать методы контроллера блокировки в отдельном потоке, предоставив `AsyncTaskExecutor`, такой как {spring-framework-api}/core/task/VirtualThreadTaskExecutor.html[`VirtualThreadTaskExecutor`] следующим образом:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n			AsyncTaskExecutor executor = ...\n			configurer.setExecutor(executor);\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nБлокировка выполнения."}
{"id": 265, "text": "По умолчанию методы контроллера, тип возвращаемого значения которых не распознается настроенным `ReactiveAdapterRegistry` считается блокирующим, но вы можете установить собственный контроллер. предикат метода через BlockingExecutionConfigurer.\nВебсокетсервис.\nКонфигурация Java WebFlux объявляет bean-компонент WebSocketHandlerAdapter, который обеспечивает поддержка вызова обработчиков WebSocket.\nЭто означает, что все, что осталось сделать в Чтобы обработать запрос на рукопожатие WebSocket, необходимо сопоставить `WebSocketHandler` с URL-адресом. через SimpleUrlHandlerMapping.\nВебсокетсервис.\nВ некоторых случаях может потребоваться создать bean-компонент WebSocketHandlerAdapter с предоставил службу WebSocketService, которая позволяет настраивать свойства сервера WebSocket.\nНапример:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public WebSocketService getWebSocketService() {\n			TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();\n			strategy.setMaxSessionIdleTimeout(0L);\n			return new HandshakeWebSocketService(strategy);\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\n* Предоставляет конфигурацию Spring по умолчанию для приложений WebFlux.\n* обнаруживает и делегирует реализации `WebFluxConfigurer` для настройки этой конфигурации.\n`@EnableWebFlux` импортирует `DelegatingWebFluxConfiguration`, который:.\nВ расширенном режиме вы можете удалить `@EnableWebFlux` и расширить его непосредственно из `ДелегированиеWebFluxConfiguration` вместо реализации `WebFluxConfigurer`, как показано в следующем примере:\nJava\n	@Configuration\n	public class WebConfig extends DelegatingWebFluxConfiguration {\n	@Configuration\n	class WebConfig : DelegatingWebFluxConfiguration {\n`@EnableWebFlux` импортирует `DelegatingWebFluxConfiguration`, который:."}
{"id": 266, "text": "Вы можете сохранить существующие методы в `WebConfig`, но теперь вы также можете переопределить объявления компонентов. из базового класса и по-прежнему иметь любое количество других реализаций `WebMvcConfigurer` путь к классам."}
{"id": 267, "text": "Использование аннотации `@Configuration`. `@Configuration` — это аннотация уровня класса, указывающая, что объект является источником определения бобов.\nКлассы `@Configuration` объявляют bean-компоненты через `@Bean`-аннотацию. методы.\nВызовы методов `@Bean` в классах `@Configuration` также могут использоваться для определения межкомпонентные зависимости.\nСм. для общего ознакомления.\nВнедрение межкомпонентных зависимостей.\nКогда компоненты имеют зависимости друг от друга, выразить эту зависимость очень просто. как если бы один метод компонента вызывал другой, как показано в следующем примере:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public BeanOne beanOne() {\n			return new BeanOne(beanTwo());\n		@Bean\n		public BeanTwo beanTwo() {\n			return new BeanTwo();\n	@Configuration\n	class AppConfig {\nВнедрение межкомпонентных зависимостей.\nВ предыдущем примере beanOne получает ссылку на beanTwo через конструктор. инъекция.\nВнедрение межкомпонентных зависимостей.\nПРИМЕЧАНИЕ.\nЭтот метод объявления зависимостей между компонентами работает только в том случае, если используется метод `@Bean`. объявляется внутри класса @Configuration.\nВы не можете объявлять зависимости между компонентами используя простые классы `@Component`.\nВнедрение метода поиска.\nКак отмечалось ранее, внедрение метода поиска представляет собой расширенная функция, которую следует использовать редко.\nЭто полезно в тех случаях, когда Компонент с областью действия Singleton зависит от компонента с областью действия прототипа."}
{"id": 268, "text": "Использование Java для этого Тип конфигурации предоставляет естественные средства для реализации этого шаблона.\nВ следующем примере показано, как использовать внедрение метода поиска:\nJava\n	public abstract class CommandManager {\n		public Object process(Object commandState) {\n			// возьмите новый экземпляр соответствующего командного интерфейса\n			Command command = createCommand();\n			// установить состояние экземпляра команды (надеюсь, нового)\n			command.setState(commandState);\n			return command.execute();\n		// окей... но где реализация этого метода?\n		protected abstract Command createCommand();\nВнедрение метода поиска.\nИспользуя конфигурацию Java, вы можете создать подкласс CommandManager, в котором абстрактный метод createCommand() переопределяется таким образом, что он ищет новый (прототип) командный объект.\nВ следующем примере показано, как это сделать:\nJava\n	@Bean\n	@Scope(\"prototype\")\n	public AsyncCommand asyncCommand() {\n		AsyncCommand command = new AsyncCommand();\n		// добавьте сюда зависимости по мере необходимости\n		return command;\n	@Bean\n	public CommandManager commandManager() {\n		// вернуть новую анонимную реализацию CommandManager с помощью createCommand()\n		// переопределено для возврата нового прототипа командного объекта\n		return new CommandManager() {\n			protected Command createCommand() {\n				return asyncCommand();\nДополнительная информация о внутренней работе конфигурации на основе Java.\nРассмотрим следующий пример, который показывает, что аннотированный метод @Bean вызывается дважды:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean"}
{"id": 269, "text": "public ClientService clientService1() {\n			ClientServiceImpl clientService = new ClientServiceImpl();\n			clientService.setClientDao(clientDao());\n			return clientService;\n		@Bean\n		public ClientService clientService2() {\n			ClientServiceImpl clientService = new ClientServiceImpl();\n			clientService.setClientDao(clientDao());\n			return clientService;\n		@Bean\n		public ClientDao clientDao() {\n			return new ClientDaoImpl();\n	@Configuration\n	class AppConfig {\nДополнительная информация о внутренней работе конфигурации на основе Java. `clientDao()` был вызван один раз в `clientService1()` и один раз в `clientService2()`.\nПоскольку этот метод создает новый экземпляр ClientDaoImpl и возвращает его, вам следует обычно ожидается наличие двух экземпляров (по одному для каждой службы).\nЭто определенно было бы Проблема: в Spring экземпляры bean-компонентов по умолчанию имеют область действия «singleton».\nЭто вот тут и начинается волшебство: все классы `@Configuration` подразделяются на подклассы во время запуска. с `CGLIB`.\nВ подклассе дочерний метод сначала проверяет контейнер на наличие кэшированные (с ограниченной областью действия) bean-компоненты перед тем, как они вызовут родительский метод и создадут новый экземпляр.\nДополнительная информация о внутренней работе конфигурации на основе Java.\nПРИМЕЧАНИЕ.\nПоведение может различаться в зависимости от области действия вашего компонента.\nМы говорим про синглтоны здесь."}
{"id": 270, "text": "Дополнительная информация о внутренней работе конфигурации на основе Java. [ПРИМЕЧАНИЕ] = Нет необходимости добавлять CGLIB в ваш путь к классам, поскольку классы CGLIB переупакованы. в пакете `org.springframework.cglib` и включен непосредственно в пакет `spring-core` JAR.\nДополнительная информация о внутренней работе конфигурации на основе Java. [СОВЕТ] = Есть несколько ограничений, поскольку CGLIB динамически добавляет функции время запуска.\nВ частности, классы конфигурации не должны быть окончательными.\nОднако любой конструкторы разрешены в классах конфигурации, включая использование `@Autowired` или единственное объявление конструктора, отличное от стандартного, для внедрения по умолчанию.\nДополнительная информация о внутренней работе конфигурации на основе Java.\nЕсли вы предпочитаете избегать каких-либо ограничений, налагаемых CGLIB, рассмотрите возможность объявления вашего `@Bean` методы для классов, отличных от `@Configuration` (например, для простых классов `@Component` вместо этого) или аннотируя свой класс конфигурации с помощью `@Configuration(proxyBeanMethods = false)`.\nМежметодные вызовы между методами `@Bean` затем не перехватываются, поэтому вам придется полагаться исключительно на внедрение зависимостей на этапе там уровень конструктора или метода."}
{"id": 271, "text": "1. Введение. `configuration` предоставляет единый конфигурационный слой: YAML-файлы, аннотации и переменные окружения с поддержкой профилей и валидации значений на старте.\n- централизует настройки приложения;\n- минимизирует runtime-ошибки через раннюю валидацию;\n- упрощает перенос между окружениями (`dev`, `stage`, `prod`).\n```xml\n```java\n    @Required\n    private String url;\n    @Required\n    private String username;\n    private String password;\n    private int poolSize = 16;\n    public String getUrl() { return url; }\n    public String getUsername() { return username; }\n    public String getPassword() { return password; }\n    public int getPoolSize() { return poolSize; }\n```java\n    private final DatasourceConfig config;\n    public ReportRepository(DatasourceConfig config) {\n        this.config = config;\n    public String connectionInfo() {\n        // Никогда не логируйте пароль.\n        return config.getUrl() + \"|\" + config.getUsername();\n```yaml\n    url: jdbc:postgresql://db:5432/reports\n    username: report_user\n    password: ${DB_PASSWORD}\n    pool-size: 24\n    profile: prod\n    strict-binding: true\n    fail-on-unknown-keys: true\n- `DB_PASSWORD` -> `lilipup.datasource.password`\n- `LILIPUP_DATASOURCE_POOL_SIZE` -> `lilipup.datasource.pool-size`"}
{"id": 272, "text": "- Всегда помечайте критичные поля аннотацией `@Required`.\n- Всегда включайте `fail-on-unknown-keys=true` в production, чтобы ловить опечатки в YAML.\n- Проверяйте наличие всех секретов в окружении до старта (пароли, токены, ключи).\n- Не храните реальные секреты в репозитории; используйте env/secret-manager.\n- Убедитесь, что `strict-binding=true`, если конфиг используется для безопасности и доступа к данным.\n- `ConfigBindingException`: не удалось привести строку к целевому типу.\n- `MissingRequiredPropertyException`: отсутствует обязательное поле.\n- `UnknownPropertyException`: в YAML найден неизвестный ключ при strict режиме.\n```java\n    private final ConfigResolver resolver;\n    public TimeoutProvider(ConfigResolver resolver) {\n        this.resolver = resolver;\n    public int requestTimeoutMs() {\n        // Fallback не должен маскировать критичную misconfiguration.\n        return resolver.getInt(\"lilipup.http.request-timeout-ms\").orElse(3000);\n- Храните профильные конфиги в `application-<profile>.yaml`.\n- Используйте объектные конфиги (`@ConfigProperties`) вместо хаотичного чтения строковых ключей.\n- Разделяйте «бизнес-конфиги» и «инфраструктурные конфиги» по префиксам.\n- Делайте fail-fast на этапе bootstrap, а не в runtime-запросах."}
{"id": 273, "text": "- Добавляйте smoke-test, который поднимает контекст со всеми production-ключами."}
{"id": 274, "text": "* Использование `DataSource`\n* Использование `DataSourceUtils`\n* Реализация `SmartDataSource`\n* Расширение `AbstractDataSource`\n* Использование `SingleConnectionDataSource`\n* Использование `DriverManagerDataSource`\n* Использование `TransactionAwareDataSourceProxy`\n* Использование `DataSourceTransactionManager`/`JdbcTransactionManager`\nИспользование источника данных.\nSpring получает соединение с базой данных через DataSource. «Источник данных» — это часть спецификации JDBC и является фабрикой обобщенных соединений.\nЭто позволяет контейнер или фреймворк скрывают проблемы пула соединений и управления транзакциями из кода приложения.\nКак разработчику, вам не обязательно знать подробности о том, как подключиться к базе данных.\nЭто обязанность администратора, который настраивает источник данных.\nСкорее всего, вы выполняете обе роли при разработке и тестировании кода, но вы не обязательно знать, как настроен источник производственных данных.\nИспользование источника данных.\nКогда вы используете уровень JDBC Spring, вы можете получить источник данных из JNDI или настройте свою собственную реализацию пула соединений, предоставленную третьей стороной.\nТрадиционным выбором являются Apache Commons DBCP и C3P0 с классами DataSource в стиле bean-компонентов; для современного пула соединений JDBC вместо этого рассмотрите HikariCP с его API в стиле компоновщика.\nИспользование источника данных.\nПРИМЕЧАНИЕ.\nВам следует использовать классы DriverManagerDataSource и SimpleDriverDataSource. (как включено в дистрибутив Spring) только в целях тестирования!\nЭти варианты не обеспечивают объединение в пул и снижают производительность при выполнении нескольких запросов на соединение.\nИспользование источника данных.\nВ следующем разделе используется реализация Spring DriverManagerDataSource."}
{"id": 275, "text": "Несколько других вариантов DataSource будут рассмотрены позже.\nЧтобы настроить DriverManagerDataSource:. .\nПолучите соединение с DriverManagerDataSource, как вы обычно получаете JDBC. соединение..\nУкажите полное имя класса драйвера JDBC, чтобы `DriverManager` может загрузить класс драйвера..\nУкажите URL-адрес, который зависит от драйверов JDBC. (См. документацию к вашему драйверу для правильного значения.).\nУкажите имя пользователя и пароль для подключения к базе данных.\nЧтобы настроить DriverManagerDataSource:.\nВ следующем примере показано, как настроить DriverManagerDataSource: См. пример кода в исходном документе.\nЧтобы настроить DriverManagerDataSource:.\nСледующие два примера показывают базовое подключение и настройку для DBCP и C3P0.\nЧтобы узнать о дополнительных параметрах, помогающих управлять функциями объединения, см. продукт документация для соответствующих реализаций пула соединений.\nЧтобы настроить DriverManagerDataSource:.\nВ следующем примере показана конфигурация DBCP: См. пример кода в исходном документе.\nЧтобы настроить DriverManagerDataSource:.\nВ следующем примере показана конфигурация C3P0: См. пример кода в исходном документе.\nИспользование DataSourceUtils.\nКласс DataSourceUtils — это удобный и мощный вспомогательный класс, который предоставляет `статические` методы для получения соединений из JNDI и закрытия соединений при необходимости.\nОн поддерживает связанное с потоком соединение JDBC с DataSourceTransactionManager, но также с JtaTransactionManager и JpaTransactionManager.\nИспользование DataSourceUtils.\nОбратите внимание, что JdbcTemplate подразумевает доступ к соединению DataSourceUtils, используя его. за каждой операцией JDBC, неявно участвуя в текущей транзакции.\nРеализация SmartDataSource."}
{"id": 276, "text": "Интерфейс SmartDataSource должен быть реализован классами, которые могут предоставить подключение к реляционной базе данных.\nОн расширяет интерфейс DataSource, позволяя классы, которые его используют, запрашивают, следует ли закрывать соединение после заданного операция.\nТакое использование эффективно, если вы знаете, что вам нужно повторно использовать соединение.\nРасширение «AbstractDataSource». «AbstractDataSource» — это «абстрактный» базовый класс для Spring «DataSource». реализации.\nОн реализует код, общий для всех реализаций DataSource.\nВам следует расширить класс AbstractDataSource, если вы пишете свой собственный DataSource. реализация.\nИспользование SingleConnectionDataSource.\nКласс SingleConnectionDataSource является реализацией SmartDataSource. интерфейс, который окружает одно соединение, которое не закрывается после каждого использования.\nЭто не поддерживает многопоточность.\nИспользование SingleConnectionDataSource.\nЕсли какой-либо клиентский код вызывает метод close, предполагая соединение из пула (как при использовании инструменты сохранения), вам следует установить для свойства `suppressClose` значение `true`.\nЭта настройка возвращает прокси-сервер с подавлением закрытия, который оборачивает физическое соединение.\nОбратите внимание, что вы можете больше не привязывайте это к собственному Oracle Connection или аналогичному объекту.\nИспользование SingleConnectionDataSource.\nSingleConnectionDataSource — это прежде всего тестовый класс.\nОбычно это позволяет легко тестировать кода вне сервера приложений в сочетании с простой средой JNDI.\nВ отличие от DriverManagerDataSource, он постоянно использует одно и то же соединение. избегая чрезмерного создания физических соединений.\nИспользование DriverManagerDataSource."}
{"id": 277, "text": "Класс DriverManagerDataSource является реализацией стандартного DataSource. интерфейс, который настраивает простой драйвер JDBC через свойства компонента и возвращает новый «Соединение» каждый раз.\nИспользование DriverManagerDataSource.\nЭта реализация полезна для тестовых и автономных сред за пределами Jakarta EE. контейнер, либо как bean-компонент DataSource в контейнере Spring IoC, либо совместно с простой средой JNDI.\nВызовы `Connection.close()` с учетом пула закройте соединение, чтобы любой код сохранения, поддерживающий `DataSource`, должен работать.\nОднако, использовать пулы соединений в стиле JavaBean (например, commons-dbcp) очень просто, даже в тесте среды, что почти всегда предпочтительнее использовать такой пул соединений, а не `DriverManagerDataSource`.\nИспользование TransactionAwareDataSourceProxy.\nTransactionAwareDataSourceProxy — это прокси для целевого DataSource.\nПрокси оборачивает это выберите DataSource, чтобы добавить информацию о транзакциях, управляемых Spring.\nВ этом отношении это аналогичен транзакционному JNDI DataSource, предоставляемому сервером Jakarta EE.\nИспользование TransactionAwareDataSourceProxy.\nПРИМЕЧАНИЕ.\nИспользовать этот класс желательно редко, за исключением случаев, когда необходимо обновить уже существующий код. вызывается и передается стандартная реализация интерфейса JDBC DataSource.\nВ этом случае вы все еще можете использовать этот код и в то же время иметь этот код участие в управляемых Spring транзакциях.\nОбычно предпочтительнее написать свой собственный новый код, используя абстракции более высокого уровня для управления ресурсами, такие как `JdbcTemplate` или `DataSourceUtils`.\nИспользование TransactionAwareDataSourceProxy."}
{"id": 278, "text": "См. {spring-framework-api}/jdbc/datasource/TransactionAwareDataSourceProxy.html[`TransactionAwareDataSourceProxy`] javadoc для более подробной информации.\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nКласс DataSourceTransactionManager является классом PlatformTransactionManager. реализация для одного JDBC DataSource.\nОн связывает JDBC `Connection` из указанного `DataSource` в текущий выполняющийся поток, потенциально позволяя использовать одно связанное с потоком `Соединение` для каждого `DataSource`.\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nКод приложения необходим для получения соединения JDBC через `DataSourceUtils.getConnection(DataSource)` вместо стандарта Java EE `DataSource.getConnection`.\nОн выдает непроверенные исключения `org.springframework.dao`. вместо проверенных `SQLExceptions`.\nВсе классы фреймворка (например, JdbcTemplate) используют эта стратегия неявно.\nЕсли не используется с менеджером транзакций, стратегия поиска ведет себя точно так же, как DataSource.getConnection, и поэтому может использоваться в любом случае.\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nКласс DataSourceTransactionManager поддерживает точки сохранения (PROPAGATION_NESTED), пользовательские уровни изоляции и тайм-ауты, которые применяются в соответствии с соответствующим оператором JDBC. таймауты запросов.\nДля поддержки последнего код приложения должен либо использовать JdbcTemplate, либо вызовите метод DataSourceUtils.applyTransactionTimeout(..) для каждого созданного оператора.\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nВы можете использовать DataSourceTransactionManager вместо JtaTransactionManager в случай с одним ресурсом, поскольку он не требует, чтобы контейнер поддерживал транзакцию JTA координатор."}
{"id": 279, "text": "Переключение между этими менеджерами транзакций — это всего лишь вопрос конфигурации. при условии, что вы придерживаетесь требуемого шаблона поиска соединений.\nОбратите внимание, что JTA не поддерживает точки сохранения или пользовательские уровни изоляции и имеет другой механизм тайм-аута, но в остальном демонстрирует аналогичное поведение с точки зрения ресурсов JDBC и управления фиксацией/откатом JDBC.\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nДля отложенного получения фактических подключений к ресурсам в стиле JTA Spring предоставляет соответствующий прокси-класс `DataSource` для целевого пула соединений: см. {spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].\nЭто особенно полезно для потенциально пустых транзакций без фактического оператора. выполнение (никогда не получая реальный ресурс в таком сценарии), а также перед маршрутный `DataSource`, что означает использование синхронизированного с транзакцией флага только для чтения и/или уровень изоляции (например, IsolationLevelDataSourceRouter).\nИспользование DataSourceTransactionManager/JdbcTransactionManager. `LazyConnectionDataSourceProxy` также обеспечивает специальную поддержку соединения только для чтения. пул для использования во время транзакции только для чтения, избегая накладных расходов на переключение JDBC.\nФлаг соединения, доступный только для чтения, в начале и конце каждой транзакции при выборке. его из основного пула соединений (что может быть дорогостоящим в зависимости от драйвера JDBC).\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nПРИМЕЧАНИЕ."}
{"id": 280, "text": "Начиная с версии 5.3, Spring предоставляет расширенный вариант JdbcTransactionManager, который добавляет возможности трансляции исключений при фиксации/откате (в соответствии с `JdbcTemplate`).\nГде DataSourceTransactionManager всегда выдает только TransactionSystemException. (аналог JTA), `JdbcTransactionManager` преобразует ошибки блокировки базы данных и т. д. в соответствующие подклассы DataAccessException.\nОбратите внимание, что код приложения должен быть подготовлен к таким исключениям, а не исключительно к «TransactionSystemException».\nВ таких случаях рекомендуется использовать JdbcTransactionManager.\nИспользование DataSourceTransactionManager/JdbcTransactionManager.\nС точки зрения поведения исключений, JdbcTransactionManager примерно эквивалентен `JpaTransactionManager`, а также `R2dbcTransactionManager`, служащий непосредственным компаньон/замена друг друга.\nDataSourceTransactionManager, с другой стороны. эквивалентен `JtaTransactionManager` и может служить его прямой заменой."}
{"id": 281, "text": "Конструкторы.\nВы можете вызывать конструкторы, используя оператор new.\nВы должны использовать полностью квалифицированное имя класса для всех типов, кроме тех, которые находятся в пакете `java.lang` («Целое число», «С плавающей запятой», «Строка» и т. д.).\nКонструкторы.\nВ следующем примере показано, как использовать оператор new для вызова конструкторов.\nJava\n	Inventor einstein = parser.parseExpression(\n		\"new org.spring.samples.spel.inventor.Inventor('Альберт Эйнштейн', 'Немецкий')\"))\n			.getValue(Inventor.class);\n	// создать новый экземпляр Inventor в методе add() списка.\n	parser.parseExpression(\n		\"Members.add(new org.spring.samples.spel.inventor.Inventor('Альберт Эйнштейн', 'Немецкий'))\")\n			.getValue(societyContext);\n	// создать новый экземпляр Inventor в методе add() списка.\n	parser.parseExpression(\n		\"Members.add(new org.spring.samples.spel.inventor.Inventor('Альберт Эйнштейн', 'Немецкий'))\")\n			.getValue(societyContext)"}
{"id": 282, "text": "Типы контента.\nВы можете настроить, как Spring MVC определяет запрошенные типы мультимедиа из запроса. (например, заголовок Accept, расширение URL-адреса, параметр запроса и т. д.).\nТипы контента.\nПо умолчанию проверяется только заголовок Accept.\nТипы контента.\nЕсли вам необходимо использовать разрешение типа контента на основе URL-адреса, рассмотрите возможность использования параметра запроса стратегия по расширению пути.\nСм. и Соответствие суффикса и RFD для подробнее.\nТипы контента.\nВы можете настроить разрешение запрошенного типа контента, как показано в следующем примере: См. пример кода в исходном документе."}
{"id": 283, "text": "Дополнительные возможности ApplicationContext.\nКак обсуждалось в введение в главу, `org.springframework.beans.factory` пакет предоставляет базовую функциональность для управления и манипулирования bean-компонентами, в том числе в программный способ.\nПакет `org.springframework.context` добавляет {spring-framework-api}/context/ApplicationContext.html[`ApplicationContext`] интерфейс, который расширяет интерфейс BeanFactory в дополнение к расширению других интерфейсы для обеспечения дополнительных функций в большем количестве приложений фреймворк-ориентированный стиль.\nМногие люди используют `ApplicationContext` совершенно декларативную моду, даже не создавая ее программно, а опираясь на поддерживают такие классы, как «ContextLoader», для автоматического создания экземпляра `ApplicationContext` как часть обычного процесса запуска веб-приложения Jakarta EE.\nДополнительные возможности ApplicationContext.\nЧтобы улучшить функциональность BeanFactory в более ориентированном на инфраструктуру стиле, контекст пакет также предоставляет следующие функциональные возможности:\n* Доступ к сообщениям в стиле i18n, через интерфейс MessageSource.\n* Доступ к ресурсам, таким как URL-адреса и файлы, через интерфейс ResourceLoader.\n* Публикация событий, а именно для bean-компонентов, реализующих интерфейс ApplicationListener,\nДополнительные возможности ApplicationContext. с помощью интерфейса ApplicationEventPublisher.\n* Загрузка нескольких (иерархических) контекстов, позволяющая каждому сосредоточиться на одном\nДополнительные возможности ApplicationContext. конкретный уровень, например веб-уровень приложения, через Интерфейс HierarchicalBeanFactory.\nИнтернационализация с использованием MessageSource."}
{"id": 284, "text": "Интерфейс ApplicationContext расширяет интерфейс MessageSource и следовательно, обеспечивает функциональность интернационализации («i18n»).\nSpring также предоставляет Интерфейс HierarchicalMessageSource, который может разрешать сообщения иерархически.\nВместе эти интерфейсы обеспечивают основу, на которой Spring обрабатывает сообщения. разрешение.\nМетоды, определенные в этих интерфейсах, включают:\n* `String getMessage(String code, Object[] args, String default, Locale loc)`: базовый\nИнтернационализация с использованием MessageSource. метод, используемый для получения сообщения из MessageSource.\nКогда сообщение не найдено для указанной локали используется сообщение по умолчанию.\nЛюбые переданные аргументы становятся значения замены, используя функциональность MessageFormat, предоставляемую стандартом. библиотека.\n* `String getMessage(String code, Object[] args, Locale loc)`: по сути то же самое, что и\nИнтернационализация с использованием MessageSource. предыдущий метод, но с одним отличием: нельзя указать сообщение по умолчанию.\nЕсли сообщение не может быть найдено, выдается исключение NoSuchMessageException.\n* `String getMessage(MessageSourceResolvable разрешимый, языковой стандарт)`: Все свойства\nИнтернационализация с использованием MessageSource. используемые в предыдущих методах, также заключены в класс с именем `MessageSourceResolvable`, который вы можете использовать с этим методом.\nИнтернационализация с использованием MessageSource.\nКогда «ApplicationContext» загружается, он автоматически ищет «MessageSource». bean-компонент, определенный в контексте.\nКомпонент должен иметь имя messageSource.\nЕсли такой боб найден, все вызовы предыдущих методов делегируются источнику сообщения."}
{"id": 285, "text": "Если нет источник сообщения найден, ApplicationContext пытается найти родительский элемент, содержащий боб с таким же названием.\nЕсли да, то он использует этот компонент в качестве MessageSource.\nЕсли `ApplicationContext` не может найти источник сообщений, пустой `DelegatingMessageSource` создается для того, чтобы иметь возможность принимать вызовы к методы, определенные выше.\nИнтернационализация с использованием MessageSource.\nSpring предоставляет три реализации MessageSource: ResourceBundleMessageSource, ReloadableResourceBundleMessageSource. и «StaticMessageSource».\nВсе они реализуют HierarchicalMessageSource для выполнения вложенных обмен сообщениями. `StaticMessageSource` используется редко, но предоставляет программные способы добавлять сообщения в источник.\nВ следующем примере показан ResourceBundleMessageSource:\n	<beans>\n		<bean id=\"messageSource\"\n				class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n			<property name=\"basenames\">\n				<list>\n					<value>format</value>\n					<value>exceptions</value>\n					<value>windows</value>\n				</list>\n			</property>\n		</bean>\n	</beans>\nИнтернационализация с использованием MessageSource.\nВ примере предполагается, что у вас есть три пакета ресурсов, которые называются «формат», «исключения» и «окна». определенный в вашем пути к классам.\nЛюбой запрос на разрешение сообщения обрабатывается стандартным для JDK способом разрешения сообщений через объекты ResourceBundle.\nДля В целях примера предположим, что содержимое двух из приведенных выше файлов пакета ресурсов следующие:"}
{"id": 286, "text": "message=Alligators rock!\n	argument.required=The {0} argument is required.\nin exceptions.properties.\nВ следующем примере показана программа для запуска функции MessageSource.\nПомните, что все реализации ApplicationContext также являются MessageSource. реализации и поэтому могут быть преобразованы в интерфейс MessageSource.\nJava\n	public static void main(String[] args) {\n		MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\");\n		String message = resources.getMessage(\"message\", null, \"Default\", Locale.ENGLISH);\n		System.out.println(message);\n[literal,subs=\"дословно,цитаты\"].\nAlligators rock!\n[literal,subs=\"дословно,цитаты\"].\nПодводя итог, можно сказать, что MessageSource определен в файле beans.xml, который существует в корне вашего пути к классам.\nОпределение bean-компонента `messageSource` относится к количество пакетов ресурсов через свойство basenames.\nТри файла, которые переданные в списке свойству `basenames`, существуют как файлы в корне вашего путь к классам и называются «format.properties», «Exceptions.properties» и `windows.properties` соответственно.\n[literal,subs=\"дословно,цитаты\"].\nВ следующем примере показаны аргументы, передаваемые при поиске сообщений.\nЭти аргументы преобразуются в объекты String и вставляются в заполнители в поисковом сообщении.\n	<beans>"}
{"id": 287, "text": "<!-- this MessageSource is being used in a web application -->\n		<bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n			<property name=\"basename\" value=\"exceptions\"/>\n		</bean>\n		<!-- lets inject the above MessageSource into this POJO -->\n		<bean id=\"example\" class=\"com.something.Example\">\n			<property name=\"messages\" ref=\"messageSource\"/>\n		</bean>\n	</beans>\nJava\n	public class Example {\n		private MessageSource messages;\n		public void setMessages(MessageSource messages) {\n			this.messages = messages;\n		public void execute() {\n			String message = this.messages.getMessage(\"argument.required\",\n				new Object [] {\"userDao\"}, \"Required\", Locale.ENGLISH);\n			System.out.println(message);\n	class Example {\n[literal,subs=\"дословно,цитаты\"].\nАргумент userDao является обязательным.\n[literal,subs=\"дословно,цитаты\"].\nЧто касается интернационализации («i18n»), различные Spring MessageSource реализации следуют тем же правилам разрешения локали и резервного варианта, что и стандартный JDK. `РесурсБундл`."}
{"id": 288, "text": "Короче говоря, продолжая пример, определенный `messageSource` ранее, если вы хотите разрешить сообщения в соответствии с британской локалью (en-GB), вы создаст файлы с именами «format_en_GB.properties», «Exceptions_en_GB.properties» и `windows_en_GB.properties` соответственно.\n[literal,subs=\"дословно,цитаты\"].\nОбычно разрешение локали управляется окружающей средой приложение.\nВ следующем примере локаль, для которой (британские) сообщения разрешено указывается вручную:\nJava\n	public static void main(final String[] args) {\n		MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\");\n		String message = resources.getMessage(\"argument.required\",\n			new Object [] {\"userDao\"}, \"Required\", Locale.UK);\n		System.out.println(message);\n[literal,subs=\"дословно,цитаты\"].\nЭбагум парень, аргумент 'userDao' обязателен, я говорю, обязателен.\n[literal,subs=\"дословно,цитаты\"].\nВы также можете использовать интерфейс MessageSourceAware для получения ссылки на любой `MessageSource`, который был определен.\nЛюбой компонент, определенный в В `ApplicationContext`, реализующий интерфейс `MessageSourceAware`, вводится MessageSource контекста приложения при создании и настройке компонента.\n[literal,subs=\"дословно,цитаты\"].\nПРИМЕЧАНИЕ."}
{"id": 289, "text": "Поскольку MessageSource в Spring основан на ResourceBundle в Java, он не объединяет пакеты с тем же базовым именем, но будет использовать только первый найденный пакет.\nПоследующие пакеты сообщений с тем же базовым именем игнорируются.\n[literal,subs=\"дословно,цитаты\"].\nПРИМЕЧАНИЕ.\nВ качестве альтернативы ResourceBundleMessageSource Spring предоставляет Класс ReloadableResourceBundleMessageSource.\nЭтот вариант поддерживает тот же пакет формат файла, но он более гибок, чем стандартный формат на основе JDK.\nРеализация ResourceBundleMessageSource.\nВ частности, он позволяет читать файлы из любого местоположения ресурса Spring (не только из пути к классам) и поддерживает горячую перезагрузка файлов свойств пакета (при этом эффективно кэшируя их между собой).\nСм. {spring-framework-api}/context/support/ReloadableResourceBundleMessageSource.html[`ReloadableResourceBundleMessageSource`] javadoc для получения подробной информации.\nСтандартные и пользовательские события.\nОбработка событий в ApplicationContext обеспечивается через ApplicationEvent. класс и интерфейс ApplicationListener.\nЕсли компонент, реализующий Интерфейс ApplicationListener развертывается в контексте каждый раз, когда `ApplicationEvent` публикуется в `ApplicationContext`, о чем уведомляется этот компонент.\nПо сути, это стандартный шаблон проектирования Observer.\nСтандартные и пользовательские события.\nСОВЕТ: Начиная с Spring 4.2, инфраструктура мероприятий была значительно улучшена и предлагает\nСтандартные и пользовательские события. возможность публикации любого произвольного события (то есть объекта, который не обязательно расшириться из `ApplicationEvent`)."}
{"id": 290, "text": "Когда такой объект публикуется, мы оборачиваем его в событие для вас.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение. | `ContextRefreshedEvent` | Публикуется, когда `ApplicationContext` инициализируется или обновляется (например, используя метод Refresh() в интерфейсе ConfigurationApplicationContext).\nЗдесь «`initialized`» означает, что все bean-компоненты загружены, bean-компоненты постпроцессора обнаружены. и активированы, синглтоны создаются заранее, а объект ApplicationContext готов к использованию.\nПока контекст не закрыт, может быть запущено обновление. несколько раз, при условии, что выбранный `ApplicationContext` действительно поддерживает такое «горячее» освежает.\nНапример, XmlWebApplicationContext поддерживает горячее обновление, но GenericApplicationContext — нет.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение. | `ContextStartedEvent` | Публикуется, когда ApplicationContext запускается с помощью метода start() в Интерфейс `ConfigurableApplicationContext`.\nЗдесь «запущено» означает, что весь «жизненный цикл» bean-компоненты получают явный сигнал запуска.\nОбычно этот сигнал используется для перезапуска компонентов. после явной остановки, но его также можно использовать для запуска компонентов, которые не были настроен на автозапуск (например, компоненты, которые еще не запустились на инициализация)."}
{"id": 291, "text": ".Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение. | `ContextStoppedEvent` | Публикуется, когда `ApplicationContext` остановлен с помощью метода `stop()` в Интерфейс `ConfigurableApplicationContext`.\nЗдесь «остановлено» означает, что весь «жизненный цикл» bean-компоненты получают явный сигнал остановки.\nОстановленный контекст может быть перезапущен через вызов `start()`.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение. | `ContextClosedEvent` | Публикуется, когда ApplicationContext закрывается с помощью метода close(). через интерфейс «ConfigurableApplicationContext» или через перехватчик завершения работы JVM.\nЗдесь, «закрытый» означает, что все одноэлементные компоненты будут уничтожены.\nКак только контекст закрыт, срок его службы подходит к концу, и его невозможно обновить или перезапустить.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение. | `RequestHandledEvent` | Веб-событие, сообщающее всем компонентам о том, что HTTP-запрос был обслужен.\nЭто Событие публикуется после завершения запроса.\nЭто событие применимо только к веб-приложения, использующие Spring DispatcherServlet."}
{"id": 292, "text": ".Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение. | `ServletRequestHandledEvent` | Подкласс RequestHandledEvent, который добавляет контекстную информацию, специфичную для сервлета.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nВы также можете создавать и публиковать свои собственные события.\nВ следующем примере показан простой класс, расширяющий базовый класс Spring `ApplicationEvent`:\nJava\n	public class BlockedListEvent extends ApplicationEvent {\n		private final String address;\n		private final String content;\n		public BlockedListEvent(Object source, String address, String content) {\n			super(source);\n			this.address = address;\n			this.content = content;\n		// аксессор и другие методы...\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nЧтобы опубликовать пользовательское ApplicationEvent, вызовите метод publishEvent() в `ApplicationEventPublisher`.\nОбычно это делается путем создания класса, реализующего `ApplicationEventPublisherAware` и зарегистрировать его как bean-компонент Spring.\nСледующие пример показывает такой класс:\nJava\n	public class EmailService implements ApplicationEventPublisherAware {\n		private List<String> blockedList;\n		private ApplicationEventPublisher publisher;\n		public void setBlockedList(List<String> blockedList) {\n			this.blockedList = blockedList;\n		public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {\n			this.publisher = publisher;"}
{"id": 293, "text": "public void sendEmail(String address, String content) {\n			if (blockedList.contains(address)) {\n				publisher.publishEvent(new BlockedListEvent(this, address, content));\n				return;\n			// отправить письмо...\n	class EmailService : ApplicationEventPublisherAware {\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nВо время настройки контейнер Spring обнаруживает, что EmailService реализует `ApplicationEventPublisherAware` и автоматически вызывает `setApplicationEventPublisher()`.\nНа самом деле переданный параметр — это Spring сам контейнер.\nВы взаимодействуете с контекстом приложения через его Интерфейс ApplicationEventPublisher.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nЧтобы получить собственный ApplicationEvent, вы можете создать класс, реализующий `ApplicationListener` и зарегистрируйте его как bean-компонент Spring.\nСледующий пример показывает такой класс:\nJava\n	public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {\n		private String notificationAddress;\n		public void setNotificationAddress(String notificationAddress) {\n			this.notificationAddress = notificationAddress;\n		public void onApplicationEvent(BlockedListEvent event) {\n			// уведомляем соответствующие стороны через NotificationAddress...\n	class BlockedListNotifier : ApplicationListener<BlockedListEvent> {\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение."}
{"id": 294, "text": "Обратите внимание, что ApplicationListener обычно параметризуется типом вашего пользовательского события (BlockedListEvent в предыдущем примере).\nЭто означает, что метод onApplicationEvent() может оставаться типобезопасным, что позволяет избежать необходимости приведения типов.\nВы можете зарегистрировать столько прослушивателей событий, сколько пожелаете, но учтите, что по умолчанию прослушиватели событий получают события синхронно.\nЭто означает, что метод publicEvent() блокируется до тех пор, пока все прослушиватели не завершат обработку события.\nОдним из преимуществ этого синхронного и однопоточного подхода является то, что, когда прослушиватель получает событие, он работает внутри контекста транзакции издателя, если контекст транзакции доступен.\nЕсли возникает необходимость в другой стратегии публикации событий, например асинхронной обработке событий по умолчанию, см. javadoc для интерфейса Spring {spring-framework-api}/context/event/ApplicationEventMulticaster.html[`ApplicationEventMulticaster`] и реализация {spring-framework-api}/context/event/SimpleApplicationEventMulticaster.html[`SimpleApplicationEventMulticaster`] для параметров конфигурации, которые можно применить к пользовательскому определению bean-компонента applicationEventMulticaster.\nВ этих случаях ThreadLocals и контекст ведения журнала не передаются для обработки событий.\nСм. раздел наблюдения `@EventListener` для получения дополнительной информации о проблемах наблюдаемости.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nВ следующем примере показаны определения компонентов, используемые для регистрации и настройки каждого из классы выше:"}
{"id": 295, "text": "<bean id=\"emailService\" class=\"example.EmailService\">\n		<property name=\"blockedList\">\n			<list>\n				<value>known.spammer@example.org</value>\n				<value>known.hacker@example.org</value>\n				<value>john.doe@example.org</value>\n			</list>\n		</property>\n	</bean>\n	<bean id=\"blockedListNotifier\" class=\"example.BlockedListNotifier\">\n		<property name=\"notificationAddress\" value=\"blockedlist@example.org\"/>\n	</bean>\n	<!-- optional: a custom ApplicationEventMulticaster definition -->\n	<bean id=\"applicationEventMulticaster\" class=\"org.springframework.context.event.SimpleApplicationEventMulticaster\">\n		<property name=\"taskExecutor\" ref=\"...\"/>\n		<property name=\"errorHandler\" ref=\"...\"/>\n	</bean>\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nОбъединив все это вместе, можно сказать, что метод sendEmail() компонента emailService если есть сообщения электронной почты, которые следует заблокировать, вызывается пользовательское событие типа «BlockedListEvent» опубликован."}
{"id": 296, "text": "Компонент `blockedListNotifier` зарегистрирован как `ApplicationListener` и получает `BlockedListEvent`, после чего он может уведомить соответствующие стороны.\n.Встроенные события [cols=\"30%,70%\"] |=== | Событие| Объяснение.\nПРИМЕЧАНИЕ.\nМеханизм событий Spring предназначен для простой связи между bean-компонентами Spring. в одном и том же контексте приложения.\nОднако для более сложных предприятий потребности в интеграции, отдельно поддерживаемое Проект {spring-site-projects}/spring-integration/[Spring Integration] предоставляет полная поддержка создания легких, https://www.enterpriseintegrationpatterns.com[ориентированный на шаблоны], управляемый событиями архитектуры, основанные на известной модели программирования Spring.\nПрослушиватели событий на основе аннотаций.\nВы можете зарегистрировать прослушиватель событий в любом методе управляемого компонента, используя метод Аннотация `@EventListener`.\nBlockedListNotifier можно переписать следующим образом:\nJava\n	public class BlockedListNotifier {\n		private String notificationAddress;\n		public void setNotificationAddress(String notificationAddress) {\n			this.notificationAddress = notificationAddress;\n		@EventListener\n		public void processBlockedListEvent(BlockedListEvent event) {\n			// уведомляем соответствующие стороны через NotificationAddress...\n	class BlockedListNotifier {\nПрослушиватели событий на основе аннотаций.\nПРИМЕЧАНИЕ.\nНе делайте такие bean-компоненты ленивыми, поскольку ApplicationContext будет учитывать это и не будет регистрировать метод для прослушивания событий.\nПрослушиватели событий на основе аннотаций."}
{"id": 297, "text": "Сигнатура метода еще раз объявляет тип события, которое он прослушивает. но на этот раз с гибким именем и без реализации специального интерфейса прослушивателя.\nТип события также можно сузить с помощью дженериков, если фактический тип события разрешает ваш общий параметр в его иерархии реализации.\nПрослушиватели событий на основе аннотаций.\nЕсли ваш метод должен прослушивать несколько событий или вы хотите определить его без вообще, типы событий также можно указать в самой аннотации. следующий пример показывает, как это сделать:\nJava\n	@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})\n	public void handleContextStart() {\nПрослушиватели событий на основе аннотаций.\nТакже можно добавить дополнительную фильтрацию во время выполнения, используя атрибут Condition. аннотации, которая определяет выражение `SpEL`, которое должно соответствовать для фактического вызова метода для определенного события.\nПрослушиватели событий на основе аннотаций.\nВ следующем примере показано, как можно переписать наш уведомитель, чтобы он вызывался только в том случае, если Атрибут события `content` равен `my-event`:\nJava\n	@EventListener(condition = \"#blEvent.content == 'my-event'\")\n	public void processBlockedListEvent(BlockedListEvent blEvent) {\n		// уведомляем соответствующие стороны через NotificationAddress...\nПрослушиватели событий на основе аннотаций.\nКаждое выражение SpEL оценивается в соответствии с выделенным контекстом.\nВ следующей таблице перечислены элементы, доступные контексту, чтобы вы могли использовать их для условной обработки событий:"}
{"id": 298, "text": "Прослушиватели событий на основе аннотаций. .Метаданные событий доступны в выражениях SpEL. |=== | Имя| Местоположение| Описание| Пример\nПрослушиватели событий на основе аннотаций. | Событие | корневой объект | Фактический ApplicationEvent. | `#root.event` или `event`\nПрослушиватели событий на основе аннотаций. | Массив аргументов | корневой объект | Аргументы (в виде массива объектов), используемые для вызова метода. | `#root.args` или `args`; `args[0]` для доступа к первому аргументу и т. д.\nПрослушиватели событий на основе аннотаций. | __Имя аргумента__ | контекст оценки | Имя конкретного аргумента метода.\nЕсли имена недоступны (например, потому что код был скомпилирован без флага `-parameters`), отдельные аргументы также доступны с использованием синтаксиса `#a<#arg>`, где `<#arg>` обозначает индекс аргумента (начиная с 0). | `#blEvent` или `#a0` (вы также можете использовать обозначение параметра `#p0` или `#p<#arg>` в качестве псевдонима) |===\nПрослушиватели событий на основе аннотаций.\nОбратите внимание, что `#root.event` предоставляет вам доступ к базовому событию, даже если ваш метод подпись фактически относится к произвольному объекту, который был опубликован.\nПрослушиватели событий на основе аннотаций."}
{"id": 299, "text": "Если вам необходимо опубликовать событие как результат обработки другого события, вы можете изменить сигнатура метода для возврата события, которое должно быть опубликовано, как показано в следующем примере:\nJava\n	@EventListener\n	public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {\n		// уведомляем соответствующие стороны через NotificationAddress и\n		// затем опубликуйте ListUpdateEvent...\nПРИМЕЧАНИЕ.\nЭта функция не поддерживается для.\nМетод handleBlockedListEvent() публикует новое событие ListUpdateEvent для каждого `BlockedListEvent`, который он обрабатывает.\nЕсли вам нужно опубликовать несколько событий, вы можете вернуться вместо этого используйте `Collection` или массив событий.\nАсинхронные слушатели.\nЕсли вы хотите, чтобы конкретный прослушиватель обрабатывал события асинхронно, вы можете повторно использовать В следующем примере показано, как это сделать:\nJava\n	@EventListener\n	@Async\n	public void processBlockedListEvent(BlockedListEvent event) {\n		// BlockedListEvent обрабатывается в отдельном потоке\n* Если асинхронный прослушиватель событий выдает исключение, оно не передается в\nПомните о следующих ограничениях при использовании асинхронных событий:. звонящий.\nСм. {spring-framework-api}/aop/interceptor/AsyncUncaughtExceptionHandler.html[`AsyncUncaughtExceptionHandler`] для более подробной информации.\n* Методы прослушивания асинхронных событий не могут публиковать последующее событие, возвращая\nПомните о следующих ограничениях при использовании асинхронных событий:. ценность.\nЕсли вам нужно опубликовать другое событие в результате обработки, добавьте {spring-framework-api}/context/ApplicationEventPublisher.html[`ApplicationEventPublisher`] опубликовать событие вручную."}
{"id": 300, "text": "* ThreadLocals и контекст ведения журнала по умолчанию не передаются при обработке событий.\nПомните о следующих ограничениях при использовании асинхронных событий:.\nСм. раздел наблюдения `@EventListener` для получения дополнительной информации о проблемах наблюдаемости.\nПорядок слушателей.\nЕсли вам нужно, чтобы один прослушиватель вызывался перед другим, вы можете добавить `@Order` аннотация к объявлению метода, как показано в следующем примере:\nJava\n	@EventListener\n	@Order(42)\n	public void processBlockedListEvent(BlockedListEvent event) {\n		// уведомляем соответствующие стороны через NotificationAddress...\nОбщие события.\nВы также можете использовать дженерики для дальнейшего определения структуры вашего мероприятия.\nРассмотрите возможность использования `EntityCreatedEvent<T>`, где `T` — это тип фактического созданного объекта.\nНапример, вы может создать следующее определение прослушивателя, чтобы получать только `EntityCreatedEvent` для `Человек`:\nJava\n	@EventListener\n	public void onPersonCreated(EntityCreatedEvent<Person> event) {\nОбщие события.\nИз-за стирания типа это работает только в том случае, если вызываемое событие разрешает общий параметры, по которым фильтрует прослушиватель событий (то есть что-то вроде `класс PersonCreatedEvent расширяет EntityCreatedEvent<Person> {... }`).\nОбщие события.\nВ определенных обстоятельствах это может стать довольно утомительным, если все события происходят по одному и тому же сценарию. структуру (как и должно быть в случае события в предыдущем примере)."}
{"id": 301, "text": "В таком случае вы можете реализовать ResolvableTypeProvider, чтобы направлять структуру за пределы среды выполнения. окружающая среда обеспечивает.\nСледующее событие показывает, как это сделать:\nJava\n	public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {\n		public EntityCreatedEvent(T entity) {\n			super(entity);\n		@Override\n		public ResolvableType getResolvableType() {\n			return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));\n	class EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {\nОбщие события.\nСОВЕТ: Это работает не только для ApplicationEvent, но и для любого произвольного объекта, который вы отправляете как событие.\nОбщие события.\nНаконец, как и в случае с классической реализацией ApplicationListener, фактическая многоадресная рассылка происходит через контекстный объект ApplicationEventMulticaster во время выполнения.\nПо умолчанию это SimpleApplicationEventMulticaster с синхронной публикацией событий в вызывающем потоке.\nЭто можно заменить/настроить с помощью определения bean-компонента applicationEventMulticaster, например, для асинхронной обработки всех событий и/или для обработки исключений прослушивателя:\n	@Bean\n	ApplicationEventMulticaster applicationEventMulticaster() {\n		SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();\n		multicaster.setTaskExecutor(...);\n		multicaster.setErrorHandler(...);\n		return multicaster;\nУдобный доступ к низкоуровневым ресурсам.\nДля оптимального использования и понимания контекстов приложений вам следует ознакомиться с себя с помощью абстракции Spring `Resource`, как описано в\nУдобный доступ к низкоуровневым ресурсам."}
{"id": 302, "text": "Контекст приложения — это ResourceLoader, который можно использовать для загрузки объектов Resource. «Ресурс» — это, по сути, более многофункциональная версия класса JDK «java.net.URL».\nФактически, реализации Resource оборачивают экземпляр java.net.URL, где соответствующий. «Ресурс» может получить ресурсы низкого уровня практически из любого места в мире. прозрачная мода, в том числе из пути к классам, местоположения файловой системы, где угодно описывается стандартным URL-адресом и некоторыми другими вариантами.\nЕсли расположение ресурса строка — это простой путь без каких-либо специальных префиксов, откуда берутся эти ресурсы. специфичен и соответствует фактическому типу контекста приложения.\nУдобный доступ к низкоуровневым ресурсам.\nВы можете настроить компонент, развернутый в контексте приложения, для реализации специального интерфейс обратного вызова ResourceLoaderAware для автоматического обратного вызова время инициализации с самим контекстом приложения, передаваемым как ResourceLoader.\nВы также можете предоставить свойства типа «Ресурс», которые будут использоваться для доступа к статическим ресурсам.\nОни вводятся в него, как и любые другие свойства.\nВы можете указать эти `Resource` свойства как простые пути `String` и полагаются на автоматическое преобразование из этого текста. строки в фактические объекты Resource при развертывании компонента.\nУдобный доступ к низкоуровневым ресурсам.\nПуть или пути к местоположению, предоставленные конструктору ApplicationContext, на самом деле строки ресурсов и, в простой форме, обрабатываются соответствующим образом в соответствии с конкретными реализация контекста."}
{"id": 303, "text": "Например, ClassPathXmlApplicationContext обрабатывает простой путь к местоположению как местоположение пути к классам.\nВы также можете использовать пути к местоположению (строки ресурсов). со специальными префиксами для принудительной загрузки определений из пути к классам или URL-адреса, независимо от фактического типа контекста.\nОтслеживание запуска приложений.\nApplicationContext управляет жизненным циклом приложений Spring и предоставляет богатые возможности. модель программирования вокруг компонентов.\nВ результате сложные приложения могут иметь одинаковое сложные графы компонентов и этапы запуска.\nОтслеживание запуска приложений.\nОтслеживание шагов запуска приложения с помощью конкретных показателей может помочь понять, где время тратится на этапе запуска, но его также можно использовать как способ улучшить понять жизненный цикл контекста в целом.\nОтслеживание запуска приложений. «AbstractApplicationContext» (и его подклассы) оснащен `ApplicationStartup`, который собирает данные `StartupStep` о различных этапах запуска:\n* жизненный цикл контекста приложения (сканирование базовых пакетов, управление классами конфигурации)\n* жизненный цикл bean-компонентов (создание экземпляра, интеллектуальная инициализация, постобработка)\n* обработка событий приложения\nJava\n	// создаем шаг запуска и начинаем запись\n	try (StartupStep scanPackages = getApplicationStartup().start(\"spring.context.base-packages.scan\")) {\n        // добавляем информацию о тегах к текущему шагу\n        scanPackages.tag(\"packages\", () -> Arrays.toString(basePackages));\n        // выполняем фактическую фазу, которую мы инструментируем"}
{"id": 304, "text": "this.scanner.scan(basePackages);\nВот пример инструментов в AnnotationConfigApplicationContext:.\nКонтекст приложения уже оснащен несколькими шагами.\nПосле записи эти этапы запуска можно собирать, отображать и анализировать с помощью специальных инструментов.\nПолный список существующих шагов запуска можно найти на странице\nВот пример инструментов в AnnotationConfigApplicationContext:.\nРеализация ApplicationStartup по умолчанию является безоперационным вариантом для минимальных накладных расходов.\nЭто означает, что по умолчанию при запуске приложения не будут собираться никакие метрики.\nSpring Framework поставляется с реализацией для отслеживания шагов запуска с помощью Java Flight Recorder: `FlightRecorderApplicationStartup`.\nЧтобы использовать этот вариант, вы должны настроить его экземпляр. в `ApplicationContext`, как только он будет создан.\nВот пример инструментов в AnnotationConfigApplicationContext:.\nРазработчики также могут использовать инфраструктуру ApplicationStartup, если они предоставляют собственную. подкласс `AbstractApplicationContext`, или если они хотят собрать более точные данные.\nВот пример инструментов в AnnotationConfigApplicationContext:.\nВНИМАНИЕ: `ApplicationStartup` предназначен для использования только во время запуска приложения и для основной контейнер; это ни в коем случае не замена профилировщикам Java или библиотеки метрик, такие как https://micrometer.io[Micrometer].\nВот пример инструментов в AnnotationConfigApplicationContext:.\nЧтобы начать сбор пользовательского `StartupStep`, компоненты могут либо получить `ApplicationStartup` экземпляр непосредственно из контекста приложения, сделайте так, чтобы их компонент реализовывал `ApplicationStartupAware`, или запросите тип «ApplicationStartup» в любой точке внедрения."}
{"id": 305, "text": "Вот пример инструментов в AnnotationConfigApplicationContext:.\nПРИМЕЧАНИЕ.\nРазработчикам не следует использовать пространство имен `\"spring.*\"` при создании пользовательских шагов запуска.\nЭто пространство имен зарезервировано для внутреннего использования Spring и может быть изменено.\nУдобное создание экземпляра ApplicationContext для веб-приложений.\nВы можете создавать экземпляры ApplicationContext декларативно, используя, например, `Контекстный загрузчик`.\nКонечно, вы также можете создавать экземпляры ApplicationContext. программно, используя одну из реализаций ApplicationContext.\nУдобное создание экземпляра ApplicationContext для веб-приложений.\nВы можете зарегистрировать ApplicationContext, используя ContextLoaderListener, в качестве следующий пример показывает:\n	<context-param>\n		<param-name>contextConfigLocation</param-name>\n		<param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>\n	</context-param>\n	<listener>\n		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n	</listener>\nУдобное создание экземпляра ApplicationContext для веб-приложений.\nСлушатель проверяет параметр contextConfigLocation.\nЕсли параметр не существует, прослушиватель использует `/WEB-INF/applicationContext.xml` по умолчанию.\nКогда параметр существует, прослушиватель разделяет `String`, используя предопределенный разделители (запятая, точка с запятой и пробел) и использует значения в качестве мест, где осуществляется поиск контекстов приложения.\nТакже поддерживаются шаблоны путей в стиле Ant."}
{"id": 306, "text": "Примеры: `/WEB-INF/{asterisk}Context.xml` (для всех файлов, имена которых заканчиваются на `Context.xml` и которые находятся в каталоге `WEB-INF`) и `/WEB-INF/**/*Context.xml` (для всех таких файлов в любом подкаталоге WEB-INF).\nРазвертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.\nМожно развернуть Spring `ApplicationContext` как файл RAR, инкапсулирующий контекст и все необходимые классы компонентов и JAR-библиотеки в развертывании Jakarta EE RAR. единица.\nЭто эквивалент начальной загрузки автономного `ApplicationContext` (только размещенного в среде Jakarta EE), имея возможность доступа к серверам Jakarta EE. развертывание RAR является более естественной альтернативой сценарию развертывания безголового файла WAR.\nПо сути, файл WAR без каких-либо точек входа HTTP, который используется только для загрузки Spring `ApplicationContext` в среде Jakarta EE.\nРазвертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.\nРазвертывание RAR идеально подходит для контекстов приложений, которым не нужны точки входа HTTP, но скорее состоят только из конечных точек сообщений и запланированных заданий."}
{"id": 307, "text": "Бобы в таком контексте могут использовать ресурсы сервера приложений, такие как менеджер транзакций JTA и JDBC с привязкой к JNDI. экземпляры DataSource и экземпляры JMS ConnectionFactory, а также могут регистрироваться в JMX-сервер платформы — все через стандартное управление транзакциями Spring и JNDI. и средства поддержки JMX.\nКомпоненты приложения также могут взаимодействовать с приложением. серверный JCA WorkManager через абстракцию TaskExecutor Spring.\nРазвертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.\nСм. javadoc {spring-framework-api}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter`] class для деталей конфигурации, необходимых для развертывания RAR.\nРазвертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.\nДля простого развертывания Spring ApplicationContext в виде файла RAR Jakarta EE:\nРазвертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE. .\nПакет все классы приложений в файл RAR (который представляет собой стандартный файл JAR с другим расширение файла)..\nДобавьте все необходимые JAR-файлы библиотеки в корень архива RAR..\nДобавить Дескриптор развертывания `META-INF/ra.xml` (как показано в {spring-framework-api}/jca/context/SpringContextResourceAdapter.html[javadoc для `SpringContextResourceAdapter`]) и соответствующие файлы определения bean-компонентов Spring XML (обычно `META-INF/applicationContext.xml`).."}
{"id": 308, "text": "Поместите полученный файл RAR в свой каталог развертывания сервера приложений.\nРазвертывание Spring `ApplicationContext` в виде RAR-файла Jakarta EE.\nПРИМЕЧАНИЕ.\nТакие модули развертывания RAR обычно являются автономными.\nОни не раскрывают компоненты к внешнему миру, даже к другим модулям того же приложения.\nВзаимодействие с `ApplicationContext` на основе RAR обычно возникает через адресаты JMS, с которыми он совместно используется. другие модули.\nApplicationContext на основе RAR также может, например, планировать некоторые задания. или реагировать на новые файлы в файловой системе (и тому подобное).\nЕсли необходимо разрешить синхронный доступ извне, он может (например) экспортировать конечные точки RMI, которые можно использовать другими модулями приложения на том же компьютере."}
{"id": 309, "text": "Регистрация LoadTimeWeaver.\nLoadTimeWeaver используется Spring для динамического преобразования классов по мере их появления. загружен в виртуальную машину Java (JVM).\nРегистрация LoadTimeWeaver.\nЧтобы включить переплетение во время загрузки, вы можете добавить `@EnableLoadTimeWeaving` в один из ваших Классы `@Configuration`, как показано в следующем примере:\nJava\n	@Configuration\n	@EnableLoadTimeWeaving\n	public class AppConfig {\n	@Configuration\n	@EnableLoadTimeWeaving\n	class AppConfig\nРегистрация LoadTimeWeaver.\nВ качестве альтернативы для конфигурации XML вы можете использовать элемент context:load-time-weaver:\n	<beans>\n		<context:load-time-weaver/>\n	</beans>\nРегистрация LoadTimeWeaver.\nПосле настройки для ApplicationContext любой компонент внутри этого ApplicationContext может реализовать LoadTimeWeaverAware, тем самым получая ссылку на время загрузки экземпляр ткача.\nЭто особенно полезно в сочетании с необходимо для преобразования класса JPA.\nПроконсультируйтесь с {spring-framework-api}/orm/jpa/LocalContainerEntityManagerFactoryBean.html[`LocalContainerEntityManagerFactoryBean`] javadoc для более подробной информации.\nДополнительную информацию о переплетении времени загрузки AspectJ см."}
{"id": 310, "text": "Аннотированные контроллеры.\nSpring WebFlux предоставляет модель программирования на основе аннотаций, где `@Controller` и Компоненты `@RestController` используют аннотации для выражения сопоставления запросов, ввода запроса, обрабатывать исключения и многое другое.\nАннотированные контроллеры имеют гибкие сигнатуры методов и не нужно расширять базовые классы или реализовывать определенные интерфейсы.\nJava\n	@RestController\n	public class HelloController {\n		@GetMapping(\"/hello\")\n		public String handle() {\n			return \"Hello WebFlux\";\n	@RestController\n	class HelloController {\nВ следующем листинге показан базовый пример:.\nВ предыдущем примере метод возвращает строку для записи в тело ответа."}
{"id": 311, "text": "Преобразование типа.\nПо умолчанию установлены средства форматирования для различных типов чисел и дат, а также поддержка для настройки через `@NumberFormat`, `@DurationFormat` и `@DateTimeFormat` в полях и параметры.\nПреобразование типа.\nЧтобы зарегистрировать пользовательские форматтеры и конвертеры, используйте следующее: См. пример кода в исходном документе.\nПреобразование типа.\nПо умолчанию Spring MVC учитывает запрос Locale при анализе и форматировании даты. ценности.\nЭто работает для форм, где даты представлены как строки с формой «входа». поля.\nОднако для полей формы «дата» и «время» браузеры используют фиксированный формат, определенный в спецификации HTML.\nВ таких случаях форматирование даты и времени можно настроить следующим образом: См. пример кода в исходном документе.\nПреобразование типа.\nПРИМЕЧАНИЕ.\nСм.\nSPI `FormatterRegistrar`. и FormattingConversionServiceFactoryBean для получения дополнительной информации о том, когда использовать Реализации FormatterRegistrar."}
{"id": 312, "text": "Преобразование типа пружины.\nПакет `core.convert` предоставляет общую систему преобразования типов.\nСистема определяет SPI для реализации логики преобразования типов и API для выполнения преобразований типов на время выполнения.\nВнутри контейнера Spring вы можете использовать эту систему в качестве альтернативы Реализации `PropertyEditor` для преобразования строк значений свойств внешнего компонента в необходимые типы недвижимости.\nВы также можете использовать общедоступный API в любом месте вашего приложения. где требуется преобразование типов.\nКонвертер SPI.\nSPI для реализации логики преобразования типов прост и строго типизирован, как показано ниже. определение интерфейса показывает:\n	package org.springframework.core.convert.converter;\n	public interface Converter<S, T> {\n		T convert(S source);\nКонвертер SPI.\nЧтобы создать свой собственный преобразователь, реализуйте интерфейс «Конвертер» и параметризуйте «S». как тип, из которого вы конвертируете, и `T` как тип, в который вы конвертируете.\nВы также можете прозрачно применить такой конвертер, если необходимо преобразовать коллекцию или массив `S` преобразуется в массив или коллекцию `T` при условии, что делегирующий массив или коллекция конвертер также зарегистрирован (что по умолчанию делает `DefaultConversionService`).\nКонвертер SPI.\nДля каждого вызова Convert(S) аргумент источника гарантированно не будет нулевым.\nВаш `Конвертер` может выдать любое непроверенное исключение, если преобразование не удалось."}
{"id": 313, "text": "В частности, он должен выдать `IllegalArgumentException`, чтобы сообщить о недопустимом исходном значении.\nПозаботьтесь о том, чтобы ваша реализация «Конвертера» была потокобезопасной.\nКонвертер SPI.\nНесколько реализаций конвертера предоставляются в пакете `core.convert.support` как удобство.\nК ним относятся преобразователи строк в числа и другие распространенные типы.\nВ следующем листинге показан класс StringToInteger, который является типичной реализацией Converter:\n	package org.springframework.core.convert.support;\n	final class StringToInteger implements Converter<String, Integer> {\n		public Integer convert(String source) {\n			return Integer.valueOf(source);\nИспользование ConverterFactory.\nКогда вам нужно централизовать логику преобразования для всей иерархии классов (например, при преобразовании объектов String в Enum), вы можете реализовать «ConverterFactory», как показано в следующем примере:\n	package org.springframework.core.convert.converter;\n	public interface ConverterFactory<S, R> {\n		<T extends R> Converter<S, T> getConverter(Class<T> targetType);\nИспользование ConverterFactory.\nПараметризуйте `S` как тип, из которого вы конвертируете, а `R` как определяющий базовый тип. __range__ классов, в которые вы можете преобразовать.\nЗатем реализуйте `getConverter(Class<T>)`, где «T» — подкласс «R».\n	package org.springframework.core.convert.support;"}
{"id": 314, "text": "final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {\n		public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {\n			return new StringToEnumConverter(targetType);\n		private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {\n			private Class<T> enumType;\n			public StringToEnumConverter(Class<T> enumType) {\n				this.enumType = enumType;\n			public T convert(String source) {\n				return (T) Enum.valueOf(this.enumType, source.trim());\nИспользование GenericConverter.\nЕсли вам требуется более сложная реализация «Конвертера», рассмотрите возможность использования Интерфейс `GenericConverter`.\nС более гибкой, но менее строго типизированной подписью, чем `Конвертер`, `GenericConverter` поддерживает преобразование между несколькими источниками и целями. типы.\nКроме того, GenericConverter предоставляет дескрипторы исходного и целевого типов. который вы можете использовать при реализации логики преобразования.\nТакие дескрипторы типов позволяют преобразование типов должно осуществляться аннотацией в источнике дескриптора (например, поле или метод) или с помощью общей информации, объявленной в сигнатуре поля, методе подпись и т. д.\nВ следующем листинге показано определение GenericConverter. интерфейс:\n	package org.springframework.core.convert.converter;\n	public interface GenericConverter {\n		public Set<ConvertiblePair> getConvertibleTypes();\n		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);"}
{"id": 315, "text": "Использование GenericConverter.\nЧтобы реализовать GenericConverter, необходимо, чтобы getConvertibleTypes() возвращал поддерживаемые типы. пары исходный → целевой тип.\nЗатем реализуйте Convert(Object, TypeDescriptor, TypeDescriptor)`, чтобы содержать логику преобразования.\nИсходный TypeDescriptor предоставляет доступ к исходному полю или методу, содержащему преобразуемое значение.\nЦель `TypeDescriptor` обеспечивает доступ к целевому полю или методу, в котором преобразованное значение должен быть установлен.\nИспользование GenericConverter.\nХорошим примером GenericConverter является преобразователь, который преобразует массив Java и коллекция.\nТакой ArrayToCollectionConverter анализирует поле или метод. который объявляет тип целевой коллекции для разрешения типа элемента коллекции.\nЭто позволяет каждому элементу исходного массива быть преобразовано в тип элемента коллекции перед коллекция устанавливается в целевом поле или передается целевому методу или конструктору.\nИспользование GenericConverter.\nПРИМЕЧАНИЕ.\nПоскольку GenericConverter представляет собой более сложный интерфейс SPI, вам следует использовать это только тогда, когда вам это нужно.\nВ качестве базового типа отдавайте предпочтение Converter или ConverterFactory. потребности в конверсии.\nИспользование «ConditionalGenericConverter».\nИногда вам нужно, чтобы «Конвертер» запускался только в том случае, если определенное условие выполняется."}
{"id": 316, "text": "Для Например, вы можете запустить «Конвертер», только если в файле присутствует определенная аннотация. целевое поле или метод, или вы можете запустить `Конвертер` только в том случае, если определенное метод (например, метод static valueOf) определен для целевого типа. «ConditionalGenericConverter» — это объединение «GenericConverter» и Интерфейсы `ConditionalConverter`, которые позволяют вам определять такие пользовательские критерии соответствия:\n	public interface ConditionalConverter {\n		boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);\n	public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {\nИспользование «ConditionalGenericConverter».\nХорошим примером ConditionalGenericConverter является IdToEntityConverter, который преобразует между постоянным идентификатором объекта и ссылкой на объект.\nТакой `IdToEntityConverter` может соответствовать только в том случае, если целевой тип сущности объявляет статический метод поиска (например, `findAccount(Long)`).\nВы можете выполнить такую проверку метода поиска в реализации `соответствует (TypeDescriptor, TypeDescriptor)`.\nAPI «ConversionService».\nConversionService определяет унифицированный API для выполнения логики преобразования типов на время выполнения.\nПреобразователи часто выполняются за следующим фасадным интерфейсом:\n	package org.springframework.core.convert;\n	public interface ConversionService {\n		boolean canConvert(Class<?> sourceType, Class<?> targetType);\n		<T> T convert(Object source, Class<T> targetType);\n		boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);\n		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);"}
{"id": 317, "text": "API «ConversionService».\nБольшинство реализаций ConversionService также реализуют ConverterRegistry, который предоставляет SPI для регистрации преобразователей.\nВнутри ConversionService реализация делегирует своим зарегистрированным преобразователям выполнение логики преобразования типов.\nAPI «ConversionService».\nНадежная реализация ConversionService представлена в файле core.convert.support. пакет.\nGenericConversionService — это реализация общего назначения, подходящая для использовать в большинстве сред.\nConversionServiceFactory предоставляет удобную фабрику для создание общих конфигураций ConversionService.\nНастройка ConversionService.\nConversionService — это объект без сохранения состояния, предназначенный для создания экземпляра в приложении. при запуске, а затем распределяется между несколькими потоками.\nВ приложении Spring вы обычно настройте экземпляр ConversionService для каждого контейнера Spring (или ApplicationContext).\nSpring берет этот ConversionService и использует его всякий раз, когда тип преобразование должно выполняться платформой.\nВы также можете ввести это `ConversionService` в любой из ваших bean-компонентов и вызывайте его напрямую.\nНастройка ConversionService.\nПРИМЕЧАНИЕ.\nЕсли в Spring не зарегистрирована служба ConversionService, исходный файл на основе PropertyEditor используется система.\nНастройка ConversionService.\nЧтобы зарегистрировать ConversionService по умолчанию в Spring, добавьте следующее определение bean-компонента с идентификатором `conversionService`:\n	<bean id=\"conversionService\"\n		class=\"org.springframework.context.support.ConversionServiceFactoryBean\"/>\nНастройка ConversionService.\nСлужба ConversionService по умолчанию может конвертировать строки, числа, перечисления, коллекции, карты и другие распространенные типы."}
{"id": 318, "text": "Чтобы дополнить или переопределить преобразователи по умолчанию с помощью вашего собственные преобразователи, установите свойство «конвертеры».\nЗначения свойств могут быть реализованы любой из интерфейсов Converter, ConverterFactory или GenericConverter.\n	<bean id=\"conversionService\"\n			class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n		<property name=\"converters\">\n			<set>\n				<bean class=\"example.MyCustomConverter\"/>\n			</set>\n		</property>\n	</bean>\nНастройка ConversionService.\nТакже часто используется ConversionService в приложении Spring MVC.\nСм.\nНастройка ConversionService.\nВ определенных ситуациях вам может потребоваться применить форматирование во время преобразования.\nСм. для получения подробной информации об использовании FormattingConversionServiceFactoryBean.\nПрограммное использование ConversionService.\nЧтобы программно работать с экземпляром ConversionService, вы можете добавить ссылку на это так же, как и для любого другого компонента.\nВ следующем примере показано, как это сделать:\nJava\n	@Service\n	public class MyService {\n		private final ConversionService conversionService;\n		public MyService(ConversionService conversionService) {\n			this.conversionService = conversionService;\n		public void doIt() {\n			this.conversionService.convert(...)\nПрограммное использование ConversionService.\nВ большинстве случаев вы можете использовать метод Convert, который определяет TargetType, но он не работает с более сложными типами, такими как коллекция параметризованных элементов."}
{"id": 319, "text": "Например, если вы хотите программно преобразовать «Список» «Целое число» в «Список» «Строка», вам необходимо предоставить формальное определение исходного и целевого типов.\nПрограммное использование ConversionService.\nК счастью, TypeDescriptor предоставляет различные возможности, упрощающие эту задачу. как показано в следующем примере:\nJava\n	DefaultConversionService cs = new DefaultConversionService();\n	List<Integer> input = ...\n	cs.convert(input,\n		TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class)), // <1>\n		TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class))); // <2>\n<1> Дескриптор типа `List<Integer>` <2> Дескриптор типа `List<String>`.\nОбратите внимание, что DefaultConversionService автоматически регистрирует конвертеры, которые подходит для большинства сред.\nСюда входят преобразователи коллекций, скалярные конвертеры и базовые преобразователи «Объект» в «Строка».\nВы можете зарегистрировать такие же преобразователи с любым ConverterRegistry, используя статический addDefaultConverters. метод в классе DefaultConversionService.\n<1> Дескриптор типа `List<Integer>` <2> Дескриптор типа `List<String>`."}
{"id": 320, "text": "Преобразователи типов значений повторно используются для массивов и коллекций, поэтому существует нет необходимости создавать специальный преобразователь для преобразования из «Коллекции» «S» в `Сбор` `T`, предполагая, что стандартная обработка сбора является подходящей."}
{"id": 321, "text": "`@CookieValue`.\nВы можете использовать аннотацию @CookieValue, чтобы привязать значение файла cookie HTTP к аргументу метода. в контроллере.\nJava\n	@GetMapping(\"/demo\")\n	public void handle(@CookieValue(\"JSESSIONID\") String cookie) { // <1>\nВ следующем примере кода показано, как получить значение файла cookie:. <1> Получите значение файла cookie.\nВ следующем примере кода показано, как получить значение файла cookie:.\nПреобразование типов применяется автоматически, если тип параметра целевого метода не `Строка`.\nСм. ссылку:web/webflux/controller/ann-methods/typeconversion.adoc [Преобразование типов]."}
{"id": 322, "text": "1. Введение. `core` — базовый модуль Lilipup Framework, который отвечает за контейнер компонентов, внедрение зависимостей, событийную шину и базовые абстракции запуска приложения.\n- стандартизирует инициализацию приложения;\n- управляет жизнью компонентов через контейнер `LilipupContext`;\n- предоставляет единый API для модулей `configuration`, `validation`, `security`, `scheduler`, `kafka`, `monitoring`.\n```xml\n```groovy\n```java\n    public static void main(String[] args) {\n        LilipupApplication.run(App.class, args);\n```java\n    private final TaxService taxService;\n    // Конструкторное внедрение предпочтительнее: гарантирует неизменяемость зависимостей.\n    @Inject\n    public InvoiceService(TaxService taxService) {\n        this.taxService = taxService;\n    public long calculateTotal(long baseAmount) {\n        return baseAmount + taxService.taxFor(baseAmount);\n    public long taxFor(long amount) {\n        return Math.round(amount * 0.2);\n```java\n    private final EventPublisher publisher;\n    public OrderFlow(EventPublisher publisher) {\n        this.publisher = publisher;\n    public void placeOrder(String orderId) {\n        publisher.publish(new OrderCreatedEvent(orderId));\n    @OnEvent\n    public void onOrderCreated(OrderCreatedEvent event) {\n        // Локальная реакция: запись метрики, подготовка к отправке в Kafka и т.д."}
{"id": 323, "text": "System.out.println(\"Order accepted: \" + event.orderId());\n```yaml\n    name: billing-service\n    profile: prod\n    scan-packages:\n      - com.example.app\n      - com.example.shared\n    lazy-init: false\n    fail-fast: true\n    event-bus:\n      async: true\n      workers: 8\n- `lilipup.core.lazy-init`: откладывает создание бинов до первого запроса;\n- `lilipup.core.fail-fast`: завершает запуск при ошибках графа зависимостей;\n- `lilipup.core.event-bus.async`: включает асинхронную доставку событий.\n- Всегда проверяйте, что `scan-packages` включает все модули с компонентами, иначе часть бинов не будет создана.\n- Всегда включайте `fail-fast=true` для production, чтобы не запускаться с полубитым контейнером.\n- Перед публикацией доменных событий проверяйте валидность payload (не `null`, корректные идентификаторы).\n- Не создавайте циклические зависимости между компонентами (`A -> B -> A`).\n- Проверяйте, что асинхронный `event-bus` имеет достаточное число `workers` под нагрузкой.\n- `BeanResolutionException`: контейнер не может найти/создать зависимость.\n- `CircularDependencyException`: цикл в графе DI.\n- `EventDispatchTimeoutException`: обработчик события не уложился в таймаут.\n```java"}
{"id": 324, "text": "public static void main(String[] args) {\n        try {\n            LilipupApplication.run(App.class, args);\n        } catch (BootstrapException ex) {\n            // В реальном проекте: структурированный лог + аварийное уведомление.\n            System.err.println(\"Startup failed: \" + ex.getMessage());\n            System.exit(1);\n- Используйте конструкторное внедрение как default.\n- Разделяйте `@Component` и инфраструктурные бины (`@Factory`) по пакетам.\n- Ограничивайте область сканирования (`scan-packages`) для ускорения старта.\n- Доменные события делайте immutable (`record` / финальные поля).\n- Не размещайте тяжелую I/O-логику в синхронных обработчиках событий."}
{"id": 325, "text": "Использование CustomAutowireConfigurer. {spring-framework-api}/beans/factory/annotation/CustomAutowireConfigurer.html[`CustomAutowireConfigurer`] это `BeanFactoryPostProcessor`, который позволяет вам зарегистрировать свой собственный квалификатор типы аннотаций, даже если они не снабжены аннотацией Spring `@Qualifier`.\nВ следующем примере показано, как использовать CustomAutowireConfigurer:\n	<bean id=\"customAutowireConfigurer\"\n			class=\"org.springframework.beans.factory.annotation.CustomAutowireConfigurer\">\n		<property name=\"customQualifierTypes\">\n			<set>\n				<value>example.CustomQualifier</value>\n			</set>\n		</property>\n	</bean>\n* Значение `autowire-candidate` каждого определения bean-компонента.\n* Любые шаблоны `default-autowire-candidates`, доступные в элементе `<beans/>`.\n* Наличие аннотаций `@Qualifier` и любых зарегистрированных пользовательских аннотаций.\nс помощью CustomAutowireConfigurer.\nКогда несколько bean-компонентов квалифицируются как кандидаты для автоматического подключения, определение «основного» следующим образом: если ровно одно определение компонента среди кандидатов имеет \"первичное\" атрибуту присвоено значение true, он выбирается."}
{"id": 326, "text": "API конфигурации MVC.\nВ конфигурации Java вы можете реализовать интерфейс WebMvcConfigurer, как следующий пример показывает: См. пример кода в исходном документе.\nAPI конфигурации MVC.\nВ XML вы можете проверять атрибуты и подэлементы `<mvc:annotation-driven/>`.\nВы можете просмотрите https://schema.spring.io/mvc/spring-mvc.xsd [XML-схему Spring MVC] или используйте функция завершения кода вашей IDE, чтобы узнать, какие атрибуты и доступны подэлементы."}
{"id": 327, "text": "Поддержка ДАО.\nПоддержка Data Access Object (DAO) в Spring призвана упростить работу с технологии доступа к данным (такие как JDBC, Hibernate или JPA) согласованным образом.\nЭто позволяет довольно легко переключаться между вышеупомянутыми технологиями сохранения, а также позволяет вам писать код, не беспокоясь о перехвате исключений, которые специфичны для каждой технологии.\nСогласованная иерархия исключений.\nSpring обеспечивает удобный перевод исключений, специфичных для конкретной технологии, таких как `SQLException` в свою собственную иерархию классов исключений, которая имеет `DataAccessException` как корневое исключение.\nЭти исключения оборачивают исходное исключение, поэтому никогда не возникает любой риск того, что вы можете потерять любую информацию о том, что могло пойти не так.\nСогласованная иерархия исключений.\nПомимо исключений JDBC, Spring также может обертывать исключения, специфичные для JPA и Hibernate. преобразование их в набор сфокусированных исключений времени выполнения.\nЭто позволяет вам справиться с большинством невосстанавливаемые постоянные исключения только на соответствующих уровнях, без необходимости раздражающие шаблонные блоки catch-and-throw и объявления исключений в ваших DAO. (Однако вы все равно можете перехватывать и обрабатывать исключения в любом месте.) Как упоминалось выше, Исключения JDBC (включая диалекты, специфичные для базы данных) также преобразуются в тот же иерархия, что означает, что вы можете выполнять некоторые операции с JDBC в рамках согласованной модель программирования.\nСогласованная иерархия исключений.\nПредыдущее обсуждение справедливо для различных классов шаблонов, поддерживаемых Spring. для различных фреймворков ORM."}
{"id": 328, "text": "Если вы используете классы на основе перехватчиков, приложение должно позаботьтесь об обработке HibernateExceptions и PersistenceExceptions, желательно с помощью делегирование `convertHibernateAccessException(..)` или `convertJpaAccessException(..)` методы соответственно `SessionFactoryUtils`.\nЭти методы преобразуют исключения к исключениям, совместимым с исключениями в `org.springframework.dao` иерархия исключений.\nПоскольку `PersistenceExceptions` не отмечены, они также могут быть выброшены. (однако принося в жертву общую абстракцию DAO с точки зрения исключений).\nСогласованная иерархия исключений.\nНа следующем изображении показана иерархия исключений, предоставляемая Spring. (Обратите внимание, что иерархия классов, подробно описанная на изображении, показывает только подмножество всей Иерархия DataAccessException.)\nАннотации, используемые для настройки классов DAO или репозитория.\nЛучший способ гарантировать, что ваши объекты доступа к данным (DAO) или репозитории предоставляют перевод исключений заключается в использовании аннотации `@Repository`.\nЭта аннотация также позволяет поддержке сканирования компонентов находить и настраивать ваши DAO и репозитории без необходимости предоставления для них записей конфигурации XML.\nСледующий пример показывает как использовать аннотацию `@Repository`:\nJava\n	@Repository // <1>\n	public class SomeMovieFinder implements MovieFinder {\nАннотации, используемые для настройки классов DAO или репозитория. <1> Аннотация `@Repository`.\n	@Repository // <1>\n	class SomeMovieFinder : MovieFinder {\nАннотации, используемые для настройки классов DAO или репозитория. <1> Аннотация `@Repository`."}
{"id": 329, "text": "Аннотации, используемые для настройки классов DAO или репозитория.\nЛюбая реализация DAO или репозитория требует доступа к постоянному ресурсу. в зависимости от используемой технологии сохранения.\nНапример, репозиторий на основе JDBC. необходим доступ к источнику данных JDBC, а репозиторию на основе JPA необходим доступ к `EntityManager`.\nСамый простой способ добиться этого — создать зависимость от ресурсов. внедряется с помощью одного из `@Autowired`, `@Inject`, `@Resource` или `@PersistenceContext` аннотации.\nСледующий пример работает для репозитория JPA:\nJava\n	@Repository\n	public class JpaMovieFinder implements MovieFinder {\n		@PersistenceContext\n		private EntityManager entityManager;\n	@Repository\n	class JpaMovieFinder : MovieFinder {\nАннотации, используемые для настройки классов DAO или репозитория.\nЕсли вы используете классические API-интерфейсы Hibernate, вы можете внедрить SessionFactory, как показано ниже. пример показывает:\nJava\n	@Repository\n	public class HibernateMovieFinder implements MovieFinder {\n		private SessionFactory sessionFactory;\n		@Autowired\n		public void setSessionFactory(SessionFactory sessionFactory) {\n			this.sessionFactory = sessionFactory;\nАннотации, используемые для настройки классов DAO или репозитория.\nПоследний пример, который мы здесь показываем, относится к типичной поддержке JDBC.\nУ вас может быть `DataSource` вводится в метод инициализации или конструктор, где вы должны создать JdbcTemplate. и другие классы поддержки доступа к данным (такие как SimpleJdbcCall и другие), используя этот `Источник данных`.\nВ следующем примере происходит автоматическое подключение DataSource:\nJava\n	@Repository"}
{"id": 330, "text": "public class JdbcMovieFinder implements MovieFinder {\n		private JdbcTemplate jdbcTemplate;\n		@Autowired\n		public void init(DataSource dataSource) {\n			this.jdbcTemplate = new JdbcTemplate(dataSource);\nАннотации, используемые для настройки классов DAO или репозитория.\nПРИМЕЧАНИЕ.\nПодробную информацию о том, как настройте контекст приложения, чтобы использовать эти аннотации."}
{"id": 331, "text": "Привязка данных полезна для привязки пользовательского ввода к целевому объекту, где пользовательский ввод представляет собой карту. с путями к свойствам в качестве ключей, следуя соглашениям JavaBeans. `DataBinder` — основной класс, поддерживающий это, и он предоставляет два способа привязки пользователя ввод:\n- Привязка конструктора — привязать пользовательский ввод к\nПривязка данных. конструктор общедоступных данных, ищущий значения аргументов конструктора во входных данных пользователя.\n- Привязка свойства — привязать пользовательский ввод к установщикам,\nПривязка данных. сопоставление ключей из пользовательского ввода со свойствами структуры целевого объекта.\nПривязка данных.\nВы можете применить как конструктор, так и привязку свойства или только одну.\n1. Создайте DataBinder с null в качестве целевого объекта.\n2. Установите targetType для целевого класса.\n3. Вызовите `construct`.\nЧтобы использовать привязку конструктора:.\nЦелевой класс должен иметь один общедоступный конструктор или один закрытый конструктор. с аргументами.\nЕсли существует несколько конструкторов, то конструктор по умолчанию, если он присутствует. используется.\nЧтобы использовать привязку конструктора:.\nПо умолчанию значения аргументов ищутся по именам параметров конструктора.\nSpring MVC и WebFlux поддерживает пользовательское сопоставление имен через аннотацию @BindParam в конструкторе. параметры или поля, если они присутствуют.\nПри необходимости вы также можете настроить NameResolver на `DataBinder`, чтобы настроить имя используемого аргумента.\nЧтобы использовать привязку конструктора:."}
{"id": 332, "text": "Если параметр конструктора является объектом, он создается рекурсивно в том же способом, но через вложенный путь к свойству.\nЭто означает, что привязка конструктора создает оба целевой объект и любые объекты, которые он содержит.\nЧтобы использовать привязку конструктора:.\nПривязка конструктора поддерживает аргументы List, Map и массива, преобразованные из одну строку, например список, разделенный запятыми, или на основе индексированных ключей, таких как `accounts[2].name` или `account[KEY].name`.\nЧтобы использовать привязку конструктора:.\nОшибки привязки и преобразования отражаются в BindingResult объекта DataBinder.\nЕсли цель создана успешно, то в качестве цели устанавливается созданный экземпляр. после вызова `construct`.\nПривязка свойств с помощью BeanWrapper.\nПакет `org.springframework.beans` соответствует стандарту JavaBeans.\nJavaBean — это класс с конструктором без аргументов по умолчанию, и это следует соглашение об именах, согласно которому (например) свойство с именем `bingoMadness` будет имеют метод установки `setBingoMadness(..)` и метод получения `getBingoMadness()`.\nДля дополнительную информацию о JavaBeans и спецификации см. {java-api}/java.desktop/java/beans/package-summary.html[javabeans].\nПривязка свойств с помощью BeanWrapper.\nОдним из весьма важных классов в пакете bean-компонентов является интерфейс BeanWrapper и его соответствующая реализация (`BeanWrapperImpl`)."}
{"id": 333, "text": "Как указано в javadoc, `BeanWrapper` предлагает функциональные возможности для установки и получения значений свойств (индивидуально или в массово), получить дескрипторы свойств и запросить свойства, чтобы определить, являются ли они читаемый или записываемый.\nКроме того, BeanWrapper предлагает поддержку вложенных свойств. возможность настройки свойств вложенных свойств на неограниченную глубину. `BeanWrapper` также поддерживает возможность добавления стандартных JavaBeans `PropertyChangeListeners` и VetoableChangeListeners без необходимости поддержки кода в целевом классе.\nИ последнее, но не менее важное: BeanWrapper обеспечивает поддержку установки индексированных свойств. `BeanWrapper` обычно не используется кодом приложения напрямую, а используется `DataBinder` и `BeanFactory`.\nПривязка свойств с помощью BeanWrapper.\nПринцип работы `BeanWrapper` частично определяется его названием: он оборачивает компонент в выполнять действия над этим компонентом, такие как установка и получение свойств.\nУстановка и получение основных и вложенных свойств.\nУстановка и получение свойств осуществляется через `setPropertyValue` и getPropertyValue — перегруженные варианты метода BeanWrapper.\nСм. их Javadoc для детали.\nВ таблице ниже показаны некоторые примеры этих соглашений:\n.Примеры свойств |=== | Выражение| Объяснение. | `имя` | Указывает свойство name, которое соответствует getName() или isName(). и `setName(..)`."}
{"id": 334, "text": ".Примеры свойств |=== | Выражение| Объяснение. | `аккаунт.имя` | Указывает вложенное свойство `name` свойства `account`, которое соответствует (например) методы `getAccount().setName()` или `getAccount().getName()`.\n.Примеры свойств |=== | Выражение| Объяснение. | `счета[2]` | Указывает _третий_ элемент индексированного свойства account.\nИндексированные свойства может иметь тип массива, списка или другой естественно упорядоченной коллекции.\n.Примеры свойств |=== | Выражение| Объяснение. | `аккаунты[KEY]` | Указывает значение записи карты, индексированной значением `KEY`. |===\n.Примеры свойств |=== | Выражение| Объяснение. (Следующий раздел не является для вас жизненно важным, если вы не планируете работать с непосредственно `BeanWrapper`.\nЕсли вы используете только DataBinder и BeanFactory и их реализации по умолчанию, вам следует перейти к\n.Примеры свойств |=== | Выражение| Объяснение.\nСледующие два примера классов используют BeanWrapper для получения и установки свойства:\nJava\n	public class Company {\n		private String name;\n		private Employee managingDirector;\n		public String getName() {\n			return this.name;\n		public void setName(String name) {\n			this.name = name;\n		public Employee getManagingDirector() {\n			return this.managingDirector;"}
{"id": 335, "text": "public void setManagingDirector(Employee managingDirector) {\n			this.managingDirector = managingDirector;\nJava\n	public class Employee {\n		private String name;\n		private float salary;\n		public String getName() {\n			return this.name;\n		public void setName(String name) {\n			this.name = name;\n		public float getSalary() {\n			return salary;\n		public void setSalary(float salary) {\n			this.salary = salary;\n.Примеры свойств |=== | Выражение| Объяснение.\nСледующие фрагменты кода показывают несколько примеров того, как извлекать и манипулировать некоторыми из свойства экземпляров ``Company`` и ``Employee``:\nJava\n	BeanWrapper company = new BeanWrapperImpl(new Company());\n	// установка названия компании..\n	company.setPropertyValue(\"name\", \"Some Company Inc.\");\n	// ... также можно сделать так:\n	PropertyValue value = new PropertyValue(\"name\", \"Some Company Inc.\");\n	company.setPropertyValue(value);\n	// ок, создадим директора и привяжем его к компании:\n	BeanWrapper jim = new BeanWrapperImpl(new Employee());\n	jim.setPropertyValue(\"name\", \"Jim Stravinsky\");\n	company.setPropertyValue(\"managingDirector\", jim.getWrappedInstance());\n	// получение зарплаты управляющего директора через компанию"}
{"id": 336, "text": "Float salary = (Float) company.getPropertyValue(\"managingDirector.salary\");\n``PropertyEditor``s.\nSpring использует концепцию PropertyEditor для преобразования между `Объект` и `Строка`.\nЭто может быть удобно представлять свойства иначе, чем сам объект.\nНапример, «Дата» может быть представлен в удобочитаемом виде (как ``String`: `'2007-14-09'`), в то время как мы все еще можем преобразовать удобочитаемую форму обратно в исходную дату (или даже лучше преобразовать любую дату, введенную в удобочитаемой форме, обратно в объекты Date).\nЭто поведение может быть достигнуто путем регистрации пользовательских редакторов типа `java.beans.PropertyEditor`.\nРегистрация пользовательских редакторов в BeanWrapper или альтернативно, в конкретном контейнере IoC (как упоминалось в предыдущей главе), дает ему знание того, как преобразовать свойства к нужному типу.\nПодробнее о `PropertyEditor`, см. {java-api}/java.desktop/java/beans/package-summary.html [javadoc пакета `java.beans` от Oracle].\n* Установка свойств bean-компонентов выполняется с помощью реализаций PropertyEditor.\nНесколько примеров использования редактирования свойств в Spring:."}
{"id": 337, "text": "Когда вы используете `String` в качестве значения свойства некоторого bean-компонента, который вы объявляете в XML-файле Spring (если установщик соответствующего свойства имеет `Class` параметр) использует ClassEditor, чтобы попытаться преобразовать параметр в объект Class.\n* Анализ параметров HTTP-запроса в среде Spring MVC выполняется с использованием всех видов\nНесколько примеров использования редактирования свойств в Spring:. реализаций PropertyEditor, которые вы можете вручную связать во всех подклассах `Командный Контроллер`.\nНесколько примеров использования редактирования свойств в Spring:.\nSpring имеет ряд встроенных реализаций PropertyEditor, упрощающих жизнь.\nВсе они расположены в папке org.springframework.beans.propertyeditors. пакет.\nБольшинство (но не все, как указано в следующей таблице) по умолчанию регистрируются `BeanWrapperImpl`.\nЕсли редактор свойств каким-либо образом настраивается, вы можете все равно зарегистрируйте свой собственный вариант, чтобы заменить вариант по умолчанию.\nВ следующей таблице описаны различные реализации PropertyEditor, предоставляемые Spring:\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `ByteArrayPropertyEditor` | Редактор байтовых массивов.\nПреобразует строки в соответствующие им байты представления.\nЗарегистрировано по умолчанию с помощью BeanWrapperImpl."}
{"id": 338, "text": ".Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `Редактор классов` | Анализирует строки, представляющие классы, в фактические классы и наоборот.\nКогда класс не найден, выдается исключение IllegalArgumentException.\nПо умолчанию зарегистрировано `BeanWrapperImpl`.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `Пользовательский логический редактор` | Настраиваемый редактор свойств для логических свойств.\nПо умолчанию зарегистрировано `BeanWrapperImpl`, но его можно переопределить, зарегистрировав его собственный экземпляр как специальный редактор.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `CustomCollectionEditor` | Редактор свойств коллекций, преобразующий любую исходную коллекцию в заданную цель.\nТип «Коллекция».\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `CustomDateEditor` | Настраиваемый редактор свойств для java.util.Date, поддерживающий пользовательский формат DateFormat.\nНЕ зарегистрирован по умолчанию.\nДолжен быть зарегистрирован пользователем в соответствующем формате по мере необходимости."}
{"id": 339, "text": ".Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `CustomNumberEditor` | Настраиваемый редактор свойств для любого подкласса Number, например Integer, Long, Float или `Двойник`.\nПо умолчанию регистрируется BeanWrapperImpl, но может быть переопределен с помощью регистрация его пользовательского экземпляра в качестве пользовательского редактора.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `Редактор файлов` | Преобразует строки в объекты java.io.File.\nПо умолчанию зарегистрировано `BeanWrapperImpl`.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `InputStreamEditor` | Односторонний редактор свойств, который может принимать строку и создавать (через промежуточные `ResourceEditor` и `Resource`) и `InputStream`, чтобы `InputStream` свойства могут быть заданы непосредственно в виде строк.\nОбратите внимание, что использование по умолчанию не закрывается. `InputStream` для вас.\nПо умолчанию регистрируется BeanWrapperImpl."}
{"id": 340, "text": ".Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `Редактор локали` | Может преобразовывать строки в объекты Locale и наоборот (формат строки: `[язык]\\_[страна]_[вариант]`, то же, что и метод `toString()` «Локаль»).\nТакже принимает пробелы в качестве разделителей в качестве альтернативы подчеркиванию.\nПо умолчанию регистрируется BeanWrapperImpl.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `Редактор шаблонов` | Может преобразовывать строки в объекты java.util.regex.Pattern и наоборот.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `Редактор свойств` | Может конвертировать строки (отформатированные в формате, определенном в javadoc класс `java.util.Properties`) для объектов `Properties`.\nПо умолчанию зарегистрировано от `BeanWrapperImpl`.\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `StringTrimmerEditor` | Редактор свойств, который обрезает строки.\nОпционально позволяет преобразовать пустую строку в значение `null`.\nНЕ зарегистрировано по умолчанию — должно быть зарегистрировано пользователем."}
{"id": 341, "text": ".Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение. | `URLEditor` | Может преобразовать строковое представление URL-адреса в реальный объект URL.\nПо умолчанию регистрируется BeanWrapperImpl. |===\n.Встроенный редактор PropertyEditor. [cols=\"30%,70%\"] |=== | Класс| Объяснение.\nSpring использует java.beans.PropertyEditorManager для установки пути поиска свойства. редакторы, которые могут понадобиться.\nПуть поиска также включает `sun.bean.editors`, который включает реализации PropertyEditor для таких типов, как Font, Color и большинства примитивные типы.\nТакже обратите внимание, что стандартная инфраструктура JavaBeans автоматически обнаруживает классы PropertyEditor (без необходимости их регистрации) явно), если они находятся в том же пакете, что и класс, который они обрабатывают, и имеют одинаковый имя этого класса с добавлением `Editor`.\nНапример, можно было бы иметь следующее структуру класса и пакета, которой было бы достаточно для того, чтобы класс `SomethingEditor` был распознается и используется как PropertyEditor для свойств типа Something.\n    pop\n      Something\n      SomethingEditor // PropertyEditor для класса Something\ncom chank.\nОбратите внимание, что здесь вы также можете использовать стандартный механизм JavaBeans `BeanInfo`. (описано в некоторой степени {java-tutorial}/javabeans/advanced/customization.html [здесь])."}
{"id": 342, "text": "В следующем примере используется механизм BeanInfo для явной регистрации одного или нескольких Экземпляры PropertyEditor со свойствами связанного класса:\n    pop\n      Something\n      SomethingBeanInfo // BeanInfo для класса Something\ncom chank.\nСледующий исходный код Java для указанного класса SomethingBeanInfo. связывает CustomNumberEditor со свойством age класса Something:\nJava\n	public class SomethingBeanInfo extends SimpleBeanInfo {\n		public PropertyDescriptor[] getPropertyDescriptors() {\n			try {\n				final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);\n				PropertyDescriptor ageDescriptor = new PropertyDescriptor(\"age\", Something.class) {\n					@Override\n					public PropertyEditor createPropertyEditor(Object bean) {\n						return numberPE;\n				return new PropertyDescriptor[] { ageDescriptor };\n			catch (IntrospectionException ex) {\n				throw new Error(ex.toString());\n	class SomethingBeanInfo : SimpleBeanInfo() {\nПользовательский редактор свойств.\nПри установке свойств компонента в виде строковых значений контейнер Spring IoC в конечном итоге использует стандартные реализации JavaBeans PropertyEditor для преобразования этих строк в сложный тип собственность.\nSpring предварительно регистрирует ряд пользовательских реализаций PropertyEditor (например, для преобразовать имя класса, выраженное в виде строки, в объект «Класс»).\nКроме того, Стандартный механизм поиска JavaBeans `PropertyEditor` позволяет использовать `PropertyEditor`. чтобы класс был назван соответствующим образом и помещен в тот же пакет, что и класс для которого он обеспечивает поддержку, поэтому его можно найти автоматически.\nПользовательский редактор свойств."}
{"id": 343, "text": "Если есть необходимость зарегистрировать другие пользовательские редакторы свойств, можно использовать несколько механизмов. доступен.\nСамый ручной подход, который обычно не удобен и не рекомендуется использовать метод `registerCustomEditor()` Интерфейс ConfigurationBeanFactory, если у вас есть ссылка на BeanFactory.\nДругой (чуть более удобный) механизм — использовать специальную фабрику бобов. постпроцессор под названием CustomEditorConfigurer.\nХотя вы можете использовать постпроцессоры Bean Factory с реализациями BeanFactory, CustomEditorConfigurer имеет настройкой вложенного свойства, поэтому мы настоятельно рекомендуем использовать ее с `ApplicationContext`, где вы можете развернуть его аналогично любому другому компоненту и где его можно автоматически обнаружить и применить.\nПользовательский редактор свойств.\nОбратите внимание, что все фабрики компонентов и контексты приложений автоматически используют ряд встроенные редакторы свойств с помощью BeanWrapper для обрабатывать преобразования свойств.\nСтандартные редакторы свойств, которые использует `BeanWrapper`. регистры перечислены в файле предыдущий раздел.\nКроме того, ApplicationContext также переопределяет или добавляет дополнительные редакторы для обработки поиск ресурсов способом, соответствующим конкретному типу контекста приложения.\nПользовательский редактор свойств.\nСтандартные экземпляры JavaBeans PropertyEditor используются для преобразования значений свойств. выражается в виде строк фактического сложного типа свойства.\nВы можете использовать CustomEditorConfigurer, постпроцессор фабрики компонентов, позволяющий удобно добавлять поддержка дополнительных экземпляров PropertyEditor для ApplicationContext.\nПользовательский редактор свойств.\nРассмотрим следующий пример, в котором определяется пользовательский класс ExoticType и другой класс под названием DependsOnExoticType, для которого в качестве свойства необходимо установить ExoticType:\nJava\n	package example;\n	public class ExoticType {\n		private String name;"}
{"id": 344, "text": "public ExoticType(String name) {\n			this.name = name;\n	public class DependsOnExoticType {\n		private ExoticType type;\n		public void setType(ExoticType type) {\n			this.type = type;\n	package example\n	class DependsOnExoticType {\nПользовательский редактор свойств.\nКогда все настроено правильно, мы хотим иметь возможность назначать свойство типа как строка, которую PropertyEditor преобразует в фактическое значение Экземпляр ExoticType.\nСледующее определение компонента показывает, как установить эту связь:\n	<bean id=\"sample\" class=\"example.DependsOnExoticType\">\n		<property name=\"type\" value=\"aNameForExoticType\"/>\n	</bean>\nJava\n	package example;\n	import java.beans.PropertyEditorSupport;\n	// преобразует строковое представление в объект ExoticType\n	public class ExoticTypeEditor extends PropertyEditorSupport {\n		public void setAsText(String text) {\n			setValue(new ExoticType(text.toUpperCase()));\n	package example\n	// преобразует строковое представление в объект ExoticType\n	class ExoticTypeEditor : PropertyEditorSupport() {\nРеализация PropertyEditor может выглядеть примерно так:.\nНаконец, в следующем примере показано, как использовать CustomEditorConfigurer для регистрации нового PropertyEditor с помощью `ApplicationContext`, который затем сможет использовать его по мере необходимости:\n	<bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n		<property name=\"customEditors\">\n			<map>\n				<entry key=\"example.ExoticType\" value=\"example.ExoticTypeEditor\"/>"}
{"id": 345, "text": "</map>\n		</property>\n	</bean>\n`Редактор свойствРегистратор`.\nДругой механизм регистрации редакторов свойств в контейнере Spring — это создайте и используйте PropertyEditorRegistrar.\nЭтот интерфейс особенно полезен, когда вам нужно использовать один и тот же набор редакторов свойств в нескольких разных ситуациях.\nВы можете написать соответствующий регистратор и повторно использовать его в каждом случае.\nЭкземпляры PropertyEditorRegistrar работают совместно с интерфейсом, называемым `PropertyEditorRegistry`, интерфейс, реализованный Spring `BeanWrapper`. (и DataBinder).\nЭкземпляры PropertyEditorRegistrar особенно удобны. при использовании вместе с CustomEditorConfigurer (описано называется `setPropertyEditorRegistrars(..)`.\nДобавлены экземпляры PropertyEditorRegistrar. таким образом в CustomEditorConfigurer можно легко использовать совместно с DataBinder и Контроллеры Spring MVC.\nКроме того, это позволяет избежать необходимости синхронизации на пользовательских редакторы: ожидается, что PropertyEditorRegistrar создаст новый PropertyEditor. экземпляры для каждой попытки создания компонента.\nJava\n	package com.foo.editors.spring;\n	public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {\n		public void registerCustomEditors(PropertyEditorRegistry registry) {\n			// ожидается, что будут созданы новые экземпляры PropertyEditor.\n			registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());\n			// здесь можно зарегистрировать столько редакторов пользовательских свойств, сколько потребуется...\n	package com.foo.editors.spring\n	class CustomPropertyEditorRegistrar : PropertyEditorRegistrar {\n			// здесь можно зарегистрировать столько редакторов пользовательских свойств, сколько потребуется..."}
{"id": 346, "text": "В следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.\nСм. также пример `org.springframework.beans.support.ResourceEditorRegistrar`.\nРеализация PropertyEditorRegistrar.\nОбратите внимание, как в реализации `registerCustomEditors(..)`, он создает новые экземпляры каждого редактора свойств.\nВ следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.\nВ следующем примере показано, как настроить CustomEditorConfigurer и внедрить экземпляр. нашего CustomPropertyEditorRegistrar в него:\n	<bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n		<property name=\"propertyEditorRegistrars\">\n			<list>\n				<ref bean=\"customPropertyEditorRegistrar\"/>\n			</list>\n		</property>\n	</bean>\n	<bean id=\"customPropertyEditorRegistrar\"\n		class=\"com.foo.editors.spring.CustomPropertyEditorRegistrar\"/>\nВ следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.\nНаконец (и немного отклоняясь от темы этой главы) для тех из вас, используя веб-инфраструктуру Spring MVC, используя `PropertyEditorRegistrar` в сочетании с веб-контроллерами привязки данных может быть очень удобно.\nСледующие В примере используется PropertyEditorRegistrar в реализации метода @InitBinder:\nJava\n	@Controller\n	public class RegisterUserController {\n		private final PropertyEditorRegistrar customPropertyEditorRegistrar;\n		RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {\n			this.customPropertyEditorRegistrar = propertyEditorRegistrar;\n		@InitBinder\n		void initBinder(WebDataBinder binder) {\n			this.customPropertyEditorRegistrar.registerCustomEditors(binder);"}
{"id": 347, "text": "// другие методы, связанные с регистрацией Пользователя\nВ следующем примере показано, как создать собственную реализацию PropertyEditorRegistrar:.\nЭтот стиль регистрации PropertyEditor может привести к созданию лаконичного кода (реализация метода `@InitBinder` имеет длину всего одну строку) и позволяет использовать общий `PropertyEditor` регистрационный код должен быть инкапсулирован в класс, а затем разделен между как можно большим количеством контроллеров. по мере необходимости."}
{"id": 348, "text": "Буферы данных и кодеки.\nJava NIO предоставляет ByteBuffer, но многие библиотеки создают собственный API-интерфейс байтового буфера. особенно для сетевых операций, где повторное использование буферов и/или использование прямых буферов полезно для производительности.\nНапример, Netty имеет иерархию ByteBuf, Jetty использует объединенные байтовые буферы с обратным вызовом, который необходимо освободить, и так далее.\nМодуль Spring-Core предоставляет набор абстракций для работы с различными байтовыми буферами.\nAPI следующим образом:\n* `DataBufferFactory` абстрагирует создание буфера данных.\n* `DataBuffer` представляет собой байтовый буфер, который может быть\n* `DataBufferUtils` предлагает служебные методы для буферов данных.\n* <<Кодеки>> декодируют или кодируют потоки буфера данных в объекты более высокого уровня.\nDataBufferFactory используется для создания буферов данных одним из двух способов:. .\nВыделите новый буфер данных, при необходимости заранее указав емкость, если она известна. более эффективен, даже несмотря на то, что реализации `DataBuffer` могут увеличиваться и уменьшаться по требованию..\nОберните существующий `byte[]` или `java.nio.ByteBuffer`, который украшает данные данными реализация DataBuffer, не требующая выделения.\nDataBufferFactory используется для создания буферов данных одним из двух способов:.\nОбратите внимание, что приложения WebFlux не создают DataBufferFactory напрямую, а вместо этого создают получить к нему доступ через ServerHttpResponse или ClientHttpRequest на стороне клиента."}
{"id": 349, "text": "Тип фабрики зависит от базового клиента или сервера, например: `NettyDataBufferFactory` для Reactor Netty, `DefaultDataBufferFactory` для других.\n`Буфер данных`.\nИнтерфейс DataBuffer предлагает операции, аналогичные java.nio.ByteBuffer, но также дает несколько дополнительных преимуществ, некоторые из которых основаны на Netty `ByteBuf`.\nНиже приведен неполный список преимуществ:\n* Чтение и запись с независимыми позициями, т. е. не требующий вызова `flip()` для\n`Буфер данных`. чередовать чтение и запись.\n* Емкость расширяется по требованию, как и в случае с `java.lang.StringBuilder`.\n* Объединенные буферы и подсчет ссылок через `PooledDataBuffer`.\n* Просмотрите буфер как `java.nio.ByteBuffer`, `InputStream` или `OutputStream`.\n* Определите индекс или последний индекс для данного байта.\n`PooledDataBuffer`.\nКак объяснено в Javadoc для {java-api}/java.base/java/nio/ByteBuffer.html[ByteBuffer], байтовые буферы могут быть прямыми или непрямыми.\nПрямые буферы могут находиться вне кучи Java. что устраняет необходимость копирования для собственных операций ввода-вывода.\nЭто делает прямые буферы особенно полезны для получения и отправки данных через сокет, но они также более дорого создавать и выпускать, что приводит к идее объединения буферов.\n`PooledDataBuffer`."}
{"id": 350, "text": "PooledDataBuffer — это расширение DataBuffer, которое помогает при подсчете ссылок. необходим для пула байтовых буферов.\nКак это работает?\nКогда `PooledDataBuffer` выделенный счетчик ссылок равен 1.\nВызовы `retain()` увеличивают счетчик, в то время как вызовы Release() уменьшают его.\nПока счетчик больше 0, буфер гарантированно не выпустят.\nКогда счетчик уменьшается до 0, буфер пула может быть освобождается, что на практике может означать, что зарезервированная память для буфера возвращается в пул памяти.\n`PooledDataBuffer`.\nОбратите внимание: вместо того, чтобы напрямую работать с PooledDataBuffer, в большинстве случаев лучше использовать удобные методы DataBufferUtils, которые применяют выпуск или сохранение к `DataBuffer`, только если он является экземпляром `PooledDataBuffer`.\n* Объединение потока буферов данных в единый буфер, возможно, с нулевой копией, например, через\nDataBufferUtils предлагает ряд служебных методов для работы с буферами данных:. составные буферы, если это поддерживается базовым API байтового буфера.\n* Превратите `InputStream` или NIO `Channel` в `Flux<DataBuffer>`, и наоборот\nDataBufferUtils предлагает ряд служебных методов для работы с буферами данных:. `Publisher<DataBuffer>` в `OutputStream` или NIO `Channel`.\n* Методы освобождения или сохранения `DataBuffer`, если буфер является экземпляром\nDataBufferUtils предлагает ряд служебных методов для работы с буферами данных:. `PooledDataBuffer`."}
{"id": 351, "text": "* Пропустить или взять из потока байтов до достижения определенного количества байтов.\n* `Encoder` для кодирования `Publisher<T>` в поток буферов данных.\n* `Decoder` для декодирования `Publisher<DataBuffer>` в поток объектов более высокого уровня.\nПакет `org.springframework.core.codec` предоставляет следующие стратегические интерфейсы:.\nМодуль Spring-core предоставляет byte[], ByteBuffer, DataBuffer, Resource и Реализации кодировщика и декодера `String`.\nМодуль Spring-Web добавляет Jackson JSON, Джексон Смайл, JAXB2, протокольные буферы и другие кодеры и декодеры.\nСм.\nИспользование `DataBuffer`.\nПри работе с буферами данных необходимо уделять особое внимание освобождению буферов. поскольку они могут быть в пуле [в пуле].\nМы будем использовать кодеки для иллюстрации как это работает, но эти концепции применимы в более широком смысле.\nДавайте посмотрим, что должны делать кодеки внутренне для управления буферами данных.\nИспользование `DataBuffer`. `Декодер` последним читает буферы входных данных перед созданием более высокого уровня. объекты, и поэтому он должен освободить их следующим образом:\nИспользование `DataBuffer`. .\nЕсли «Декодер» просто читает каждый входной буфер и готов выпустите его немедленно, это можно сделать через `DataBufferUtils.release(dataBuffer)`.."}
{"id": 352, "text": "Если «Декодер» использует операторы «Flux» или «Mono», такие как «FlatMap», «Reduce» и другие, которые предварительно выбирают и кэшируют элементы данных внутри себя или используют такие операторы, как `filter`, `skip` и другие, которые пропускают элементы, затем `doOnDiscard(DataBuffer.class, DataBufferUtils::release)` необходимо добавить в цепочка композиции, чтобы гарантировать, что такие буферы будут освобождены до их удаления, возможно также в результате ошибки или сигнала отмены..\nЕсли «Декодер» каким-либо другим способом удерживает один или несколько буферов данных, он должен убедитесь, что они освобождаются при полном чтении или в случае ошибки или сигналов отмены, которые происходят до того, как кэшированные буферы данных будут прочитаны и освобождены.\nИспользование `DataBuffer`.\nОбратите внимание, что DataBufferUtils#join предлагает безопасный и эффективный способ агрегирования данных. буферный поток в один буфер данных.\nАналогично `skipUntilByteCount` и TakeUntilByteCount — это дополнительные безопасные методы, которые могут использовать декодеры.\nИспользование `DataBuffer`. `Кодировщик` выделяет буферы данных, которые другие должны прочитать (и освободить).\nИтак, «Кодер» особо нечего делать.\nОднако `Кодер` должен позаботиться об освобождении буфера данных, если возникает ошибка сериализации при заполнении буфера данными.\nНапример:\nJava\n	DataBuffer buffer = factory.allocateBuffer();\n	boolean release = true;\n	try {"}
{"id": 353, "text": "// сериализовать и заполнить буфер..\n		release = false;\n	finally {\n		if (release) {\n			DataBufferUtils.release(buffer);\n	return buffer;\nИспользование `DataBuffer`.\nПотребитель «Кодировщика» отвечает за освобождение получаемых им буферов данных.\nВ приложении WebFlux выходные данные «Кодировщика» используются для записи на HTTP-сервер. ответ или HTTP-запрос клиента, и в этом случае освобождение буферов данных является ответственность за запись кода в ответ сервера или в запрос клиента.\nИспользование `DataBuffer`.\nОбратите внимание, что при работе в Netty имеются параметры отладки для https://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks [устранение проблем с утечками буфера]."}
{"id": 354, "text": "Декларативное управление транзакциями.\nПРИМЕЧАНИЕ.\nБольшинство пользователей Spring Framework выбирают декларативное управление транзакциями.\nЭтот вариант имеет наименьшее влияние на код приложения и, следовательно, наиболее соответствует идеалам неинвазивный легкий контейнер.\nДекларативное управление транзакциями Spring Framework стало возможным благодаря Spring. аспектно-ориентированное программирование (АОП).\nОднако, поскольку код транзакционных аспектов с дистрибутивом Spring Framework и может использоваться в шаблонном режиме, AOP Обычно не обязательно понимать концепции, чтобы эффективно использовать этот код.\nДекларативное управление транзакциями Spring Framework похоже на EJB CMT в том смысле, что вы можете указать поведение транзакции (или его отсутствие) вплоть до уровня отдельного метода.\nВы можете выполнить вызов setRollbackOnly() в контексте транзакции, если необходимо.\nРазличия между двумя типами управления транзакциями заключаются в следующем:\n* В отличие от EJB CMT, который привязан к JTA, декларативная транзакция Spring Framework\nДекларативное управление транзакциями. управление работает в любой среде.\nОн может работать с транзакциями JTA или локальными транзакции с использованием JDBC, JPA или Hibernate путем настройки конфигурации файлы.\n* Вы можете применить декларативное управление транзакциями Spring Framework к любому классу.\nДекларативное управление транзакциями. а не просто специальные классы, такие как EJB.\n* Spring Framework предлагает декларативный\nДекларативное управление транзакциями. эквивалент.\nПредоставляется как программная, так и декларативная поддержка правил отката.\n* Spring Framework позволяет настраивать поведение транзакций с помощью АОП.\nДекларативное управление транзакциями."}
{"id": 355, "text": "Например, вы можете вставить собственное поведение в случае отката транзакции. ты может также добавить произвольный совет наряду с советом по транзакциям.\nС EJB CMT вы не может влиять на управление транзакциями контейнера, за исключением случаев, когда `setRollbackOnly()`.\n* Spring Framework не поддерживает распространение контекстов транзакций между\nДекларативное управление транзакциями. удаленные вызовы, как это делают высокопроизводительные серверы приложений.\nЕсли вам нужна эта функция, мы рекомендую вам использовать EJB.\nОднако прежде чем использовать такую функцию, подумайте внимательно: потому что обычно никто не хочет, чтобы транзакции охватывали удаленные вызовы.\nДекларативное управление транзакциями.\nКонцепция правил отката важна.\nОни позволяют указать, какие исключения (и метательные объекты) должны вызывать автоматический откат.\nВы можете указать это декларативно, в конфигурации, а не в коде Java.\nИтак, хотя вы все равно можете вызвать setRollbackOnly() объект TransactionStatus для отката текущей транзакции, чаще всего вы можно указать правило, согласно которому MyApplicationException всегда должно приводить к откату. существенным преимуществом этого варианта является то, что бизнес-объекты не зависят от Транзакционная инфраструктура.\nНапример, им обычно не нужно импортировать Spring.\nAPI транзакций или другие API Spring.\nДекларативное управление транзакциями."}
{"id": 356, "text": "Хотя поведение EJB-контейнера по умолчанию автоматически откатывает транзакцию на системное исключение (обычно исключение времени выполнения), EJB CMT не откатывает транзакция автоматически при исключении приложения (т. е. проверенном исключении кроме `java.rmi.RemoteException`).\nХотя поведение Spring по умолчанию для декларативное управление транзакциями соответствует соглашению EJB (откат происходит автоматически только для непроверенных исключений), часто бывает полезно настроить это поведение."}
{"id": 357, "text": "Сервлет по умолчанию.\nSpring MVC позволяет сопоставлять `DispatcherServlet` с `/` (таким образом переопределяя сопоставление сервлета контейнера по умолчанию), при этом позволяя выполнять запросы статических ресурсов. обрабатывается сервлетом контейнера по умолчанию.\nОн настраивает `DefaultServletHttpRequestHandler` с сопоставлением URL-адресов `/**` и самым низким приоритетом. относительно других сопоставлений URL-адресов.\nСервлет по умолчанию.\nЭтот обработчик пересылает все запросы сервлету по умолчанию.\nСледовательно, оно должно остаются последними в порядке всех остальных URL-адресов HandlerMappings.\nЭто случае, если вы используете `<mvc:annotation-driven>`.\nАльтернативно, если вы настроите собственный настроенный экземпляр HandlerMapping, обязательно установите для его свойства order значение ниже, чем у DefaultServletHttpRequestHandler, который равен Integer.MAX_VALUE.\nСервлет по умолчанию.\nВ следующем примере показано, как включить эту функцию, используя настройки по умолчанию: См. пример кода в исходном документе.\nСервлет по умолчанию.\nПредостережение относительно переопределения сопоставления сервлетов `/` заключается в том, что `RequestDispatcher` для Сервлет по умолчанию должен быть получен по имени, а не по пути. `DefaultServletHttpRequestHandler` пытается автоматически определить сервлет по умолчанию для контейнер во время запуска, используя список известных имен для большинства основных сервлетов контейнеры (включая Tomcat, Jetty, GlassFish, JBoss, WebLogic и WebSphere)."}
{"id": 358, "text": "Если сервлет по умолчанию был настроен под другим именем или если используется другой контейнер сервлетов, где имя сервлета по умолчанию неизвестно, тогда вы должны явно указать имя сервлета по умолчанию, как показано в следующем примере: См. пример кода в исходном документе."}
{"id": 359, "text": "Обзор компонента.\nКонтейнер Spring IoC управляет одним или несколькими компонентами.\nЭти бобы созданы с помощью метаданные конфигурации, которые вы предоставляете в контейнер (например, в форме XML определения `<bean/>`).\nОбзор компонента.\nВнутри самого контейнера эти определения bean-компонентов представлены как BeanDefinition. объекты, которые содержат (помимо прочей информации) следующие метаданные:\n* Имя класса с указанием пакета: обычно это фактический класс реализации\nОбзор компонента. bean-компонент определяется.\n* Элементы конфигурации поведения компонента, которые определяют, как компонент должен вести себя в\nОбзор компонента. контейнер (область действия, обратные вызовы жизненного цикла и т. д.).\n* Ссылки на другие bean-компоненты, необходимые для выполнения bean-компонентом своей работы. Эти\nОбзор компонента. ссылки также называются соавторами или зависимостями.\n* Другие параметры конфигурации, которые необходимо установить во вновь созданном объекте — например, размер\nОбзор компонента. ограничение пула или количества соединений, используемых в компоненте, который управляет пул соединений.\nОбзор компонента.\nЭти метаданные преобразуются в набор свойств, которые составляют определение каждого компонента.\nВ следующей таблице описаны эти свойства:\nОбзор компонента. .Определение компонента |=== | Недвижимость| Объяснено в...\n| Метод уничтожения | Обратные вызовы разрушения |===."}
{"id": 360, "text": "Помимо определений компонентов, содержащих информацию о том, как создать конкретный bean, реализации `ApplicationContext` также позволяют регистрировать существующие объекты, созданные вне контейнера (пользователями).\nЭто делается путем доступа к `BeanFactory` ApplicationContext через метод `getAutowireCapableBeanFactory()`, который возвращает реализацию DefaultListableBeanFactory. `DefaultListableBeanFactory` поддерживает эту регистрацию через `registerSingleton(..)` и `registerBeanDefinition(..)` методы.\nОднако типичные приложения работают исключительно с компонентами, определенными посредством обычных Метаданные определения компонента.\n| Метод уничтожения | Обратные вызовы разрушения |===. [ПРИМЕЧАНИЕ] = Метаданные компонента и экземпляры Singleton, предоставленные вручную, необходимо зарегистрировать как можно раньше. насколько это возможно, чтобы контейнер правильно рассуждал о них во время автопроводки и другие шаги самоанализа.\nПри переопределении существующих метаданных и существующих в некоторой степени поддерживаются экземпляры Singleton, регистрация новых bean-компонентов в среда выполнения (одновременно с живым доступом к фабрике) официально не поддерживается и может привести к исключениям одновременного доступа, несогласованному состоянию в контейнере компонентов или к тому и другому.\nПереопределение компонентов.\nПереопределение компонента происходит, когда компонент регистрируется с использованием идентификатора, который уже выделено.\nХотя переопределение bean-компонента возможно, оно затрудняет чтение конфигурации.\nПереопределение компонентов.\nВНИМАНИЕ: переопределение bean-компонентов будет прекращено в будущем выпуске.\nПереопределение компонентов."}
{"id": 361, "text": "Чтобы полностью отключить переопределение bean-компонента, вы можете установить `allowBeanDefinitionOverriding` установите флаг false в ApplicationContext перед его обновлением.\nВ такой установке Исключение выдается, если используется переопределение компонента.\nПереопределение компонентов.\nПо умолчанию контейнер регистрирует каждую попытку переопределить компонент на уровне INFO, чтобы вы можете соответствующим образом адаптировать свою конфигурацию.\nХотя это и не рекомендуется, вы можете отключить эти журналы, установив для флагаallowBeanDefinitionOverriding значение true.\nПереопределение компонентов. .Конфигурация Java **** Если вы используете конфигурацию Java, соответствующий метод @Bean всегда автоматически переопределяет отсканированный класс bean-компонента с тем же именем компонента, что и возвращаемый тип Метод `@Bean` соответствует этому классу компонента.\nЭто просто означает, что контейнер вызовет фабричный метод `@Bean` в пользу любого предварительно объявленного конструктора в классе компонента. ****\nПереопределение компонентов.\nПРИМЕЧАНИЕ.\nМы признаем, что переопределение bean-компонентов в тестовых сценариях удобно, и существует явная поддержка этого.\nПожалуйста, обратитесь к\nИменование компонентов.\nКаждый компонент имеет один или несколько идентификаторов.\nЭти идентификаторы должны быть уникальными в пределах контейнер, в котором размещается компонент.\nКомпонент обычно имеет только один идентификатор.\nОднако, если это требуется более одного, лишние можно считать псевдонимами.\nИменование компонентов.\nВ метаданных конфигурации на основе XML вы используете атрибут `id`, атрибут `name` или оба для указания идентификаторов bean-компонентов."}
{"id": 362, "text": "Атрибут `id` позволяет указать ровно один `id`.\nОбычно эти имена буквенно-цифровые («myBean», «someService» и т. д.), но они также может содержать специальные символы.\nЕсли вы хотите ввести другие псевдонимы для bean, вы также можете указать их в атрибуте `name`, разделив их запятой (`,`), точка с запятой (`;`) или пробел.\nХотя атрибут `id` определен как Тип `xsd:string`, уникальность bean `id` обеспечивается контейнером, но не XML парсеры.\nИменование компонентов.\nВам не требуется указывать имя или идентификатор компонента.\nЕсли вы не предоставите `name` или `id` явно, контейнер генерирует уникальное имя для этого компонента.\nОднако, если вы хотите обратиться к этому компоненту по имени, используя элемент `ref` или Для поиска в стиле Service Locator необходимо указать имя.\nМотивы не предоставления имени связаны с использованием inner beans и соавторы автопроводки.\nИменование компонентов. .Соглашения об именах компонентов **** Соглашение заключается в использовании стандартного соглашения Java для имен полей экземпляров, когда называние фасоли.\nТо есть имена компонентов начинаются со строчной буквы и имеют верблюжий регистр. оттуда.\nПримеры таких имен включают `accountManager`, `accountService`, `userDao`, `loginController` и т. д.\nИменование компонентов."}
{"id": 363, "text": "Последовательное именование bean-компонентов упрощает чтение и понимание вашей конфигурации.\nКроме того, если вы используете Spring AOP, это очень помогает при применении советов к набору компонентов. связанные по имени. ****\nИменование компонентов.\nПРИМЕЧАНИЕ.\nПри сканировании компонентов в пути к классам Spring генерирует имена компонентов для безымянных компонентов. компоненты, следуя правилам, описанным ранее: по сути, взяв простое имя класса и переводим его первоначальный символ в нижний регистр.\nОднако в (необычном) специальном случай, когда имеется более одного символа и первый, и второй символы написаны в верхнем регистре, исходный регистр сохраняется.\nЭто те же правила, что и определяется `java.beans.Introspector.decapitalize` (который здесь использует Spring).\nИспользование псевдонима для компонента вне определения компонента.\nВ самом определении компонента вы можете указать более одного имени компонента, используя комбинация до одного имени, указанного атрибутом `id`, и любого количества других имена в атрибуте `name`.\nЭти имена могут быть эквивалентными псевдонимами одного и того же компонента. и полезны в некоторых ситуациях, например, когда каждый компонент приложения ссылайтесь на общую зависимость, используя имя компонента, специфичное для этого компонента. сам.\nИспользование псевдонима для компонента вне определения компонента.\nУказание всех псевдонимов, в которых фактически определен компонент, не всегда адекватно. однако.\nИногда желательно ввести псевдоним для компонента, который определен в другом месте."}
{"id": 364, "text": "Обычно это происходит в больших системах, где конфигурация разделена. среди каждой подсистемы, причем каждая подсистема имеет свой собственный набор определений объектов.\nВ метаданных конфигурации на основе XML вы можете использовать элемент `<alias/>` для выполнения это.\nВ следующем примере показано, как это сделать:\n	<alias name=\"fromName\" alias=\"toName\"/>\nИспользование псевдонима для компонента вне определения компонента.\nВ этом случае bean-компонент (в том же контейнере) с именем fromName также может: после использования этого определения псевдонима будет называться «toName».\nИспользование псевдонима для компонента вне определения компонента.\nНапример, метаданные конфигурации для подсистемы A могут ссылаться на источник данных по имя `subsystemA-dataSource`.\nМетаданные конфигурации для подсистемы B могут относиться к источник данных по имени subsystemB-dataSource.\nПри составлении основного приложения использующее обе эти подсистемы, основное приложение обращается к источнику данных по имя `myApp-dataSource`.\nЧтобы все три имени относились к одному и тому же объекту, вы можете добавьте следующие определения псевдонимов в метаданные конфигурации:\n	<alias name=\"myApp-dataSource\" alias=\"subsystemA-dataSource\"/>\n	<alias name=\"myApp-dataSource\" alias=\"subsystemB-dataSource\"/>\nИспользование псевдонима для компонента вне определения компонента."}
{"id": 365, "text": "Теперь каждый компонент и основное приложение могут ссылаться на источник данных по имени. которое является уникальным и гарантированно не противоречит никакому другому определению (фактически создание пространства имен), но они ссылаются на один и тот же компонент.\nИспользование псевдонима для компонента вне определения компонента. .Java-конфигурация **** Если вы используете конфигурацию Java, аннотацию @Bean можно использовать для предоставления псевдонимов.\nДополнительную информацию см. в Использование аннотации `@Bean`. ****\nСоздание экземпляров Beans.\nОпределение компонента — это, по сути, рецепт создания одного или нескольких объектов. контейнер просматривает рецепт именованного компонента, когда его об этом спрашивают, и использует конфигурацию метаданные, инкапсулированные определением этого компонента, для создания (или получения) реального объекта.\nСоздание экземпляров Beans.\nЕсли вы используете метаданные конфигурации на основе XML, вы указываете тип (или класс) объекта. который должен быть создан в атрибуте `class` элемента `<bean/>`.\nЭто Атрибут `class` (который внутренне является свойством `Class` в `BeanDefinition` экземпляр) обычно является обязательным. (Исключения см. и Наследование определения компонента.) Вы можете использовать свойство Class одним из двух способов:\n* Обычно для указания класса компонента, который будет создан в случае, когда контейнер\nСоздание экземпляров Beans. сам непосредственно создает компонент, рефлексивно вызывая его конструктор, что-то вроде эквивалентно коду Java с оператором new."}
{"id": 366, "text": "* Чтобы указать фактический класс, содержащий статический фабричный метод, который\nСоздание экземпляров Beans. вызывается для создания объекта, в менее распространенном случае, когда контейнер вызывает `статический` фабричный метод класса для создания компонента.\nВозвращенный тип объекта при вызове `статического` фабричного метода может быть тот же или другой класс класс целиком.\nСоздание экземпляров Beans. .Имена вложенных классов **** Если вы хотите настроить определение компонента для вложенного класса, вы можете использовать либо метод двоичное имя или исходное имя вложенного класса.\nСоздание экземпляров Beans.\nНапример, если у вас есть класс SomeThing в пакете com.example и этот класс `SomeThing` имеет `статический` вложенный класс под названием `OtherThing`, они могут быть разделяются знаком доллара (`$`) или точкой (`.`).\nТаким образом, значение атрибута class в определением компонента будет `com.example.SomeThing$OtherThing` или `com.example.SomeThing.OtherThing`. ****\nСоздание экземпляра с помощью конструктора.\nКогда вы создаете компонент с помощью конструктора, все обычные классы могут использоваться и совместим с Spring.\nТо есть разрабатываемый класс не нуждается в реализации любые конкретные интерфейсы или быть закодированы определенным образом.\nПросто указание bean-компонента класса должно хватить.\nОднако в зависимости от того, какой тип IoC вы используете для этого конкретного bean, вам может понадобиться конструктор по умолчанию (пустой)."}
{"id": 367, "text": "Создание экземпляра с помощью конструктора.\nКонтейнер Spring IoC может управлять практически любым классом, которым вы хотите управлять.\nЭто не ограничивается управлением настоящими JavaBeans.\nБольшинство пользователей Spring предпочитают настоящие JavaBeans с моделируются только конструктор по умолчанию (без аргументов) и соответствующие сеттеры и геттеры после свойств в контейнере.\nВы также можете попробовать более экзотические блюда в стиле без бобов. классы в вашем контейнере.\nЕсли, например, вам нужно использовать устаревший пул соединений который абсолютно не соответствует спецификации JavaBean, Spring может управлять им как ну.\nСоздание экземпляра с помощью конструктора.\nС помощью метаданных конфигурации на основе XML вы можете указать свой класс bean-компонента следующим образом:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\"/>\n	<bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>\nСоздание экземпляра с помощью конструктора.\nПодробно о механизме передачи аргументов конструктору (если требуется) и установка свойств экземпляра объекта после его создания, см.\nСоздание экземпляра с помощью конструктора.\nПРИМЕЧАНИЕ.\nВ случае аргументов конструктора контейнер может выбрать соответствующий конструктор среди нескольких перегруженных конструкторов.\nПри этом, чтобы избежать двусмысленностей, рекомендуется сделать подписи конструктора максимально простыми.\nСоздание экземпляра с помощью статического фабричного метода."}
{"id": 368, "text": "При определении bean-компонента, который вы создаете с помощью статического фабричного метода, используйте класс атрибут, чтобы указать класс, который содержит `статический` фабричный метод и атрибут с именем `factory-method`, чтобы указать имя самого фабричного метода.\nВы должны быть возможность вызвать этот метод (с необязательными аргументами, как описано ниже) и вернуть живой объект, который впоследствии обрабатывается так, как если бы он был создан с помощью конструктора.\nОдно из применений такого определения компонента — вызов «статических» фабрик в устаревшем коде.\nСоздание экземпляра с помощью статического фабричного метода.\nСледующее определение компонента указывает, что компонент будет создан путем вызова заводской метод.\nВ определении не указан тип (класс) возвращаемого объекта, а скорее класс, содержащий фабричный метод.\nВ этом примере Метод createInstance() должен быть статическим.\nВ следующем примере показано, как укажите фабричный метод:\n	<bean id=\"clientService\"\n		class=\"examples.ClientService\"\n		factory-method=\"createInstance\"/>\nСоздание экземпляра с помощью статического фабричного метода.\nВ следующем примере показан класс, который будет работать с предыдущим определением компонента:\nJava\n	public class ClientService {\n		private static ClientService clientService = new ClientService();\n		private ClientService() {}\n		public static ClientService createInstance() {\n			return clientService;\nСоздание экземпляра с помощью статического фабричного метода."}
{"id": 369, "text": "Подробности о механизме предоставления (необязательных) аргументов фабричному методу. и установка свойств экземпляра объекта после того, как объект возвращается с фабрики, см. подробные сведения о зависимостях и конфигурации.\nСоздание экземпляра с помощью статического фабричного метода.\nПРИМЕЧАНИЕ.\nВ случае аргументов фабричного метода контейнер может выбрать соответствующий метод среди нескольких перегруженных методов с тем же именем.\nПри этом, чтобы избежать двусмысленностей, рекомендуется сделать сигнатуры фабричных методов максимально простыми.\nСоздание экземпляра с помощью статического фабричного метода. [СОВЕТ] = Типичным проблемным случаем с перегрузкой фабричных методов является Mockito с его многочисленными перегрузки метода `mock`.\nВыберите наиболее конкретный вариант «макета»:\n	<bean id=\"clientService\" class=\"org.mockito.Mockito\" factory-method=\"mock\">\n		<constructor-arg type=\"java.lang.Class\" value=\"examples.ClientService\"/>\n		<constructor-arg type=\"java.lang.String\" value=\"clientService\"/>\n	</bean>\nСоздание экземпляра с использованием метода фабрики экземпляра.\nАналогично созданию экземпляра через метод [статический фабричный метод] создание экземпляра с помощью фабричного метода экземпляра вызывает нестатический метод существующего компонента из контейнера для создания нового компонента."}
{"id": 370, "text": "Чтобы использовать это механизм, оставьте атрибут class пустым, а в атрибуте Factory-Bean укажите укажите имя bean-компонента в текущем (или родительском, или предковом) контейнере, который содержит метод экземпляра, который должен быть вызван для создания объекта.\nУстановите имя сам фабричный метод с атрибутом Factory-method.\nСледующий пример показывает как настроить такой bean:\n	<!-- the factory bean, which contains a method called createClientServiceInstance() -->\n	<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n		<!-- inject any dependencies required by this locator bean -->\n	</bean>\n	<!-- the bean to be created via the factory bean -->\n	<bean id=\"clientService\"\n		factory-bean=\"serviceLocator\"\n		factory-method=\"createClientServiceInstance\"/>\nJava\n	public class DefaultServiceLocator {\n		private static ClientService clientService = new ClientServiceImpl();\n		public ClientService createClientServiceInstance() {\n			return clientService;\nВ следующем примере показан соответствующий класс:.\nОдин фабричный класс также может содержать более одного фабричного метода, как показано в следующем примере:\n	<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n		<!-- inject any dependencies required by this locator bean -->\n	</bean>\n	<bean id=\"clientService\"\n		factory-bean=\"serviceLocator\""}
{"id": 371, "text": "factory-method=\"createClientServiceInstance\"/>\n	<bean id=\"accountService\"\n		factory-bean=\"serviceLocator\"\n		factory-method=\"createAccountServiceInstance\"/>\nJava\n	public class DefaultServiceLocator {\n		private static ClientService clientService = new ClientServiceImpl();\n		private static AccountService accountService = new AccountServiceImpl();\n		public ClientService createClientServiceInstance() {\n			return clientService;\n		public AccountService createAccountServiceInstance() {\n			return accountService;\nВ следующем примере показан соответствующий класс:.\nЭтот подход показывает, что самим фабричным компонентом можно управлять и настраивать его с помощью внедрение зависимостей (DI).\nСм.\nПодробные сведения о зависимостях и конфигурации.\nВ следующем примере показан соответствующий класс:.\nПРИМЕЧАНИЕ.\nВ документации Spring «фабричный компонент» относится к компоненту, настроенному в Spring-контейнер, который создает объекты через `FactoryBean` (обратите внимание на заглавные буквы) относится к специфичному для Spring\nОпределение типа выполнения компонента.\nТип времени выполнения конкретного bean-компонента определить непросто.\nУказанный класс в определение метаданных компонента — это просто начальная ссылка на класс, потенциально объединенная с объявленным фабричным методом или являющимся классом FactoryBean, что может привести к другой тип времени выполнения bean-компонента или вообще не установлен в случае уровня экземпляра фабричный метод (который вместо этого разрешается через указанное имя Factory-Bean)."}
{"id": 372, "text": "Кроме того, прокси-сервер AOP может обернуть экземпляр компонента прокси-сервером на основе интерфейса с ограниченное раскрытие фактического типа целевого компонента (только его реализованные интерфейсы).\nОпределение типа выполнения компонента.\nРекомендуемый способ узнать о фактическом типе среды выполнения конкретного компонента: вызов BeanFactory.getType для указанного имени компонента.\nЭто требует всего вышеперечисленного учитывает все случаи и возвращает тип объекта, который вызывает вызов `BeanFactory.getBean`. собираюсь вернуться за тем же именем компонента."}
{"id": 373, "text": "Зависимости.\nТипичное корпоративное приложение не состоит из одного объекта (или компонента в Весенний разговор).\nДаже самое простое приложение имеет несколько объектов, которые работают вместе для представить то, что конечный пользователь видит как целостное приложение.\nВ следующем разделе объясняется, как вы переходите от определения ряда самостоятельных определений компонентов к полностью реализованному приложение, в котором объекты взаимодействуют для достижения цели."}
{"id": 374, "text": "Настройка различной транзакционной семантики для разных компонентов.\nРассмотрим сценарий, в котором у вас есть несколько объектов уровня обслуживания, и вы хотите применить совершенно другую конфигурацию транзакций к каждому из них.\nВы можете сделать это путем определения отдельных элементов `<aop:advisor/>` с разными `pointcut` и Значения атрибута advice-ref.\nНастройка различной транзакционной семантики для разных компонентов.\nДля сравнения сначала предположим, что все ваши классы уровня обслуживания определено в корневом пакете `x.y.service`.\nЧтобы сделать все bean-компоненты, являющиеся экземплярами классов определенные в этом пакете (или в подпакетах) и имеющие имена, заканчивающиеся на `Service`, имеют конфигурации транзакций по умолчанию, вы можете написать следующее:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans"}
{"id": 375, "text": "https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<aop:config>\n			<aop:pointcut id=\"serviceOperation\"\n					expression=\"execution(* x.y.service..*Service.*(..))\"/>\n			<aop:advisor pointcut-ref=\"serviceOperation\" advice-ref=\"txAdvice\"/>\n		</aop:config>\n		<!-- these two beans will be transactional... -->\n		<bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n		<bean id=\"barService\" class=\"x.y.service.extras.SimpleBarService\"/>\n		<!-- ... and these two beans won't -->\n		<bean id=\"anotherService\" class=\"org.xyz.SomeService\"/> <!-- (not in the right package) -->"}
{"id": 376, "text": "<bean id=\"barManager\" class=\"x.y.service.SimpleBarManager\"/> <!-- (doesn't end in 'Service') -->\n		<tx:advice id=\"txAdvice\">\n			<tx:attributes>\n				<tx:method name=\"get*\" read-only=\"true\"/>\n				<tx:method name=\"*\"/>\n			</tx:attributes>\n		</tx:advice>\n		<!-- other transaction infrastructure beans such as a TransactionManager omitted... -->\n	</beans>\nНастройка различной транзакционной семантики для разных компонентов.\nВ следующем примере показано, как настроить два разных компонента с совершенно разными настройки транзакции:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans"}
{"id": 377, "text": "https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<aop:config>\n			<aop:pointcut id=\"defaultServiceOperation\"\n					expression=\"execution(* x.y.service.*Service.*(..))\"/>\n			<aop:pointcut id=\"noTxServiceOperation\"\n					expression=\"execution(* x.y.service.ddl.DefaultDdlManager.*(..))\"/>\n			<aop:advisor pointcut-ref=\"defaultServiceOperation\" advice-ref=\"defaultTxAdvice\"/>\n			<aop:advisor pointcut-ref=\"noTxServiceOperation\" advice-ref=\"noTxAdvice\"/>\n		</aop:config>\n		<!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) -->\n		<bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>"}
{"id": 378, "text": "<!-- this bean will also be transactional, but with totally different transactional settings -->\n		<bean id=\"anotherFooService\" class=\"x.y.service.ddl.DefaultDdlManager\"/>\n		<tx:advice id=\"defaultTxAdvice\">\n			<tx:attributes>\n				<tx:method name=\"get*\" read-only=\"true\"/>\n				<tx:method name=\"*\"/>\n			</tx:attributes>\n		</tx:advice>\n		<tx:advice id=\"noTxAdvice\">\n			<tx:attributes>\n				<tx:method name=\"*\" propagation=\"NEVER\"/>\n			</tx:attributes>\n		</tx:advice>\n		<!-- other transaction infrastructure beans such as a TransactionManager omitted... -->\n	</beans>"}
{"id": 379, "text": "`ДиспетчерХандлер`.\nSpring WebFlux, как и Spring MVC, разработан на основе шаблона фронт-контроллера. где центральный WebHandler, DispatcherHandler, предоставляет общий алгоритм для обработка запросов, в то время как фактическая работа выполняется настраиваемыми компонентами делегирования.\nЭта модель является гибкой и поддерживает разнообразные рабочие процессы.\n`ДиспетчерХандлер`.\nDispatcherHandler обнаруживает необходимые ему компоненты делегата из конфигурации Spring.\nОн также спроектирован как bean-компонент Spring и реализует ApplicationContextAware. для доступа к контексту, в котором он работает.\nЕсли DispatcherHandler объявлен с помощью bean-компонента имя `webHandler`, оно, в свою очередь, обнаруживается {spring-framework-api}/web/server/adapter/WebHttpHandlerBuilder.html[`WebHttpHandlerBuilder`], который объединяет цепочку обработки запросов, как описано в\n* `DispatcherHandler` с именем bean-компонента `webHandler`\n* Компоненты `WebFilter` и `WebExceptionHandler`\n* специальные компоненты `DispatcherHandler`\n* Другие\nКонфигурация Spring в приложении WebFlux обычно содержит:.\nКонфигурация передается WebHttpHandlerBuilder для построения цепочки обработки. как показано в следующем примере:\nJava\n	ApplicationContext context = ...\n	HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();\nСпециальные типы бобов.\nDispatcherHandler делегирует специальные bean-компоненты для обработки запросов и рендеринга. соответствующие ответы.\nПод «специальными компонентами» мы подразумеваем управляемые Spring экземпляры Object, которые реализовать контракты платформы WebFlux."}
{"id": 380, "text": "Обычно они имеют встроенные контракты, но вы можете настроить их свойства, расширить или заменить их.\nСпециальные типы бобов.\nВ следующей таблице перечислены специальные bean-компоненты, обнаруженные DispatcherHandler.\nОбратите внимание, что есть также некоторые другие компоненты, обнаруженные на более низком уровне (см. в API веб-обработчика).\n[cols=\"1,2\", options=\"header\"] |=== | Тип фасоли | Объяснение. | `HandlerMapping` | Сопоставьте запрос с обработчиком.\nСопоставление основано на некоторых критериях, деталях которые различаются в зависимости от реализации HandlerMapping — аннотированные контроллеры, простые Сопоставления шаблонов URL-адресов и другие.\n[cols=\"1,2\", options=\"header\"] |=== | Тип фасоли | Объяснение.\nОсновными реализациями HandlerMapping являются RequestMappingHandlerMapping для Аннотированные методы @RequestMapping, RouterFunctionMapping для функциональной конечной точки. маршруты и SimpleUrlHandlerMapping для явной регистрации шаблонов путей URI. и экземпляры WebHandler.\n[cols=\"1,2\", options=\"header\"] |=== | Тип фасоли | Объяснение. | `Адаптер Обработчика` | Помогите DispatcherHandler вызвать обработчик, сопоставленный с запросом, независимо от как на самом деле вызывается обработчик.\nНапример, вызов аннотированного контроллера требует разрешения аннотаций.\nОсновная цель HandlerAdapter — защитить `DispatcherHandler` из таких подробностей."}
{"id": 381, "text": "[cols=\"1,2\", options=\"header\"] |=== | Тип фасоли | Объяснение. | `HandlerResultHandler` | Обработайте результат вызова обработчика и завершите ответ.\nСм. ссылку:web/webflux/dispatcher-handler.adoc#webflux-resulthandling [Обработка результатов].\nКонфигурация WebFlux.\nПриложения могут объявлять инфраструктурные компоненты (перечисленные в разделе которые необходимы для обработки запросов.\nОднако в большинстве случаев это лучшая отправная точка.\nОн объявляет необходимые bean-компоненты и обеспечивает более высокий уровень API обратного вызова конфигурации для его настройки.\nКонфигурация WebFlux.\nПРИМЕЧАНИЕ.\nSpring Boot использует конфигурацию WebFlux для настройки Spring WebFlux, а также предоставляет множество дополнительных удобных опций.\n* Каждому `HandlerMapping` предлагается найти соответствующий обработчик, и используется первое совпадение.\n* Если обработчик найден, он запускается через соответствующий `HandlerAdapter`, который\nDispatcherHandler обрабатывает запросы следующим образом:. предоставляет возвращаемое значение выполнения как HandlerResult.\n* HandlerResult передается соответствующему HandlerResultHandler для завершения\nDispatcherHandler обрабатывает запросы следующим образом:. обработка путем прямой записи ответа или использования представления для рендеринга.\nОбработка результатов.\nВозвращаемое значение вызова обработчика через HandlerAdapter упаковывается как HandlerResult вместе с некоторым дополнительным контекстом и передается первому `HandlerResultHandler`, который заявляет о его поддержке.\nВ следующей таблице показаны доступные Реализации HandlerResultHandler, все из которых объявлены в"}
{"id": 382, "text": "Обработка результатов. [cols=\"1,2,1\", options=\"header\"] |=== | Тип обработчика результатов | Возвращаемые значения | Порядок по умолчанию\nОбработка результатов. | `ResponseEntityResultHandler` | `ResponseEntity`, обычно из экземпляров `@Controller`.\nОбработка результатов. | `ServerResponseResultHandler` | `ServerResponse`, обычно от функциональных конечных точек.\nОбработка результатов. | `ResponseBodyResultHandler` | Обрабатывать возвращаемые значения из методов @ResponseBody или классов @RestController. | 100\nОбработка результатов. | `ViewResolutionResultHandler` | `CharSequence`, {spring-framework-api}/web/reactive/result/view/View.html[`View`], {spring-framework-api}/ui/Model.html[Модель], `Карта`, {spring-framework-api}/web/reactive/result/view/Rendering.html[Визуализация], или любой другой «Объект» рассматривается как атрибут модели.\nОбработка результатов.\nСм. также ссылку:web/webflux/dispatcher-handler.adoc#webflux-viewsolve [Разрешение просмотра]. | `Целое.MAX_VALUE`\nИсключения.\nРеализации HandlerAdapter могут обрабатывать внутренние исключения при вызове запроса. обработчик, например метод контроллера.\nОднако исключение может быть отложено, если запрос обработчик возвращает асинхронное значение.\nИсключения."}
{"id": 383, "text": "HandlerAdapter может предоставлять свой механизм обработки исключений как `DispatchExceptionHandler` устанавливается на `HandlerResult`, который он возвращает.\nКогда это будет установлено, DispatcherHandler также применит его к обработке результата.\nИсключения.\nHandlerAdapter также может реализовать DispatchExceptionHandler.\nВ этом случае DispatcherHandler применит его к исключениям, возникающим до отображения обработчика. например, во время сопоставления обработчика или ранее, например, в `WebFilter`.\nИсключения.\nСм. также ссылку:web/webflux/controller/ann-Exceptions.adoc[Exceptions] в разделе «Аннотированный контроллер» или\nПосмотреть разрешение.\nРазрешение просмотра позволяет выполнять рендеринг в браузере с помощью HTML-шаблона и модели без привязывая вас к определенной технологии просмотра.\nВ Spring WebFlux разрешение просмотра равно поддерживается через специальную ссылку:web/webflux/dispatcher-handler.adoc#webflux-resulthandling[HandlerResultHandler] который использует экземпляры ViewResolver для сопоставления строки (представляющей имя логического представления) с экземпляр `View`.\nЗатем View используется для отображения ответа.\nПосмотреть разрешение.\nВеб-приложениям необходимо использовать библиотеку рендеринга просмотра для поддержки этого варианта использования.\nОбращение.\nHandlerResult, переданный в ViewResolutionResultHandler, содержит возвращаемое значение. из обработчика и модели, содержащей атрибуты, добавленные во время запроса обработка.\nВозвращаемое значение обрабатывается как одно из следующих:\n* `String`, `CharSequence`: логическое имя представления, которое должно быть преобразовано в `View` через\nОбращение. список настроенных реализаций ViewResolver."}
{"id": 384, "text": "* `void`: выберите имя представления по умолчанию на основе пути запроса за вычетом начального и\nОбращение. завершающую косую черту и преобразуйте ее в «View».\nТо же самое происходит, когда имя представления не было предоставлено (например, был возвращен атрибут модели) или было возвращено асинхронное значение. (например, «Моно» заполнено пустым).\n* {spring-framework-api}/web/reactive/result/view/Rendering.html[Рендеринг]: API для\nОбращение. просмотреть сценарии разрешения.\nИзучите возможности вашей IDE с автодополнением кода.\n* «Модель», «Карта»: дополнительные атрибуты модели, которые будут добавлены в модель по запросу.\n* Любое другое: любое другое возвращаемое значение (кроме простых типов, как определено\nОбращение. {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]) рассматривается как атрибут модели, добавляемый в модель.\nИмя атрибута является производным из имени класса, используя {spring-framework-api}/core/Conventions.html[conventions], если не присутствует аннотация метода-обработчика `@ModelAttribute`.\nОбращение.\nМодель может содержать асинхронные реактивные типы (например, из Reactor или RxJava).\nПриор для рендеринга AbstractView преобразует такие атрибуты модели в конкретные значения. и обновляет модель."}
{"id": 385, "text": "Реактивные типы с одним значением разрешаются в одно значение. значение или отсутствие значения (если пусто), а реактивные типы с несколькими значениями (например, `Flux<T>`) собрано и разрешено в `List<T>`.\nОбращение.\nНастроить разрешение представления так же просто, как добавить bean-компонент ViewResolutionResultHandler. в вашу конфигурацию Spring.\nWebFlux Config предоставляет специальный API конфигурации для разрешения просмотра.\nОбращение.\nСм.\nView Technologies для получения дополнительной информации о технологиях просмотра, интегрированных с Spring WebFlux.\nПеренаправление.\nСпециальный префикс `redirect:` в имени представления позволяет выполнить перенаправление. `UrlBasedViewResolver` (и его подклассы) распознают это как инструкцию, которую нужен редирект.\nОстальная часть имени представления — это URL-адрес перенаправления.\nПеренаправление.\nКонечный эффект такой же, как если бы контроллер вернул RedirectView или `Rendering.redirectTo(\"abc\").build()`, но теперь сам контроллер может работают в терминах логических имен представлений.\nИмя представления, например `redirect:/some/resource` относится к текущему приложению, а имя представления, например `redirect:https://example.com/arvary/path` перенаправляет на абсолютный URL-адрес.\nПеренаправление.\nПРИМЕЧАНИЕ: в отличие от стека сервлетов, Spring WebFlux не поддерживает отправку «FORWARD», поэтому префиксы «forward:» в результате не поддерживаются.\nСогласование содержания."}
{"id": 386, "text": "ViewResolutionResultHandler поддерживает согласование содержимого.\nОн сравнивает запрос типы мультимедиа с типами мультимедиа, поддерживаемыми каждым выбранным «Просмотром».\nПервый `Вид` который поддерживает запрошенные типы носителя.\nСогласование содержания.\nДля поддержки таких типов мультимедиа, как JSON и XML, Spring WebFlux предоставляет `HttpMessageWriterView`, который представляет собой специальный `View`, который визуализируется через просмотры через Конфигурация WebFlux.\nПредставления по умолчанию: всегда выбираются и используются, если они соответствуют запрошенному типу носителя."}
{"id": 387, "text": "Поддержка встроенной базы данных.\nПакет `org.springframework.jdbc.datasource.embedded` обеспечивает поддержку встроенных Механизмы баз данных Java.\nПоддержка https://www.hsqldb.org[HSQL], https://www.h2database.com[H2] и https://db.apache.org/derby[Derby] предоставляются. изначально.\nВы также можете использовать расширяемый API для подключения новых встроенных типов баз данных и Реализации DataSource.\nПоддержка встроенной базы данных.\nЗачем использовать встроенную базу данных?\nПоддержка встроенной базы данных.\nВстроенная база данных может быть полезна на этапе разработки проекта из-за ее легкий характер.\nПреимущества включают простоту настройки, быстрый запуск, тестируемость и возможность быстрого развития вашего SQL во время разработки.\nСоздание встроенной базы данных.\nВы можете представить экземпляр встроенной базы данных как компонент, как показано в следующем примере: См. пример кода в исходном документе.\nСоздание встроенной базы данных.\nПредыдущая конфигурация создает встроенную базу данных H2, заполняемую SQL из ресурсы `schema.sql` и `test-data.sql` в корне пути к классам.\nКроме того, как Рекомендуется встроенной базе данных присваивать уникальное имя. встроенная база данных доступна контейнеру Spring как компонент типа `javax.sql.DataSource`, который затем можно при необходимости внедрить в объекты доступа к данным.\nСоздание встроенной базы данных."}
{"id": 388, "text": "См. {spring-framework-api}/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html[javadoc для `EmbeddedDatabaseBuilder`] для получения более подробной информации обо всех поддерживаемых опциях.\nВыбор типа встроенной базы данных.\nВ этом разделе описывается, как выбрать одну из трех встроенных баз данных, которые Spring поддерживает.\nОн включает в себя следующие темы:\n* Использование HSQL\n* Использование H2\n* Использование Derby\nИспользование HSQL.\nSpring поддерживает HSQL 1.8.0 и выше.\nHSQL является встроенной базой данных по умолчанию, если ни один тип не указан. явно указано.\nЧтобы явно указать HSQL, установите атрибут `type` тег `embedded-database` в `HSQL`.\nЕсли вы используете API-интерфейс конструктора, вызовите `setType(EmbeddedDatabaseType)` с `EmbeddedDatabaseType.HSQL`.\nИспользование H2.\nSpring поддерживает базу данных H2.\nЧтобы включить H2, установите атрибут `type` тег `embedded-database` в `H2`.\nЕсли вы используете API-интерфейс конструктора, вызовите `setType(EmbeddedDatabaseType)` с `EmbeddedDatabaseType.H2`.\nИспользование Дерби.\nSpring поддерживает Apache Derby 10.5 и выше.\nЧтобы включить Derby, установите `type` атрибут тега `embedded-database` равен `DERBY`.\nЕсли вы используете API конструктора, вызовите метод setType(EmbeddedDatabaseType) с помощью EmbeddedDatabaseType.DERBY.\nНастройка типа встроенной базы данных."}
{"id": 389, "text": "Хотя каждый поддерживаемый тип имеет настройки подключения по умолчанию, возможно при необходимости настроить их.\nВ следующем примере используется H2 с пользовательским драйвером:\nJava\n	@Configuration\n	public class DataSourceConfig {\n		@Bean\n		public DataSource dataSource() {\n			return new EmbeddedDatabaseBuilder()\n					.setDatabaseConfigurer(EmbeddedDatabaseConfigurers\n							.customizeConfigurer(H2, this::customize))\n					.addScript(\"schema.sql\")\n					.build();\n		private EmbeddedDatabaseConfigurer customize(EmbeddedDatabaseConfigurer defaultConfigurer) {\n			return new EmbeddedDatabaseConfigurerDelegate(defaultConfigurer) {\n				@Override\n				public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n					super.configureConnectionProperties(properties, databaseName);\n					properties.setDriverClass(CustomDriver.class);\n	@Configuration\n	class DataSourceConfig {\nТестирование логики доступа к данным с помощью встроенной базы данных.\nВстроенные базы данных предоставляют простой способ тестирования кода доступа к данным.\nСледующий пример – это Шаблон теста интеграции доступа к данным, использующий встроенную базу данных.\nИспользование такого шаблона может быть полезен в единичных случаях, когда встроенную базу данных не нужно повторно использовать в ходе тестирования. занятия.\nОднако если вы хотите создать встроенную базу данных, которая будет использоваться совместно с набором тестов, рассмотрите возможность использования Spring TestContext Framework и настройка встроенной базы данных как bean-компонента в Spring `ApplicationContext`, как описано в Создание встроенной базы данных.\nВ следующем листинге показан тестовый шаблон:\nJava\n	public class DataAccessIntegrationTestTemplate {\n		private EmbeddedDatabase db;\n		@BeforeEach\n		public void setUp() {"}
{"id": 390, "text": "// Создает размещение данных HSQL в памяти, заполненных скриптами по умолчанию.\n			// путь к классам:schema.sql и путь к классам:data.sql\n			db = new EmbeddedDatabaseBuilder()\n					.generateUniqueName(true)\n					.addDefaultScripts()\n					.build();\n		@Test\n		public void testDataAccess() {\n			JdbcTemplate template = new JdbcTemplate(db);\n			template.query( /* ... */ );\n		@AfterEach\n		public void tearDown() {\n			db.shutdown();\n	class DataAccessIntegrationTestTemplate {\nГенерация уникальных имен для встроенных баз данных.\nКоманды разработчиков часто сталкиваются с ошибками во встроенных базах данных, если их набор тестов случайно пытается воссоздать дополнительные экземпляры той же базы данных.\nЭто может произойти довольно легко, если за это отвечает файл конфигурации XML или класс @Configuration. для создания встроенной базы данных и последующего повторного использования соответствующей конфигурации. в нескольких сценариях тестирования в одном наборе тестов (то есть в одной JVM). процесс) - например, интеграционные тесты для встроенных баз данных, чьи Конфигурация `ApplicationContext` различается только в зависимости от того, какое определение bean-компонента профили активны.\nГенерация уникальных имен для встроенных баз данных."}
{"id": 391, "text": "Основной причиной таких ошибок является тот факт, что Spring `EmbeddedDatabaseFactory` (используется внутренне как элементом пространства имен XML `<jdbc:embedded-database>`, так и элементом `EmbeddedDatabaseBuilder` для конфигурации Java) устанавливает имя встроенной базы данных `testdb`, если не указано иное.\nВ случае `<jdbc:embedded-database>`, встроенной базе данных обычно присваивается имя, равное идентификатору компонента (часто что-то вроде `dataSource`).\nТаким образом, последующие попытки создания встроенной базы данных не приводит к созданию новой базы данных.\nВместо этого повторно используется тот же URL-адрес соединения JDBC. и попытки создать новую встроенную базу данных фактически указывают на существующую встроенная база данных, созданная на основе той же конфигурации.\nГенерация уникальных имен для встроенных баз данных.\nЧтобы решить эту распространенную проблему, Spring Framework 4.2 обеспечивает поддержку генерации уникальные имена для встроенных баз данных.\nЧтобы включить использование сгенерированных имен, используйте одно из следующие варианты.\n* `EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()`\n* `EmbeddedDatabaseBuilder.generateUniqueName()`\n* `<jdbc:embedded-databasegenerate-name=\"true\" ... >`\nРасширение поддержки встроенной базы данных.\nВы можете расширить поддержку встроенной базы данных Spring JDBC двумя способами:\n* Внедрите EmbeddedDatabaseConfigurer для поддержки нового типа встроенной базы данных.\n* Реализуйте DataSourceFactory для поддержки новой реализации DataSource, например"}
{"id": 392, "text": "Расширение поддержки встроенной базы данных. пул соединений для управления подключениями к встроенной базе данных.\nРасширение поддержки встроенной базы данных.\nМы рекомендуем вам внести свой вклад в расширение сообщества Spring по адресу {spring-framework-issues}[Проблемы с GitHub]."}
{"id": 393, "text": "Включить конфигурацию MVC.\nВы можете использовать аннотацию @EnableWebMvc для включения конфигурации MVC с программной конфигурацией или `<mvc:annotation-driven>` с конфигурацией XML, как показано в следующем примере: См. пример кода в исходном документе.\nВключить конфигурацию MVC.\nВНИМАНИЕ: Начиная с версии 7.0, поддержка пространства имен конфигурации XML для Spring MVC устарела.\nПока нет планов по его полному удалению, но конфигурация XML не будет обновлена. модель конфигурации Java.\nВключить конфигурацию MVC.\nПРИМЕЧАНИЕ.\nПри использовании Spring Boot вы можете использовать классы @Configuration типа WebMvcConfigurer, но без @EnableWebMvc, чтобы сохранить настройки Spring Boot MVC.\nБолее подробную информацию см. в раздел MVC Config API и в {spring-boot-docs-ref}/web/servlet.html#web.servlet.spring-mvc.auto-configuration[специальной документации Spring Boot].\nВключить конфигурацию MVC.\nВ предыдущем примере регистрируется несколько Spring MVC. доступные в пути к классам (например, конвертеры полезной нагрузки для JSON, XML и другие)."}
{"id": 394, "text": "Абстракция окружающей среды.\nИнтерфейс {spring-framework-api}/core/env/Environment.html[`Environment`] — это абстракция, интегрированная в контейнер, которая моделирует два ключевых аспекты среды приложения: profiles и ссылка:core/beans/environment.adoc#beans-property-source-abstraction[properties].\nАбстракция окружающей среды.\nПрофиль — это именованная логическая группа определений компонентов, которая должна быть зарегистрирована в контейнер только в том случае, если данный профиль активен.\nБобы могут быть назначены профилю независимо от того, определено ли оно в XML или с аннотациями.\nРоль объекта «Среда» с отношение к профилям заключается в определении того, какие профили (если таковые имеются) активны в данный момент, и какие профили (если есть) должны быть активны по умолчанию.\nАбстракция окружающей среды.\nСвойства играют важную роль практически во всех приложениях и могут возникать из различные источники: файлы свойств, системные свойства JVM, системная среда. переменные, JNDI, параметры контекста сервлета, специальные объекты «Свойства», объекты «Карта» и т. д. дальше.\nРоль объекта «Среда» по отношению к свойствам заключается в предоставлении пользователь с удобным сервисным интерфейсом для настройки источников свойств и решения свойства от них.\nПрофили определения компонентов предоставляют механизм в основном контейнере, который позволяет регистрация разных bean-компонентов в разных средах."}
{"id": 395, "text": "Слово «окружающая среда» может означать разные вещи для разных пользователей, и эта функция может помочь во многих варианты использования, в том числе:\n* Работа с источником данных в памяти в процессе разработки, а не поиск того же источника.\nПрофили определения компонентов. источник данных из JNDI во время контроля качества или производства.\n* Регистрация инфраструктуры мониторинга только при развертывании приложения в\nПрофили определения компонентов. среда исполнения.\n* Регистрация индивидуальных реализаций bean-компонентов для клиента A по сравнению с клиентом.\nПрофили определения компонентов.\nРазвертывания Б.\nПрофили определения компонентов.\nРассмотрим первый вариант использования в практическом приложении, требующем `Источник данных`.\nВ тестовой среде конфигурация может выглядеть следующим образом:\nJava\n	@Bean\n	public DataSource dataSource() {\n		return new EmbeddedDatabaseBuilder()\n			.setType(EmbeddedDatabaseType.HSQL)\n			.addScript(\"my-schema.sql\")\n			.addScript(\"my-test-data.sql\")\n			.build();\nПрофили определения компонентов.\nТеперь рассмотрим, как это приложение можно развернуть в отделе контроля качества или в производстве. среде, предполагая, что источник данных для приложения зарегистрирован с каталогом JNDI производственного сервера приложений.\nНаш bean-компонент dataSource теперь выглядит следующим образом:\nJava\n	@Bean(destroyMethod = \"\")\n	public DataSource dataSource() throws Exception {\n		Context ctx = new InitialContext();"}
{"id": 396, "text": "return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\nПрофили определения компонентов.\nПроблема в том, как переключаться между использованием этих двух вариантов в зависимости от текущая среда.\nСо временем пользователи Spring разработали несколько способов сделать это, обычно полагаясь на комбинацию переменных системной среды и операторы XML `<import/>`, содержащие токены pass:q[`${placeholder}`], которые разрешают к правильному пути к файлу конфигурации в зависимости от значения среды переменная.\nПрофили определения компонентов — это основная функция контейнера, которая обеспечивает решение этой проблемы.\nПрофили определения компонентов.\nЕсли мы обобщим вариант использования, показанный в предыдущем примере bean-компонента, специфичного для конкретной среды, определения, мы в конечном итоге сталкиваемся с необходимостью зарегистрировать определенные определения bean-компонентов в определенных контекстах, но не в других.\nВы можете сказать, что хотите зарегистрировать определенный профиль определений bean-компонентов в ситуации A и другой профиль в ситуация Б.\nМы начинаем с обновления нашей конфигурации, чтобы отразить эту потребность.\nИспользование `@Profile`. {spring-framework-api}/context/annotation/Profile.html[`@Profile`] аннотация позволяет указать, что компонент имеет право на регистрацию. когда один или несколько указанных профилей активны.\nИспользуя наш предыдущий пример, мы можно переписать конфигурацию dataSource следующим образом:\nJava\n	@Configuration"}
{"id": 397, "text": "@Profile(\"development\")\n	public class StandaloneDataConfig {\n		@Bean\n		public DataSource dataSource() {\n			return new EmbeddedDatabaseBuilder()\n				.setType(EmbeddedDatabaseType.HSQL)\n				.addScript(\"classpath:com/bank/config/sql/schema.sql\")\n				.addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n				.build();\n	@Configuration\n	@Profile(\"development\")\n	class StandaloneDataConfig {\nJava\n	@Configuration\n	@Profile(\"production\")\n	public class JndiDataConfig {\n		@Bean(destroyMethod = \"\") // <1>\n		public DataSource dataSource() throws Exception {\n			Context ctx = new InitialContext();\n			return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\nИспользование `@Profile`. <1> `@Bean(destroyMethod = \"\")` отключает вывод метода уничтожения по умолчанию.\n	@Configuration\n	@Profile(\"production\")\n	class JndiDataConfig {\nИспользование `@Profile`. <1> `@Bean(destroyMethod = \"\")` отключает вывод метода уничтожения по умолчанию.\nИспользование `@Profile`.\nПРИМЕЧАНИЕ.\nКак упоминалось ранее, с методами `@Bean` вы обычно предпочитаете использовать программные методы."}
{"id": 398, "text": "JNDI-поиск, используя либо помощники Spring `JndiTemplate`/`JndiLocatorDelegate`, либо прямое использование JNDI `InitialContext`, показанное ранее, но не JndiObjectFactoryBean` вариант, который заставит вас объявить тип возвращаемого значения как тип FactoryBean.\nИспользование `@Profile`.\nСтрока профиля может содержать простое имя профиля (например, «производство») или выражение профиля.\nВыражение профиля позволяет реализовать более сложную логику профиля. выраженное (например, «производство и США-Восток»).\nСледующие операторы поддерживаются в выражения профиля:\n* `!`: логическое `НЕ` профиля.\n* `&`: логическое `И` профилей.\n* `|`: логическое \"ИЛИ\" профилей.\nИспользование `@Profile`.\nПРИМЕЧАНИЕ.\nНельзя смешивать операторы `&` и `|` без использования круглых скобок.\nНапример, `производство и США-Восток | eu-central` не является допустимым выражением.\nЭто должно быть выражено как `производство & (США-Восток | ЕС-Центр)`.\nИспользование `@Profile`.\nВы можете использовать @Profile в качестве ссылки:core/beans/classpath-scanning.adoc#beans-meta-annotations[meta-annotation] для этой цели. создания пользовательской аннотации.\nВ следующем примере определяется пользовательский аннотация `@Production`, которую можно использовать в качестве замены `@Profile(\"производство\")`:"}
{"id": 399, "text": "Java\n	@Target(ElementType.TYPE)\n	@Retention(RetentionPolicy.RUNTIME)\n	@Profile(\"production\")\n	public @interface Production {\n	@Target(AnnotationTarget.CLASS)\n	@Retention(AnnotationRetention.RUNTIME)\n	@Profile(\"production\")\n	annotation class Production\nИспользование `@Profile`.\nСОВЕТ: Если класс `@Configuration` помечен как `@Profile`, все методы `@Bean` и Аннотации `@Import`, связанные с этим классом, игнорируются, если только один или несколько из указанные профили активны.\nЕсли отмечен класс `@Component` или `@Configuration` с `@Profile({\"p1\", \"p2\"})` этот класс не регистрируется и не обрабатывается, если профили «p1» или «p2» активированы.\nЕсли данный профиль имеет префикс NOT (`!`), аннотированный элемент регистрируется только в том случае, если профиль не активный.\nНапример, для `@Profile({\"p1\", \"!p2\"})` регистрация произойдет, если профиль «p1» активен или профиль «p2» не активен.\nИспользование `@Profile`. `@Profile` также может быть объявлен на уровне метода, чтобы включать только один конкретный компонент. класса конфигурации (например, для альтернативных вариантов определенного компонента), как следующий пример показывает:\nJava\n	@Configuration\n	public class AppConfig {"}
{"id": 400, "text": "@Bean(\"dataSource\")\n		@Profile(\"development\") // <1>\n		public DataSource standaloneDataSource() {\n			return new EmbeddedDatabaseBuilder()\n				.setType(EmbeddedDatabaseType.HSQL)\n				.addScript(\"classpath:com/bank/config/sql/schema.sql\")\n				.addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n				.build();\n		@Bean(\"dataSource\")\n		@Profile(\"production\") // <2>\n		public DataSource jndiDataSource() throws Exception {\n			Context ctx = new InitialContext();\n			return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\nИспользование `@Profile`. <1> Метод `standaloneDataSource` доступен только в профиле `development`. <2> Метод jndiDataSource доступен только в рабочем профиле.\n	@Configuration\n	class AppConfig {\nИспользование `@Profile`. <1> Метод `standaloneDataSource` доступен только в профиле `development`. <2> Метод jndiDataSource доступен только в рабочем профиле."}
{"id": 401, "text": "Использование `@Profile`. [ПРИМЕЧАНИЕ] = При использовании `@Profile` в методах `@Bean` может применяться особый сценарий: перегруженные методы `@Bean` с тем же именем метода Java (аналог конструктора перегрузки), условие `@Profile` должно быть последовательно объявлено на всех перегруженные методы.\nЕсли условия несовместны, то только условие на первое объявление среди перегруженных методов имеет значение.\nСледовательно, `@Profile` может не использоваться для выбора перегруженного метода с определенной сигнатурой аргумента другой.\nРазрешение между всеми фабричными методами для одного и того же компонента соответствует Spring Алгоритм разрешения конструктора во время создания.\nИспользование `@Profile`.\nЕсли вы хотите определить альтернативные компоненты с разными условиями профиля, используйте разные имена методов Java, которые указывают на одно и то же имя компонента, используя имя `@Bean` атрибут, как показано в предыдущем примере.\nЕсли все подписи аргументов одинаковы (например, все варианты имеют фабричные методы без аргументов), это единственный способ представить такое расположение в допустимом классе Java в первую очередь (поскольку может быть только один метод с определенным именем и сигнатурой аргумента).\nПрофили определения XML-компонентов.\nАналогом XML является атрибут `profile` элемента `<beans>`.\nНаш предыдущий образец Конфигурацию можно переписать в двух XML-файлах следующим образом:\n	<beans profile=\"development\""}
{"id": 402, "text": "xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n		xsi:schemaLocation=\"...\">\n		<jdbc:embedded-database id=\"dataSource\">\n			<jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n			<jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n		</jdbc:embedded-database>\n	</beans>\n	<beans profile=\"production\"\n		xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:jee=\"http://www.springframework.org/schema/jee\"\n		xsi:schemaLocation=\"...\">\n		<jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n	</beans>\nПрофили определения XML-компонентов."}
{"id": 403, "text": "Также можно избежать разделения и вложения элементов `<beans/>` в один и тот же файл, как показано в следующем примере:\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n		xmlns:jee=\"http://www.springframework.org/schema/jee\"\n		xsi:schemaLocation=\"...\">\n		<!-- other bean definitions -->\n		<beans profile=\"development\">\n			<jdbc:embedded-database id=\"dataSource\">\n				<jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n				<jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n			</jdbc:embedded-database>\n		</beans>\n		<beans profile=\"production\">\n			<jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n		</beans>\n	</beans>\nПрофили определения XML-компонентов."}
{"id": 404, "text": "В Spring-bean.xsd разрешены только такие элементы, как последние в файле.\nЭто должно помочь обеспечить гибкость без необходимости беспорядок в файлах XML.\nПрофили определения XML-компонентов. [ПРИМЕЧАНИЕ] = Аналог XML не поддерживает выражения профиля, описанные ранее.\nЭто возможно, однако, чтобы отменить профиль, используйте оператор `!`.\nТакже возможно применить логическое «и» путем вложения профилей, как показано в следующем примере:\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n		xmlns:jee=\"http://www.springframework.org/schema/jee\"\n		xsi:schemaLocation=\"...\">\n		<!-- other bean definitions -->\n		<beans profile=\"production\">\n			<beans profile=\"us-east\">\n				<jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n			</beans>\n		</beans>\n	</beans>\nПрофили определения XML-компонентов."}
{"id": 405, "text": "В предыдущем примере bean-компонент `dataSource` доступен, если оба `production` и `dataSource` Профили `us-east` активны.\nАктивация профиля.\nТеперь, когда мы обновили нашу конфигурацию, нам все еще нужно указать Spring, какой профиль активен.\nЕсли бы мы запустили наш пример приложения прямо сейчас, мы бы увидели выброшено исключение NoSuchBeanDefinitionException, поскольку контейнер не смог найти bean-компонент Spring с именем dataSource.\nАктивация профиля.\nАктивировать профиль можно несколькими способами, но самый простой – это сделать это программно с помощью API «Среды», который доступен через `Контекст приложения`.\nВ следующем примере показано, как это сделать:\nJava\n	AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n	ctx.getEnvironment().setActiveProfiles(\"development\");\n	ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\n	ctx.refresh();\nАктивация профиля.\nКроме того, вы также можете декларативно активировать профили через Свойство Spring.profiles.active, которое можно указать через системную среду. переменные, системные свойства JVM, параметры контекста сервлета в `web.xml` или даже в виде запись в JNDI (см. `PropertySource` Abstraction).\nВ интеграционных тестах активен профили можно объявить с помощью аннотации @ActiveProfiles в файле Spring-test. модуль (см. конфигурация контекста с профилями среды).\nАктивация профиля."}
{"id": 406, "text": "Обратите внимание, что профили не являются предложением «или-или».\nВы можете активировать несколько профили сразу.\nПрограммно вы можете предоставить несколько имен профилей `setActiveProfiles()`, который принимает `String...` varargs.\nСледующий пример активирует несколько профилей:\nJava\n	ctx.getEnvironment().setActiveProfiles(\"profile1\", \"profile2\");\n	ctx.getEnvironment().setActiveProfiles(\"profile1\", \"profile2\")\nАктивация профиля.\nДекларативно `spring.profiles.active` может принимать список имен профилей, разделенных запятыми, как показано в следующем примере:\n	-Dspring.profiles.active=\"profile1,profile2\"\nПрофиль по умолчанию представляет собой профиль, который включается, если ни один профиль не активен.\nРассмотрим следующий пример:\nJava\n	@Configuration\n	@Profile(\"default\")\n	public class DefaultDataConfig {\n		@Bean\n		public DataSource dataSource() {\n			return new EmbeddedDatabaseBuilder()\n				.setType(EmbeddedDatabaseType.HSQL)\n				.addScript(\"classpath:com/bank/config/sql/schema.sql\")\n				.build();\n	@Configuration\n	@Profile(\"default\")\n	class DefaultDataConfig {\nПрофиль по умолчанию.\nЕсли ни один профиль не активен, `dataSource` создано.\nВы можете рассматривать это как способ предоставить определение по умолчанию для одного или нескольких фасоль.\nЕсли какой-либо профиль включен, профиль по умолчанию не применяется."}
{"id": 407, "text": "Профиль по умолчанию.\nИмя профиля по умолчанию — «default».\nВы можете изменить имя профиль по умолчанию, используя `setDefaultProfiles()` в `Среде` или, декларативно, используя свойство Spring.profiles.default.\nАбстракция PropertySource.\nАбстракция Spring «Среда» обеспечивает операции поиска в настраиваемой области. иерархия источников собственности.\nРассмотрим следующий листинг:\nJava\n	ApplicationContext ctx = new GenericApplicationContext();\n	Environment env = ctx.getEnvironment();\n	boolean containsMyProperty = env.containsProperty(\"my-property\");\n	System.out.println(\"Does my environment contain the 'my-property' property? \" + containsMyProperty);\nАбстракция PropertySource.\nВ предыдущем фрагменте мы видим высокоуровневый способ запроса Spring, является ли свойство my-property определены для текущей среды.\nЧтобы ответить на этот вопрос, объект «Среда» выполняет поиск по набору {spring-framework-api}/core/env/PropertySource.html[`PropertySource`] объекты.\nPropertySource — это простая абстракция над любым источником пар ключ-значение.\nSpring {spring-framework-api}/core/env/StandardEnvironment.html[`StandardEnvironment`] настроен с двумя объектами PropertySource, один из которых представляет набор системных свойств JVM. (`System.getProperties()`) и один, представляющий набор переменных системной среды. (`System.getenv()`)."}
{"id": 408, "text": "Абстракция PropertySource.\nПРИМЕЧАНИЕ.\nЭти источники свойств по умолчанию присутствуют для StandardEnvironment для использования в автономном режиме. приложения. {spring-framework-api}/web/context/support/StandardServletEnvironment.html[`StandardServletEnvironment`] заполняется дополнительными источниками свойств по умолчанию, включая конфигурацию сервлета, сервлет параметры контекста и {spring-framework-api}/jndi/JndiPropertySource.html[`JndiPropertySource`] если JNDI доступен.\nАбстракция PropertySource.\nКонкретно, когда вы используете StandardEnvironment, вызов env.containsProperty(\"my-property\")` возвращает true, если в файле присутствует системное свойство my-property или переменная среды my-property. время выполнения.\nАбстракция PropertySource. [СОВЕТ] = Выполняемый поиск является иерархическим.\nПо умолчанию системные свойства имеют приоритет над переменные среды.\nИтак, если свойство my-property установлено в обоих местах во время вызов `env.getProperty(\"my-property\")`, значение системного свойства \"wins`\" и возвращается.\nОбратите внимание, что значения свойств не объединяются. но скорее полностью перекрыто предыдущей записью.\nАбстракция PropertySource.\nДля общего StandardServletEnvironment полная иерархия выглядит следующим образом: записи с самым высоким приоритетом вверху:\nАбстракция PropertySource. .\nПараметры ServletConfig (если применимо — например, в случае контекста DispatcherServlet).\nПараметры ServletContext (записи параметров контекста web.xml)."}
{"id": 409, "text": "Переменные среды JNDI (записи `java:comp/env/`).\nСвойства системы JVM (аргументы командной строки `-D`).\nСистемная среда JVM (переменные среды операционной системы)\nАбстракция PropertySource.\nСамое главное, что весь механизм настраивается.\nВозможно, у вас есть собственный источник свойств, которые вы хотите интегрировать в этот поиск.\nДля этого реализуйте и создайте свой собственный PropertySource и добавьте его в набор PropertySources для текущая `Окружающая среда`.\nВ следующем примере показано, как это сделать:\nJava\nАбстракция PropertySource.\nConfigurableApplicationContext ctx = new GenericApplicationContext(); MutablePropertySources sources = ctx.getEnvironment().getPropertySources(); sources.addFirst(new MyPropertySource());\nАбстракция PropertySource.\nВ предыдущем коде MyPropertySource был добавлен с наивысшим приоритетом в поиск.\nЕсли он содержит свойство my-property, оно обнаруживается и возвращается в пользу любое свойство my-property в любом другом PropertySource. {spring-framework-api}/core/env/MutablePropertySources.html[`MutablePropertySources`] API предоставляет ряд методов, которые позволяют точно манипулировать набором источники собственности.\nИспользование `@PropertySource`. {spring-framework-api}/context/annotation/PropertySource.html[`@PropertySource`] аннотация предоставляет удобный и декларативный механизм для добавления PropertySource. к «Среде» Spring.\nИспользование `@PropertySource`."}
{"id": 410, "text": "Учитывая файл app.properties, содержащий пару ключ-значение testbean.name=myTestBean, следующий класс `@Configuration` использует `@PropertySource` таким образом, что вызов testBean.getName() возвращает myTestBean:\nJava\n	   @Autowired\n	   Environment env;\n	   @Bean\n	   public TestBean testBean() {\n		   TestBean testBean = new TestBean();\n		   testBean.setName(env.getProperty(\"testbean.name\"));\n		   return testBean;\n	@Configuration\n	@PropertySource(\"classpath:/com/myco/app.properties\")\n	class AppConfig {\n@Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig {.\nЛюбые заполнители `${...}`, присутствующие в местоположении ресурса `@PropertySource`, являются разрешено в отношении набора источников собственности, уже зарегистрированных в отношении среде, как показано в следующем примере:\nJava\n@Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig {. @Configuration @PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\") public class AppConfig {\n	   @Autowired\n	   Environment env;\n	   @Bean\n	   public TestBean testBean() {\n		   TestBean testBean = new TestBean();\n		   testBean.setName(env.getProperty(\"testbean.name\"));"}
{"id": 411, "text": "return testBean;\n	@Configuration\n	@PropertySource(\"classpath:/com/\\${my.placeholder:default/path}/app.properties\")\n	class AppConfig {\n@Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig {.\nПредполагая, что my.placeholder уже присутствует в одном из источников свойств. зарегистрированы (например, системные свойства или переменные среды), заполнитель решено до соответствующего значения.\nЕсли нет, то используется `default/path`. по умолчанию.\nЕсли значение по умолчанию не указано и свойство не может быть разрешено, Выдается `IllegalArgumentException`.\n@Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig {.\nПРИМЕЧАНИЕ. @PropertySource можно использовать как повторяющуюся аннотацию. `@PropertySource` также может использоваться в качестве метааннотации для создания пользовательских аннотаций с помощью переопределение атрибутов.\nРазрешение заполнителя в заявлениях.\nИсторически значение заполнителей в элементах можно было определить только по Свойства системы JVM или переменные среды.\nЭто уже не так.\nПотому что абстракция «Среда» интегрирована во весь контейнер, ее легко маршрутизировать разрешение заполнителей через него.\nЭто означает, что вы можете настроить процесс разрешения любым удобным для вас способом.\nВы можете изменить приоритет поиска по системные свойства и переменные среды или полностью удалите их."}
{"id": 412, "text": "Вы также можете добавить свой собственные источники собственности, если это необходимо.\nРазрешение заполнителя в заявлениях.\nКонкретно, следующее утверждение работает независимо от того, где находится «клиент». свойство определено, если оно доступно в `Среде`:\n	<beans>\n		<import resource=\"com/bank/service/${customer}-config.xml\"/>\n	</beans>"}
{"id": 413, "text": "Преобразование кодов ошибок в сообщения об ошибках.\nМы рассмотрели привязку и проверку данных.\nВ этом разделе описывается вывод сообщений, соответствующих к ошибкам проверки.\nВ примере, показанном в предшествующий раздел, мы отклонили поля «имя» и «возраст».\nЕсли мы хотим вывести сообщения об ошибках, используя `MessageSource`, мы можем сделать это, используя код ошибки, который мы указываем при отклонении поля. («имя» и «возраст» в данном случае).\nКогда вы вызываете (прямо или косвенно, используя например, класс ValidationUtils), rejectValue или один из других методов reject. из интерфейса `Errors`, базовая реализация не только регистрирует код, который вы передается, но также регистрирует ряд дополнительных кодов ошибок. `MessageCodesResolver` определяет, какие коды ошибок регистрирует интерфейс `Errors`.\nПо умолчанию Используется `DefaultMessageCodesResolver`, который (например) не только регистрирует сообщение с кодом, который вы указали, но также регистрирует сообщения, содержащие переданное вами имя поля. к методу отклонения.\nИтак, если вы отклоните поле, используя `rejectValue(\"age\", \"too.darn.old\")`, помимо кода «too.darn.old», Spring также регистрирует «too.darn.old.age» и `too.darn.old.age.int` (первое включает имя поля, а второе — тип поля)."}
{"id": 414, "text": "Это сделано для удобства разработчиков при работе с сообщениями об ошибках.\nПреобразование кодов ошибок в сообщения об ошибках.\nДополнительную информацию о MessageCodesResolver и стратегии по умолчанию можно найти. в Javadoc {spring-framework-api}/validation/MessageCodesResolver.html[`MessageCodesResolver`] и {spring-framework-api}/validation/DefaultMessageCodesResolver.html[`DefaultMessageCodesResolver`], соответственно."}
{"id": 415, "text": "Оценка.\nВ этом разделе описывается программное использование интерфейсов SpEL и его языка выражений.\nПолный справочник по языку можно найти в\nОценка.\nСледующий код демонстрирует, как использовать API SpEL для оценки буквальной строки. выражение «Привет, мир».\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	Expression exp = parser.parseExpression(\"'Hello World'\"); // <1>\n	String message = (String) exp.getValue();\nОценка. <1> Значение переменной сообщения — «Hello World».\nОценка.\nКлассы и интерфейсы SpEL, которые вы, скорее всего, будете использовать, расположены в папке Пакет `org.springframework.expression` и его подпакеты, такие как `spel.support`.\nОценка.\nИнтерфейс ExpressionParser отвечает за анализ строки выражения.\nВ В предыдущем примере строка выражения представляет собой строковый литерал, обозначаемый окружающим одинарные кавычки.\nИнтерфейс `Expression` отвечает за оценку определенная строка выражения.\nДва типа исключений, которые могут быть выброшены при вызове `parser.parseExpression(...)` и `exp.getValue(...)` являются `ParseException` и `EvaluationException` соответственно.\nОценка.\nSpEL поддерживает широкий спектр функций, таких как вызов методов, доступ к свойствам, и вызов конструкторов.\nОценка.\nВ следующем примере вызова метода мы вызываем метод concat для строки буквально «Привет, мир».\nJava"}
{"id": 416, "text": "ExpressionParser parser = new SpelExpressionParser();\n	Expression exp = parser.parseExpression(\"'Hello World'.concat('!')\"); // <1>\n	String message = (String) exp.getValue();\nОценка. <1> Значение `message` теперь равно `\"Hello World!\"`.\nОценка.\nВ следующем примере показано, как получить доступ к свойству JavaBean `Bytes` объекта строковый литерал `Hello World`.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	// вызывает 'getBytes()'\n	Expression exp = parser.parseExpression(\"'Hello World'.bytes\"); // <1>\n	byte[] bytes = (byte[]) exp.getValue();\nОценка. <1> Эта строка преобразует литерал в массив байтов.\nОценка.\nSpEL также поддерживает вложенные свойства, используя стандартную запись через точку (например, `prop1.prop2.prop3`), а также соответствующую настройку значений свойств.\nДоступ к публичным полям также возможен.\nОценка.\nВ следующем примере показано, как использовать запись через точку для получения длины строкового литерала.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	// вызывает 'getBytes().length'\n	Expression exp = parser.parseExpression(\"'Hello World'.bytes.length\"); // <1>"}
{"id": 417, "text": "int length = (Integer) exp.getValue();\nОценка. <1> `'Hello World'.bytes.length` дает длину литерала.\nОценка.\nКонструктор String можно вызвать вместо использования строкового литерала, как показано ниже. пример показывает.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	Expression exp = parser.parseExpression(\"new String('hello world').toUpperCase()\"); // <1>\n	String message = exp.getValue(String.class);\nОценка. <1> Создайте новую строку из литерала и преобразуйте ее в верхний регистр.\nОценка.\nОбратите внимание на использование общего метода: `public <T> T getValue(Class<T> желаемыйResultType)`.\nИспользование этого метода избавляет от необходимости приводить значение выражения к желаемому значению. тип результата. `EvaluationException` выдается, если значение не может быть приведено к введите `T` или преобразуйте его с помощью зарегистрированного преобразователя типов.\nОценка.\nБолее распространенное использование SpEL — предоставление строки выражения, которая вычисляется против конкретного экземпляра объекта (называемого корневым объектом).\nСледующий пример показывает как получить свойство name из экземпляра класса Inventor и как его ссылайтесь на свойство `name` в логическом выражении.\nJava\n	// Создайте и настройте календарь\n	GregorianCalendar c = new GregorianCalendar();\n	c.set(1856, 7, 9);"}
{"id": 418, "text": "// Аргументами конструктора являются имя, день рождения и национальность.\n	Inventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n	ExpressionParser parser = new SpelExpressionParser();\n	Expression exp = parser.parseExpression(\"name\"); // Parse name as an expression\n	String name = (String) exp.getValue(tesla);\n	// name == \"Никола Тесла\"\n	exp = parser.parseExpression(\"name == 'Nikola Tesla'\");\n	boolean result = exp.getValue(tesla, Boolean.class);\n	// результат == правда\nПонимание `EvaluationContext`.\nAPI EvaluationContext используется при оценке выражения для разрешения свойств. методы или поля и помочь выполнить преобразование типов.\nSpring предоставляет два реализации.\nПонимание `EvaluationContext`. `SimpleEvaluationContext` Предоставляет подмножество основных функций языка SpEL и параметров конфигурации, например категории выражений, которые не требуют полного использования языка SpEL синтаксис и должен быть существенно ограничен.\nПримеры включают, помимо прочего, выражения привязки данных и фильтры на основе свойств.\nПонимание `EvaluationContext`. `StandardEvaluationContext` Предоставляет полный набор функций языка SpEL и параметров конфигурации.\nВы можете использовать он позволяет указать корневой объект по умолчанию и настроить все доступные, связанные с оценкой. стратегия.\nПонимание `EvaluationContext`. `SimpleEvaluationContext` предназначен для поддержки только подмножества языка SpEL. синтаксис."}
{"id": 419, "text": "Например, он исключает ссылки на типы Java, конструкторы и ссылки на компоненты.\nТакже требуется явно выбрать уровень поддержки свойств и методов. в выражениях.\nПри создании SimpleEvaluationContext вам необходимо выбрать уровень поддержка, необходимая для привязки данных в выражениях SpEL:\n* Привязка данных для доступа только для чтения.\n* Привязка данных для доступа на чтение и запись.\n* Пользовательский PropertyAccessor (обычно не основанный на отражении), потенциально в сочетании с\n`DataBindingPropertyAccessor`.\nУдобно, что SimpleEvaluationContext.forReadOnlyDataBinding() обеспечивает доступ только для чтения. к свойствам через DataBindingPropertyAccessor.\nАналогично, `SimpleEvaluationContext.forReadWriteDataBinding()` обеспечивает доступ для чтения и записи к свойства.\nАльтернативно, настройте пользовательские средства доступа через `SimpleEvaluationContext.forPropertyAccessors(...)`, потенциально отключить назначение и при необходимости активируйте разрешение метода и/или преобразователь типов через построитель.\nПреобразование типа.\nПо умолчанию SpEL использует службу преобразования, доступную в ядре Spring. (`org.springframework.core.convert.ConversionService`).\nЭта услуга конвертации поставляется со множеством встроенных конвертеров для обычных преобразований, но при этом полностью расширяема, поэтому что вы можете добавлять собственные преобразования между типами.\nКроме того, он поддерживает дженерики.\nЭто означает, что при работе с универсальными типами в выражениях SpEL пытается преобразования для поддержания корректности типов любых объектов, с которыми он сталкивается.\nПреобразование типа.\nЧто это означает на практике?"}
{"id": 420, "text": "Предположим, что используется присвоение с использованием `setValue()`. чтобы установить свойство List.\nТип свойства на самом деле — List<Boolean>.\nSpEL распознает, что элементы списка необходимо преобразовать в логические значения перед помещается в него.\nВ следующем примере показано, как это сделать.\nJava\n	class Simple {\n		public List<Boolean> booleanList = new ArrayList<>();\n	Simple simple = new Simple();\n	simple.booleanList.add(true);\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	// «false» передается здесь как строка. SpEL и служба конвертации\n	// распознает, что это должно быть логическое значение, и преобразует его соответствующим образом.\n	parser.parseExpression(\"booleanList[0]\").setValue(context, simple, \"false\");\n	// б неверно\n	Boolean b = simple.booleanList.get(0);\n	// «false» передается здесь как строка. SpEL и служба конвертации\n	// распознает, что это должно быть логическое значение, и преобразует его соответствующим образом.\n	parser.parseExpression(\"booleanList[0]\").setValue(context, simple, \"false\")\nКонфигурация парсера.\nАнализатор выражений SpEL можно настроить с помощью конфигурации анализатора. объект (`org.springframework.expression.spel.SpelParserConfiguration`)."}
{"id": 421, "text": "Конфигурация объект управляет поведением некоторых компонентов выражения.\nНапример, если вы индекс в коллекцию и элемент по указанному индексу имеет значение null, SpEL может автоматически создать элемент.\nЭто полезно при использовании выражений, состоящих из цепочка ссылок на свойства.\nАналогично, если вы индексируете коллекцию и указываете индекс, превышающий текущий размер коллекции, SpEL может автоматически увеличить коллекцию, чтобы она соответствовала этому индексу.\nЧтобы добавить элемент в указанный индекс, SpEL попытается создать элемент, используя значение по умолчанию для этого типа элемента. конструктор перед установкой указанного значения.\nЕсли тип элемента не имеет конструктор по умолчанию, в коллекцию будет добавлен `null`.\nЕсли нет встроенного конвертере или пользовательском конвертере, который знает, как установить значение, `null` останется в коллекция по указанному индексу.\nСледующий пример демонстрирует, как автоматически увеличивать «Список».\nJava\n	class Demo {\n		public List<String> list;\n	// Включать:\n	// - автоматическая инициализация нулевой ссылки\n	// - рост автоколлекции\n	SpelParserConfiguration config = new SpelParserConfiguration(true, true);\n	ExpressionParser parser = new SpelExpressionParser(config);\n	Expression expression = parser.parseExpression(\"list[3]\");\n	Demo demo = new Demo();\n	Object o = expression.getValue(demo);\n	// demo.list теперь будет настоящей коллекцией из 4 записей\n	// Каждая запись представляет собой новую пустую строку."}
{"id": 422, "text": "// demo.list теперь будет настоящей коллекцией из 4 записей\n	// Каждая запись представляет собой новую пустую строку.\nКонфигурация парсера.\nПо умолчанию выражение SpEL не может содержать более 10 000 символов; однако, `maxExpressionLength` можно настроить.\nЕсли вы создадите `SpelExpressionParser` программно вы можете указать собственный maxExpressionLength при создании `SpelParserConfiguration`, которую вы предоставляете `SpelExpressionParser`.\nЕсли вы хотите установите `maxExpressionLength`, используемый для анализа выражений SpEL внутри `ApplicationContext` — например, в определениях XML-компонентов, `@Value` и т. д. — вы можете установите системное свойство JVM или свойство Spring с именем `spring.context.expression.maxLength` до максимальной длины выражения, необходимой вашему приложению (см.\nСборник SpEL.\nSpring предоставляет базовый компилятор для выражений SpEL.\nВыражения, как правило, интерпретируется, что обеспечивает большую динамическую гибкость во время оценки, но не обеспечить оптимальную производительность.\nДля периодического использования выражений это нормально, но когда используемые другими компонентами, такими как Spring Integration, производительность может быть очень важна, и нет никакой реальной необходимости в динамизме.\nСборник SpEL.\nКомпилятор SpEL призван удовлетворить эту потребность.\nВо время оценки компилятор генерирует класс Java, который воплощает поведение выражения во время выполнения, и использует его класс, чтобы добиться гораздо более быстрого вычисления выражения."}
{"id": 423, "text": "Из-за отсутствия набора текста выражения, компилятор использует информацию, собранную во время интерпретируемых вычислений выражения при выполнении компиляции.\nНапример, он не знает тип ссылки на свойство исключительно из выражения, но во время первой интерпретации оценка, он выясняет, что это такое.\nКонечно, основываясь на таких производных информация может вызвать проблемы позже, если типы различных элементов выражения меняться со временем.\nПо этой причине компиляция лучше всего подходит для выражений, Информация о типе не изменится при повторных оценках.\nСборник SpEL.\nРассмотрим следующее основное выражение.\n	someArray[0].someProperty.someOtherProperty < 0.1\nСборник SpEL.\nПоскольку предыдущее выражение включает доступ к массиву, разыменование некоторых свойств и числовых операций, прирост производительности может быть очень заметным.\nВ примере микро тестовый прогон из 50 000 итераций, оценка с использованием интерпретатора и всего 3 мс при использовании скомпилированной версии выражения.\nКонфигурация компилятора.\nПо умолчанию компилятор не включен, но его можно включить одним из двух способов. разные способы.\nВы можете включить его, используя процесс настройки парсера. (обсуждается ранее) или с помощью свойства Spring, когда использование SpEL встроено в другой компонент.\nВ этом разделе обсуждаются оба этих варианта.\nКонфигурация компилятора.\nКомпилятор может работать в одном из трех режимов, которые зафиксированы в `org.springframework.expression.spel.SpelCompilerMode` перечисление.\nРежимы следующие."}
{"id": 424, "text": "Конфигурация компилятора. `ВЫКЛ` Компилятор выключен, и все выражения будут оцениваться в _interpreted_ режим.\nЭто режим по умолчанию. `НЕМЕДЛЕННО` В немедленном режиме выражения компилируются как можно скорее, обычно после первая интерпретированная оценка.\nЕсли вычисление скомпилированного выражения не удалось (для например, из-за изменения типа, как описано ранее), вызывающий выражение оценка получает исключение.\nЕсли изменяются типы различных элементов выражения со временем рассмотрите возможность перехода в режим «MIXED» или отключения компилятора. `СМЕШАННЫЙ` В смешанном режиме вычисление выражения автоматически переключается между _интерпретируемым_ и _скомпилировано_ с течением времени.\nПосле некоторого количества успешных интерпретаций выражение компилируется.\nЕсли вычисление скомпилированного выражения завершается неудачей (например, из-за изменение типа), этот сбой будет обнаружен внутри системы, и система переключится обратно. в режим интерпретации для данного выражения.\nПо сути, исключение, что вызывающий абонент получает в режиме «НЕМЕДЛЕННО» вместо этого обрабатывается внутри.\nНекоторое время спустя, компилятор может сгенерировать другую скомпилированную форму и переключиться на нее.\nЭтот цикл переключения между интерпретируемым и скомпилированным режимом будет продолжаться до тех пор, пока система не определит, что это нет смысла продолжать попытки — например, при достижении определенного порога неудачи достигнуто — в этот момент система навсегда переключится на интерпретируемый режим для данного выражения.\nКонфигурация компилятора.\nРежим `IMMEDIATE` существует, поскольку режим `MIXED` может вызвать проблемы с выражениями, которые имеют побочные эффекты."}
{"id": 425, "text": "Если скомпилированное выражение терпит неудачу после частичного успеха, оно возможно, уже сделал что-то, что повлияло на состояние системы.\nЕсли это произошло, вызывающая сторона может не захотеть, чтобы она автоматически перезапускалась в интерпретируемом режиме, поскольку часть выражения может быть запущена дважды.\nКонфигурация компилятора.\nПосле выбора режима используйте SpelParserConfiguration для настройки парсера.\nВ следующем примере показано, как это сделать.\nJava\n	SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,\n			this.getClass().getClassLoader());\n	SpelExpressionParser parser = new SpelExpressionParser(config);\n	Expression expr = parser.parseExpression(\"payload\");\n	MyMessage message = new MyMessage();\n	Object payload = expr.getValue(message);\nКонфигурация компилятора.\nКогда вы указываете режим компилятора, вы также можете указать ClassLoader (передавая null). разрешено).\nСкомпилированные выражения определяются в дочернем файле ClassLoader, созданном под любым именем. что поставляется.\nВажно убедиться, что если указан ClassLoader, он может просмотреть все типы, участвующие в процессе оценки выражений.\nЕсли вы не укажете ClassLoader, используется ClassLoader по умолчанию (обычно контекст ClassLoader для поток, который выполняется во время вычисления выражения).\nКонфигурация компилятора.\nВторой способ настройки компилятора предназначен для использования, когда SpEL встроен в какой-либо файл. другой компонент, и его невозможно настроить через конфигурацию объект."}
{"id": 426, "text": "В таких случаях можно установить `spring.expression.compiler.mode` свойство через системное свойство JVM (или через Значения перечисления SpelCompilerMode («выключено», «немедленно» или «смешанно»).\nОграничения компилятора.\nSpring не поддерживает компиляцию всех видов выражений.\nОсновное внимание уделяется общие выражения, которые, вероятно, будут использоваться в контекстах, критичных к производительности. следующие типы выражений не могут быть скомпилированы.\n* Выражения, связанные с присвоением\n* Выражения, зависящие от службы преобразования\n* Выражения с использованием пользовательских преобразователей.\n* Выражения с использованием перегруженных операторов.\n* Выражения с использованием синтаксиса построения массива.\n* Выражения с использованием выделения или проекции\n* Выражения с использованием ссылок на компоненты\nОграничения компилятора.\nВ будущем может поддерживаться компиляция дополнительных видов выражений."}
{"id": 427, "text": "События, связанные с транзакцией.\nНачиная с Spring 4.2, прослушиватель события может быть привязан к фазе транзакции.\nТипичным примером является обработка события при успешном завершении транзакции.\nЭто позволяет использовать события с большей гибкостью, когда результат текущего транзакция действительно имеет значение для слушателя.\nСобытия, связанные с транзакцией.\nВы можете зарегистрировать обычный прослушиватель событий, используя аннотацию @EventListener.\nЕсли вам нужно привязать его к транзакции, используйте @TransactionalEventListener.\nПри этом прослушиватель по умолчанию привязывается к фазе фиксации транзакции.\nСобытия, связанные с транзакцией.\nСледующий пример демонстрирует эту концепцию.\nПредположим, что компонент публикует созданный заказом событие и что мы хотим определить прослушиватель, который должен обрабатывать это событие только после транзакция, в которой он был опубликован, успешно зафиксирована.\nСледующие пример устанавливает такой прослушиватель событий:\nJava\n	@Component\n	public class MyComponent {\n		@TransactionalEventListener\n		public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) {\n	@Component\n	class MyComponent {\nСобытия, связанные с транзакцией.\nАннотация `@TransactionalEventListener` предоставляет атрибут `phase`, который позволяет вам настроить фазу транзакции, к которой должен быть привязан прослушиватель.\nДопустимые фазы: BEFORE_COMMIT, AFTER_COMMIT (по умолчанию), AFTER_ROLLBACK, а также `AFTER_COMPLETION`, который агрегирует завершение транзакции (будь то фиксация или откат).\nСобытия, связанные с транзакцией.\nЕсли ни одна транзакция не выполняется, прослушиватель вообще не вызывается, поскольку мы не можем соблюдать необходимая семантика."}
{"id": 428, "text": "Однако вы можете переопределить это поведение, установив `fallbackExecution` атрибут аннотации имеет значение true.\nСобытия, связанные с транзакцией. [ПРИМЕЧАНИЕ] = Начиная с версии 6.1, `@TransactionalEventListener` может работать с транзакциями, связанными с потоками, управляемыми «PlatformTransactionManager», а также реактивные транзакции, управляемые «ReactiveTransactionManager».\nВ первом случае слушатели гарантированно увидят текущую транзакцию, связанную с потоком.\nПоскольку последний использует контекст Reactor вместо локальных переменных потока, транзакция контекст должен быть включен в опубликованный экземпляр события в качестве источника события.\nСм. {spring-framework-api}/transaction/reactive/TransactionalEventPublisher.html[`TransactionalEventPublisher`] javadoc для получения подробной информации."}
{"id": 429, "text": "Классы, используемые в примерах.\nВ этом разделе перечислены классы, используемые в примерах этой главы.\nJava\n	package org.spring.samples.spel.inventor;\n	import java.util.Date;\n	import java.util.GregorianCalendar;\n	public class Inventor {\n		private String name;\n		private String nationality;\n		private String[] inventions;\n		private Date birthdate;\n		private PlaceOfBirth placeOfBirth;\n		public Inventor(String name, String nationality) {\n			GregorianCalendar c= new GregorianCalendar();\n			this.name = name;\n			this.nationality = nationality;\n			this.birthdate = c.getTime();\n		public Inventor(String name, Date birthdate, String nationality) {\n			this.name = name;\n			this.nationality = nationality;\n			this.birthdate = birthdate;\n		public Inventor() {\n		public String getName() {\n			return name;\n		public void setName(String name) {\n			this.name = name;\n		public String getNationality() {\n			return nationality;\n		public void setNationality(String nationality) {\n			this.nationality = nationality;\n		public Date getBirthdate() {\n			return birthdate;\n		public void setBirthdate(Date birthdate) {\n			this.birthdate = birthdate;\n		public PlaceOfBirth getPlaceOfBirth() {\n			return placeOfBirth;\n		public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {\n			this.placeOfBirth = placeOfBirth;\n		public void setInventions(String[] inventions) {\n			this.inventions = inventions;"}
{"id": 430, "text": "public String[] getInventions() {\n			return inventions;\n	package org.spring.samples.spel.inventor\nJava\n	package org.spring.samples.spel.inventor;\n	public class PlaceOfBirth {\n		private String city;\n		private String country;\n		public PlaceOfBirth(String city) {\n			this.city=city;\n		public PlaceOfBirth(String city, String country) {\n			this(city);\n			this.country = country;\n		public String getCity() {\n			return city;\n		public void setCity(String s) {\n			this.city = s;\n		public String getCountry() {\n			return country;\n		public void setCountry(String country) {\n			this.country = country;\n	package org.spring.samples.spel.inventor\nJava\n	package org.spring.samples.spel.inventor;\n	import java.util.*;\n	public class Society {\n		private String name;\n		public static String Advisors = \"advisors\";\n		public static String President = \"president\";\n		private List<Inventor> members = new ArrayList<>();\n		private Map officers = new HashMap();\n		public List getMembers() {\n			return members;\n		public Map getOfficers() {\n			return officers;\n		public String getName() {\n			return name;\n		public void setName(String name) {\n			this.name = name;\n		public boolean isMember(String name) {\n			for (Inventor inventor : members) {"}
{"id": 431, "text": "if (inventor.getName().equals(name)) {\n					return true;\n			return false;\n	package org.spring.samples.spel.inventor\n	class Society {"}
{"id": 432, "text": "Пример АОП.\nТеперь, когда вы увидели, как работают все составные части, мы можем собрать их вместе, чтобы сделать что-то полезное.\nПример АОП.\nВыполнение бизнес-сервисов иногда может завершаться сбоем из-за проблем параллелизма (например, например, проигравший в тупике).\nЕсли операцию повторить, она, скорее всего, завершится успешно. при следующей попытке.\nДля бизнес-услуг, где уместно повторить попытку в таком условия (идемпотентные операции, которым не нужно возвращаться к пользователю в случае конфликта разрешение), мы хотим прозрачно повторить операцию, чтобы клиент не увидел `PessimisticLockingFailureException`.\nЭто требование, которое явно затрагивает несколько сервисов на уровне сервисов и, следовательно, идеально подходит для реализации через аспект.\nПример АОП.\nПоскольку мы хотим повторить операцию, нам нужно воспользоваться советом, чтобы мы могли вызовите `proceed` несколько раз.\nВ следующем листинге показана реализация основного аспекта: См. пример кода в исходном документе.\nПример АОП. `@Around(\"com.xyz.CommonPointcuts.businessService()\")` ссылается на `businessService` с именем pointcut, определенный в\nПример АОП.\nОбратите внимание, что этот аспект реализует интерфейс Ordered, поэтому мы можем установить приоритет аспект выше, чем совет по транзакции (мы хотим новую транзакцию каждый раз, когда мы повторите попытку).\nСвойства maxRetries и order настраиваются Spring.\nОсновное действие происходит в doConcurrentOperation вокруг совета."}
{"id": 433, "text": "Обратите внимание, что для В этот момент мы применяем логику повтора к каждому «businessService».\nМы пытаемся продолжить, и если мы потерпим неудачу с PessimisticLockingFailureException, мы попробуем еще раз, если только мы исчерпали все наши повторные попытки.\nПример АОП.\nСоответствующая конфигурация Spring следующая: См. пример кода в исходном документе.\nПример АОП.\nЧтобы уточнить этот аспект, чтобы он повторял только идемпотентные операции, мы могли бы определить следующее `Идемпотентная` аннотация: См. пример кода в исходном документе.\nПример АОП.\nЗатем мы можем использовать аннотацию для аннотирования реализации сервисных операций.\nИзменение аспект, позволяющий повторять только идемпотентные операции, требует уточнения pointcut выражение, чтобы совпадали только операции `@Idempotent`, как показано ниже: См. пример кода в исходном документе."}
{"id": 434, "text": "Язык выражений Spring (SpEL).\nЯзык выражений Spring (сокращенно SpEL) — это мощный язык выражений, который поддерживает запросы и манипулирование графом объектов во время выполнения.\nСинтаксис языка аналогично https://jakarta.ee/specifications/expression-language/[Jakarta Expression Language], но предлагает дополнительные функции, в первую очередь вызов метода и базовую строку. функциональность шаблонов.\nЯзык выражений Spring (SpEL).\nХотя существует несколько других языков выражений Java — OGNL, MVEL и JBoss EL, и это лишь некоторые из них: язык выражений Spring был создан для обеспечения Сообщество Spring с единым хорошо поддерживаемым языком выражений, который можно использовать повсюду. все продукты из портфолио Spring.\nЕго языковые особенности обусловлены требования проектов в портфолио Spring, включая требования к инструментам для завершение кода в рамках поддержки IDE {spring-site-tools}[Spring Tools].\nТем не менее, SpEL основан на независимом от технологии API, который позволяет другим реализациям языка выражений интегрироваться, если возникнет такая необходимость.\nЯзык выражений Spring (SpEL).\nХотя SpEL служит основой для оценки выражений в Spring портфолио, он не привязан напрямую к Spring и может использоваться независимо.\nЧтобы быть самодостаточным, во многих примерах в этой главе используется SpEL, как если бы это был самостоятельный язык выражения.\nЭто требует создания нескольких начальных настроек классы инфраструктуры, такие как синтаксический анализатор."}
{"id": 435, "text": "Большинству пользователей Spring не нужно иметь дело с эту инфраструктуру и вместо этого может создавать только строки выражений для оценки.\nПримером такого типичного использования является интеграция SpEL в создание XML или определения bean-компонентов на основе аннотаций, как показано на рисунке\nЯзык выражений Spring (SpEL).\nВ этой главе рассматриваются особенности языка выражений, его API и языка. синтаксис.\nВ нескольких местах в качестве целевых используются классы Inventor и Society. объекты для оценки выражений.\nЭти объявления классов и данные, используемые для для их заполнения перечислены в конце главы.\n* Буквальные выражения\n* Доступ к свойствам, массивам, спискам и картам.\n* Встроенные списки\n* Встроенные карты\n* Построение массива\n* Реляционные операторы\n* Регулярные выражения\n* Логические операторы\n* Строковые операторы\n* Математические операторы\n* Назначение\n* Введите выражения\n* Вызов метода\n* Вызов конструктора\n* Переменные\n* Пользовательские функции\n* Ссылки на бобы\n* Тернарный оператор, Элвис и операторы безопасной навигации.\n* Проекция коллекции\n* Выбор коллекции\n* Шаблонные выражения"}
{"id": 436, "text": "Определение новых типов советов.\nSpring AOP спроектирован так, чтобы его можно было расширять.\nХотя стратегия реализации перехвата в настоящее время используется внутри компании, можно поддерживать произвольные типы советов в помимо перехвата вокруг советов, раньше кидает советы, и после возвращения совета.\nОпределение новых типов советов.\nПакет `org.springframework.aop.framework.adapter` — это пакет SPI, который позволяет поддержка новых типов пользовательских советов может быть добавлена без изменения базовой структуры.\nЕдинственное ограничение для пользовательского типа Advice заключается в том, что он должен реализовывать Интерфейс маркера `org.aopalliance.aop.Advice`.\nОпределение новых типов советов.\nСм. {spring-framework-api}/aop/framework/adapter/package-summary.html[`org.springframework.aop.framework.adapter`] javadoc для получения дополнительной информации."}
{"id": 437, "text": "Соавторы автопроводки.\nКонтейнер Spring может автоматически связывать отношения между взаимодействующими компонентами.\nВы можете пусть Spring автоматически разрешает соавторов (другие bean-компоненты) для вашего bean-компонента проверка содержимого `ApplicationContext`.\nАвтопроводка имеет следующее преимущества:\n* Автосвязывание может значительно снизить необходимость указания свойств или конструктора.\n* Автосвязывание может обновлять конфигурацию по мере развития ваших объектов. Например, если вам нужно\nаргументы. (Другие механизмы, такие как шаблон компонента в этом отношении.). чтобы добавить зависимость к классу, эта зависимость может быть удовлетворена автоматически без вам нужно изменить конфигурацию.\nТаким образом, автоматическое подключение может быть особенно полезным. во время разработки, не отрицая возможности перехода на явную проводку при база кода становится более стабильной.\nаргументы. (Другие механизмы, такие как шаблон компонента в этом отношении.).\nПри использовании метаданных конфигурации на основе XML (см. можно указать режим автоматического подключения для определения компонента с помощью атрибута `autowire` Элемент `<bean/>`.\nФункция автоматического подключения имеет четыре режима.\nВы указываете автопроводку для каждого компонента и, таким образом, может выбирать, какие из них автоматически подключать.\nВ следующей таблице описаны четыре режима автоматического подключения:\n.Режимы автоподключения [cols=\"20%,80%\"] |=== | Режим| Объяснение. | `нет` | (По умолчанию) Без автоматического подключения."}
{"id": 438, "text": "Ссылки на компоненты должны определяться элементами `ref`.\nИзменение настройку по умолчанию не рекомендуется использовать для более крупных развертываний, поскольку указание Соавторы явно обеспечивают больший контроль и ясность.\nВ какой-то степени это документирует структуру системы.\n.Режимы автоподключения [cols=\"20%,80%\"] |=== | Режим| Объяснение. | `поИмени` | Автоподключение по имени свойства.\nSpring ищет компонент с тем же именем, что и свойство, которое необходимо автоматически подключить.\nНапример, если для определения компонента установлено значение autowire по имени и содержит свойство master (т. е. имеет свойство `setMaster(..)`), Spring ищет определение компонента с именем `master` и использует это для установки свойства.\n.Режимы автоподключения [cols=\"20%,80%\"] |=== | Режим| Объяснение. | `потипу` | Позволяет автосвязывать свойство, если в нем существует ровно один компонент типа свойства. контейнер.\nЕсли существует более одного, выдается фатальное исключение, которое указывает что вы не можете использовать автоподключение по типу для этого компонента.\nЕсли нет совпадений beans, ничего не происходит (свойство не установлено).\n.Режимы автоподключения [cols=\"20%,80%\"] |=== | Режим| Объяснение. | `конструктор` | Аналогично `byType`, но применяется к аргументам конструктора."}
{"id": 439, "text": "Если нет точно одного bean-компонента с типом аргумента конструктора в контейнере, возникает фатальная ошибка. |===\n.Режимы автоподключения [cols=\"20%,80%\"] |=== | Режим| Объяснение.\nВ режиме автоматического связывания по типу или конструктору вы можете связывать массивы и типизированные коллекции.\nВ таких случаях все кандидаты на автоподключение внутри контейнера, который соответствующие ожидаемому типу, предоставляются для удовлетворения зависимости.\nВы можете выполнить автоматическое подключение строго типизированные экземпляры Map, если ожидаемый тип ключа — String.\nАвтоматически подключенная «Карта» значения экземпляра состоят из всех экземпляров компонента, соответствующих ожидаемому типу, а Ключи экземпляра Map содержат соответствующие имена компонентов.\nОграничения и недостатки автоматического подключения.\nАвтоматическое связывание работает лучше всего, когда оно используется последовательно во всем проекте.\nЕсли автопроводка не используется вообще, разработчикам может быть сложно использовать его для подключения только одного или два определения bean-компонентов.\n* Явные зависимости в настройках `property` и `constructor-arg` всегда переопределяют.\nРассмотрим ограничения и недостатки автопроводки:. автопроводка.\nВы не можете автоматически связывать простые свойства, такие как примитивы, `Строки` и `Классы` (и массивы таких простых свойств).\nЭто ограничение по дизайну.\n* Автоматическое связывание менее точное, чем явное связывание. Хотя, как отмечалось в предыдущей таблице,\nРассмотрим ограничения и недостатки автопроводки:."}
{"id": 440, "text": "Spring старается избегать догадок в случае двусмысленности, которая может иметь неожиданные последствия. результаты.\nОтношения между объектами, управляемыми Spring, больше не являются документировано явно.\n* Информация о проводке может быть недоступна для инструментов, которые могут создавать документацию из\nРассмотрим ограничения и недостатки автопроводки:. контейнер Spring.\n* Несколько определений bean-компонентов в контейнере могут соответствовать типу, указанному в\nРассмотрим ограничения и недостатки автопроводки:. метод установки или аргумент конструктора для автоматического подключения.\nДля массивов, коллекций или `Map` экземпляры, это не обязательно проблема.\nОднако для зависимостей, которые ожидать единственного значения, эта двусмысленность не разрешается произвольно.\nЕсли нет уникального компонента определение доступно, выдается исключение.\n* Отказ от автоматического подключения в пользу явного подключения.\n* Избегайте автоматического связывания для определения компонента, устанавливая его атрибуты autowire-candidate.\n* Назначьте одно определение компонента в качестве основного кандидата, установив\nна «ложь», как описано в.\nДля атрибута `primary` элемента `<bean/>` установлено значение `true`.\n* Реализуйте более детальный контроль, доступный в конфигурации на основе аннотаций,\nна «ложь», как описано в. как описано в Конфигурация контейнера на основе аннотаций.\nИсключение компонента из автоматического подключения.\nДля каждого компонента вы можете исключить компонент из автоматического подключения."}
{"id": 441, "text": "В формате Spring XML установите атрибут `autowire-candidate` элемента `<bean/>` имеет значение `false`; с `@Bean` аннотации, атрибут называется autowireCandidate.\nКонтейнер делает это особенным определение bean-компонента недоступно для инфраструктуры автоматического подключения, включая основанное на аннотациях точки внедрения, такие как `@Autowired`.\nИсключение компонента из автоматического подключения.\nПРИМЕЧАНИЕ.\nАтрибут autowire-candidate предназначен только для автоматического связывания на основе типа.\nЭто не влияет на явные ссылки по имени, которые разрешаются, даже если указанный компонент не помечен как кандидат для автоматического подключения.\nКак следствие, автопроводка по имени, тем не менее, внедряет компонент, если имя совпадает.\nИсключение компонента из автоматического подключения.\nВы также можете ограничить кандидатов для автоматического подключения на основе сопоставления шаблонов с именами компонентов.\nЭлемент верхнего уровня `<beans/>` принимает один или несколько шаблонов внутри своего Атрибут `default-autowire-candidates`.\nНапример, чтобы ограничить статус кандидата на автоматическое подключение. для любого компонента, имя которого заканчивается на `Repository`, укажите значение `*Repository`.\nЧтобы предоставить несколько шаблонов, определить их в списке, разделенном запятыми.\nЯвное значение `true` или `false` для атрибута `autowire-candidate` определения компонента всегда принимает значение приоритет.\nДля таких bean-компонентов правила сопоставления с образцом не применяются.\nИсключение компонента из автоматического подключения."}
{"id": 442, "text": "Эти методы полезны для компонентов, которые вы никогда не хотите внедрять в другие компоненты. путем автопроводки.\nЭто не означает, что исключенный компонент не может быть настроен самостоятельно. с использованием автопроводки.\nСкорее, сам компонент не является кандидатом на автоматическое подключение других компонентов.\nИсключение компонента из автоматического подключения. [ПРИМЕЧАНИЕ] = Начиная с версии 6.2, методы `@Bean` поддерживают два варианта флага-кандидата автоматического подключения: `autowireCandidate` и `defaultCandidate`.\nИсключение компонента из автоматического подключения.\nПри использовании квалификаторы компонент, отмеченный `defaultCandidate=false`, доступен только для точек внедрения. где присутствует дополнительное указание квалификатора.\nЭто полезно для ограниченных делегаты, которые должны быть инъекционными в определенных областях, но не предназначены для мешаться бобам того же типа в других местах.\nТакой боб никогда не будет вводится только по простому объявленному типу, а не по типу плюс конкретный квалификатор.\nИсключение компонента из автоматического подключения.\nНапротив, autowireCandidate=false ведет себя точно так же, как autowire-candidate. атрибут, как описано выше: такой компонент вообще никогда не будет внедрен по типу."}
{"id": 443, "text": "Внедрение зависимостей (DI) — это процесс, при котором объекты определяют свои зависимости. (то есть другие объекты, с которыми они работают) только через аргументы конструктора, аргументы фабричного метода или свойства, которые установлены в экземпляре объекта после он создается или возвращается из фабричного метода.\nЗатем контейнер вводит эти зависимости при создании компонента.\nЭтот процесс по сути является обратным (следовательно, имя Inversion of Control) самого компонента, управляющего созданием экземпляра. или расположение его зависимостей самостоятельно, используя прямую конструкцию классов или шаблон локатора службы.\nВнедрение зависимостей.\nКод становится чище благодаря принципу DI, а развязка более эффективна, когда объекты снабжены их зависимостями.\nОбъект не ищет свои зависимости и не выполняет не знать расположение или класс зависимостей.\nВ результате ваши занятия станут проще. для тестирования, особенно когда зависимости связаны с интерфейсами или абстрактными базовыми классами, которые позволяют использовать заглушки или макетные реализации в модульных тестах.\nВнедрение зависимостей.\nDI существует в двух основных вариантах: и внедрение зависимостей на основе сеттера.\nВнедрение зависимостей на основе конструктора.\nDI на основе конструктора выполняется контейнером, вызывающим конструктор с помощью количество аргументов, каждый из которых представляет зависимость.\nВызов статического фабричного метода с конкретными аргументами для создания компонента почти эквивалентно, и это обсуждение обрабатывает аргументы конструктора и статического фабричного метода одинаково.\nВ следующем примере показан класс, который может быть внедрен только с помощью конструктора инъекция:\nJava\n	public class SimpleMovieLister {\n		// SimpleMovieLister зависит от MovieFinder"}
{"id": 444, "text": "private final MovieFinder movieFinder;\n		// конструктор, чтобы контейнер Spring мог внедрить MovieFinder\n		public SimpleMovieLister(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n		// которая бизнес-логика, фактически использует внедрение MovieFinder, опущена...\nВнедрение зависимостей на основе конструктора.\nОбратите внимание, что в этом классе нет ничего особенного.\nЭто POJO, который не зависит от конкретных интерфейсов контейнера, базовых классов или аннотаций.\nРазрешение аргументов конструктора.\nСопоставление разрешения аргументов конструктора происходит с использованием типа аргумента.\nЕсли нет потенциальная двусмысленность существует в аргументах конструктора определения компонента, Порядок, в котором аргументы конструктора определяются в определении компонента, — это порядок в котором эти аргументы передаются соответствующему конструктору, когда компонент создается экземпляр.\nРассмотрим следующий класс:\nJava\n	package x.y;\n	public class ThingOne {\n		public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n	package x.y\n	class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)\nРазрешение аргументов конструктора.\nПредполагая, что классы ThingTwo и ThingThree не связаны наследованием, нет существует потенциальная двусмысленность.\nТаким образом, следующая конфигурация работает нормально, и вы не необходимо явно указать индексы или типы аргументов конструктора в Элемент `<constructor-arg/>`.\n	<beans>\n		<bean id=\"beanOne\" class=\"x.y.ThingOne\">\n			<constructor-arg ref=\"beanTwo\"/>\n			<constructor-arg ref=\"beanThree\"/>"}
{"id": 445, "text": "</bean>\n		<bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n		<bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n	</beans>\nРазрешение аргументов конструктора.\nПри ссылке на другой компонент тип известен и может произойти сопоставление (как это было в случае с случай с предыдущим примером).\nПри использовании простого типа, например `<value>true</value>`, Spring не может определить тип значения и поэтому не может сопоставить его по типу без помощи.\nРассмотрим следующий класс:\nJava\n	package examples;\n	public class ExampleBean {\n		// Количество лет для расчета окончательного ответа\n		private final int years;\n		// Ответ на вопрос о жизни, Вселенной и всем остальном\n		private final String ultimateAnswer;\n		public ExampleBean(int years, String ultimateAnswer) {\n			this.years = years;\n			this.ultimateAnswer = ultimateAnswer;\n	package examples\n[дискретный] Соответствие типов аргументов конструктора.\nВ предыдущем сценарии контейнер может использовать сопоставление типов с простыми типами, если вы явно указываете тип аргумента конструктора через атрибут type, как показано в следующем примере:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n		<constructor-arg type=\"int\" value=\"7500000\"/>\n		<constructor-arg type=\"java.lang.String\" value=\"42\"/>"}
{"id": 446, "text": "</bean>\n[дискретный] Индекс аргумента конструктора.\nВы можете использовать атрибут index, чтобы явно указать индекс аргументов конструктора. как показано в следующем примере:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n		<constructor-arg index=\"0\" value=\"7500000\"/>\n		<constructor-arg index=\"1\" value=\"42\"/>\n	</bean>\n[дискретный] Индекс аргумента конструктора.\nПомимо разрешения неоднозначности нескольких простых значений, указание индекса устраняет неоднозначность, когда конструктор имеет два аргумента одного типа.\n[дискретный] Индекс аргумента конструктора.\nПРИМЕЧАНИЕ.\nИндекс начинается с 0.\n[дискретный] Имя аргумента конструктора.\nВы также можете использовать имя параметра конструктора для устранения неоднозначности значения, как показано ниже. пример показывает:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n		<constructor-arg name=\"years\" value=\"7500000\"/>\n		<constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n	</bean>\n[дискретный] Имя аргумента конструктора.\nИмейте в виду, что для того, чтобы эта работа работала «из коробки», ваш код должен быть скомпилирован с использованием Флаг `-parameters` включен, чтобы Spring мог искать имя параметра в конструкторе."}
{"id": 447, "text": "Если вы не можете или не хотите компилировать свой код с флагом «-parameters», вы можете использовать команду https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html[@ConstructorProperties] Аннотация JDK для явного указания аргументов конструктора.\nПример класса будет тогда надо выглядеть следующим образом:\nJava\n	package examples;\n	public class ExampleBean {\n		// Поля опущены\n		@ConstructorProperties({\"years\", \"ultimateAnswer\"})\n		public ExampleBean(int years, String ultimateAnswer) {\n			this.years = years;\n			this.ultimateAnswer = ultimateAnswer;\n	package examples\nВнедрение зависимостей на основе сеттера.\nВнедрение на основе сеттера осуществляется контейнером, вызывающим методы сеттера на вашем компьютере. bean-компоненты после вызова конструктора без аргументов или «статического» фабричного метода без аргументов для создайте экземпляр вашего bean-компонента.\nВнедрение зависимостей на основе сеттера.\nВ следующем примере показан класс, в который можно внедрить зависимости только с помощью чистого инъекция сеттера.\nЭтот класс представляет собой обычный Java.\nЭто POJO, у которого нет зависимостей. в интерфейсах, специфичных для контейнера, базовых классах или аннотациях.\nJava\n	public class SimpleMovieLister {\n		// SimpleMovieLister зависит от MovieFinder\n		private MovieFinder movieFinder;\n		// метод установки в контейнер Spring можно внедрить MovieFinder\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;"}
{"id": 448, "text": "// которая бизнес-логика, фактически использует внедрение MovieFinder, опущена...\n	// которая бизнес-логика, фактически использует внедрение MovieFinder, опущена...\nclass SimpleMovieLister {. `ApplicationContext` поддерживает DI на основе конструктора и установщика для bean-компонентов, которые он использует. управляет.\nОн также поддерживает DI на основе установщика после того, как некоторые зависимости уже были установлены. вводится с помощью конструктора.\nВы настраиваете зависимости в виде `BeanDefinition`, который вы используете вместе с экземплярами `PropertyEditor` для конвертировать свойства из одного формата в другой.\nОднако у большинства пользователей Spring не работает с этими классами напрямую (то есть программно), а скорее с XML-компонентом определения, аннотированные компоненты (то есть классы, аннотированные `@Component`, `@Controller` и т. д.) или методы `@Bean` в Java-классах `@Configuration`.\nЭти источники затем внутренне конвертируются в экземпляры BeanDefinition и используются для загрузить весь экземпляр контейнера Spring IoC.\nclass SimpleMovieLister {.\nDI на основе конструктора или установщика? **** Поскольку вы можете смешивать DI на основе конструктора и установщика, хорошим практическим правилом является используйте конструкторы для обязательных зависимостей и методов установки или методов конфигурации. для необязательных зависимостей."}
{"id": 449, "text": "Обратите внимание, что использование файла @Autowired аннотацию к методу установки можно использовать, чтобы сделать свойство обязательной зависимостью; однако внедрение конструктора с программной проверкой аргументов предпочтительнее.\nclass SimpleMovieLister {.\nКоманда Spring обычно выступает за внедрение конструктора, поскольку оно позволяет реализовать компоненты приложения как неизменяемые объекты и гарантируют, что необходимые зависимости не являются «нулевыми».\nБолее того, компоненты, внедренные конструктором, всегда возвращаются клиенту. (вызывающий) код в полностью инициализированном состоянии.\nВ качестве примечания: большое количество конструкторов аргументы — это неприятный запах кода, подразумевающий, что в классе, вероятно, слишком много аргументов. обязанности и должны быть переработаны для более эффективного разделения задач.\nclass SimpleMovieLister {.\nВнедрение сеттера в первую очередь следует использовать только для необязательных зависимостей, которые могут быть присвоены разумные значения по умолчанию внутри класса.\nВ противном случае должны быть выполнены ненулевые проверки. выполняется везде, где код использует зависимость.\nОдним из преимуществ внедрения сеттеров является то, что методы установки делают объекты этого класса доступными для реконфигурации или повторного внедрения. позже.\nТаким образом, управление посредством JMX MBeans является привлекательным вариант использования для инъекции сеттера.\nclass SimpleMovieLister {.\nИспользуйте стиль DI, который наиболее подходит для конкретного класса.\nИногда при общении со сторонними классами, для которых у вас нет исходников, выбор делается за вами."}
{"id": 450, "text": "Например, если сторонний класс не предоставляет никаких методов установки, тогда конструктор инъекции могут быть единственной доступной формой DI. ****\n* ApplicationContext создается и инициализируется метаданными конфигурации, которые\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:. описывает все бобы.\nМетаданные конфигурации могут быть заданы с помощью XML, кода Java или аннотации.\n* Для каждого bean-компонента его зависимости выражаются в виде свойств, конструктора\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:. аргументы или аргументы метода статической фабрики (если вы используете их вместо обычный конструктор).\nЭти зависимости предоставляются компоненту, когда компонент фактически создан.\n* Каждое свойство или аргумент конструктора представляет собой фактическое определение устанавливаемого значения или\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:. ссылка на другой компонент в контейнере.\n* Каждое свойство или аргумент конструктора, являющееся значением, преобразуется из указанного значения.\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:. форматировать фактический тип этого свойства или аргумента конструктора.\nПо умолчанию весна может преобразовать значение, предоставленное в строковом формате, во все встроенные типы, такие как `int`, `long`, `String`, `boolean` и т. д.\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:.\nКонтейнер Spring проверяет конфигурацию каждого компонента при создании контейнера.\nОднако сами свойства компонента не устанавливаются до тех пор, пока компонент не будет фактически создан."}
{"id": 451, "text": "Создаются bean-компоненты с одноэлементной областью действия и настроенные на предварительное создание экземпляров (по умолчанию). при создании контейнера.\nОбласти действия определены в файле Области компонентов.\nВ противном случае компонент создается только тогда, когда он запрошен.\nСоздание bean-компонента потенциально приводит к граф создаваемых bean-компонентов, а также зависимости bean-компонента и его зависимости зависимости (и т. д.) создаются и назначаются.\nОбратите внимание, что разрешение не совпадает между эти зависимости могут проявиться поздно, то есть при первом создании затронутого компонента.\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:. .Циркулярные зависимости **** Если вы используете преимущественно внедрение конструктора, можно создать неразрешимую задачу.\nСценарий циклической зависимости.\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:.\nНапример: классу A требуется экземпляр класса B посредством внедрения конструктора, и классу B требуется экземпляр класса A посредством внедрения конструктора.\nЕсли вы настроите bean-компоненты для классов A и B, которые будут внедряться друг в друга, контейнер Spring IoC обнаруживает эту циклическую ссылку во время выполнения и выдает `BeanCurrentlyInCreationException`.\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:.\nОдним из возможных решений является редактирование исходного кода некоторых классов, которые будут настроены с помощью сеттеры, а не конструкторы.\nВ качестве альтернативы избегайте внедрения конструктора и используйте только инъекция сеттера.\nДругими словами, хотя это и не рекомендуется, вы можете настроить циклические зависимости с внедрением сеттера."}
{"id": 452, "text": "Контейнер выполняет разрешение зависимостей компонентов следующим образом:.\nВ отличие от типичного случая (без циклических зависимостей), циклическая зависимость между бобами А и бобами Б заставляет один из бобов впрыскиваться в другой до того, как быть полностью инициализированным (классический сценарий «курица и яйцо»). ****\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:.\nВ целом вы можете быть уверены, что Spring поступит правильно.\nОн обнаруживает проблемы конфигурации, такие как ссылки на несуществующие bean-компоненты и циклические зависимости в контейнере время загрузки.\nSpring устанавливает свойства и разрешает зависимости как можно позже, когда бин фактически создан.\nЭто означает, что контейнер Spring, который загрузил правильно может позже сгенерировать исключение при запросе объекта, если есть проблема с созданием этого объекта или одной из его зависимостей - например, компонент выдает исключение в результате отсутствия или недопустимого свойства.\nЭто потенциально задерживает видимость некоторых проблем с конфигурацией — вот почему реализации `ApplicationContext` одноэлементные bean-компоненты по умолчанию перед созданием экземпляра.\nЦеной некоторого предварительного времени и памяти, чтобы создайте эти bean-компоненты до того, как они действительно понадобятся, вы обнаружите проблемы с конфигурацией при создании `ApplicationContext`, не позже.\nВы все равно можете переопределить это значение по умолчанию. поведение, чтобы одноэлементные компоненты инициализировались лениво, а не с нетерпением. предварительно созданный.\nКонтейнер выполняет разрешение зависимостей компонентов следующим образом:."}
{"id": 453, "text": "Если циклических зависимостей не существует, когда один или несколько взаимодействующих компонентов впрыскивается в зависимый компонент, каждый сотрудничающий компонент предварительно полностью конфигурируется. для внедрения в зависимый компонент.\nЭто означает, что если компонент A зависит от bean B, контейнер Spring IoC полностью настраивает bean B перед вызовом метод установки для bean-компонента A.\nДругими словами, создается экземпляр bean-компонента (если он не является предварительно созданный синглтон), его зависимости установлены и соответствующий жизненный цикл методы (например, bean [настроенный метод инициализации]) или метод обратного вызова InitializingBean) вызываются.\nПримеры внедрения зависимостей.\nВ следующем примере используются метаданные конфигурации на основе XML для DI на основе установщика.\nМаленький часть файла конфигурации Spring XML определяет некоторые определения bean-компонентов следующим образом:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n		<!-- setter injection using the nested ref element -->\n		<property name=\"beanOne\">\n			<ref bean=\"anotherExampleBean\"/>\n		</property>\n		<!-- setter injection using the neater ref attribute -->\n		<property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n		<property name=\"integerProperty\" value=\"1\"/>\n	</bean>\n	<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>"}
{"id": 454, "text": "<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\nJava\n	public class ExampleBean {\n		private AnotherBean beanOne;\n		private YetAnotherBean beanTwo;\n		private int i;\n		public void setBeanOne(AnotherBean beanOne) {\n			this.beanOne = beanOne;\n		public void setBeanTwo(YetAnotherBean beanTwo) {\n			this.beanTwo = beanTwo;\n		public void setIntegerProperty(int i) {\n			this.i = i;\nВ следующем примере показан соответствующий класс ExampleBean:.\nВ предыдущем примере объявлены сеттеры, соответствующие указанным свойствам. в XML-файле.\nВ следующем примере используется внедрение зависимостей на основе конструктора:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n		<!-- constructor injection using the nested ref element -->\n		<constructor-arg>\n			<ref bean=\"anotherExampleBean\"/>\n		</constructor-arg>\n		<!-- constructor injection using the neater ref attribute -->\n		<constructor-arg ref=\"yetAnotherBean\"/>\n		<constructor-arg type=\"int\" value=\"1\"/>\n	</bean>\n	<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n	<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\nJava\n	public class ExampleBean {\n		private AnotherBean beanOne;\n		private YetAnotherBean beanTwo;\n		private int i;\n		public ExampleBean("}
{"id": 455, "text": "AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {\n			this.beanOne = anotherBean;\n			this.beanTwo = yetAnotherBean;\n			this.i = i;\nВ следующем примере показан соответствующий класс ExampleBean:.\nАргументы конструктора, указанные в определении компонента, используются в качестве аргументов для конструктор `ExampleBean`.\nВ следующем примере показан соответствующий класс ExampleBean:.\nТеперь рассмотрим вариант этого примера, где вместо использования конструктора Spring сказано вызвать `статический` фабричный метод для возврата экземпляра объекта:\n	<bean id=\"exampleBean\" class=\"examples.ExampleBean\" factory-method=\"createInstance\">\n		<constructor-arg ref=\"anotherExampleBean\"/>\n		<constructor-arg ref=\"yetAnotherBean\"/>\n		<constructor-arg value=\"1\"/>\n	</bean>\n	<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n	<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\nJava\n	public class ExampleBean {\n		// частный конструктор\n		private ExampleBean(...) {\n		// статический фабричный метод; аргументы этого метода могут быть\n		// учитываем зависимости возвращаемого компонента,\n		// независимо от того, как на самом деле используются эти аргументы.\n		public static ExampleBean createInstance (\n			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {\n			ExampleBean eb = new ExampleBean (...);"}
{"id": 456, "text": "// еще какие-то операции...\n			return eb;\nВ следующем примере показан соответствующий класс ExampleBean:.\nАргументы фабричного метода static предоставляются элементами <constructor-arg/>`, точно так же, как если бы конструктор действительно использовался.\nТип класса, который является возвращаемый фабричным методом, не обязательно должен быть того же типа, что и класс, который содержит `статический` фабричный метод (хотя в этом примере он есть).\nЭкземпляр (нестатический) фабричный метод может использоваться практически идентичным образом (кроме из-за использования атрибута Factory-Bean вместо атрибута Class), поэтому мы не обсуждайте эти детали здесь."}
{"id": 457, "text": "Использование `зависит от`.\nЕсли компонент является зависимостью другого компонента, это обычно означает, что один компонент установлен как собственность другого.\nОбычно это достигается с помощью в метаданных на основе XML или через autowiring.\nИспользование `зависит от`.\nОднако иногда зависимости между компонентами менее прямые.\nПример: статический инициализатор в классе должен быть запущен, например, для регистрации драйвера базы данных.\nАтрибут «зависит от» или аннотация «@DependsOn» могут явно принудительно принудительно использовать один или несколько компонентов. должен быть инициализирован до инициализации компонента, использующего этот элемент.\nСледующий пример использует атрибут «зависит от» для выражения зависимости от одного компонента:\n	<bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager\"/>\n	<bean id=\"manager\" class=\"ManagerBean\" />\nИспользование `зависит от`.\nЧтобы выразить зависимость от нескольких компонентов, укажите список имен компонентов в качестве значения атрибут «зависит от» (запятые, пробелы и точки с запятой допустимы) разделители):\n	<bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager,accountDao\">\n		<property name=\"manager\" ref=\"manager\" />\n	</bean>\n	<bean id=\"manager\" class=\"ManagerBean\" />"}
{"id": 458, "text": "<bean id=\"accountDao\" class=\"x.y.jdbc.JdbcAccountDao\" />\nИспользование `зависит от`.\nПРИМЕЧАНИЕ.\nАтрибут «зависит от» может указывать как зависимость времени инициализации, так и в случае с singleton только beans, соответствующая зависимость от времени разрушения.\nЗависимые bean-компоненты, которые определяют Отношения «зависит от» с данным компонентом уничтожаются первыми, до данного компонента. сам разрушается.\nТаким образом, «зависит от» также может управлять порядком завершения работы."}
{"id": 459, "text": "Точки расширения контейнера.\nОбычно разработчику приложения не требуется создавать подкласс ApplicationContext. классы реализации.\nВместо этого контейнер Spring IoC можно расширить, подключив реализации специальных интерфейсов интеграции.\nСледующие несколько разделов описывают эти интерфейсы интеграции.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nИнтерфейс `BeanPostProcessor` определяет методы обратного вызова, которые вы можете реализовать для предоставить собственную логику создания экземпляров (или переопределить стандартную для контейнера), зависимость логика разрешения и так далее.\nЕсли вы хотите реализовать некоторую пользовательскую логику после Контейнер Spring завершает создание экземпляра, настройку и инициализацию компонента, вы можете подключите одну или несколько пользовательских реализаций BeanPostProcessor.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nВы можете настроить несколько экземпляров BeanPostProcessor и контролировать их порядок. в котором эти экземпляры BeanPostProcessor запускаются путем установки свойства order.\nВы можете установить это свойство, только если BeanPostProcessor реализует Ordered. интерфейс.\nЕсли вы пишете свой собственный BeanPostProcessor, вам следует рассмотреть возможность реализации интерфейс Ordered тоже.\nДля получения более подробной информации см.\nJavadoc {spring-framework-api}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`] и интерфейсы {spring-framework-api}/core/Ordered.html[`Ordered`].\nСм. также примечание о\nНастройка Bean-компонентов с помощью BeanPostProcessor. [ПРИМЕЧАНИЕ] = Экземпляры `BeanPostProcessor` работают с экземплярами bean-компонентов (или объектов)."}
{"id": 460, "text": "То есть, контейнер Spring IoC создает экземпляр экземпляра bean-компонента, а затем `BeanPostProcessor` экземпляры делают свою работу.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nЭкземпляры BeanPostProcessor имеют область действия для каждого контейнера.\nЭто актуально только в том случае, если вы использовать иерархии контейнеров.\nЕсли вы определите BeanPostProcessor в одном контейнере, он обрабатывает только bean-компоненты в этом контейнере.\nДругими словами, бобы, которые определенные в одном контейнере, не подвергаются постобработке с помощью BeanPostProcessor, определенного в другой контейнер, даже если оба контейнера являются частью одной и той же иерархии.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nЧтобы изменить фактическое определение компонента (то есть схему, определяющую компонент), вместо этого вам нужно использовать BeanFactoryPostProcessor, как описано в =\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nИнтерфейс `org.springframework.beans.factory.config.BeanPostProcessor` состоит из ровно два метода обратного вызова.\nКогда такой класс регистрируется как постпроцессор с контейнер, для каждого экземпляра компонента, созданного контейнером, постпроцессор получает обратный вызов из контейнера перед контейнером методы инициализации (такие как `InitializingBean.afterPropertiesSet()` или любой другой объявленный метод `init`), и после инициализации любого компонента выполняются обратные вызовы.\nПостпроцессор может выполнять любые действия с экземпляром компонента, включая игнорирование обратный вызов полностью.\nПостпроцессор компонента обычно проверяет интерфейсы обратного вызова, или он может обернуть компонент прокси."}
{"id": 461, "text": "Некоторые классы инфраструктуры Spring AOP реализованы как постпроцессоры bean-компонентов для обеспечения логики прокси-обертывания.\nНастройка Bean-компонентов с помощью BeanPostProcessor. `ApplicationContext` автоматически обнаруживает любые bean-компоненты, определенные в метаданные конфигурации, реализующие интерфейс BeanPostProcessor. `ApplicationContext` регистрирует эти bean-компоненты как постпроцессоры, чтобы их можно было вызывать позже, при создании компонента.\nПостпроцессоры Bean могут быть развернуты в контейнере в так же, как и любые другие бобы.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nОбратите внимание, что при объявлении BeanPostProcessor с использованием фабричного метода @Bean на класс конфигурации, тип возвращаемого значения фабричного метода должен быть реализацией сам класс или, по крайней мере, `org.springframework.beans.factory.config.BeanPostProcessor` интерфейс, четко указывающий на постпроцессорную природу этого компонента.\nВ противном случае `ApplicationContext` не может автоматически определить его по типу до его полного создания.\nПоскольку экземпляр BeanPostProcessor должен быть создан заранее, чтобы примениться к инициализации других bean-компонентов в контексте, это раннее обнаружение типов имеет решающее значение.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nПрограммная регистрация экземпляров BeanPostProcessor.\nПРИМЕЧАНИЕ.\nХотя рекомендуемый подход к регистрации BeanPostProcessor заключается в Автоопределение `ApplicationContext` (как описано ранее), их можно зарегистрировать программно против `ConfigurableBeanFactory` с помощью `addBeanPostProcessor` метод."}
{"id": 462, "text": "Это может быть полезно, когда вам нужно оценить условную логику перед регистрации или даже для копирования постпроцессоров компонентов между контекстами иерархии.\nОднако обратите внимание, что экземпляры BeanPostProcessor, добавленные программно, не учитывают `Упорядоченный` интерфейс.\nЗдесь порядок регистрации диктует порядок исполнения.\nТакже обратите внимание, что экземпляры BeanPostProcessor регистрируются программно. всегда обрабатываются раньше тех, которые регистрируются посредством автоматического обнаружения, независимо от каких-либо явный порядок.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nЭкземпляры.`BeanPostProcessor` и автоматическое проксирование AOP [ПРИМЕЧАНИЕ] = Классы, реализующие интерфейс BeanPostProcessor, являются специальными и обрабатываются по-разному в зависимости от контейнера.\nВсе экземпляры BeanPostProcessor и bean-компоненты, которые они прямая ссылка создается при запуске, как часть специальной фазы запуска из `ApplicationContext`.\nДалее регистрируются все экземпляры BeanPostProcessor. отсортированным образом и применяется ко всем остальным бобам в контейнере.\nПотому что АОП автоматическое проксирование реализовано как сам BeanPostProcessor, а не как BeanPostProcessor. ни экземпляры, ни bean-компоненты, на которые они напрямую ссылаются, не подлежат автоматическому проксированию и, таким образом, в них не вплетены аспекты.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nДля любого такого bean-компонента вы должны увидеть информационное сообщение журнала: `Bean someBean is not имеет право на обработку всеми интерфейсами BeanPostProcessor (например: не имеет право на автоматическое проксирование)`.\nНастройка Bean-компонентов с помощью BeanPostProcessor."}
{"id": 463, "text": "Если у вас есть bean-компоненты, подключенные к вашему `BeanPostProcessor` с помощью автоматического подключения или `@Resource` (который может вернуться к автоподключению), Spring может получить доступ к неожиданным bean-компонентам при поиске кандидатов зависимостей, соответствующих типу, и, следовательно, сделать их не подходит для автоматического проксирования или других видов постобработки компонентов.\nНапример, если вы иметь зависимость, помеченную `@Resource`, где имя поля или установщика не указано напрямую соответствуют объявленному имени компонента и атрибут имени не используется, Spring обращается к другим компонентам для сопоставления их по типу.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nСледующие примеры показывают, как писать, регистрировать и использовать экземпляры BeanPostProcessor. в `ApplicationContext`.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nПример: Hello World, стиль BeanPostProcessor.\nНастройка Bean-компонентов с помощью BeanPostProcessor.\nЭтот первый пример иллюстрирует базовое использование.\nВ примере показан пользовательский Реализация `BeanPostProcessor`, которая вызывает метод `toString()` каждого bean-компонента как он создается контейнером и выводит полученную строку на системную консоль.\nJava\n	package scripting;\n	import org.springframework.beans.factory.config.BeanPostProcessor;\n	public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {\n		// просто верните созданный компонент как есть\n		public Object postProcessBeforeInitialization(Object bean, String beanName) {\n			return bean; // we could potentially return any object reference here..."}
{"id": 464, "text": "public Object postProcessAfterInitialization(Object bean, String beanName) {\n			System.out.println(\"Bean '\" + beanName + \"' created : \" + bean.toString());\n			return bean;\n	package scripting\n	class InstantiationTracingBeanPostProcessor : BeanPostProcessor {\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:lang=\"http://www.springframework.org/schema/lang\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/lang\n			https://www.springframework.org/schema/lang/spring-lang.xsd\">\n		<lang:groovy id=\"messenger\"\n				script-source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\">\n			<lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/>\n		</lang:groovy>"}
{"id": 465, "text": "когда создается экземпляр вышеуказанного bean-компонента (мессенджера), этот заказ\n		Реализация BeanPostProcessor выведет этот факт на системную консоль.\n		<bean class=\"scripting.InstantiationTracingBeanPostProcessor\"/>\n	</beans>\nСледующий элемент beans использует InstantiationTracingBeanPostProcessor:.\nОбратите внимание, что InstantiationTracingBeanPostProcessor просто определен.\nЭто не даже иметь имя, и, поскольку это bean-компонент, в него можно внедрить зависимости, как и в любой другой компонент. другой боб. (Предыдущая конфигурация также определяет компонент, поддерживаемый Groovy. сценарий.)\nJava\n	import org.springframework.context.ApplicationContext;\n	import org.springframework.context.support.ClassPathXmlApplicationContext;\n	import org.springframework.scripting.Messenger;\n	public final class Boot {\n		public static void main(final String[] args) throws Exception {\n			ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\");\n			Messenger messenger = ctx.getBean(\"messenger\", Messenger.class);\n			System.out.println(messenger);\n[literal,subs=\"дословно,цитаты\"].\nКомпонент 'messenger' создан: org.springframework.scripting.groovy.GroovyMessenger org.springframework.scripting.groovy.GroovyMessenger@272961\n[literal,subs=\"дословно,цитаты\"].\nПример: AutowiredAnnotationBeanPostProcessor.\n[literal,subs=\"дословно,цитаты\"]."}
{"id": 466, "text": "Использование интерфейсов обратного вызова или аннотаций в сочетании с пользовательским BeanPostProcessor. реализация — это распространенное средство расширения контейнера Spring IoC.\nПримером является Spring `AutowiredAnnotationBeanPostProcessor` — реализация BeanPostProcessor` который поставляется с дистрибутивом Spring и автоматически подключает аннотированные поля, методы установки, и произвольные методы конфигурации.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nСледующая точка расширения, которую мы рассмотрим, — это `org.springframework.beans.factory.config.BeanFactoryPostProcessor`.\nСемантика этот интерфейс аналогичен интерфейсам BeanPostProcessor, с одним основным разница: `BeanFactoryPostProcessor` работает с метаданными конфигурации компонента.\nТо есть контейнер Spring IoC позволяет BeanFactoryPostProcessor читать метаданные конфигурации и, возможно, изменить их _до_ создания экземпляра контейнера любые bean-компоненты, кроме экземпляров BeanFactoryPostProcessor.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nВы можете настроить несколько экземпляров BeanFactoryPostProcessor и контролировать их порядок. который эти экземпляры `BeanFactoryPostProcessor` запускают, устанавливая свойство `order`.\nОднако вы можете установить это свойство, только если BeanFactoryPostProcessor реализует `Упорядоченный` интерфейс.\nЕсли вы пишете свой собственный BeanFactoryPostProcessor, вам следует рассмотрите возможность реализации интерфейса Ordered.\nСм. javadoc {spring-framework-api}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`] и интерфейсы {spring-framework-api}/core/Ordered.html[`Ordered`] для получения более подробной информации."}
{"id": 467, "text": "Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor. [ПРИМЕЧАНИЕ] = Если вы хотите изменить фактические экземпляры bean-компонента (то есть объекты, созданные из метаданных конфигурации), то вместо этого вам нужно использовать BeanPostProcessor. (описано ранее в Хотя технически возможно работать с экземплярами bean-компонентов внутри BeanFactoryPostProcessor. (например, используя `BeanFactory.getBean()`), это приводит к преждевременному созданию экземпляра bean-компонента, нарушение стандартного жизненного цикла контейнера.\nЭто может вызвать негативные побочные эффекты, такие как минуя постобработку bean-компонента.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nКроме того, экземпляры BeanFactoryPostProcessor ограничены для каждого контейнера.\nЭто актуально только если вы используете иерархии контейнеров.\nЕсли вы определяете `BeanFactoryPostProcessor` в одном контейнере, он применяется только к определениям компонентов в этом контейнере.\nОпределения компонентов в одном контейнере не обрабатываются экземплярами BeanFactoryPostProcessor в другом контейнер, даже если оба контейнера являются частью одной и той же иерархии.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nПостпроцессор фабрики компонентов запускается автоматически, когда он объявляется внутри `ApplicationContext`, чтобы применить изменения к метаданным конфигурации, которые определить контейнер.\nSpring включает в себя ряд предопределенных фабрик компонентов. постпроцессоры, такие как PropertyOverrideConfigurer и `PropertySourcesPlaceholderConfigurer`.\nВы также можете использовать собственный BeanFactoryPostProcessor. -- например, для регистрации редакторов пользовательских свойств."}
{"id": 468, "text": "Настройка метаданных конфигурации с помощью BeanFactoryPostProcessor. `ApplicationContext` автоматически обнаруживает любые развернутые в нем bean-компоненты, которые реализовать интерфейс BeanFactoryPostProcessor.\nОн использует эти бобы в качестве фабрики по производству бобов. постпроцессоры в нужное время.\nВы можете развернуть эти bean-компоненты постпроцессора как вы бы выбрали любой другой боб.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nПРИМЕЧАНИЕ.\nКак и в случае с BeanPostProcessor, вы обычно не хотите настраивать ``BeanFactoryPostProcessor`` для отложенной инициализации.\nЕсли ни один другой компонент не ссылается на `Bean(Factory)PostProcessor`, этот постпроцессор вообще не будет создан.\nТаким образом, пометка его для отложенной инициализации будет проигнорирована, и `Bean(Factory)PostProcessor` будет быстро создан, даже если вы установите Атрибуту `default-lazy-init` присвоено значение `true` в объявлении вашего элемента `<beans />`.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nПример: замена заполнителя свойства с помощью PropertySourcesPlaceholderConfigurer.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nВы можете использовать PropertySourcesPlaceholderConfigurer для экстернализации значений свойств. из определения компонента в отдельном файле, используя стандартный формат Java «Свойства».\nЭто позволяет человеку, развертывающему приложение, настраивать его с учетом специфики среды. свойства, такие как URL-адреса баз данных и пароли, без сложностей и рисков изменение основного файла или файлов определения XML для контейнера.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor."}
{"id": 469, "text": "Рассмотрим следующий фрагмент метаданных конфигурации на основе XML, где DataSource со значениями заполнителей определяется:\n	<bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">\n		<property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/>\n	</bean>\n	<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n		<property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>\n		<property name=\"url\" value=\"${jdbc.url}\"/>\n		<property name=\"username\" value=\"${jdbc.username}\"/>\n		<property name=\"password\" value=\"${jdbc.password}\"/>\n	</bean>\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nВ примере показаны свойства, настроенные из внешнего файла Properties.\nВо время выполнения, к метаданным применяется PropertySourcesPlaceholderConfigurer, который заменяет некоторые свойства `DataSource`.\nЗаменяемые значения указываются как заполнители form pass:q[`${property-name}`], который соответствует стилю Ant, log4j и JSP EL.\nНастройка метаданных конфигурации с помощью BeanFactoryPostProcessor.\nФактические значения берутся из другого файла в стандартном формате Java «Свойства»:"}
{"id": 470, "text": "[literal,subs=\"дословно,цитаты\"]. jdbc.driverClassName=org.hsqldb.jdbcDriver jdbc.url=jdbc:hsqldb:hsql://production:9002 jdbc.username=sa jdbc.password=root\n[literal,subs=\"дословно,цитаты\"].\nТаким образом, строка `${jdbc.username}` заменяется во время выполнения значением 'sa' и то же самое относится и к другим значениям-заполнителям, которые соответствуют ключам в файле свойств.\nPropertySourcesPlaceholderConfigurer проверяет наличие заполнителей в большинстве свойств и атрибуты определения компонента.\nКроме того, вы можете настроить префикс заполнителя, суффикс, разделитель значений по умолчанию и escape-символ.\nКроме того, экранирование по умолчанию персонажа можно изменить или отключить глобально, установив параметр `spring.placeholder.escapeCharacter.default` через системное свойство JVM (или через механизм SpringProperties[`SpringProperties`]).\n[literal,subs=\"дословно,цитаты\"].\nС помощью пространства имен context вы можете настроить заполнители свойств. со специальным элементом конфигурации.\nВы можете указать одно или несколько местоположений в качестве список, разделенный запятыми, в атрибуте location, как показано в следующем примере:\n	<context:property-placeholder location=\"classpath:com/something/jdbc.properties\"/>\n[literal,subs=\"дословно,цитаты\"]."}
{"id": 471, "text": "PropertySourcesPlaceholderConfigurer не только ищет свойства в свойстве. файл, который вы указываете.\nПо умолчанию, если не удается найти свойство в указанных файлах свойств, он проверяет свойства Spring `Environment` и обычные свойства Java `System`.\n[literal,subs=\"дословно,цитаты\"]. [ВНИМАНИЕ] = Для данного приложения должен быть определен только один такой элемент со свойствами что это нужно.\nМожно настроить несколько заполнителей свойств, если они имеют отдельные синтаксис заполнителя (`${...}`).\n[literal,subs=\"дословно,цитаты\"].\nЕсли вам необходимо модулировать источник свойств, используемых для замены, вам следует не создавать несколько заполнителей свойств.\nСкорее, вам следует создать свой собственный Компонент `PropertySourcesPlaceholderConfigurer`, который собирает используемые свойства.\n[literal,subs=\"дословно,цитаты\"]. [СОВЕТ] = Вы можете использовать PropertySourcesPlaceholderConfigurer для замены имен классов, которые иногда полезно, когда вам нужно выбрать конкретный класс реализации во время выполнения.\nВ следующем примере показано, как это сделать:\n	<bean class=\"org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer\">\n		<property name=\"locations\">\n			<value>classpath:com/something/strategy.properties</value>\n		</property>\n		<property name=\"properties\">"}
{"id": 472, "text": "<value>custom.strategy.class=com.something.DefaultStrategy</value>\n		</property>\n	</bean>\n	<bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/>\n[literal,subs=\"дословно,цитаты\"].\nЕсли класс не может быть разрешен во время выполнения в допустимый класс, разрешение компонента происходит сбой, когда он вот-вот будет создан, что происходит во время `preInstantiateSingletons()` фаза `ApplicationContext` для bean-компонента без ленивой инициализации.\n[literal,subs=\"дословно,цитаты\"].\nПример: PropertyOverrideConfigurer.\n[literal,subs=\"дословно,цитаты\"].\nPropertyOverrideConfigurer, еще один постпроцессор фабрики компонентов, напоминает `PropertySourcesPlaceholderConfigurer`, но в отличие от последнего, исходные определения может иметь значения по умолчанию или вообще не иметь значений для свойств компонента.\nЕсли переопределение В файле `Properties` нет записи для определенного свойства компонента, значение по умолчанию используется определение контекста.\n[literal,subs=\"дословно,цитаты\"].\nОбратите внимание, что определение компонента не знает о переопределении, поэтому оно не из файла определения XML сразу становится очевидным, что используется конфигуратор переопределения. использован.\nВ случае нескольких экземпляров PropertyOverrideConfigurer, которые определяют разные значения для одного и того же свойства компонента, последний из них выигрывает из-за механизма переопределения."}
{"id": 473, "text": "dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql:mydb.\nЭтот пример файла можно использовать с определением контейнера, который содержит компонент с именем dataSource, который имеет свойства driverClassName и url.\ndataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql:mydb.\nТакже поддерживаются составные имена свойств, если каждый компонент пути за исключением того, что последнее переопределяемое свойство уже не равно нулю (предположительно инициализировано конструкторами).\nВ следующем примере свойство Sammy объекта Bob свойству `fred` bean-компонента `tom` присвоено скалярное значение `123`:\ntom.fred.bob.sammy=123.\nПРИМЕЧАНИЕ.\nУказанные значения переопределения всегда являются буквальными значениями.\nОни не переведены на ссылки на бобы.\nЭто соглашение также применяется, когда исходное значение в XML-компоненте определение указывает ссылку на компонент.\ntom.fred.bob.sammy=123.\nБлагодаря пространству имен context, представленному в Spring 2.5, можно настроить переопределение свойства с помощью специального элемента конфигурации, как показано в следующем примере:\nНастройка логики создания экземпляров с помощью FactoryBean.\nВы можете реализовать интерфейс `org.springframework.beans.factory.FactoryBean` для объектов, которые сами являются фабриками.\nНастройка логики создания экземпляров с помощью FactoryBean.\nИнтерфейс FactoryBean — это точка подключения к контейнеру Spring IoC. логика создания экземпляров."}
{"id": 474, "text": "Если у вас сложный код инициализации, который лучше выразить в Java, в отличие от (потенциально) подробного объема XML, вы можете создать свой собственный `FactoryBean`, напишите сложную инициализацию внутри этого класса, а затем подключите свой пользовательский FactoryBean в контейнер.\n* `T getObject()`: Возвращает экземпляр объекта, созданного этой фабрикой.\nИнтерфейс FactoryBean<T> предоставляет три метода:. экземпляр может быть общим, в зависимости от того, возвращает ли эта фабрика синглтоны или прототипы.\n* `boolean isSingleton()`: возвращает `true`, если этот `FactoryBean` возвращает одиночные элементы или\nИнтерфейс FactoryBean<T> предоставляет три метода:. «ложь» в противном случае.\nРеализация этого метода по умолчанию возвращает true.\n* `Class<?> getObjectType()`: возвращает тип объекта, возвращаемый методом `getObject()`.\nИнтерфейс FactoryBean<T> предоставляет три метода:. или `null`, если тип заранее не известен.\nИнтерфейс FactoryBean<T> предоставляет три метода:.\nКонцепция и интерфейс FactoryBean используются во многих местах Spring.\nРамки.\nВ состав Spring входит более 50 реализаций интерфейса FactoryBean. сам.\nИнтерфейс FactoryBean<T> предоставляет три метода:."}
{"id": 475, "text": "Когда вам нужно запросить у контейнера сам экземпляр FactoryBean вместо bean-компонент, который он производит, префикс `id` bean-компонента с символом амперсанда (`&`), когда вызов метода getBean() класса ApplicationContext.\nИтак, для данного FactoryBean с идентификатором `myBean`, вызов `getBean(\"myBean\")` в контейнере возвращает продукт FactoryBean, тогда как вызов getBean(\"&myBean\") возвращает Сам экземпляр FactoryBean."}
{"id": 476, "text": "Лениво инициализированные компоненты.\nПо умолчанию реализации ApplicationContext охотно создают и настраивают все процесс.\nКак правило, такая предварительная реализация желательна, поскольку ошибки в конфигурация или окружающая среда обнаруживаются немедленно, а не часами или даже несколько дней спустя.\nЕсли такое поведение нежелательно, вы можете предотвратить предварительное создание экземпляра одноэлементного компонента путем маркировки определения компонента как ленивая инициализация.\nКомпонент с ленивой инициализацией сообщает контейнеру IoC создать компонент. экземпляре при первом запросе, а не при запуске.\nЛениво инициализированные компоненты.\nЭто поведение контролируется аннотацией `@Lazy` или в XML атрибутом `lazy-init` элемента `<bean/>`, как следующий пример показывает: См. пример кода в исходном документе.\nЛениво инициализированные компоненты.\nКогда предыдущая конфигурация используется ApplicationContext, ленивый bean-компонент не создается заранее при запуске `ApplicationContext`, тогда как `notLazy` тщательно создается заранее.\nЛениво инициализированные компоненты.\nОднако, когда лениво инициализированный bean-компонент является зависимостью одноэлементного bean-компонента, который не инициализированный с отложенной инициализацией, `ApplicationContext` создает bean-компонент с ленивой инициализацией по адресу start, потому что он должен удовлетворять зависимостям синглтона.\nКомпонент с ленивой инициализацией вводится в одноэлементный компонент в другом месте, где не выполняется ленивая инициализация.\nЛениво инициализированные компоненты."}
{"id": 477, "text": "Вы также можете управлять отложенной инициализацией набора bean-компонентов, используя аннотацию @Lazy в файле @Configuration. аннотированный класс или в XML, используя атрибут `default-lazy-init` в элементе `<beans/>`, как показано в следующем примере. показывает: См. пример кода в исходном документе."}
{"id": 478, "text": "Внедрение метода.\nВ большинстве сценариев приложений большинство компонентов в контейнере Singleton Bean должен взаимодействовать с другим Singleton Bean или не-Singleton Bean необходимо сотрудничать с другим компонентом, не являющимся одноэлементным, вы обычно обрабатываете зависимость определяя один компонент как свойство другого.\nПроблема возникает, когда жизненный цикл компонента разные.\nПредположим, что одноэлементный компонент A должен использовать неодноэлементный (прототипный) компонент B, возможно, при каждом вызове метода на A.\nКонтейнер создает только одноэлементный компонент A. один раз и, таким образом, получает только одну возможность установить свойства.\nКонтейнер не может предоставлять bean-компоненту A новый экземпляр bean-компонента B каждый раз, когда он необходим.\nВнедрение метода.\nРешение состоит в том, чтобы отказаться от некоторой инверсии контроля.\nВы можете реализуя интерфейс ApplicationContextAware, и посредством вызова `getBean(\"B\")` к контейнеру] запросить (обычно новый) экземпляр bean B каждый раз, когда bean A нуждается в этом.\nСледующий пример показывает этот подход:\nJava\n	package fiona.apple;\n	// Импорт Spring-API\n	import org.springframework.beans.BeansException;\n	import org.springframework.context.ApplicationContext;\n	import org.springframework.context.ApplicationContextAware;\n	 * A class that uses a stateful Command-style class to perform\n	 * some processing.\n	public class CommandManager implements ApplicationContextAware {\n		private ApplicationContext applicationContext;\n		public Object process(Map commandState) {\n			// возьмите новый экземпляр соответствующей команды"}
{"id": 479, "text": "Command command = createCommand();\n			// установить состояние экземпляра команды (надеюсь, нового)\n			command.setState(commandState);\n			return command.execute();\n		protected Command createCommand() {\n			// обратите внимание на зависимость Spring API!\n			return this.applicationContext.getBean(\"command\", Command.class);\n		public void setApplicationContext(\n				ApplicationContext applicationContext) throws BeansException {\n			this.applicationContext = applicationContext;\n	package fiona.apple\n	// Импорт Spring-API\n	// Класс, который использует класс в стиле Command с сохранением состояния для выполнения\n	// некоторая обработка.\n	class CommandManager : ApplicationContextAware {\nВнедрение метода.\nПредыдущее нежелательно, поскольку бизнес-код знает и связан с Весенний фреймворк.\nВнедрение метода, несколько продвинутая функция Spring IoC. контейнер, позволяет вам аккуратно обработать этот вариант использования.\nВнедрение метода. **** Вы можете прочитать больше о мотивации внедрения метода в {spring-site-blog}/2004/08/06/method-injection/[эта запись в блоге]. ****\nВнедрение метода поиска — это способность контейнера переопределять методы bean-компоненты, управляемые контейнером, и вернуть результат поиска для другого именованного bean-компонента в контейнер.\nПоиск обычно включает прототип bean-компонента, как в описанном сценарии. в предыдущий раздел."}
{"id": 480, "text": "Spring Framework реализует этот метод внедрения, используя генерацию байт-кода из библиотеки CGLIB для динамически генерировать подкласс, который переопределяет метод.\n* Чтобы это динамическое подклассирование работало, класс, который находится в контейнере bean-компонентов Spring,\n[ПРИМЕЧАНИЕ]. подклассы не могут быть «финальными», и переопределяемый метод также не может быть «финальным».\n* Модульное тестирование класса, имеющего `абстрактный` метод, требует создания подкласса класса.\n[ПРИМЕЧАНИЕ]. самостоятельно и предоставить заглушку реализации `абстрактного` метода.\n* Еще одним ключевым ограничением является то, что методы поиска не работают с фабричными методами и\n[ПРИМЕЧАНИЕ]. в частности, не с методами `@Bean` в классах конфигурации, поскольку в этом случае контейнер не отвечает за создание экземпляра и поэтому не может создавать подкласс, создаваемый во время выполнения на лету.\n[ПРИМЕЧАНИЕ].\nВ случае с классом CommandManager в предыдущем фрагменте кода Контейнер Spring динамически переопределяет реализацию createCommand(). метод.\nКласс CommandManager не имеет каких-либо зависимостей Spring, так как переработанный пример показывает:\nJava\n	package fiona.apple;\n	// больше никакого весеннего импорта!\n	public abstract class CommandManager {\n		public Object process(Object commandState) {\n			// возьмите новый экземпляр соответствующего командного интерфейса\n			Command command = createCommand();\n			// установить состояние экземпляра команды (надеюсь, нового)\n			command.setState(commandState);\n			return command.execute();"}
{"id": 481, "text": "// окей... но где реализация этого метода?\n		protected abstract Command createCommand();\n	package fiona.apple\n	// больше никакого весеннего импорта!\n	abstract class CommandManager {\n[ПРИМЕЧАНИЕ].\nВ клиентском классе, содержащем внедряемый метод (CommandManager в этом примере случае), метод, который будет внедрен, требует подписи следующего вида:\n	<public|protected> [abstract] <return-type> theMethodName(no-arguments);\n[ПРИМЕЧАНИЕ].\nЕсли метод является «абстрактным», динамически создаваемый подкласс реализует этот метод.\nВ противном случае динамически созданный подкласс переопределяет конкретный метод, определенный в оригинальный класс.\nРассмотрим следующий пример:\n	<!-- a stateful bean deployed as a prototype (non-singleton) -->\n	<bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\">\n		<!-- inject dependencies here as required -->\n	</bean>\n	<!-- commandManager uses myCommand prototype bean -->\n	<bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n		<lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n	</bean>\n[ПРИМЕЧАНИЕ]."}
{"id": 482, "text": "Компонент, идентифицированный как `commandManager`, вызывает собственный метод `createCommand()`. всякий раз, когда ему нужен новый экземпляр bean-компонента `myCommand`.\nВы должны быть осторожны при развертывании компонент `myCommand` в качестве прототипа, если это действительно то, что нужно.\nЕсли это a singleton, тот же экземпляр `myCommand` bean возвращается каждый раз.\n[ПРИМЕЧАНИЕ].\nАльтернативно, в модели компонента на основе аннотаций вы можете объявить поиск через аннотацию `@Lookup`, как показано в следующем примере:\nJava\n	public abstract class CommandManager {\n		public Object process(Object commandState) {\n			Command command = createCommand();\n			command.setState(commandState);\n			return command.execute();\n		@Lookup(\"myCommand\")\n		protected abstract Command createCommand();\n	abstract class CommandManager {\n[ПРИМЕЧАНИЕ].\nИли, более идиоматично, вы можете рассчитывать на то, что целевой компонент будет разрешен против объявленный тип возвращаемого значения метода поиска:\nJava\n	public abstract class CommandManager {\n		public Object process(Object commandState) {\n			Command command = createCommand();\n			command.setState(commandState);\n			return command.execute();\n		@Lookup\n		protected abstract Command createCommand();\n	abstract class CommandManager {\n[ПРИМЕЧАНИЕ]. [СОВЕТ] = Другой способ доступа к целевым компонентам с разной областью действия — это `ObjectFactory`/.\nТочка внедрения `Provider`."}
{"id": 483, "text": "См.\n[ПРИМЕЧАНИЕ].\nВы также можете найти `ServiceLocatorFactoryBean` (в `org.springframework.beans.factory.config`), чтобы быть полезным.\nПроизвольная замена метода.\nМенее полезная форма внедрения метода, чем внедрение метода поиска, — это возможность замените произвольные методы в управляемом компоненте другой реализацией метода. ты можете спокойно пропустить остальную часть этого раздела, пока эта функция вам действительно не понадобится.\nПроизвольная замена метода.\nС метаданными конфигурации на основе XML вы можете использовать элемент replaced-method для замените существующую реализацию метода другой для развернутого компонента.\nРассмотрим следующий класс, у которого есть метод ComputeValue, который мы хотим переопределить:\nJava\n	public class MyValueCalculator {\n		public String computeValue(String input) {\n			// какой-то реальный код...\n		// еще какие-то методы...\n	class MyValueCalculator {\n		// еще какие-то методы...\nПроизвольная замена метода.\nКласс, реализующий `org.springframework.beans.factory.support.MethodReplacer` Интерфейс предоставляет новое определение метода, как показано в следующем примере:\nJava\n		public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n			// получить входное значение, работать с ним и вернуть вычисленный результат\n			String input = (String) args[0];\n			return ...;\nПроизвольная замена метода."}
{"id": 484, "text": "Определение компонента для развертывания исходного класса и указания переопределения метода будет напоминают следующий пример:\n	<bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\">\n		<!-- arbitrary method replacement -->\n		<replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\">\n			<arg-type>String</arg-type>\n		</replaced-method>\n	</bean>\n	<bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/>\nПроизвольная замена метода.\nВы можете использовать один или несколько элементов `<arg-type/>` внутри `<replaced-method/>` элемент, указывающий сигнатуру переопределяемого метода.\nПодпись для аргументов необходим только если метод перегружен и имеется несколько вариантов существуют внутри класса.\nДля удобства строка типа аргумента может быть подстрока полного имени типа.\nНапример, все следующее соответствует `java.lang.String`:\n	java.lang.String\n	String\n	Str\nПроизвольная замена метода.\nПоскольку количества аргументов часто достаточно, чтобы различать все возможные варианты. выбор, этот ярлык может сэкономить много времени на вводе текста, позволяя вводить только кратчайшая строка, соответствующая типу аргумента."}
{"id": 485, "text": "Настройка природы компонента.\nSpring Framework предоставляет ряд интерфейсов, которые вы можете использовать для настройки характера боба.\nВ этом разделе они группируются следующим образом:\n* Обратные вызовы жизненного цикла\n* `ApplicationContextAware` и `BeanNameAware`\n* Другие `Aware` интерфейсы\nОбратные вызовы жизненного цикла.\nДля взаимодействия с контейнером, управляющим жизненным циклом компонента, вы можете реализовать интерфейсы Spring `InitializingBean` и `DisposableBean`.\nКонтейнер вызывает `afterPropertiesSet()` для первого и `destroy()` для второго, чтобы позволить компоненту выполнить определенные действия при инициализации и уничтожении ваших bean-компонентов.\nОбратные вызовы жизненного цикла. [СОВЕТ] = Аннотации JSR-250 `@PostConstruct` и `@PreDestroy` обычно считаются лучшими. практика получения обратных вызовов жизненного цикла в современном приложении Spring.\nИспользуя эти аннотации означают, что ваши bean-компоненты не связаны с интерфейсами, специфичными для Spring.\nПодробности см. в с использованием `@PostConstruct` и `@PreDestroy`.\nОбратные вызовы жизненного цикла.\nЕсли вы не хотите использовать аннотации JSR-250, но все равно хотите удалить рассмотрите метаданные определения bean-компонентов `init-method` и`destroy-method`.\nОбратные вызовы жизненного цикла.\nВнутри Spring Framework использует реализации BeanPostProcessor для обработки любых интерфейсы обратного вызова, которые он может найти и вызвать соответствующие методы."}
{"id": 486, "text": "Если вам нужен индивидуальный функции или другое поведение жизненного цикла Spring по умолчанию не предлагает, вы можете реализуйте `BeanPostProcessor` самостоятельно.\nДля получения дополнительной информации см.\nОбратные вызовы жизненного цикла.\nВ дополнение к обратным вызовам инициализации и уничтожения объекты, управляемые Spring, могут также реализовать интерфейс «Жизненный цикл», чтобы эти объекты могли участвовать в процесс запуска и завершения работы, определяемый собственным жизненным циклом контейнера.\nОбратные вызовы жизненного цикла.\nВ этом разделе описаны интерфейсы обратного вызова жизненного цикла.\nОбратные вызовы инициализации.\nИнтерфейс `org.springframework.beans.factory.InitializingBean` позволяет bean-компоненту выполнить работу по инициализации после того, как контейнер установил все необходимые свойства на боб.\nИнтерфейс InitializingBean определяет один метод:\n	void afterPropertiesSet() throws Exception;\nОбратные вызовы инициализации.\nМы рекомендуем вам не использовать интерфейс `InitializingBean`, поскольку он излишне связывает код с Spring.\nВ качестве альтернативы мы предлагаем использовать аннотацию `@PostConstruct` или указание метода инициализации POJO.\nВ случае метаданных конфигурации на основе XML: вы можете использовать атрибут init-method, чтобы указать имя метода, который имеет void подпись без аргументов.\nВ конфигурации Java вы можете использовать атрибут initMethod `@Бин`.\nСм.\nПолучение обратных вызовов жизненного цикла.\nРассмотрим следующий пример:\n	<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\nJava\n	public class ExampleBean {"}
{"id": 487, "text": "public void init() {\n			// сделать некоторую работу по инициализации\n	class ExampleBean {\nОбратные вызовы инициализации.\nПредыдущий пример имеет почти тот же эффект, что и следующий пример. (который состоит из двух списков):\n	<bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/>\nJava\n	public class AnotherExampleBean implements InitializingBean {\n		@Override\n		public void afterPropertiesSet() {\n			// сделать некоторую работу по инициализации\n	class AnotherExampleBean : InitializingBean {\nОбратные вызовы инициализации.\nОднако первый из двух предыдущих примеров не связывает код с Spring.\nОбратные вызовы инициализации. [ПРИМЕЧАНИЕ] = Имейте в виду, что `@PostConstruct` и методы инициализации в целом выполняются внутри блокировки создания синглтона контейнера.\nЭкземпляр компонента рассматривается только как полностью инициализированный и готовый к публикации для других после возвращения из Метод `@PostConstruct`.\nТакие отдельные методы инициализации предназначены только для проверки состояния конфигурации и, возможно, подготовки некоторых структур данных на основе заданной конфигурации, но без дальнейших действий с доступом к внешнему компоненту.\nВ противном случае существует риск тупиковой ситуации при инициализации.\nОбратные вызовы инициализации.\nДля сценария, в котором должны быть запущены дорогостоящие действия после инициализации, например, этапы асинхронной подготовки базы данных, ваш компонент должен либо реализовать `SmartInitializingSingleton.afterSingletonsInstantiated()` или полагаться на контекст событие обновления: реализация `ApplicationListener<ContextRefreshedEvent>` или объявляя эквивалент аннотации `@EventListener(ContextRefreshedEvent.class)`."}
{"id": 488, "text": "Эти варианты появляются после обычной одноэлементной инициализации и, следовательно, вне любой блокировки создания синглтона.\nОбратные вызовы инициализации.\nВ качестве альтернативы вы можете реализовать интерфейс «(Smart)Lifecycle» и интегрироваться с ним. общее управление жизненным циклом контейнера, включая механизм автозапуска, шаг остановки перед уничтожением и потенциальные обратные вызовы остановки/перезапуска (см. ниже).\nОбратные вызовы разрушения.\nРеализация интерфейса org.springframework.beans.factory.DisposableBean позволяет bean-компонент получает обратный вызов, когда контейнер, содержащий его, уничтожается.\nИнтерфейс DisposableBean определяет один метод:\n	void destroy() throws Exception;\nОбратные вызовы разрушения.\nМы рекомендуем вам не использовать интерфейс обратного вызова DisposableBean, поскольку он излишне связывает код с Spring.\nВ качестве альтернативы мы предлагаем использовать аннотацию `@PreDestroy` или указание общего метода, который поддерживается определениями компонентов.\nС помощью XML метаданные конфигурации, вы можете использовать атрибут `destroy-method` в `<bean/>`.\nВ конфигурации Java вы можете использовать атрибут `destroyMethod` @Bean`.\nВидеть\n	<bean id=\"exampleDestructionBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\nJava\n	public class ExampleBean {\n		public void cleanup() {\n			// выполнить некоторую работу по уничтожению (например, освободить соединения из пула)\n	class ExampleBean {\nОбратные вызовы разрушения.\nПредыдущее определение имеет почти тот же эффект, что и следующее определение:"}
{"id": 489, "text": "<bean id=\"exampleDestructionBean\" class=\"examples.AnotherExampleBean\"/>\nJava\n	public class AnotherExampleBean implements DisposableBean {\n		@Override\n		public void destroy() {\n			// выполнить некоторую работу по уничтожению (например, освободить соединения из пула)\n	class AnotherExampleBean : DisposableBean {\nОбратные вызовы разрушения.\nОднако первое из двух предыдущих определений не связывает код со Spring.\nОбратные вызовы разрушения.\nОбратите внимание, что Spring также поддерживает вывод методов уничтожения, обнаруживая общедоступное «закрытие» или метод «выключения».\nЭто поведение по умолчанию для методов `@Bean` в конфигурации Java. классы и автоматически соответствует `java.lang.AutoCloseable` или `java.io.Closeable` реализации, не связывая логику разрушения с Spring.\nОбратные вызовы разрушения.\nСОВЕТ: Для вывода метода уничтожения с помощью XML вы можете назначить атрибут `destroy-method`. элемента `<bean>` специальное значение `(inferred)`, которое инструктирует Spring автоматически обнаружить общедоступный метод закрытия или завершения работы в классе компонента для конкретного определения компонента.\nВы также можете установить это специальное значение `(inferred)` для атрибута `default-destroy-method`. элемента `<beans>`, чтобы применить это поведение ко всему набору определений bean-компонентов (см."}
{"id": 490, "text": "Обратные вызовы разрушения. [ПРИМЕЧАНИЕ] = Для расширенных фаз выключения вы можете реализовать интерфейс «Жизненный цикл» и получать ранний сигнал остановки перед вызовом методов уничтожения любого одноэлементного bean-компонента.\nВы также можете реализовать SmartLifecycle для шага остановки с привязкой по времени, когда контейнер будет ждать завершения всей такой обработки остановки, прежде чем переходить к уничтожению методов.\nМетоды инициализации и уничтожения по умолчанию.\nКогда вы пишете инициализацию и уничтожаете обратные вызовы методов, которые не используют Интерфейсы обратного вызова InitializingBean и DisposableBean, специфичные для Spring, позволяют обычно пишут методы с такими именами, как `init()`, `initialize()`, `dispose()`, и так далее.\nВ идеале имена таких методов обратного вызова жизненного цикла стандартизированы для всех систем. проект, чтобы все разработчики использовали одни и те же имена методов и обеспечивали согласованность.\nМетоды инициализации и уничтожения по умолчанию.\nВы можете настроить контейнер Spring на «поиск» именованной инициализации и уничтожение. имена методов обратного вызова для каждого компонента.\nЭто означает, что вы, как разработчик приложений, можете написать классы вашего приложения и использовать обратный вызов инициализации под названием `init()`, без необходимости настройки атрибута `init-method=\"init\"` для каждого определения компонента.\nКонтейнер Spring IoC вызывает этот метод при создании компонента (и в соответствии со стандартным контрактом обратного вызова жизненного цикла (описано ранее)."}
{"id": 491, "text": "Эта функция также обеспечивает согласованное соглашение об именах для инициализации и уничтожить обратные вызовы методов.\nМетоды инициализации и уничтожения по умолчанию.\nПредположим, что ваши методы обратного вызова инициализации называются `init()`, а метод уничтожения методы обратного вызова называются `destroy()`.\nТогда ваш класс будет похож на класс в следующий пример:\nJava\n	public class DefaultBlogService implements BlogService {\n		private BlogDao blogDao;\n		public void setBlogDao(BlogDao blogDao) {\n			this.blogDao = blogDao;\n		// это (неудивительно) метод обратного вызова инициализации\n		public void init() {\n			if (this.blogDao == null) {\n				throw new IllegalStateException(\"The [blogDao] property must be set.\");\n	class DefaultBlogService : BlogService {\n	<beans default-init-method=\"init\">\n		<bean id=\"blogService\" class=\"com.something.DefaultBlogService\">\n			<property name=\"blogDao\" ref=\"blogDao\" />\n		</bean>\n	</beans>\nЗатем вы можете использовать этот класс в компоненте, напоминающем следующий:.\nНаличие атрибута default-init-method в элементе верхнего уровня `<beans/>`. атрибут заставляет контейнер Spring IoC распознавать метод init в bean-компоненте class в качестве обратного вызова метода инициализации.\nКогда компонент создается и собирается, если В классе bean есть такой метод, он вызывается в подходящее время."}
{"id": 492, "text": "Затем вы можете использовать этот класс в компоненте, напоминающем следующий:.\nВы можете настроить обратные вызовы метода уничтожения аналогичным образом (то есть в XML), используя метод Атрибут `default-destroy-method` в элементе `<beans/>` верхнего уровня.\nЗатем вы можете использовать этот класс в компоненте, напоминающем следующий:.\nЕсли существующие классы компонентов уже имеют методы обратного вызова, имена которых различаются. согласно соглашению, вы можете переопределить значение по умолчанию, указав (то есть в XML) имя метода, используя атрибуты `init-method` и `destroy-method` `<bean/>` сам.\nЗатем вы можете использовать этот класс в компоненте, напоминающем следующий:.\nКонтейнер Spring гарантирует, что будет вызван настроенный обратный вызов инициализации. сразу после того, как компонент поставляется со всеми зависимостями.\nТаким образом, инициализация обратный вызов вызывается по ссылке на необработанный компонент, что означает, что перехватчики AOP и т. д. вперед еще не применяются к компоненту.\nЦелевой компонент сначала полностью создается и затем применяется прокси-сервер AOP (например) со своей цепочкой перехватчиков.\nЕсли цель bean-компонент и прокси-сервер определяются отдельно, ваш код может даже взаимодействовать с необработанным целевой компонент в обход прокси."}
{"id": 493, "text": "Следовательно, было бы непоследовательно применять перехватчиков с методом init, поскольку это приведет к объединению жизненного цикла нацеливайте bean-компонент на его прокси-сервер или перехватчики и оставляйте странную семантику, когда ваш код взаимодействует напрямую с необработанным целевым компонентом.\nОбъединение механизмов жизненного цикла.\nНачиная с Spring 2.5, у вас есть три варианта управления поведением жизненного цикла компонента:\n* Xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[`InitializingBean`] и\n* Пользовательские методы `init()` и `destroy()`\n* Xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc [`@PostConstruct` и `@PreDestroy` аннотации]\nОбъединение механизмов жизненного цикла. .\nВы можете комбинировать эти механизмы для управления данным компонентом.\nОбъединение механизмов жизненного цикла.\nПРИМЕЧАНИЕ.\nЕсли для компонента настроено несколько механизмов жизненного цикла и каждый механизм настроено с другим именем метода, то каждый настроенный метод запускается в порядок, указанный после этого примечания.\nОднако если настроено то же имя метода, например `init()` для метода инициализации - для более чем одного из этих механизмов жизненного цикла, этот метод запускается один раз, как описано в\nОбъединение механизмов жизненного цикла.\nНесколько механизмов жизненного цикла, настроенных для одного и того же компонента, с разными методы инициализации называются следующим образом:"}
{"id": 494, "text": "Объединение механизмов жизненного цикла. .\nМетоды, аннотированные `@PostConstruct`. `afterPropertiesSet()`, как определено интерфейсом обратного вызова `InitializingBean`.\nПользовательский настроенный метод `init()`\nМетоды уничтожения вызываются в том же порядке:. .\nМетоды, помеченные `@PreDestroy`. `destroy()`, как определено интерфейсом обратного вызова `DisposableBean`.\nСпециально настроенный метод `destroy()`\nОбратные вызовы при запуске и завершении работы.\nИнтерфейс «Жизненный цикл» определяет основные методы для любого объекта, имеющего свои собственные требования жизненного цикла (например, запуск и остановка какого-либо фонового процесса):\n	public interface Lifecycle {\n		void start();\n		void stop();\n		boolean isRunning();\nОбратные вызовы при запуске и завершении работы.\nЛюбой объект, управляемый Spring, может реализовать интерфейс Lifecycle.\nЗатем, когда `ApplicationContext` сам получает сигналы запуска и остановки (например, для остановки/перезапуска). сценарий во время выполнения), он каскадирует эти вызовы ко всем реализациям жизненного цикла. определены в этом контексте.\nЭто делается путем делегирования полномочий «LifecycleProcessor», как показано ниже. в следующем листинге:\n	public interface LifecycleProcessor extends Lifecycle {\n		void onRefresh();\n		void onClose();\nОбратные вызовы при запуске и завершении работы.\nОбратите внимание, что «LifecycleProcessor» сам по себе является расширением «Lifecycle». интерфейс."}
{"id": 495, "text": "Он также добавляет два других метода для реагирования на обновляемый контекст. и закрылся.\nОбратные вызовы при запуске и завершении работы. [СОВЕТ] = Обратите внимание, что обычный интерфейс org.springframework.context.Lifecycle представляет собой простой интерфейс. контракт на явные уведомления о запуске и остановке и не подразумевает автозапуск во время обновления контекста.\nДля детального контроля над автозапуском и плавного остановку конкретного компонента (включая фазы запуска и остановки), рассмотрите возможность реализации вместо этого используется расширенный интерфейс org.springframework.context.SmartLifecycle.\nОбратные вызовы при запуске и завершении работы.\nТакже обратите внимание, что уведомления об остановке не гарантированно приходят до уничтожения.\nПри обычном завершении работы все bean-компоненты Lifecycle сначала получают уведомление об остановке, а затем распространяются обратные вызовы общего разрушения.\nОднако при горячем обновлении во время в течение времени жизни контекста или при остановленных попытках обновления вызываются только методы уничтожения.\nОбратные вызовы при запуске и завершении работы.\nПорядок вызовов запуска и завершения работы может иметь важное значение.\nЕсли «зависит от» Между любыми двумя объектами существует связь, зависимая сторона начинается после ее зависимости, и он останавливается перед своей зависимостью.\nОднако иногда прямое зависимости неизвестны.\nВы можете знать только, что должны запускаться объекты определенного типа. перед объектами другого типа.\nВ таких случаях интерфейс SmartLifecycle определяет другой вариант, а именно метод getPhase(), определенный в его суперинтерфейсе, `Поэтапно`."}
{"id": 496, "text": "В следующем листинге показано определение поэтапного интерфейса:\n	public interface Phased {\n		int getPhase();\n	public interface SmartLifecycle extends Lifecycle, Phased {\n		boolean isAutoStartup();\n		void stop(Runnable callback);\nВ следующем листинге показано определение интерфейса SmartLifecycle:.\nПри запуске первыми запускаются объекты с наименьшей фазой.\nПри остановке, соблюдается обратный порядок.\nТаким образом, объект, реализующий SmartLifecycle и чей метод getPhase() возвращает Integer.MIN_VALUE, будет запущен одним из первых и последний, кто остановился.\nНа другом конце спектра находится фазовое значение `Integer.MAX_VALUE` будет указывать, что объект должен быть запущен последним и остановлен. сначала (вероятно, потому, что это зависит от запуска других процессов).\nПри рассмотрении значение фазы, также важно знать, что фаза по умолчанию для любого «нормального» Объект «Жизненный цикл», который не реализует «SmartLifecycle», имеет значение «0».\nСледовательно, любой отрицательное значение фазы указывает на то, что объект должен начаться раньше этих стандартных компоненты (и останавливаемся после них).\nОбратное справедливо для любого положительного значения фазы.\nВ следующем листинге показано определение интерфейса SmartLifecycle:.\nМетод остановки, определенный SmartLifecycle, принимает обратный вызов.\nЛюбой реализация должна вызвать метод обратного вызова `run()` после того, как эта реализация процесс выключения завершен."}
{"id": 497, "text": "Это позволяет при необходимости асинхронное завершение работы, поскольку реализация по умолчанию интерфейса LifecycleProcessor, `DefaultLifecycleProcessor` ожидает достижения значения тайм-аута для группы объектов. внутри каждой фазы, чтобы вызвать этот обратный вызов.\nТайм-аут для каждой фазы по умолчанию составляет 30 секунд.\nВы можете переопределить экземпляр процессора жизненного цикла по умолчанию, определив компонент с именем `lifecycleProcessor` в контексте.\nЕсли вы хотите только изменить тайм-аут, достаточно определить следующее:\n	<bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support.DefaultLifecycleProcessor\">\n		<!-- timeout value in milliseconds -->\n		<property name=\"timeoutPerShutdownPhase\" value=\"10000\"/>\n	</bean>\nВ следующем листинге показано определение интерфейса SmartLifecycle:.\nКак упоминалось ранее, интерфейс LifecycleProcessor определяет методы обратного вызова для обновление и закрытие контекста.\nПоследний вызывает отключение процесс, как если бы `stop()` был вызван явно, но это происходит, когда контекст закрытие.\nС другой стороны, обратный вызов «обновить» обеспечивает еще одну функцию Компоненты `SmartLifecycle`.\nКогда контекст обновляется (после того, как все объекты были создан и инициализирован), вызывается этот обратный вызов.\nВ этот момент процессор жизненного цикла по умолчанию проверяет логическое значение, возвращаемое каждым Метод isAutoStartup() объекта SmartLifecycle."}
{"id": 498, "text": "Если `true`, этот объект начать с этого момента, а не ждать явного вызова контекста или собственный метод `start()` (в отличие от обновления контекста, старт контекста не происходит) автоматически для стандартной реализации контекста).\nЗначение `фазы` и любое Отношения «зависит от» определяют порядок запуска, как описано ранее.\nГрамотное завершение работы контейнера Spring IoC в не-веб-приложениях. [ПРИМЕЧАНИЕ] = Этот раздел относится только к не-веб-приложениям.\nSpring веб-интерфейс Реализации ApplicationContext уже имеют код для корректного завершения работы. контейнер Spring IoC, когда соответствующее веб-приложение закрывается.\nГрамотное завершение работы контейнера Spring IoC в не-веб-приложениях.\nЕсли вы используете IoC-контейнер Spring в среде, отличной от веб-приложения (для например, в среде рабочего стола богатого клиента), зарегистрируйте перехватчик завершения работы с помощью JVM.\nЭто обеспечит плавное завершение работы и вызов соответствующих методов уничтожения на вашем компьютере.\nSingleton beans, чтобы освободить все ресурсы.\nВам все равно придется настроить и правильно реализовать эти обратные вызовы уничтожения.\nГрамотное завершение работы контейнера Spring IoC в не-веб-приложениях.\nЧтобы зарегистрировать перехватчик завершения работы, вызовите метод `registerShutdownHook()`, который объявленный в интерфейсе ConfigurationApplicationContext, как показано в следующем примере:\nJava\n	import org.springframework.context.ConfigurableApplicationContext;\n	import org.springframework.context.support.ClassPathXmlApplicationContext;"}
{"id": 499, "text": "public final class Boot {\n		public static void main(final String[] args) throws Exception {\n			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n			// добавляем перехватчик завершения работы для приведенного выше контекста...\n			ctx.registerShutdownHook();\n			// приложение запускается здесь...\n			// выход из основного метода, хук вызывается перед закрытием приложения...\n		// добавляем перехватчик завершения работы для приведенного выше контекста...\n		ctx.registerShutdownHook()\n		// приложение запускается здесь...\n		// выход из основного метода, хук вызывается перед закрытием приложения...\nБезопасность резьбы и видимость.\nОсновной контейнер Spring публикует созданные одноэлементные экземпляры в потокобезопасном режиме. защита доступа с помощью одноэлементной блокировки и гарантия видимости в других потоках.\nБезопасность резьбы и видимость.\nКак следствие, классам компонентов, предоставляемым приложением, не нужно беспокоиться о видимость их состояния инициализации.\nОбычные поля конфигурации не обязательно должны быть помечены как «изменчивые», если они мутируют только на этапе инициализации, предоставление гарантий видимости, аналогичных «final», даже для конфигурации на основе установщика состояние, которое является изменчивым на этом начальном этапе.\nЕсли такие поля изменяются после этапе создания компонента и его последующей первоначальной публикации, их необходимо объявить как «летучий» или охраняется общей блокировкой при каждом доступе.\nБезопасность резьбы и видимость."}
{"id": 500, "text": "Обратите внимание, что одновременный доступ к такому состоянию конфигурации в экземплярах одноэлементного компонента, например, для экземпляров контроллера или экземпляров репозитория, полностью потокобезопасен после такая безопасная первоначальная публикация со стороны контейнера.\nЭто включает в себя общий синглтон Экземпляры FactoryBean, которые также обрабатываются в рамках общей одноэлементной блокировки.\nБезопасность резьбы и видимость.\nДля обратных вызовов уничтожения состояние конфигурации остается потокобезопасным, но любая среда выполнения состояние, накопленное между инициализацией и уничтожением, должно храниться в потокобезопасном режиме. структуры (или в «изменчивых» полях для простых случаев) в соответствии с общими рекомендациями Java.\nБезопасность резьбы и видимость.\nБолее глубокая интеграция жизненного цикла, как показано выше, включает изменяемое во время выполнения состояние, такое как «исполняемое» поле, которое необходимо объявить как «изменчивое».\nВ то время как общий обратные вызовы жизненного цикла следуют определенному порядку, например, обратный вызов начала гарантированно происходит только после полной инициализации и обратного вызова остановки только после первоначального запуска, есть особый случай с общей остановкой перед уничтожением: это строго рекомендовал, чтобы внутреннее состояние любого такого компонента также допускало немедленную уничтожить обратный вызов без предшествующей остановки, поскольку это может произойти во время чрезвычайной ситуации. завершение работы после отмены начальной загрузки или в случае тайм-аута остановки, вызванного другим компонентом.\n`ApplicationContextAware` и `BeanNameAware`."}
{"id": 501, "text": "Когда `ApplicationContext` создает экземпляр объекта, реализующий Интерфейс `org.springframework.context.ApplicationContextAware`, предоставляется экземпляр со ссылкой на этот `ApplicationContext`.\nВ следующем листинге показано определение интерфейса ApplicationContextAware:\n	public interface ApplicationContextAware {\n		void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n`ApplicationContextAware` и `BeanNameAware`.\nТаким образом, bean-компоненты могут программно манипулировать создавшим их ApplicationContext. через интерфейс ApplicationContext или путем приведения ссылки к известному подкласс этого интерфейса (например, «ConfigurableApplicationContext», который предоставляет дополнительный функционал).\nОдним из вариантов использования может быть программный поиск других компонентов.\nИногда эта возможность бывает полезна.\nОднако в целом вам следует избегать этого, потому что он связывает код со Spring и не следует стилю инверсии управления, где соавторы предоставляются компонентам в качестве свойств.\nДругие методы `ApplicationContext` обеспечивает доступ к файловым ресурсам, публикацию событий приложения, и доступ к «MessageSource».\nЭти дополнительные возможности описаны в\n`ApplicationContextAware` и `BeanNameAware`.\nАвтопроводка — еще одна альтернатива для получения ссылки на `Контекст приложения`.\nТрадиционные_ режимы автосвязывания `constructor` и`byType`. (как описано в Соавторы автоматического подключения) может предоставить зависимость типа `ApplicationContext` для аргумента конструктора или параметра метода установки, соответственно.\nДля большей гибкости, включая возможность автоматического связывания полей и методы с несколькими параметрами, используйте функции автоматического связывания на основе аннотаций."}
{"id": 502, "text": "Если да, `ApplicationContext` автоматически подключается к полю, аргументу конструктора или методу. параметр, который ожидает тип ApplicationContext, если поле, конструктор или рассматриваемый метод содержит аннотацию @Autowired.\nДля получения дополнительной информации см.\n`ApplicationContextAware` и `BeanNameAware`.\nКогда `ApplicationContext` создает класс, реализующий `org.springframework.beans.factory.BeanNameAware`, классу предоставляется ссылка на имя, определенное в определении связанного с ним объекта.\nСледующий список показывает определение интерфейса BeanNameAware:\n	public interface BeanNameAware {\n		void setBeanName(String name) throws BeansException;\n`ApplicationContextAware` и `BeanNameAware`.\nОбратный вызов вызывается после заполнения обычных свойств компонента, но до обратный вызов инициализации, такой как `InitializingBean.afterPropertiesSet()` или собственный init-метод.\nДругие `Aware` интерфейсы.\nПомимо `ApplicationContextAware` и `BeanNameAware` (обсуждалось ранее), Spring предлагает широкий спектр интерфейсов обратного вызова «Aware», которые позволяют bean-компонентам указывать контейнеру. что они требуют определенной зависимости от инфраструктуры.\nКак правило, название указывает на тип зависимости.\nВ следующей таблице приведены наиболее важные интерфейсы «Aware»:\nДругие `Aware` интерфейсы. .Поддерживаемые интерфейсы |=== | Имя| Внедренная зависимость | Объяснено в...\nДругие `Aware` интерфейсы. | `ApplicationContextAware` | Объявление `ApplicationContext`. | `ApplicationContextAware` и `BeanNameAware`"}
{"id": 503, "text": "Другие `Aware` интерфейсы. | `ApplicationEventPublisherAware` | Издатель событий включающего в себя ApplicationContext. | Дополнительные возможности ApplicationContext\nДругие `Aware` интерфейсы. | `BeanClassLoaderAware` | Загрузчик классов, используемый для загрузки классов компонентов. | Создание экземпляров Beans\n| `BeanNameAware` | Имя объявляющего компонента. | `ApplicationContextAware` и `BeanNameAware`. | `LoadTimeWeaverAware` | Определен Weaver для обработки определения класса во время загрузки. | Переплетение во время загрузки с AspectJ в Spring Framework\n| `BeanNameAware` | Имя объявляющего компонента. | `ApplicationContextAware` и `BeanNameAware`. | `MessageSourceAware` | Настроенная стратегия разрешения сообщений (с поддержкой параметризации и интернационализация). | Дополнительные возможности ApplicationContext\n| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления. | `ResourceLoaderAware` | Настроен загрузчик для низкоуровневого доступа к ресурсам. | Ресурсы\n| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления. | `ServletConfigAware` | Текущая `ServletConfig`, в которой работает контейнер.\nДействует только в веб-версии Spring. `Контекст приложения`. | Spring MVC\n| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления. | `ServletContextAware` | Текущий `ServletContext`, в котором работает контейнер.\nДействует только в веб-версии Spring. `Контекст приложения`. | Spring MVC |==="}
{"id": 504, "text": "| `NotificationPublisherAware` | Издатель уведомлений Spring JMX. | Уведомления.\nЕще раз обратите внимание, что использование этих интерфейсов привязывает ваш код к Spring API и не следуйте стилю «Инверсия управления».\nВ результате мы рекомендуем их для инфраструктуры. bean-компоненты, которым требуется программный доступ к контейнеру."}
{"id": 505, "text": "Зависимости и конфигурация в деталях.\nКак упоминалось в предыдущий раздел, вы можете определить свойства bean-компонента и аргументы конструктора как ссылки на другие управляемые bean-компоненты. (соавторы) или как значения, определенные в строке.\nМетаданные конфигурации Spring на основе XML поддерживают для этой цели типы подэлементов внутри его элементов `<property/>` и `<constructor-arg/>`.\nПрямые значения (примитивы, строки и т. д.).\nАтрибут `value` элемента `<property/>` указывает свойство или конструктор. аргумент как удобочитаемое строковое представление.\nВесна значения от String до фактического типа свойства или аргумента.\nВ следующем примере показаны различные устанавливаемые значения:\n	<bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n		<!-- results in a setDriverClassName(String) call -->\n		<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n		<property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/>\n		<property name=\"username\" value=\"root\"/>\n		<property name=\"password\" value=\"misterkaoli\"/>\n	</bean>\nПрямые значения (примитивы, строки и т. д.)."}
{"id": 506, "text": "В следующем примере используется ссылка:core/beans/dependents/factory-properties-detailed.adoc#beans-p-namespace[p-namespace] для еще большей краткости.\nXML-конфигурация:\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:p=\"http://www.springframework.org/schema/p\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n		https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\n			destroy-method=\"close\"\n			p:driverClassName=\"com.mysql.jdbc.Driver\"\n			p:url=\"jdbc:mysql://localhost:3306/mydb\"\n			p:username=\"root\"\n			p:password=\"misterkaoli\"/>\n	</beans>\nПрямые значения (примитивы, строки и т. д.).\nПредыдущий XML более краток."}
{"id": 507, "text": "Однако опечатки обнаруживаются во время выполнения, а не время разработки, если вы не используете IDE (например, https://www.jetbrains.com/idea/[IntelliJ IDEA] или {spring-site-tools}[Spring Tools]), который поддерживает автоматическое свойство. завершение при создании определений компонентов.\nТакая помощь IDE настоятельно рекомендуется.\n	<bean id=\"mappings\"\n		class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">\n		<!-- typed as a java.util.Properties -->\n		<property name=\"properties\">\n			<value>\n				jdbc.driver.className=com.mysql.jdbc.Driver\n				jdbc.url=jdbc:mysql://localhost:3306/mydb\n			</value>\n		</property>\n	</bean>\nВы также можете настроить экземпляр java.util.Properties следующим образом:.\nКонтейнер Spring преобразует текст внутри элемента `<value/>` в экземпляр `java.util.Properties` с использованием механизма JavaBeans `PropertyEditor`.\nЭто это хороший ярлык и одно из немногих мест, где команда Spring предпочитает использовать вложенный элемент `<value/>` в стиле атрибута `value`."}
{"id": 508, "text": "Элемент `idref` — это просто защищенный от ошибок способ передать `id` (строковое значение, а не ссылка) другого компонента в контейнере на `<constructor-arg/>` или `<property/>` элемент.\nВ следующем примере показано, как его использовать:\n	<bean id=\"collaborator\" class=\"...\" />\n	<bean id=\"client\" class=\"...\">\n		<property name=\"targetName\">\n			<idref bean=\"collaborator\" />\n		</property>\n	</bean>\nЭлемент `idref`.\nПредыдущий фрагмент определения компонента точно эквивалентен (во время выполнения) следующий фрагмент:\n	<bean id=\"collaborator\" class=\"...\" />\n	<bean id=\"client\" class=\"...\">\n		<property name=\"targetName\" value=\"collaborator\" />\n	</bean>\nЭлемент `idref`.\nПервая форма предпочтительнее второй, поскольку использование тега idref позволяет контейнер проверяет во время развертывания, что указанный именованный компонент действительно существует.\nВ во втором варианте проверка значения, передаваемого в метод, не выполняется.\nСвойство targetName компонента client.\nТаким образом, опечатки обнаруживаются только вероятные фатальные результаты), когда фактически создается экземпляр `client` bean."}
{"id": 509, "text": "Если «клиент» bean-компонент — это bean-компонент prototype, эта опечатка и полученный результат исключение может быть обнаружено только спустя много времени после развертывания контейнера.\nЭлемент `idref`.\nПРИМЕЧАНИЕ.\nОбычное место (по крайней мере, в версиях до Spring 2.0), где `<idref/>` элемент приносит значение находится в конфигурации перехватчики AOP в определении bean-компонента ProxyFactoryBean.\nИспользование элементов `<idref/>` при указании имена перехватчиков не позволяют вам ошибиться в написании идентификатора перехватчика.\nСсылки на другие компоненты (соавторы).\nЭлемент `ref` является последним элементом внутри `<constructor-arg/>` или `<property/>`. элемент определения.\nЗдесь вы устанавливаете значение указанного свойства компонента как ссылка на другой компонент (соавтор), управляемый контейнером.\nСсылочный компонент — это зависимость bean-компонента, свойство которого должно быть установлено, и оно инициализируется по требованию. по мере необходимости, прежде чем свойство будет установлено. (Если соавтор является одноэлементным компонентом, он может уже инициализирован контейнером.) Все ссылки в конечном итоге являются ссылками на другой объект.\nОбласть действия и проверка зависят от того, указываете ли вы идентификатор или имя другой объект через атрибут bean или parent.\nСсылки на другие компоненты (соавторы)."}
{"id": 510, "text": "Указание целевого компонента через атрибут bean тега <ref/> является наиболее простым. общую форму и позволяет создавать ссылку на любой компонент в том же контейнере или родительский контейнер, независимо от того, находится ли он в том же XML-файле.\nЦенность Атрибут `bean` может совпадать с атрибутом `id` целевого bean-компонента или совпадать с ним. как одно из значений атрибута `name` целевого bean-компонента.\nСледующий пример показывает, как использовать элемент `ref`:\n	<ref bean=\"someBean\"/>\nСсылки на другие компоненты (соавторы).\nУказание целевого компонента через атрибут «parent» создает ссылку на компонент. это находится в родительском контейнере текущего контейнера.\nЗначение «родителя» Атрибут может совпадать либо с атрибутом `id` целевого bean-компонента, либо с одним из значения в атрибуте `name` целевого bean-компонента.\nЦелевой компонент должен находиться в родительский контейнер текущего.\nВ основном вам следует использовать этот эталонный вариант компонента. когда у вас есть иерархия контейнеров и вы хотите обернуть существующий компонент в родительский компонент контейнер с прокси-сервером, имеющим то же имя, что и родительский компонент.\nСледующая пара листинги показывают, как использовать атрибут «parent»:\n	<!-- in the parent context -->\n	<bean id=\"accountService\" class=\"com.something.SimpleAccountService\">"}
{"id": 511, "text": "<!-- insert dependencies as required here -->\n	</bean>\n	<!-- in the child (descendant) context, bean name is the same as the parent bean -->\n	<bean id=\"accountService\"\n		class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n		<property name=\"target\">\n			<ref parent=\"accountService\"/> <!-- notice how we refer to the parent bean -->\n		</property>\n		<!-- insert other configuration and dependencies as required here -->\n	</bean>\nСсылки на другие компоненты (соавторы).\nПРИМЕЧАНИЕ.\nАтрибут local элемента ref больше не поддерживается в bean-компонентах версии 4.0.\nXSD, поскольку он больше не предоставляет значения по обычной ссылке на компонент.\nИзменить ваши существующие `ref local` ссылаются на `ref bean` при обновлении до схемы 4.0.\nВнутренние бобы.\nЭлемент `<bean/>` внутри элементов `<property/>` или `<constructor-arg/>` определяет внутренний компонент, как показано в следующем примере:\n	<bean id=\"outer\" class=\"...\">\n		<!-- instead of using a reference to a target bean, simply define the target bean inline -->\n		<property name=\"target\">"}
{"id": 512, "text": "<bean class=\"com.example.Person\"> <!-- this is the inner bean -->\n				<property name=\"name\" value=\"Fiona Apple\"/>\n				<property name=\"age\" value=\"25\"/>\n			</bean>\n		</property>\n	</bean>\nВнутренние бобы.\nОпределение внутреннего компонента не требует определенного идентификатора или имени.\nЕсли указано, контейнер не использует такое значение в качестве идентификатора.\nКонтейнер также игнорирует флаг «scope» создание, поскольку внутренние компоненты всегда анонимны и всегда создаются вместе с внешними боб.\nНевозможно получить доступ к внутренним компонентам независимо или внедрить их в сотрудничающие bean-компоненты, отличные от включающего bean-компонента.\nВнутренние бобы.\nВ крайнем случае, можно получать обратные вызовы уничтожения из пользовательской области — например, для внутреннего bean-компонента с областью запроса, содержащегося в одноэлементном bean-компоненте.\nСоздание экземпляра внутреннего компонента привязан к содержащему его компоненту, но обратные вызовы разрушения позволяют ему участвовать в жизненном цикле области запроса.\nЭто не распространенный сценарий.\nВнутренние бобы обычно просто делятся областью действия содержащего их компонента.\nКоллекции."}
{"id": 513, "text": "Элементы `<list/>`, `<set/>`, `<map/>` и `<props/>` устанавливают свойства и аргументы типов Java `Collection` List`, `Set`, `Map` и `Properties`, соответственно.\nВ следующем примере показано, как их использовать:\n	<bean id=\"moreComplexObject\" class=\"example.ComplexObject\">\n		<!-- results in a setAdminEmails(java.util.Properties) call -->\n		<property name=\"adminEmails\">\n			<props>\n				<prop key=\"administrator\">administrator@example.org</prop>\n				<prop key=\"support\">support@example.org</prop>\n				<prop key=\"development\">development@example.org</prop>\n			</props>\n		</property>\n		<!-- results in a setSomeList(java.util.List) call -->\n		<property name=\"someList\">\n			<list>\n				<value>a list element followed by a reference</value>\n				<ref bean=\"myDataSource\" />\n			</list>\n		</property>\n		<!-- results in a setSomeMap(java.util.Map) call -->\n		<property name=\"someMap\">\n			<map>"}
{"id": 514, "text": "<entry key=\"an entry\" value=\"just some string\"/>\n				<entry key=\"a ref\" value-ref=\"myDataSource\"/>\n			</map>\n		</property>\n		<!-- results in a setSomeSet(java.util.Set) call -->\n		<property name=\"someSet\">\n			<set>\n				<value>just some string</value>\n				<ref bean=\"myDataSource\" />\n			</set>\n		</property>\n	</bean>\nКоллекции.\nЗначение ключа или значения карты или заданное значение также может быть любым из следующие элементы:\n	фасоль | ссылка | идеф | список | набор | карта | реквизит | ценность | нулевой\nОбъединение коллекций.\nКонтейнер Spring также поддерживает объединение коллекций.\nПриложение разработчик может определить родительский элемент `<list/>`, `<map/>`, `<set/>` или `<props/>` и иметь дочерние элементы `<list/>`, `<map/>`, `<set/>` или `<props/>`, наследующие и переопределить значения из родительской коллекции.\nТо есть значения дочерней коллекции результат слияния элементов родительской и дочерней коллекций с дочерней коллекцией элементы коллекции, переопределяющие значения, указанные в родительской коллекции.\nОбъединение коллекций."}
{"id": 515, "text": "В этом разделе, посвященном слиянию, обсуждается механизм родительско-дочерних компонентов.\nЧитатели незнакомы с определениями родительских и дочерних компонентов, возможно, захочется прочитать\n	<beans>\n		<bean id=\"parent\" abstract=\"true\" class=\"example.ComplexObject\">\n			<property name=\"adminEmails\">\n				<props>\n					<prop key=\"administrator\">administrator@example.com</prop>\n					<prop key=\"support\">support@example.com</prop>\n				</props>\n			</property>\n		</bean>\n		<bean id=\"child\" parent=\"parent\">\n			<property name=\"adminEmails\">\n				<!-- the merge is specified on the child collection definition -->\n				<props merge=\"true\">\n					<prop key=\"sales\">sales@example.com</prop>\n					<prop key=\"support\">support@example.co.uk</prop>\n				</props>\n			</property>\n		</bean>\n	<beans>\nСледующий пример демонстрирует слияние коллекций:.\nОбратите внимание на использование атрибута `merge=true` в элементе `<props/>` Свойство `adminEmails` определения `дочернего` компонента."}
{"id": 516, "text": "Когда `дочерний` компонент разрешен и создается контейнером, полученный экземпляр имеет `adminEmails` Коллекция `Properties`, содержащая результат слияния дочерних элементов.\nКоллекция `adminEmails` с родительской коллекцией `adminEmails`.\nСледующий список показывает результат:\nadministrator=administrator@example.com sales=sales@example.com support=support@example.co.uk.\nНабор значений дочерней коллекции Properties наследует все элементы свойств из родительский `<props/>`, а дочернее значение для значения `support` переопределяет значение в родительская коллекция.\nadministrator=administrator@example.com sales=sales@example.com support=support@example.co.uk.\nТакое поведение слияния применяется аналогично `<list/>`, `<map/>` и `<set/>`. типы коллекций.\nВ конкретном случае элемента `<list/>` семантика связанный с типом коллекции List (то есть с понятием упорядоченной коллекции). коллекция значений) сохраняется.\nЗначения родительского элемента предшествуют всем значениям дочернего списка. ценности.\nВ случае типов коллекций Map, Set и Properties порядок не упорядочивается. существует.\nСледовательно, семантика упорядочения не действует для типов коллекций, лежащих в основе связанные типы реализации Map, Set и Properties, которые контейнер использует внутренне.\nОграничения слияния коллекций.\nВы не можете объединить разные типы коллекций (например, «Карта» и «Список»)."}
{"id": 517, "text": "Если ты попытайтесь это сделать, будет выдано соответствующее исключение.\nАтрибут `merge` должен быть указанный в нижнем, унаследованном, дочернем определении.\nУказание атрибута merge на определение родительской коллекции является избыточным и не приводит к желаемому слиянию.\nСтрого типизированная коллекция.\nБлагодаря поддержке Java универсальных типов вы можете использовать строго типизированные коллекции.\nТо есть можно объявить тип «Коллекция» так, чтобы он мог содержать только (например) элементы String.\nЕсли вы используете Spring для внедрения зависимостей строго типизированную `Collection` в bean-компонент, вы можете воспользоваться преимуществами Spring поддержка преобразования типов, так что элементы вашей строго типизированной коллекции экземпляры преобразуются в соответствующий тип перед добавлением в «Коллекцию».\nСледующий класс Java и определение компонента показывают, как это сделать:\nJava\n	public class SomeClass {\n		private Map<String, Float> accounts;\n		public void setAccounts(Map<String, Float> accounts) {\n			this.accounts = accounts;\n	<beans>\n		<bean id=\"something\" class=\"x.y.SomeClass\">\n			<property name=\"accounts\">\n				<map>\n					<entry key=\"one\" value=\"9.99\"/>\n					<entry key=\"two\" value=\"2.75\"/>\n					<entry key=\"six\" value=\"3.99\"/>\n				</map>\n			</property>\n		</bean>"}
{"id": 518, "text": "</beans>\nСтрого типизированная коллекция.\nКогда свойство account компонента Something готовится к внедрению, дженерики информация о типе элемента строго типизированного `Map<String, Float>` доступны посредством отражения.\nТаким образом, инфраструктура преобразования типов Spring распознает различные элементы значений имеют тип Float, а строковые значения (9.99, 2.75 и `3.99`) преобразуются в фактический тип `Float`.\nЗначения пустых и пустых строк.\nSpring рассматривает пустые аргументы для свойств и т.п. как пустые «строки».\nСледующий фрагмент метаданных конфигурации на основе XML устанавливает для свойства `email` пустое значение. `Строковое` значение (\"\").\n	<bean class=\"ExampleBean\">\n		<property name=\"email\" value=\"\"/>\n	</bean>\nJava\n	exampleBean.setEmail(\"\");\n	exampleBean.email = \"\"\n	<bean class=\"ExampleBean\">\n		<property name=\"email\">\n			<null/>\n		</property>\n	</bean>\nJava\n	exampleBean.setEmail(null);\n	exampleBean.email = null\nЯрлык XML с пространством имен p.\nПространство имен p позволяет использовать атрибуты элемента bean (вместо вложенных элементы `<property/>`) для описания значений свойств взаимодействующих bean-компонентов или того и другого.\nЯрлык XML с пространством имен p."}
{"id": 519, "text": "Spring поддерживает расширяемые форматы конфигурации. которые основаны на определении XML-схемы.\nФормат конфигурации `beans`, обсуждаемый в эта глава определена в документе XML-схемы.\nОднако пространство имен p не определено. в файле XSD и существует только в ядре Spring.\nЯрлык XML с пространством имен p.\nВ следующем примере показаны два фрагмента XML (первый использует стандартный формат XML, а второй использует пространство имен p), которые приводят к одному и тому же результату:\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:p=\"http://www.springframework.org/schema/p\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean name=\"classic\" class=\"com.example.ExampleBean\">\n			<property name=\"email\" value=\"someone@somewhere.com\"/>\n		</bean>\n		<bean name=\"p-namespace\" class=\"com.example.ExampleBean\"\n			p:email=\"someone@somewhere.com\"/>\n	</beans>"}
{"id": 520, "text": "Ярлык XML с пространством имен p.\nВ примере показан атрибут в пространстве имен p, называемый электронной почтой в определении компонента.\nЭто говорит Spring о необходимости включить объявление свойства.\nКак упоминалось ранее, p-namespace не имеет определения схемы, поэтому вы можете установить имя атрибута к имени свойства.\nЯрлык XML с пространством имен p.\nСледующий пример включает в себя еще два определения bean-компонентов, оба из которых имеют ссылку на еще один боб:\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:p=\"http://www.springframework.org/schema/p\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean name=\"john-classic\" class=\"com.example.Person\">\n			<property name=\"name\" value=\"John Doe\"/>\n			<property name=\"spouse\" ref=\"jane\"/>\n		</bean>\n		<bean name=\"john-modern\"\n			class=\"com.example.Person\"\n			p:name=\"John Doe\""}
{"id": 521, "text": "p:spouse-ref=\"jane\"/>\n		<bean name=\"jane\" class=\"com.example.Person\">\n			<property name=\"name\" value=\"Jane Doe\"/>\n		</bean>\n	</beans>\nЯрлык XML с пространством имен p.\nЭтот пример включает не только значение свойства, использующее пространство имен p. но также использует специальный формат для объявления ссылок на свойства.\nВ то время как первый боб определение использует `<property name=\"spouse\" ref=\"jane\"/>` для создания ссылки из bean-компонента `john` на bean `jane`, второе определение bean-компонента использует `p:spouse-ref=\"jane\"` в качестве атрибут, чтобы сделать то же самое.\nВ данном случае «супруга» — это имя объекта недвижимости, тогда как часть `-ref` указывает, что это не прямое значение, а скорее ссылка на другой компонент.\nЯрлык XML с пространством имен p.\nПРИМЕЧАНИЕ.\nПространство имен p не такое гибкое, как стандартный формат XML.\nНапример, формат для объявления ссылок на свойства, конфликтующих со свойствами, оканчивающимися на Ref, тогда как стандартный формат XML этого не делает.\nМы рекомендуем вам тщательно выбирать подход и сообщите об этом членам вашей команды, чтобы избежать создания XML-документов, в которых используются все три подхода одновременно."}
{"id": 522, "text": "Ярлык XML с пространством имен c.\nПодобно пространство имен c, представленное в Spring 3.1, позволяет использовать встроенные атрибуты для настройки аргументы конструктора, а не вложенные элементы constructor-arg.\nЯрлык XML с пространством имен c.\nВ следующем примере пространство имен `c:` используется для того же самого, что и from.\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:c=\"http://www.springframework.org/schema/c\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n		<bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n		<!-- traditional declaration with optional argument names -->\n		<bean id=\"beanOne\" class=\"x.y.ThingOne\">\n			<constructor-arg name=\"thingTwo\" ref=\"beanTwo\"/>\n			<constructor-arg name=\"thingThree\" ref=\"beanThree\"/>"}
{"id": 523, "text": "<constructor-arg name=\"email\" value=\"something@somewhere.com\"/>\n		</bean>\n		<!-- c-namespace declaration with argument names -->\n		<bean id=\"beanOne\" class=\"x.y.ThingOne\" c:thingTwo-ref=\"beanTwo\"\n			c:thingThree-ref=\"beanThree\" c:email=\"something@somewhere.com\"/>\n	</beans>\nЯрлык XML с пространством имен c.\nПространство имен `c:` использует те же соглашения, что и `p:` (завершающий `-ref` для ссылки на компоненты) для установки аргументов конструктора по их именам.\nАналогично, его необходимо объявить в файле XML, даже если он не определен в схеме XSD. (он существует внутри ядра Spring).\nЯрлык XML с пространством имен c.\nВ редких случаях, когда имена аргументов конструктора недоступны (обычно, если байт-код был скомпилирован без флага `-parameters`), вы можете вернуться к индексы аргументов, а именно:\n	<!-- c-namespace index declaration -->\n	<bean id=\"beanOne\" class=\"x.y.ThingOne\" c:_0-ref=\"beanTwo\" c:_1-ref=\"beanThree\"\n		c:_2=\"something@somewhere.com\"/>"}
{"id": 524, "text": "Ярлык XML с пространством имен c.\nПРИМЕЧАНИЕ.\nИз-за грамматики XML индексная запись требует присутствия ведущего `_`, поскольку имена атрибутов XML не могут начинаться с цифры (хотя некоторые IDE это допускают).\nСоответствующее индексное обозначение также доступно для элементов `<constructor-arg>`, но обычно не используется, поскольку там обычно достаточно простого порядка объявления.\nЯрлык XML с пространством имен c.\nНа практике разрешение конструктора довольно эффективен при сопоставлении аргументов, поэтому, если вам это действительно не нужно, мы рекомендуем используя обозначение имени во всей вашей конфигурации.\nСоставные имена свойств.\nВы можете использовать составные или вложенные имена свойств при установке свойств компонента, если все компоненты пути, кроме имени конечного свойства, не имеют значения null.\nРассмотрим следующее определение компонента:\n	<bean id=\"something\" class=\"things.ThingOne\">\n		<property name=\"fred.bob.sammy\" value=\"123\" />\n	</bean>\nСоставные имена свойств.\nКомпонент `something` имеет свойство `fred`, свойство `bob`, которое имеет `sammy`. свойство, и этому окончательному свойству Sammy присваивается значение 123.\nДля того, чтобы чтобы это работало, свойство `fred` объекта `something` и свойство `bob` объекта `fred` не должны быть нулевым после создания компонента.\nВ противном случае выдается исключение NullPointerException."}
{"id": 525, "text": "Области применения компонентов.\nКогда вы создаете определение компонента, вы создаете рецепт для создания реальных экземпляров. класса, определенного этим определением компонента.\nИдея о том, что определение компонента является Рецепт важен, потому что он означает, что, как и в случае с классом, вы можете создать множество объектов. экземпляры из одного рецепта.\nОбласти применения компонентов.\nВы можете контролировать не только различные зависимости и значения конфигурации, которые необходимо быть подключен к объекту, созданному на основе определенного определения компонента, но также управлять область действия объектов, созданных на основе определенного определения компонента.\nЭтот подход мощный и гибкий, поскольку вы можете выбирать объем создаваемых объектов через конфигурацию вместо необходимости запекать в области объекта на Java уровень класса.\nКомпоненты могут быть определены для развертывания в одной из нескольких областей.\nSpring Framework поддерживает шесть областей действия, четыре из которых доступны только в том случае, если вы используете веб-ориентированный `ApplicationContext`.\nВы также можете создать\n.Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание. | singleton | (По умолчанию) Охватывает одно определение bean-компонента одним экземпляром объекта для каждого Spring IoC. контейнер.\n.Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание. | прототип | Охватывает одно определение компонента любым количеством экземпляров объекта."}
{"id": 526, "text": ".Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание. | запрос | Охватывает одно определение bean-компонента жизненным циклом одного HTTP-запроса.\nТо есть, каждый HTTP-запрос имеет свой собственный экземпляр компонента, созданный на основе одного компонента. определение.\nДействует только в контексте Spring `ApplicationContext`, поддерживающего веб-интерфейс.\n.Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание. | сессия | Охватывает одно определение bean-компонента жизненным циклом HTTP-сеанса.\nДействует только в контекст веб-приложения Spring `ApplicationContext`.\n.Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание. | приложение | Охватывает одно определение bean-компонента жизненным циклом ServletContext.\nДействует только в контекст веб-приложения Spring `ApplicationContext`.\n.Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание. | websocket | Охватывает одно определение bean-компонента жизненным циклом WebSocket.\nДействует только в контекст веб-приложения Spring `ApplicationContext`. |===\n.Области применения бинов [cols=\"20%,80%\"] |=== | Область применения| Описание.\nПРИМЕЧАНИЕ."}
{"id": 527, "text": "Область потока доступна, но по умолчанию не зарегистрирована.\nДля получения дополнительной информации см. документацию для {spring-framework-api}/context/support/SimpleThreadScope.html[`SimpleThreadScope`].\nИнструкции о том, как зарегистрировать эту или любую другую пользовательскую область, см.\nСинглтон-область.\nУправляется только один общий экземпляр одноэлементного компонента, и все запросы к компонентам с идентификатором или идентификаторами, которые соответствуют определению этого компонента, в результате получается один конкретный компонент экземпляр, возвращаемый контейнером Spring.\nСинглтон-область.\nДругими словами, когда вы определяете определение компонента, и его область действия ограничена Singleton, контейнер Spring IoC создает ровно один экземпляр объекта определяется этим определением компонента.\nЭтот единственный экземпляр хранится в кеше такого одиночные bean-компоненты и все последующие запросы и ссылки на этот именованный bean-компонент. вернуть кэшированный объект.\nНа следующем изображении показано, как работает область действия Singleton:\nизображение::singleton.png[].\nКонцепция Singleton bean-компонента Spring отличается от шаблона Singleton, определенного в книга шаблонов Gang of Four (GoF).\nСинглтон GoF жестко задает область действия объект такой, что для каждого создается один и только один экземпляр определенного класса.\nКлассЗагрузчик.\nОбъем синглтона Spring лучше всего можно описать как охват каждого контейнера. и для каждого компонента."}
{"id": 528, "text": "Это означает, что если вы определите один компонент для определенного класса в один контейнер Spring, контейнер Spring создает один и только один экземпляр класса, определенного этим определением компонента.\nОбласть синглтона является областью действия по умолчанию.\nSpring.\nЧтобы определить компонент как синглтон в XML, вы можете определить компонент, как показано в следующий пример:\n	<bean id=\"accountService\" class=\"com.something.DefaultAccountService\"/>\n	<!-- the following is equivalent, though redundant (singleton scope is the default) -->\n	<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\nОбласть применения прототипа.\nОбласть развертывания bean-компонента, не являющаяся одноэлементным прототипом, приводит к созданию нового bean-компонента каждый раз, когда делается запрос на этот конкретный bean-компонент.\nТо есть боб вводится в другой компонент или вы запрашиваете его через вызов метода getBean() в контейнер.\nКак правило, вы должны использовать область прототипа для всех bean-компонентов с состоянием и Singleton область действия для bean-компонентов без сохранения состояния.\nизображение::prototype.png[]. (Объект доступа к данным (DAO) обычно не конфигурируется как прототип, поскольку типичный DAO не поддерживает любое разговорное состояние.\nНам было проще повторно использовать ядро синглтон-диаграмма.)"}
{"id": 529, "text": "<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\nВ следующем примере компонент определяется как прототип в XML:.\nВ отличие от других областей видимости, Spring не управляет полным жизненным циклом объекта. прототип компонента.\nКонтейнер создает экземпляр, настраивает и иным образом собирает объект-прототип и передает его клиенту без дальнейшей записи этого прототипа. экземпляр.\nТаким образом, хотя методы обратного вызова жизненного цикла инициализации вызываются на всех объекты независимо от области применения, в случае прототипов настраивается уничтожение обратные вызовы жизненного цикла не вызываются.\nКлиентский код должен очистить область действия прототипа. объекты и освободить дорогостоящие ресурсы, которые хранятся в прототипах bean-компонентов.\nЧтобы получить контейнер Spring для освобождения ресурсов, хранящихся в компонентах прототипа, попробуйте использовать пользовательская ссылка:core/beans/factory-extension.adoc#beans-factory-extension-bpp[постпроцессор bean] который содержит ссылку на bean-компоненты, которые необходимо очистить.\nВ следующем примере компонент определяется как прототип в XML:.\nВ некотором смысле, роль контейнера Spring по отношению к bean-компоненту в области прототипа является замена оператора Java `new`.\nВсе управление жизненным циклом после этого момента должно обрабатываться клиентом. (Подробнее о жизненном цикле bean-компонента Spring контейнер, см.\nОбратные вызовы жизненного цикла.)\nSingleton Beans с зависимостями от прототипа bean-компонента."}
{"id": 530, "text": "Когда вы используете одноэлементные bean-компоненты с зависимостями от прототипных bean-компонентов, имейте в виду, что зависимости разрешаются во время создания экземпляра.\nТаким образом, если вы внедрите зависимость bean-компонент с областью прототипа в bean-компонент с областью действия Singleton, создается новый компонент-прототип а затем внедряется зависимость в одноэлементный компонент.\nЭкземпляр прототипа является единственным экземпляр, который когда-либо предоставляется bean-компоненту с одиночной областью видимости.\nSingleton Beans с зависимостями от прототипа bean-компонента.\nОднако предположим, что вы хотите, чтобы одноэлементный компонент получил новый экземпляр Компонент с областью действия прототипа неоднократно во время выполнения.\nВы не можете внедрить зависимость bean-компонент в области прототипа в ваш синглтон-компонент, потому что эта инъекция происходит только один раз, когда контейнер Spring создает экземпляр одноэлементного компонента и разрешает и внедряет свои зависимости.\nЕсли вам нужен новый экземпляр прототипа bean-компонента по адресу во время выполнения более одного раза, см.\nВнедрение метода.\nОбласти запросов, сеансов, приложений и WebSocket.\nОбласти запроса, сеанса, приложения и веб-сокета доступны только если вы используете веб-реализацию Spring `ApplicationContext` (например, `XmlWebApplicationContext`).\nЕсли вы используете эти области с обычными контейнерами Spring IoC, такие как ClassPathXmlApplicationContext, IllegalStateException, которое жалуется о неизвестной области bean-компонента.\nПервоначальная веб-конфигурация."}
{"id": 531, "text": "Для поддержки области видимости bean-компонентов по запросу, сеансу, приложению и уровни `websocket` (компоненты веб-области), некоторая незначительная начальная конфигурация требуется, прежде чем вы определите свои bean-компоненты. (Эта первоначальная настройка не требуется для стандартных областей: «singleton» и «prototype».)\nПервоначальная веб-конфигурация.\nТо, как вы выполните эту первоначальную настройку, зависит от вашей конкретной среды сервлетов.\nПервоначальная веб-конфигурация.\nЕсли вы получаете доступ к bean-компонентам с ограниченной областью действия в Spring Web MVC, по сути, в рамках запроса, который обрабатывается Spring `DispatcherServlet`, никакой специальной настройки не требуется. `DispatcherServlet` уже предоставляет все соответствующее состояние.\nПервоначальная веб-конфигурация.\nЕсли вы используете веб-контейнер сервлетов, запросы которого обрабатываются вне Spring `DispatcherServlet` (например, при использовании JSF) необходимо зарегистрировать `org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`.\nЭто можно сделать программно, используя интерфейс WebApplicationInitializer.\nАльтернативно добавьте следующее объявление в файл web.xml вашего веб-приложения:\n	<web-app>\n		<listener>\n			<listener-class>\n				org.springframework.web.context.request.RequestContextListener\n			</listener-class>\n		</listener>\n	</web-app>\nПервоначальная веб-конфигурация."}
{"id": 532, "text": "В качестве альтернативы, если есть проблемы с настройкой вашего прослушивателя, рассмотрите возможность использования Spring `RequestContextFilter`.\nСопоставление фильтров зависит от окружающей сети. конфигурацию приложения, поэтому вам придется изменить ее соответствующим образом.\nСледующий список показывает фильтрующую часть веб-приложения:\n	<web-app>\n		<filter>\n			<filter-name>requestContextFilter</filter-name>\n			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>\n		</filter>\n		<filter-mapping>\n			<filter-name>requestContextFilter</filter-name>\n			<url-pattern>/*</url-pattern>\n		</filter-mapping>\n	</web-app>\nПервоначальная веб-конфигурация.\nDispatcherServlet, RequestContextListener и RequestContextFilter работают точно то же самое, а именно привязать объект HTTP-запроса к «Потоку», который обслуживает этот запрос.\nЭто делает bean-компоненты, доступные в области запроса и сеанса. по цепочке вызовов.\n	<bean id=\"loginAction\" class=\"com.something.LoginAction\" scope=\"request\"/>\nРассмотрим следующую конфигурацию XML для определения компонента:.\nКонтейнер Spring создает новый экземпляр компонента LoginAction, используя метод Определение bean-компонента `loginAction` для каждого HTTP-запроса.\nТо есть Область действия компонента `loginAction` находится на уровне HTTP-запроса."}
{"id": 533, "text": "Вы можете изменить внутреннюю состояние экземпляра, который создается столько, сколько вы хотите, потому что другие экземпляры созданный на основе того же определения bean-компонента `loginAction`, не видит этих изменений в состоянии.\nОни специфичны для индивидуального запроса.\nКогда запрос завершает обработку, Компонент, ограниченный запросом, отбрасывается.\nРассмотрим следующую конфигурацию XML для определения компонента:.\nПри использовании компонентов, управляемых аннотациями, или конфигурации Java, аннотация `@RequestScope` может использоваться для назначения компонента области запроса.\nСледующий пример показывает, как чтобы сделать это:\nJava\n	@RequestScope\n	@Component\n	public class LoginAction {\n	@RequestScope\n	@Component\n	class LoginAction {\n	<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\"/>\nРассмотрим следующую конфигурацию XML для определения компонента:.\nКонтейнер Spring создает новый экземпляр bean-компонента UserPreferences, используя метод Определение bean-компонента userPreferences на время существования одного HTTP-сеанса.\nВ другом Другими словами, bean-компонент `userPreferences` фактически ограничен уровнем HTTP-сеанса.\nКак с помощью bean-компонентов области запроса вы можете изменить внутреннее состояние экземпляра, который создается столько, сколько вы хотите, зная, что другие экземпляры HTTP `Session`, которые также используя экземпляры, созданные на основе того же определения bean-компонента `userPreferences`, они не видятся изменения состояния, поскольку они специфичны для отдельного HTTP-сеанса."}
{"id": 534, "text": "Когда HTTP `Session` в конечном итоге отбрасывается, bean-компонент, ограниченный этим конкретным HTTP. «Сессия» также отбрасывается.\nРассмотрим следующую конфигурацию XML для определения компонента:.\nПри использовании компонентов, управляемых аннотациями, или конфигурации Java, вы можете использовать Аннотация `@SessionScope` для назначения компонента области `session`.\nJava\n	@SessionScope\n	@Component\n	public class UserPreferences {\n	@SessionScope\n	@Component\n	class UserPreferences {\n	<bean id=\"appPreferences\" class=\"com.something.AppPreferences\" scope=\"application\"/>\nРассмотрим следующую конфигурацию XML для определения компонента:.\nКонтейнер Spring создает новый экземпляр bean-компонента AppPreferences, используя метод Определение bean-компонента appPreferences один раз для всего веб-приложения.\nТо есть Компонент `appPreferences` имеет область действия на уровне `ServletContext` и хранится как обычный Атрибут `ServletContext`.\nЭто чем-то похоже на одноэлементный компонент Spring, но отличается двумя важными способами: это синглтон для ServletContext, а не для Spring. `ApplicationContext` (которых в любом веб-приложении может быть несколько), и он фактически предоставляется и, следовательно, виден как атрибут ServletContext.\nРассмотрим следующую конфигурацию XML для определения компонента:.\nПри использовании компонентов, управляемых аннотациями, или конфигурации Java, вы можете использовать Аннотация `@ApplicationScope` для назначения компонента области `application`. следующий пример показывает, как это сделать:\nJava\n	@ApplicationScope\n	@Component"}
{"id": 535, "text": "public class AppPreferences {\n	@ApplicationScope\n	@Component\n	class AppPreferences {\nОбласть веб-сокета.\nОбласть WebSocket связана с жизненным циклом сеанса WebSocket и применяется к STOMP для приложений WebSocket, см.\nBean-компоненты с областью действия как зависимости.\nКонтейнер Spring IoC управляет не только созданием экземпляров ваших объектов (компонентов), но также и подключение соавторов (или зависимостей).\nЕсли вы хотите ввести (для пример) bean-компонент с областью HTTP-запроса в другой bean-компонент с более продолжительной областью действия, вы можете выберите внедрение прокси-сервера AOP вместо ограниченного компонента.\nТо есть вам нужно ввести прокси-объект, который предоставляет тот же общедоступный интерфейс, что и объект с заданной областью, но который может также получить реальный целевой объект из соответствующей области (например, HTTP-запрос) и делегировать вызовы метода на реальный объект.\nBean-компоненты с областью действия как зависимости. [ПРИМЕЧАНИЕ] = Вы также можете использовать `<aop:scoped-proxy/>` между bean-компонентами, областью действия которых является `singleton`, при этом ссылка затем проходит через промежуточный прокси, который можно сериализовать и, следовательно, может повторно получить целевой одноэлементный компонент при десериализации.\nBean-компоненты с областью действия как зависимости."}
{"id": 536, "text": "При объявлении `<aop:scoped-proxy/>` для bean-компонента с областью `prototype` каждый метод вызов общего прокси-сервера приводит к созданию нового целевого экземпляра, к которому вызов затем переадресовывается.\nBean-компоненты с областью действия как зависимости.\nКроме того, прокси с ограниченной областью действия — не единственный способ доступа к компонентам из более коротких областей действия в мода, безопасная для жизненного цикла.\nВы также можете указать свою точку инъекции (т. аргумент конструктора или установщика или поле с автоматическим связыванием) как `ObjectFactory<MyTargetBean>`, позволяющий вызывать getObject() для получения текущего экземпляра по требованию каждый раз. время, когда это необходимо, не удерживая экземпляр и не сохраняя его отдельно.\nBean-компоненты с областью действия как зависимости.\nВ качестве расширенного варианта вы можете объявить `ObjectProvider<MyTargetBean>`, который доставляет несколько дополнительных вариантов доступа, включая getIfAvailable и getIfUnique.\nBean-компоненты с областью действия как зависимости.\nВариант JSR-330 называется Provider и используется с Provider<MyTargetBean>. объявление и соответствующий вызов get() для каждой попытки получения.\nДополнительную информацию о JSR-330 в целом см. в здесь.\nBean-компоненты с областью действия как зависимости.\nКонфигурация в следующем примере состоит только из одной строки, но важно понять «почему», а также «как», стоящее за этим:"}
{"id": 537, "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<!-- an HTTP Session-scoped bean exposed as a proxy -->\n		<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\">\n			<!-- instructs the container to proxy the surrounding bean -->\n			<aop:scoped-proxy/> <1>\n		</bean>\n		<!-- a singleton-scoped bean injected with a proxy to the above bean -->\n		<bean id=\"userService\" class=\"com.something.SimpleUserService\">"}
{"id": 538, "text": "<!-- a reference to the proxied userPreferences bean -->\n			<property name=\"userPreferences\" ref=\"userPreferences\"/>\n		</bean>\n	</beans>\nBean-компоненты с областью действия как зависимости. <1> Строка, определяющая прокси.\nBean-компоненты с областью действия как зависимости.\nЧтобы создать такой прокси, вы вставляете дочерний элемент `<aop:scoped-proxy/>` в определение bean-компонента с ограниченной областью действия (см. и конфигурация на основе XML-схемы).\nBean-компоненты с областью действия как зависимости.\nПочему определения bean-компонентов ограничены областью запроса, сеанса и пользовательской области? уровни требуют элемента `<aop:scoped-proxy/>` в распространенных сценариях?\nРассмотрим следующее определение одноэлементного компонента и сравним его с что вам нужно определить для вышеупомянутых областей (обратите внимание, что следующие Определение bean-компонента `userPreferences` в его нынешнем виде является неполным):\n	<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\"/>\n	<bean id=\"userManager\" class=\"com.something.UserManager\">\n		<property name=\"userPreferences\" ref=\"userPreferences\"/>\n	</bean>\nBean-компоненты с областью действия как зависимости."}
{"id": 539, "text": "В предыдущем примере в одноэлементный компонент (`userManager`) вводится ссылка к HTTP-компоненту с областью действия `Session` (`userPreferences`).\nСущественным моментом здесь является то, что Компонент `userManager` является одноэлементным: его экземпляр создается ровно один раз в контейнер и его зависимости (в данном случае только одна, bean-компонент `userPreferences`) тоже вводили только один раз.\nЭто означает, что компонент `userManager` работает только на точно такой же объект `userPreferences` (то есть тот, с которым он был первоначально внедрен).\nBean-компоненты с областью действия как зависимости.\nЭто не то поведение, которое вам нужно при внедрении компонента с более короткой областью действия в долгоживущий bean-компонент с областью действия (например, внедрение HTTP-компонента с областью действия «Session») bean как зависимость от одноэлементного bean-компонента).\nСкорее, вам нужен один `userManager` объект, и на время существования HTTP-сеанса вам понадобится объект userPreferences. это специфично для HTTP-сеанса.\nТаким образом, контейнер создает объект, который предоставляет тот же общедоступный интерфейс, что и класс UserPreferences (в идеале объект, который является экземпляром UserPreferences), который может получить реальную Объект UserPreferences из механизма определения области (HTTP-запрос, сеанс и т. д.). далее)."}
{"id": 540, "text": "Контейнер внедряет этот прокси-объект в компонент `userManager`, который не зная, что эта ссылка UserPreferences является прокси.\nВ этом примере, когда Экземпляр UserManager вызывает метод для внедренного зависимости UserPreferences. объект, он фактически вызывает метод на прокси.\nЗатем прокси извлекает реальный Объект UserPreferences из (в данном случае) HTTP-сеанса и делегирует вызов метода для полученного реального объекта UserPreferences.\nBean-компоненты с областью действия как зависимости.\nТаким образом, при внедрении вам потребуется следующая (правильная и полная) конфигурация: bean-компоненты `request-` и `session-scoped` в взаимодействующие объекты, как показано в следующем примере. показывает:\n	<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\">\n		<aop:scoped-proxy/>\n	</bean>\n	<bean id=\"userManager\" class=\"com.something.UserManager\">\n		<property name=\"userPreferences\" ref=\"userPreferences\"/>\n	</bean>\nВыбор типа прокси для создания.\nПо умолчанию, когда контейнер Spring создает прокси для компонента, помеченного знаком элемента `<aop:scoped-proxy/>` создается прокси класса на основе CGLIB.\nВыбор типа прокси для создания. [ПРИМЕЧАНИЕ] = Прокси-серверы CGLIB не перехватывают частные методы."}
{"id": 541, "text": "Попытка вызвать частный метод на таком прокси-сервере не будет делегироваться фактическому целевому объекту с заданной областью.\nВыбор типа прокси для создания.\nАльтернативно вы можете настроить контейнер Spring для создания стандартного JDK. прокси на основе интерфейса для таких bean-компонентов с ограниченной областью действия, указав `false` для значения атрибут proxy-target-class элемента `<aop:scoped-proxy/>`.\nИспользование JDK прокси на основе интерфейса означает, что вам не нужны дополнительные библиотеки в вашем путь к классам приложения, чтобы повлиять на такое проксирование.\nОднако это также означает, что класс bean-компонент с областью действия должен реализовывать хотя бы один интерфейс и чтобы все участники в который вводится ограниченный bean-компонент, должен ссылаться на bean-компонент через один из его интерфейсы.\nВ следующем примере показан прокси-сервер на основе интерфейса:\n	<!-- DefaultUserPreferences implements the UserPreferences interface -->\n	<bean id=\"userPreferences\" class=\"com.stuff.DefaultUserPreferences\" scope=\"session\">\n		<aop:scoped-proxy proxy-target-class=\"false\"/>\n	</bean>\n	<bean id=\"userManager\" class=\"com.stuff.UserManager\">\n		<property name=\"userPreferences\" ref=\"userPreferences\"/>\n	</bean>\nВыбор типа прокси для создания."}
{"id": 542, "text": "Для получения более подробной информации о выборе проксирования на основе классов или интерфейсов см. см.\nМеханизмы проксирования.\nНепосредственное внедрение ссылок на запрос/сеанс.\nВ качестве альтернативы заводским областям видимости Spring WebApplicationContext также поддерживает внедрение HttpServletRequest, HttpServletResponse, HttpSession, `WebRequest` и (если JSF присутствует) `FacesContext` и `ExternalContext` в Компоненты, управляемые Spring, просто посредством автоматического подключения на основе типов рядом с обычным внедрением. баллы за другие бобы.\nSpring обычно вводит прокси для такого запроса и сеанса. объекты, преимущество которых заключается в работе с одноэлементными и сериализуемыми компонентами. а также аналогично прокси-серверам с областью действия для компонентов с заводской областью действия.\nПользовательские области.\nМеханизм области видимости компонента является расширяемым.\nВы можете определить свой собственный области действия или даже переопределить существующие области действия, хотя последнее считается плохой практикой. и вы не можете переопределить встроенные области действия «singleton» и «prototype».\nСоздание пользовательской области.\nЧтобы интегрировать ваши пользовательские области видимости в контейнер Spring, вам необходимо реализовать Интерфейс `org.springframework.beans.factory.config.Scope`, который описан в этом раздел."}
{"id": 543, "text": "Информацию о том, как реализовать свои собственные области видимости, см. в разделе «Область действия». реализации, поставляемые вместе с самим Spring Framework и {spring-framework-api}/beans/factory/config/Scope.html[`Scope`] javadoc, где более подробно объясняются методы, которые необходимо реализовать.\nСоздание пользовательской области.\nИнтерфейс `Scope` имеет четыре метода для получения объектов из области видимости и удаления их из области видимости. прицел, и пусть они будут уничтожены.\nСоздание пользовательской области.\nНапример, реализация области сеанса возвращает bean-компонент области сеанса (если он не существует, метод возвращает новый экземпляр компонента после привязки его к сеанс для дальнейшего использования).\nСледующий метод возвращает объект из базовая область действия:\nJava\n	Object get(String name, ObjectFactory<?> objectFactory)\nСоздание пользовательской области.\nНапример, реализация области сеанса удаляет bean-компонент области сеанса из базовый сеанс.\nОбъект должен быть возвращен, но вы можете вернуть `null`, если объект с указанным именем не найден.\nСледующий метод удаляет объект из базовая область действия:\nJava\n	Object remove(String name)\nСоздание пользовательской области.\nСледующий метод регистрирует обратный вызов, который область должна вызывать, когда она уничтожено или когда указанный объект в области уничтожен:\nJava\n	void RegisterDestructionCallback (имя строки, Runnable DestructionCallback)\nСоздание пользовательской области."}
{"id": 544, "text": "См. {spring-framework-api}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc] или реализацию Spring для получения дополнительной информации об обратных вызовах уничтожения.\nJava\n	String getConversationId()\nСледующий метод получает идентификатор диалога для базовой области:.\nЭтот идентификатор различен для каждой области.\nДля реализации в области сеанса это идентификатор может быть идентификатором сеанса.\nИспользование пользовательской области.\nПосле того, как вы напишете и протестируете одну или несколько пользовательских реализаций Scope, вам необходимо сделать контейнер Spring знает о ваших новых областях.\nСледующий метод является центральным. метод для регистрации новой области видимости в контейнере Spring:\nJava\n	void registerScope(String scopeName, Scope scope);\nИспользование пользовательской области.\nЭтот метод объявлен в интерфейсе ConfigurationBeanFactory, который доступен через свойство BeanFactory в большей части конкретного ApplicationContext. реализации, поставляемые вместе со Spring.\nИспользование пользовательской области.\nПервым аргументом метода `registerScope(..)` является уникальное имя, связанное с область применения.\nПримерами таких имен в самом контейнере Spring являются `singleton` и `прототип`.\nВторым аргументом метода `registerScope(..)` является фактический экземпляр. пользовательской реализации Scope, которую вы хотите зарегистрировать и использовать.\nИспользование пользовательской области.\nПредположим, вы пишете свою собственную реализацию Scope, а затем регистрируете ее, как показано. в следующем примере.\nИспользование пользовательской области.\nПРИМЕЧАНИЕ."}
{"id": 545, "text": "В следующем примере используется SimpleThreadScope, который включен в Spring, но не является зарегистрирован по умолчанию.\nИнструкции будут такими же для вашего собственного «Области применения». реализации.\nJava\n	Scope threadScope = new SimpleThreadScope();\n	beanFactory.registerScope(\"thread\", threadScope);\nИспользование пользовательской области.\nЗатем вы можете создать определения bean-компонентов, которые соответствуют правилам области действия вашего пользовательского интерфейса. `Объем`, а именно:\n	<bean id=\"...\" class=\"...\" scope=\"thread\">\nИспользование пользовательской области.\nБлагодаря специальной реализации «Области» вы не ограничены программной регистрацией. области применения.\nВы также можете выполнить регистрацию Scope декларативно, используя команду Класс CustomScopeConfigurer, как показано в следующем примере:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd"}
{"id": 546, "text": "http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\">\n			<property name=\"scopes\">\n				<map>\n					<entry key=\"thread\">\n						<bean class=\"org.springframework.context.support.SimpleThreadScope\"/>\n					</entry>\n				</map>\n			</property>\n		</bean>\n		<bean id=\"thing2\" class=\"x.y.Thing2\" scope=\"thread\">\n			<property name=\"name\" value=\"Rick\"/>\n			<aop:scoped-proxy/>\n		</bean>\n		<bean id=\"thing1\" class=\"x.y.Thing1\">\n			<property name=\"thing2\" ref=\"thing2\"/>\n		</bean>\n	</beans>\nИспользование пользовательской области.\nПРИМЕЧАНИЕ.\nКогда вы помещаете `<aop:scoped-proxy/>` в объявление `<bean>` для Реализация FactoryBean, областью действия является сам фабричный компонент, а не объект. возвращается из `getObject()`."}
{"id": 547, "text": "Резервный вариант SockJS.\nВ общедоступном Интернете ограничительные прокси-серверы, находящиеся вне вашего контроля, могут препятствовать использованию WebSocket. взаимодействия, либо потому, что они не настроены на передачу заголовка «Upgrade», либо потому что они закрывают долгоживущие соединения, которые кажутся простаивающими.\nРезервный вариант SockJS.\nРешением этой проблемы является эмуляция WebSocket, то есть попытка использовать WebSocket. сначала, а затем вернуться к методам на основе HTTP, которые эмулируют WebSocket взаимодействие и предоставлять один и тот же API уровня приложения.\nРезервный вариант SockJS.\nВ стеке сервлетов Spring Framework обеспечивает поддержку как сервера, так и клиента. для протокола SockJS.\nОбзор.\nЦель SockJS — позволить приложениям использовать API WebSocket, но при этом вернуться к альтернативы, отличные от WebSocket, когда это необходимо во время выполнения, без необходимости изменить код приложения.\n* {sockjs-protocol}[протокол SockJS]\nSockJS состоит из:. определяется в виде исполняемого файла {sockjs-protocol-site}/sockjs-protocol-0.3.3.html[озвученные тесты].\n* {sockjs-client}[SockJS JavaScript-клиент] — клиентская библиотека для использования в браузерах.\n* Реализации сервера SockJS, включая одну в модуле Spring-websocket Spring Framework.\n* Java-клиент SockJS в модуле Spring-websocket (начиная с версии 4.1).\nSockJS состоит из:.\nSockJS предназначен для использования в браузерах."}
{"id": 548, "text": "Он использует различные техники для поддержки широкого спектра версий браузера.\nПолный список типов транспорта и браузеров SockJS см.\nСтраница {sockjs-client}[SockJS-клиент].\nТранспорт делятся на три основные категории: WebSocket, потоковая передача HTTP и длинный опрос HTTP.\nОбзор этих категорий см. {spring-site-blog}/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[это сообщение в блоге].\nSockJS состоит из:.\nКлиент SockJS начинает с отправки `GET /info` в получить основную информацию с сервера.\nПосле этого он должен решить, какой транспорт использовать.\nЕсли возможно, используется WebSocket.\nЕсли нет, то в большинстве браузеров существует хотя бы один вариант потоковой передачи HTTP.\nЕсли нет, то HTTP (длинный) используется опрос.\n* pass:q[`{server-id}`] полезен для маршрутизации запросов в кластере, но в других случаях не используется.\n* pass:q[`{session-id}`] соотносит HTTP-запросы, принадлежащие сеансу SockJS.\n* pass:q[`{transport}`] указывает тип транспорта (например, `websocket`, `xhr-streaming` и другие).\nгде:.\nТранспорту WebSocket требуется только один HTTP-запрос для выполнения подтверждения WebSocket."}
{"id": 549, "text": "Все последующие сообщения обмениваются через этот сокет.\nгде:.\nHTTP-транспорт требует большего количества запросов.\nНапример, потоковая передача Ajax/XHR основана на один длительный запрос для сообщений между сервером и клиентом и дополнительный HTTP POST запросы сообщений клиент-сервер.\nДлинный опрос аналогичен, за исключением того, что он завершает текущий запрос после каждой отправки от сервера к клиенту.\nгде:.\nSockJS добавляет минимальное кадрирование сообщений.\nНапример, сервер отправляет букву `o` («открытый» кадр) изначально сообщения отправляются как `a[\"message1\",\"message2\"]` (массив в кодировке JSON), буква `h` (кадр `heartbeat`), если сообщения не передаются. на 25 секунд (по умолчанию) и букву «c» («рамка «закрыть»)» для закрытия сеанса.\nгде:.\nЧтобы узнать больше, запустите пример в браузере и посмотрите HTTP-запросы.\nКлиент SockJS позволяет фиксировать список транспортов, поэтому можно видеть каждый транспорт по одному.\nКлиент SockJS также предоставляет флаг отладки. что позволяет отображать полезные сообщения в консоли браузера.\nНа стороне сервера вы можете включить Журнал TRACE для org.springframework.web.socket.\nБолее подробную информацию см. в протоколе SockJS. https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html [озвученный тест]."}
{"id": 550, "text": "Включение SockJS.\nВы можете включить SockJS через конфигурацию, как показано в следующем примере: См. пример кода в исходном документе.\nВключение SockJS.\nПредыдущий пример предназначен для использования в приложениях Spring MVC и должен быть включен в пакет конфигурация файла `DispatcherServlet`.\nОднако Spring WebSocket и поддержка SockJS не зависит от Spring MVC.\nОтносительно просто интегрироваться в другие среды HTTP-обслуживания с помощью {spring-framework-api}/web/socket/sockjs/support/SockJsHttpRequestHandler.html[`SockJsHttpRequestHandler`].\nВключение SockJS.\nНа стороне браузера приложения могут использовать {sockjs-client}[`sockjs-client`] (версия 1.0.x).\nЭто эмулирует W3C WebSocket API и взаимодействует с сервером, чтобы выбрать лучший вариант транспорта, в зависимости от браузера, в котором он работает.\nСм.\nСтраница {sockjs-client}[sockjs-client] и список типы транспорта, поддерживаемые браузером.\nКлиент также предоставляет несколько параметры конфигурации — например, чтобы указать, какие транспорты включать.\nИЕ 8 и 9.\nInternet Explorer 8 и 9 продолжают использоваться.\nОни ключевая причина использования SockJS.\nВ этом разделе рассматриваются важные соображения по поводу работы в этих браузерах.\nИЕ 8 и 9."}
{"id": 551, "text": "Клиент SockJS поддерживает потоковую передачу Ajax/XHR в IE 8 и 9 с помощью Microsoft. https://web.archive.org/web/20160219230343/https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx[`XDomainRequest`].\nЭто работает во всех доменах, но не поддерживает отправку файлов cookie.\nФайлы cookie часто необходимы для приложений Java.\nОднако, поскольку клиент SockJS можно использовать со многими серверами типов (не только Java), ему необходимо знать, имеют ли значение файлы cookie.\nЕсли да, то клиент SockJS предпочитает Ajax/XHR для потоковой передачи.\nВ противном случае это опирается на технику на основе iframe.\nИЕ 8 и 9.\nПервый запрос `/info` от клиента SockJS — это запрос информация, которая может повлиять на выбор клиентом транспорта.\nОдна из этих деталей заключается в том, использует ли серверное приложение файлы cookie. (например, для целей аутентификации или кластеризации с помощью закрепленных сеансов).\nПоддержка SockJS в Spring включает свойство sessionCookieNeeded.\nОн включен по умолчанию, поскольку большинство приложений Java используют JSESSIONID. печенье.\nЕсли вашему приложению это не нужно, вы можете отключить эту опцию, и клиент SockJS затем должен выбрать «xdr-streaming» в IE 8 и 9.\nИЕ 8 и 9."}
{"id": 552, "text": "Если вы используете транспорт на основе iframe, имейте в виду что браузерам можно дать указание блокировать использование IFrames на данной странице с помощью установка заголовка ответа HTTP `X-Frame-Options` в `DENY`, `SAMEORIGIN` или `ALLOW-FROM <origin>`.\nЭто используется для предотвращения https://www.owasp.org/index.php/Clickjacking[кликджекинг].\nИЕ 8 и 9. [ПРИМЕЧАНИЕ] = Spring Security 3.2+ обеспечивает поддержку установки X-Frame-Options на каждом ответ.\nПо умолчанию в конфигурации Spring Security Java для него установлено значение DENY.\nВ версии 3.2 пространство имен Spring Security XML не устанавливает этот заголовок по умолчанию. но его можно настроить для этого.\nВ будущем он может установить его по умолчанию.\nИЕ 8 и 9.\nСм. {docs-spring-security}/features/exploits/headers.html#headers-default [Заголовки безопасности по умолчанию]. документации Spring Security для получения подробной информации о том, как настроить настройка заголовка X-Frame-Options.\nВы также можете увидеть {spring-github-org}/spring-security/issues/2718[gh-2718] для дополнительного фона.\nИЕ 8 и 9."}
{"id": 553, "text": "Если ваше приложение добавляет заголовок ответа `X-Frame-Options` (как и должно!) и полагается на транспорт на основе iframe, вам необходимо установить значение заголовка `SAMEORIGIN` или `ALLOW-FROM <origin>`.\nВесенний SockJS поддержке также необходимо знать расположение клиента SockJS, поскольку он загружен из iframe.\nПо умолчанию iframe настроен на загрузку клиента SockJS. из местоположения CDN.\nРекомендуется настроить эту опцию для использования URL-адрес из того же источника, что и приложение.\nИЕ 8 и 9.\nВ следующем примере показано, как его настроить: См. пример кода в исходном документе.\nИЕ 8 и 9.\nПРИМЕЧАНИЕ.\nВо время первоначальной разработки включите режим разработки клиента SockJS, который предотвращает браузер от кэширования запросов SockJS (например, iframe), которые в противном случае кэшироваться.\nПодробности о том, как его включить, см.\nСтраница {sockjs-client}[SockJS-клиент].\nСердцебиение.\nПротокол SockJS требует, чтобы серверы отправляли периодические сообщения, чтобы запретить прокси-серверы. от заключения, что соединение зависло.\nКонфигурация Spring SockJS имеет свойство называется «heartbeatTime», который вы можете использовать для настройки частоты.\nПо умолчанию Heartbeat отправляется через 25 секунд, при условии, что на этом этапе не было отправлено никаких других сообщений. соединение."}
{"id": 554, "text": "Это 25-секундное значение соответствует следующему {rfc-site}/rfc6202[рекомендация IETF] для общедоступных интернет-приложений.\nСердцебиение.\nПРИМЕЧАНИЕ.\nПри использовании STOMP через WebSocket и SockJS, если клиент STOMP и сервер согласовывают Heartbeats для обмена, Heartbeats SockJS отключены.\nСердцебиение.\nПоддержка Spring SockJS также позволяет вам настроить TaskScheduler для планировать задачи Heartbeats.\nПланировщик задач поддерживается пулом потоков, с настройками по умолчанию, основанными на количестве доступных процессоров. ты следует рассмотреть возможность настройки параметров в соответствии с вашими конкретными потребностями.\nКлиент отключается.\nПотоковая передача HTTP и длинный опрос HTTP Транспорты SockJS требуют, чтобы соединение оставалось открыты дольше обычного.\nОбзор этих методов см. {spring-site-blog}/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[это сообщение в блоге].\nКлиент отключается.\nВ контейнерах сервлетов это осуществляется посредством асинхронной поддержки сервлета 3, которая позволяет выйти из потока контейнера сервлетов, обработать запрос и продолжить написать ответ из другой ветки.\nКлиент отключается.\nКонкретная проблема заключается в том, что API сервлетов не предоставляет уведомления клиенту. это ушло.\nСм. https://github.com/eclipse-ee4j/servlet-api/issues/44[eclipse-ee4j/servlet-api#44].\nОднако контейнеры сервлетов вызывают исключение при последующих попытках записи. к ответу."}
{"id": 555, "text": "Поскольку служба SockJS Spring поддерживает контрольные сигналы, отправляемые сервером (каждый по умолчанию 25 секунд), это означает, что в течение этого времени обычно обнаруживается отключение клиента. период времени (или раньше, если сообщения отправляются чаще).\nКлиент отключается.\nПРИМЕЧАНИЕ.\nВ результате могут возникнуть сбои сетевого ввода-вывода из-за отключения клиента, что приводит к сбою сетевого ввода-вывода. может заполнить журнал ненужными трассировками стека.\nSpring делает все возможное, чтобы идентифицировать такие сетевые сбои, которые представляют собой отключение клиента (специфическое для каждого сервера) и регистрируют минимальное сообщение с использованием специальной категории журнала `DISCONNECTED_CLIENT_LOG_CATEGORY` (определено в «AbstractSockJsSession»).\nЕсли вам нужно увидеть трассировку стека, вы можете установить это категорию журнала в TRACE.\nSockJS и CORS.\nЕсли вы разрешаете запросы из разных источников (см.\nПротокол использует CORS для междоменной поддержки в потоковой передаче XHR и транспорте опроса.\nТаким образом, заголовки CORS добавляются автоматически, за исключением случаев, когда заголовки CORS присутствуют в файле. обнаружен ответ.\nИтак, если приложение уже настроено для поддержки CORS (например, через фильтр сервлетов), Spring SockJsService пропускает эту часть.\nSockJS и CORS.\nТакже можно отключить добавление этих заголовков CORS, установив параметр Свойство SuppressCors в Spring SockJsService.\n* `Access-Control-Allow-Origin`: инициализируется значением заголовка запроса `Origin`."}
{"id": 556, "text": "* `Access-Control-Allow-Credentials`: всегда установлено значение `true`.\n* `Access-Control-Request-Headers`: инициализируется значениями из эквивалентного заголовка запроса.\n* `Access-Control-Allow-Methods`: методы HTTP, поддерживаемые транспортом (см. перечисление `TransportType`).\n* «Access-Control-Max-Age»: установлено значение 31536000 (1 год).\nSockJS ожидает следующие заголовки и значения:.\nТочную реализацию см. в `addCorsHeaders` в `AbstractSockJsService` и перечисление TransportType в исходном коде.\nSockJS ожидает следующие заголовки и значения:.\nВ качестве альтернативы, если конфигурация CORS это позволяет, рассмотрите возможность исключения URL-адресов с Префикс конечной точки SockJS, что позволяет Spring SockJsService обрабатывать его.\n`SockJsClient`.\nSpring предоставляет Java-клиент SockJS для подключения к удаленным конечным точкам SockJS без с помощью браузера.\nЭто может быть особенно полезно, когда есть необходимость в двунаправленной передаче данных. связь между двумя серверами через общедоступную сеть (то есть, где сетевые прокси могут исключить использование протокола WebSocket).\nJava-клиент SockJS также очень полезен. в целях тестирования (например, для имитации большого количества одновременных пользователей).\n`SockJsClient`.\nJava-клиент SockJS поддерживает `websocket`, `xhr-streaming` и `xhr-polling`. транспорты.\nОстальные имеют смысл использовать только в браузере."}
{"id": 557, "text": "* StandardWebSocketClient во время выполнения JSR-356.\n* JettyWebSocketClient с использованием встроенного API WebSocket Jetty 9+.\n* Любая реализация Spring WebSocketClient.\nВы можете настроить WebSocketTransport с помощью:.\nXhrTransport по определению поддерживает как потоковую передачу xhr, так и опрос xhr, поскольку: с точки зрения клиента нет никакой разницы, кроме URL-адреса, используемого для подключения. на сервер.\nНа данный момент существует две реализации:\n* RestTemplateXhrTransport использует Spring RestTemplate для HTTP-запросов.\n* JettyXhrTransport использует Jetty HttpClient для HTTP-запросов.\nВы можете настроить WebSocketTransport с помощью:.\nВ следующем примере показано, как создать клиент SockJS и подключиться к конечной точке SockJS:\nВы можете настроить WebSocketTransport с помощью:.\nList<Transport> transports = new ArrayList<>(2); transports.add(new WebSocketTransport(new StandardWebSocketClient())); transports.add(new RestTemplateXhrTransport());\nВы можете настроить WebSocketTransport с помощью:.\nSockJsClient sockJsClient = new SockJsClient(transports); sockJsClient.doHandshake(new MyWebSocketHandler(), \"ws://example.com:8080/sockjs\");\nВы можете настроить WebSocketTransport с помощью:.\nПРИМЕЧАНИЕ.\nSockJS использует для сообщений массивы в формате JSON.\nПо умолчанию используется Jackson 2, и ему требуется быть на пути к классу.\nАльтернативно вы можете настроить собственную реализацию `SockJsMessageCodec` и настройте его в `SockJsClient`."}
{"id": 558, "text": "Вы можете настроить WebSocketTransport с помощью:.\nЧтобы использовать SockJsClient для имитации большого количества одновременных пользователей, вы необходимо настроить базовый HTTP-клиент (для транспорта XHR), чтобы обеспечить достаточный количество соединений и нитей.\nВ следующем примере показано, как это сделать с помощью Jetty:\nВы можете настроить WebSocketTransport с помощью:.\nHttpClient jettyHttpClient = new HttpClient(); jettyHttpClient.setMaxConnectionsPerDestination(1000); jettyHttpClient.setExecutor(new QueuedThreadPool(1000));\nВы можете настроить WebSocketTransport с помощью:.\nВ следующем примере показаны свойства, связанные с SockJS на стороне сервера (подробности см. в javadoc). что вам также следует рассмотреть возможность настройки: См. пример кода в исходном документе."}
{"id": 559, "text": "Фильтры.\nВ API сервлетов вы можете добавить `jakarta.servlet.Filter` для применения логики в стиле перехвата. до и после остальной части цепочки обработки фильтров и целевого «сервлета».\n* Данные формы\n* Пересылаемые заголовки\n* Shallow ETag\n* CORS\n* Обработчик URL\n* `GenericFilterBean` — базовый класс для `Filter`, настроенного как bean-компонент Spring;\nСуществуют также реализации базового класса для использования в приложениях Spring:. интегрируется с жизненным циклом Spring `ApplicationContext`.\n* `OncePerRequestFilter` — расширение `GenericFilterBean`, которое поддерживает одиночный\nСуществуют также реализации базового класса для использования в приложениях Spring:. вызов в начале запроса, т.е. во время фазы отправки REQUEST, и игнорируя дальнейшую обработку через отправку FORWARD.\nФильтр также обеспечивает контроль относительно того, участвует ли «Фильтр» в отправках «ASYNC» и «ERROR».\nСуществуют также реализации базового класса для использования в приложениях Spring:.\nФильтры сервлетов можно настроить в `web.xml` или с помощью аннотаций сервлетов.\nВ приложении Spring Boot вы можете {spring-boot-docs}/how-to/webserver.html#howto.webserver.add-servlet-filter-listener.spring-bean [объявить фильтры как bean-компоненты] и Boot настроит их.\nДанные формы."}
{"id": 560, "text": "Браузеры могут отправлять данные формы только через HTTP GET или HTTP POST, но клиенты, не являющиеся браузерами, также могут используйте HTTP PUT, PATCH и DELETE.\nAPI сервлетов требует `ServletRequest.getParameter{asterisk}()` методы для поддержки доступа к полям формы только для HTTP POST.\nДанные формы.\nМодуль Spring-Web обеспечивает FormContentFilter для перехвата HTTP PUT, PATCH и DELETE. запросы с типом контента «application/x-www-form-urlencoded», прочитайте данные формы из тело запроса и оберните `ServletRequest`, чтобы сделать данные формы доступен через семейство методов `ServletRequest.getParameter{asterisk}()`.\nФильтр перенаправленного заголовка. `ForwardedHeaderFilter` — это фильтр сервлетов, который изменяет запрос, чтобы а) изменить хост, порт и схему на основе заголовков «Перенаправлено» и б) удалить их. заголовки для устранения дальнейшего воздействия.\nФильтр основан на упаковке запроса и поэтому его необходимо упорядочивать перед другими фильтрами, такими как RequestContextFilter, который должен работать с измененным, а не с исходным запросом.\nВопросы безопасности.\nСуществуют соображения безопасности для пересылаемых заголовков, поскольку приложение не может знать если заголовки были добавлены прокси-сервером, как предполагалось, или вредоносным клиентом.\nВот почему прокси-сервер на границе доверия должен быть настроен на удаление ненадежных «Перенаправленных» заголовки, которые приходят извне."}
{"id": 561, "text": "Вы также можете настроить ForwardedHeaderFilter. с `removeOnly=true`, и в этом случае заголовки удаляются, но не используются.\nТипы диспетчеров.\nЧтобы поддерживать асинхронные запросы и отправлять ошибки, это Фильтр должен быть сопоставлен с DispatcherType.ASYNC, а также с DispatcherType.ERROR.\nПри использовании AbstractAnnotationConfigDispatcherServletInitializer Spring Framework (см.\nServlet Config) все фильтры автоматически регистрируются для всей отправки. типы.\nОднако при регистрации фильтра через web.xml или в Spring Boot через `FilterRegistrationBean` обязательно включите `DispatcherType.ASYNC` и DispatcherType.ERROR в дополнение к DispatcherType.REQUEST.\nМелкий ETag.\nФильтр ShallowEtagHeaderFilter создает «мелкий» ETag путем кэширования содержимого. записывается в ответ и вычисляется из него хэш MD5.\nВ следующий раз, когда клиент отправит, он делает то же самое, но также сравнивает вычисленное значение с `If-None-Match` заголовок запроса и, если они равны, возвращает 304 (NOT_MODIFIED).\nМелкий ETag.\nЭта стратегия экономит пропускную способность сети, но не ЦП, поскольку для каждого запроса необходимо вычислять полный ответ.\nМетоды HTTP, изменяющие состояние, и другие заголовки условных запросов HTTP, такие как If-Match и `If-Unmodified-Since` выходят за рамки этого фильтра.\nДругие стратегии на уровне контроллера может избежать вычислений и иметь более широкую поддержку условных запросов HTTP."}
{"id": 562, "text": "См. ссылку:web/webmvc/mvc-caching.adoc [HTTP-кэширование].\nМелкий ETag.\nЭтот фильтр имеет параметр writeWeakETag, который настраивает фильтр для записи слабых ETag. аналогично следующему: `W/\"02a2d595e6ed9a0b24f027f2b63b134d6\"` (как определено в {rfc-сайт}/rfc7232#section-2.3[RFC 7232, раздел 2.3]).\nМелкий ETag.\nДля поддержки асинхронных запросов этот фильтр должен быть сопоставлен. с DispatcherType.ASYNC, чтобы фильтр мог задерживать и успешно генерировать ETag в конец последней асинхронной отправки.\nЕсли вы используете Spring Framework `AbstractAnnotationConfigDispatcherServletInitializer` (см. ссылку:web/webmvc/mvc-servlet/container-config.adoc [Servlet Config]) все фильтры автоматически регистрируются для всех типов рассылок.\nОднако если зарегистрироваться фильтр через `web.xml` или в Spring Boot через `FilterRegistrationBean` обязательно включите `Тип Диспетчера.ASYNC`.\nКОРС.\nSpring MVC обеспечивает детальную поддержку конфигурации CORS посредством аннотаций на контроллеры.\nОднако при использовании Spring Security мы советуем полагаться на встроенный `CorsFilter`, который необходимо заказывать перед цепочкой фильтров Spring Security.\nКОРС.\nДополнительные сведения см. в разделах CORS и CORS Filter.\nОбработчик URL-адресов.\nВозможно, вы захотите, чтобы конечные точки вашего контроллера соответствовали маршрутам с косой чертой в конце URL-пути или без нее."}
{"id": 563, "text": "Например, и «GET /home», и «GET /home/» должны обрабатываться методом контроллера, аннотированным `@GetMapping(\"/home\")`.\nОбработчик URL-адресов.\nSpring предоставляет UrlHandlerFilter, который удаляет конечную косую черту из URL-путей, чтобы обеспечить согласованное представление путей с конечной косой чертой или без нее.\nЭто важно, чтобы избежать несоответствия между решениями об авторизации на основе URL-адресов и сопоставлениями запросов веб-платформы.\nФильтр может удалить косую черту одним из нескольких способов:\n* ответить статусом перенаправления HTTP, который отправляет клиентов по одному и тому же пути без косой черты в конце.\n* обернуть запрос на удаление косой черты в конце.\nОбработчик URL-адресов.\nПРИМЕЧАНИЕ.\nИсторически Spring MVC поддерживал сопоставление конечных косых черт URL-путей.\nЭта возможность устарела в версии 6.0 по соображениям безопасности и удалена в версии 7.0 с UrlHandlerFilter предоставляет более безопасную альтернативу.\nОбработчик URL-адресов.\nВот как вы можете создать и настроить UrlHandlerFilter для приложения блога: См. пример кода в исходном документе.\n- корневой путь `\"/\"` исключен из обработки косой черты.\n- `@RequestMapping(\"/\")` добавляет конечную косую черту к сопоставлению уровня типа и, следовательно, будет"}
{"id": 564, "text": "Имейте в виду следующее:. не отображать, когда применяется обработка косой черты; вместо этого используйте `@RequestMapping` (без атрибута пути)."}
{"id": 565, "text": "Пример реализации декларативной транзакции.\nРассмотрим следующий интерфейс и сопутствующую ему реализацию.\nВ этом примере используется Классы `Foo` и `Bar` в качестве заполнителей, чтобы вы могли сосредоточиться на транзакции. использование без фокусировки на конкретной модели предметной области.\nДля целей этого примера тот факт, что класс DefaultFooService выдает исключение UnsupportedOperationException. экземпляры в теле каждого реализованного метода — это хорошо.\nТакое поведение позволяет вам видеть транзакции создаются, а затем откатываются в ответ на Экземпляр UnsupportedOperationException.\nВ следующем листинге показан FooService. интерфейс:\nJava\n	// интерфейс сервиса, который мы хотим сделать транзакционным\n	package x.y.service;\n	public interface FooService {\n		Foo getFoo(String fooName);\n		Foo getFoo(String fooName, String barName);\n		void insertFoo(Foo foo);\n		void updateFoo(Foo foo);\n	// интерфейс сервиса, который мы хотим сделать транзакционным\n	package x.y.service\n	interface FooService {\nJava\n	package x.y.service;\n	public class DefaultFooService implements FooService {\n		@Override\n		public Foo getFoo(String fooName) {\n		@Override\n		public Foo getFoo(String fooName, String barName) {\n		@Override\n		public void insertFoo(Foo foo) {\n		@Override\n		public void updateFoo(Foo foo) {\n	package x.y.service\n	class DefaultFooService : FooService {\nВ следующем примере показана реализация предыдущего интерфейса:."}
{"id": 566, "text": "Предположим, что первые два метода интерфейса FooService: getFoo(String) и `getFoo(String, String)` должен выполняться в контексте транзакции с доступом только для чтения. семантику и что другие методы, `insertFoo(Foo)` и `updateFoo(Foo)`, должны запускаться в контексте транзакции с семантикой чтения и записи.\nСледующие Конфигурация подробно описана в следующих нескольких параграфах:\n	<!-- from the file 'context.xml' -->\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd"}
{"id": 567, "text": "http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<!-- this is the service object that we want to make transactional -->\n		<bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n		<!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->\n		<tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n			<!-- the transactional semantics... -->\n			<tx:attributes>\n				<!-- all methods starting with 'get' are read-only -->\n				<tx:method name=\"get*\" read-only=\"true\"/>\n				<!-- other methods use the default transaction settings (see below) -->\n				<tx:method name=\"*\"/>\n			</tx:attributes>\n		</tx:advice>\n		<!-- ensure that the above transactional advice runs for any execution\n			of an operation defined by the FooService interface -->\n		<aop:config>"}
{"id": 568, "text": "<aop:pointcut id=\"fooServiceOperation\" expression=\"execution(* x.y.service.FooService.*(..))\"/>\n			<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceOperation\"/>\n		</aop:config>\n		<!-- don't forget the DataSource -->\n		<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n			<property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/>\n			<property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/>\n			<property name=\"username\" value=\"scott\"/>\n			<property name=\"password\" value=\"tiger\"/>\n		</bean>\n		<!-- similarly, don't forget the TransactionManager -->\n		<bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n			<property name=\"dataSource\" ref=\"dataSource\"/>\n		</bean>\n		<!-- other <bean/> definitions here -->\n	</beans>\nВ следующем примере показана реализация предыдущего интерфейса:."}
{"id": 569, "text": "Изучите предыдущую конфигурацию.\nПредполагается, что вы хотите создать объект службы, компонент `fooService`, транзакционный.\nПрименяемая семантика транзакции инкапсулирована. в определении `<tx:advice/>`.\nОпределение `<tx:advice/>` читается как «все методы начинающиеся с `get`, выполняются в контексте транзакции только для чтения, и все другие методы должны работать с семантикой транзакции по умолчанию».\nАтрибуту `transaction-manager` тега `<tx:advice/>` присвоено имя Компонент TransactionManager, который будет управлять транзакциями (в данном случае компонент `txManager`).\nВ следующем примере показана реализация предыдущего интерфейса:.\nСОВЕТ: Вы можете опустить атрибут `transaction-manager` в рекомендациях по транзакциям. (`<tx:advice/>`), если имя компонента `TransactionManager`, который вы хотите провод имеет имя «transactionManager».\nЕсли компонент TransactionManager к которому вы хотите подключиться, имеет любое другое имя, вы должны использовать «менеджер транзакций» атрибут явно, как в предыдущем примере.\nВ следующем примере показана реализация предыдущего интерфейса:.\nОпределение `<aop:config/>` гарантирует, что рекомендации по транзакциям, определенные Компонент `txAdvice` запускается в соответствующих точках программы.\nСначала вы определяете pointcut, соответствующий выполнению любой операции, определенной в интерфейсе FooService. («fooServiceOperation»).\nЗатем вы связываете pointcut с txAdvice, используя советник."}
{"id": 570, "text": "Результат показывает, что при выполнении `fooServiceOperation` запускается совет, определенный `txAdvice`.\nВ следующем примере показана реализация предыдущего интерфейса:.\nВыражение, определенное в элементе `<aop:pointcut/>`, представляет собой pointcut AspectJ. выражение.\nСм. раздел AOP для получения более подробной информации о pointcut. выражения Spring.\nВ следующем примере показана реализация предыдущего интерфейса:.\nОбщее требование — сделать весь уровень обслуживания транзакционным.\nЛучший способ сделать это, чтобы изменить выражение pointcut, чтобы оно соответствовало любой операции в вашем сервисный уровень.\nВ следующем примере показано, как это сделать:\n	<aop:config>\n		<aop:pointcut id=\"fooServiceMethods\" expression=\"execution(* x.y.service.*.*(..))\"/>\n		<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceMethods\"/>\n	</aop:config>\nВ следующем примере показана реализация предыдущего интерфейса:.\nПРИМЕЧАНИЕ.\nВ предыдущем примере предполагается, что все ваши сервисные интерфейсы определены в пакете `x.y.service`.\nДополнительную информацию см. в раздел АОП.\nВ следующем примере показана реализация предыдущего интерфейса:.\nТеперь, когда мы проанализировали конфигурацию, вы можете спросить себя: «Что на самом деле делает вся эта конфигурация?»\nВ следующем примере показана реализация предыдущего интерфейса:."}
{"id": 571, "text": "Показанная ранее конфигурация используется для создания транзакционного прокси вокруг объекта. который создается на основе определения bean-компонента `fooService`.\nПрокси настроен с транзакционный совет, чтобы при вызове соответствующего метода на прокси-сервере транзакция запускается, приостанавливается, помечается как доступная только для чтения и т. д., в зависимости от конфигурация транзакции, связанная с этим методом.\nРассмотрим следующую программу этот тест запускает конфигурацию, показанную ранее:\nJava\n	public final class Boot {\n		public static void main(final String[] args) throws Exception {\n			ApplicationContext ctx = new ClassPathXmlApplicationContext(\"context.xml\");\n			FooService fooService = ctx.getBean(FooService.class);\n			fooService.insertFoo(new Foo());\nВ следующем примере показана реализация предыдущего интерфейса:.\nРезультат запуска предыдущей программы должен выглядеть следующим образом (файл Log4J вывод и трассировка стека из UnsupportedOperationException, выданного Метод `insertFoo(..)` класса `DefaultFooService` был усечен для ясности):\n	<!-- the Spring container is starting up... -->\n	[AspectJInvoctionContextExposeAdvisorAutoProxyCreator] — создание неявного прокси для bean-компонента «fooService» с 0 общими перехватчиками и 1 конкретным перехватчиком.\n	<!-- the DefaultFooService is actually proxied -->\n	[JdkDynamicAopProxy] — создание динамического прокси JDK для [x.y.service.DefaultFooService]"}
{"id": 572, "text": "<!-- ... the insertFoo(..) method is now being invoked on the proxy -->\n	[TransactionInterceptor] — Получение транзакции для x.y.service.FooService.insertFoo\n	<!-- the transactional advice kicks in here... -->\n	[DataSourceTransactionManager] — Создание новой транзакции с именем [x.y.service.FooService.insertFoo]\n	[DataSourceTransactionManager] — полученное соединение [org.apache.commons.dbcp.PoolableConnection@a53de4] для транзакции JDBC\n	<!-- the insertFoo(..) method from DefaultFooService throws an exception... -->\n	[RuleBasedTransactionAttribute] — применение правил для определения того, следует ли откатить транзакцию в java.lang.UnsupportedOperationException.\n	[TransactionInterceptor] — вызов отката транзакции на x.y.service.FooService.insertFoo из-за исключения исключения [java.lang.UnsupportedOperationException]\n	<!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) -->\n	[DataSourceTransactionManager] — откат транзакции JDBC при подключении [org.apache.commons.dbcp.PoolableConnection@a53de4]\n	[DataSourceTransactionManager] — освобождение соединения JDBC после транзакции\n	[DataSourceUtils] — Возврат соединения JDBC к источнику данных"}
{"id": 573, "text": "Исключение в потоке «основной» java.lang.UnsupportedOperationException в x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)\n	<!-- AOP infrastructure stack trace elements removed for clarity -->\n	at $Proxy0.insertFoo(Unknown Source)\n	at Boot.main(Boot.java:11)\nВ следующем примере показана реализация предыдущего интерфейса:.\nЧтобы использовать реактивное управление транзакциями, код должен использовать реактивные типы.\nВ следующем примере показана реализация предыдущего интерфейса:.\nПРИМЕЧАНИЕ.\nSpring Framework использует ReactiveAdapterRegistry, чтобы определить, является ли метод тип возвращаемого значения — реактивный.\nВ следующем примере показана реализация предыдущего интерфейса:.\nВ следующем листинге показана модифицированная версия ранее использовавшегося `FooService`, но на этот раз код использует реактивные типы:\nJava\n	// интерфейс реактивного сервиса, который мы хотим сделать транзакционным\n	package x.y.service;\n	public interface FooService {\n		Flux<Foo> getFoo(String fooName);\n		Publisher<Foo> getFoo(String fooName, String barName);\n		Mono<Void> insertFoo(Foo foo);\n		Mono<Void> updateFoo(Foo foo);\n	// интерфейс реактивного сервиса, который мы хотим сделать транзакционным\n	package x.y.service\n	interface FooService {\nJava\n	package x.y.service;\n	public class DefaultFooService implements FooService {\n		@Override\n		public Flux<Foo> getFoo(String fooName) {\n		@Override"}
{"id": 574, "text": "public Publisher<Foo> getFoo(String fooName, String barName) {\n		@Override\n		public Mono<Void> insertFoo(Foo foo) {\n		@Override\n		public Mono<Void> updateFoo(Foo foo) {\n	package x.y.service\n	class DefaultFooService : FooService {\nВ следующем примере показана реализация предыдущего интерфейса:.\nИмперативное и реактивное управление транзакциями имеют одну и ту же семантику для транзакций. определения границ и атрибутов транзакции.\nОсновное отличие императивного и реактивных транзакций – это отложенный характер последних. `Перехватчик транзакций` украшает возвращаемый реактивный тип транзакционным оператором для начала и очистки транзакция.\nСледовательно, вызов транзакционно-реактивного метода откладывает фактическое выполнение. управление транзакциями на тип подписки, который активирует обработку реактивных тип.\nВ следующем примере показана реализация предыдущего интерфейса:.\nДругой аспект реактивного управления транзакциями связан с экранированием данных, которое является естественное следствие модели программирования.\nВ следующем примере показана реализация предыдущего интерфейса:.\nВозвращаемые значения метода императивных транзакций возвращаются из транзакционных методов. при успешном завершении метода, чтобы частично вычисленные результаты не ускользнули закрытие метода.\nВ следующем примере показана реализация предыдущего интерфейса:.\nМетоды реактивной транзакции возвращают тип реактивной оболочки, который представляет собой последовательность вычислений вместе с обещанием начать и завершить вычисление.\nВ следующем примере показана реализация предыдущего интерфейса:. «Издатель» может отправлять данные во время транзакции, но не обязательно завершенной."}
{"id": 575, "text": "Поэтому методы, которые зависят от успешного завершения всей транзакции, нуждаются в для обеспечения завершения и буферизации результатов в вызывающем коде."}
{"id": 576, "text": "Настройка глобального формата даты и времени.\nПо умолчанию поля даты и времени, не помеченные @DateTimeFormat, преобразуются из строки, используя стиль DateFormat.SHORT.\nЕсли хотите, вы можете изменить это, определение вашего собственного глобального формата.\nНастройка глобального формата даты и времени.\nДля этого убедитесь, что Spring не регистрирует средства форматирования по умолчанию.\nВместо этого зарегистрируйтесь форматтеры вручную с помощью:\n* `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`\n* `org.springframework.format.datetime.DateFormatterRegistrar`\nНастройка глобального формата даты и времени.\nНапример, следующая конфигурация регистрирует глобальный формат «ггггММдд»: См. пример кода в исходном документе.\nНастройка глобального формата даты и времени.\nОбратите внимание, что при настройке форматов даты и времени в Интернете необходимо учитывать дополнительные моменты. приложения.\nПожалуйста, посмотрите"}
{"id": 577, "text": "Весеннее форматирование полей.\nКак обсуждалось в предыдущем разделе, `core.convert` — это универсальная система преобразования типов.\nОн предоставляет унифицированный API ConversionService как а также строго типизированный SPI Converter для реализации логики преобразования из одного типа. другому.\nКонтейнер Spring использует эту систему для привязки значений свойств компонента.\nВ Кроме того, и Spring Expression Language (SpEL), и DataBinder используют эту систему для привязать значения полей.\nНапример, когда SpEL необходимо преобразовать «Short» в «Long», чтобы завершите попытку `expression.setValue(Object bean, Object value)`, `core.convert` система выполняет принуждение.\nВесеннее форматирование полей.\nТеперь рассмотрим требования к преобразованию типов типичной клиентской среды, например веб-приложение или настольное приложение.\nВ таких средах вы обычно конвертируете из `String` для поддержки процесса обратной передачи клиента, а также обратно в String для поддержки просмотреть процесс рендеринга.\nКроме того, вам часто требуется локализовать строковые значения.\nЧем больше общий `core.convert` `Converter` SPI не учитывает такие требования к форматированию. напрямую.\nЧтобы напрямую обращаться к ним, Spring предоставляет удобный SPI Formatter, который предоставляет простую и надежную альтернативу реализациям PropertyEditor для клиента. среды.\nВесеннее форматирование полей."}
{"id": 578, "text": "В общем, вы можете использовать SPI «Конвертер», когда вам нужно реализовать тип общего назначения. логика преобразования — например, для преобразования между `java.util.Date` и `Long`.\nВы можете использовать SPI `Formatter`, когда работаете в клиентской среде (например, в веб-интерфейсе). приложение) и необходимо проанализировать и распечатать локализованные значения полей. `Конверсионная служба` предоставляет унифицированный API преобразования типов для обоих SPI.\nSPI форматтера.\nSPI `Formatter` для реализации логики форматирования полей прост и строго типизирован.\nСледующий листинг показывает определение интерфейса Formatter:\n	package org.springframework.format;\n	public interface Formatter<T> extends Printer<T>, Parser<T> {\nSPI форматтера. «Форматтер» является продолжением интерфейсов строительных блоков «Принтер» и «Парсер».\nСледующий листинг показывает определения этих двух интерфейсов:\n	public interface Printer<T> {\n		String print(T fieldValue, Locale locale);\n	import java.text.ParseException;\n	public interface Parser<T> {\n		T parse(String clientValue, Locale locale) throws ParseException;\nSPI форматтера.\nЧтобы создать свой собственный «Форматтер», реализуйте интерфейс «Форматтер», показанный ранее.\nПараметризируйте `T` как тип объекта, который вы хотите отформатировать, например: `java.util.Date`."}
{"id": 579, "text": "Реализуйте операцию print() для печати экземпляра T для отображение в локали клиента.\nРеализуйте операцию `parse()` для анализа экземпляра `T` из форматированного представления, возвращенного из локали клиента.\nВаш «Форматёр» должен выдавать исключение ParseException или IllegalArgumentException, если попытка синтаксического анализа не удалась.\nВозьми позаботьтесь о том, чтобы ваша реализация `Formatter` была потокобезопасной.\nSPI форматтера.\nПодпакеты `format` для удобства предоставляют несколько реализаций `Formatter`.\nПакет `number` предоставляет `NumberStyleFormatter`, `CurrencyStyleFormatter` и PercentStyleFormatter для форматирования объектов Number, использующих java.text.NumberFormat.\nПакет datetime предоставляет DateFormatter для форматирования объектов java.util.Date с помощью java.text.DateFormat, а также DurationFormatter для форматирования объектов Duration. в разных стилях, определенных в перечислении `@DurationFormat.Style` (см. <<format-annotations-api>>).\nJava\n	package org.springframework.format.datetime;\n	public final class DateFormatter implements Formatter<Date> {\n		private String pattern;\n		public DateFormatter(String pattern) {\n			this.pattern = pattern;\n		public String print(Date date, Locale locale) {\n			if (date == null) {\n				return \"\";\n			return getDateFormat(locale).format(date);\n		public Date parse(String formatted, Locale locale) throws ParseException {"}
{"id": 580, "text": "if (formatted.length() == 0) {\n				return null;\n			return getDateFormat(locale).parse(formatted);\n		protected DateFormat getDateFormat(Locale locale) {\n			DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);\n			dateFormat.setLenient(false);\n			return dateFormat;\nСледующий DateFormatter представляет собой пример реализации Formatter:.\nКоманда Spring приветствует вклад сообщества в программу Formatter.\nСм. {spring-framework-issues}[Проблемы GitHub] могут внести свой вклад.\nФорматирование на основе аннотаций.\nФорматирование поля можно настроить по типу поля или аннотации.\nСвязать аннотацию к форматтеру, реализуйте AnnotationFormatterFactory.\nСледующие В листинге показано определение интерфейса AnnotationFormatterFactory:\n	package org.springframework.format;\n	public interface AnnotationFormatterFactory<A extends Annotation> {\n		Set<Class<?>> getFieldTypes();\n		Printer<?> getPrinter(A annotation, Class<?> fieldType);\n		Parser<?> getParser(A annotation, Class<?> fieldType);\nЧтобы создать реализацию:. .\nПараметризируйте `A` как поле `annotationType`, с которым вы хотите связать логика форматирования — например, `org.springframework.format.annotation.DateTimeFormat`..\nПопросите getFieldTypes() вернуть типы полей, в которых можно использовать аннотацию..\nПусть getPrinter() вернет принтер для печати значения аннотированного поля.."}
{"id": 581, "text": "Пусть getParser() вернет Parser для анализа clientValue для аннотированного поля.\nЧтобы создать реализацию:.\nСледующий пример реализации AnnotationFormatterFactory привязывает @NumberFormat. аннотация к средству форматирования, позволяющая указать стиль или шаблон числа:\nJava\n	public final class NumberFormatAnnotationFormatterFactory\n			implements AnnotationFormatterFactory<NumberFormat> {\n		private static final Set<Class<?>> FIELD_TYPES = Set.of(Short.class,\n				Целочисленный.класс, Длинный.класс, Плавающий.класс, Двойной.класс,\n				BigDecimal.class, BigInteger.class);\n		public Set<Class<?>> getFieldTypes() {\n			return FIELD_TYPES;\n		public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {\n			return configureFormatterFrom(annotation, fieldType);\n		public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {\n			return configureFormatterFrom(annotation, fieldType);\n		private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) {\n			if (!annotation.pattern().isEmpty()) {\n				return new NumberStyleFormatter(annotation.pattern());\n			// еще\n			return switch(annotation.style()) {\n				case Style.PERCENT -> new PercentStyleFormatter();\n				case Style.CURRENCY -> new CurrencyStyleFormatter();\n				default -> new NumberStyleFormatter();\n	class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory<NumberFormat> {\nЧтобы создать реализацию:."}
{"id": 582, "text": "Чтобы запустить форматирование, вы можете аннотировать поля с помощью @NumberFormat, как показано ниже. пример показывает:\nJava\n	public class MyModel {\n		@NumberFormat(style=Style.CURRENCY)\n		private BigDecimal decimal;\nAPI форматирования аннотаций.\nAPI аннотаций переносимого формата существует в файле `org.springframework.format.annotation`. пакет.\nВы можете использовать @NumberFormat для форматирования числовых полей, таких как Double и `Long`, `@DurationFormat` для форматирования полей `Duration` в ISO-8601 и упрощенных стилях, и `@DateTimeFormat` для форматирования таких полей, как `java.util.Date`, `java.util.Calendar`, и «Long» (для миллисекундных меток времени), а также типы JSR-310 «java.time».\nAPI форматирования аннотаций.\nВ следующем примере используется @DateTimeFormat для форматирования java.util.Date как даты ISO. (гггг-ММ-дд):\nJava\n	public class MyModel {\n		@DateTimeFormat(iso=ISO.DATE)\n		private Date date;\nAPI форматирования аннотаций."}
{"id": 583, "text": "Более подробную информацию см. в javadoc для {spring-framework-api}/format/annotation/DateTimeFormat.html[`@DateTimeFormat`], {spring-framework-api}/format/annotation/DurationFormat.html[`@DurationFormat`] и {spring-framework-api}/format/annotation/NumberFormat.html[`@NumberFormat`].\nAPI форматирования аннотаций. [ВНИМАНИЕ] = Форматирование и синтаксический анализ на основе стилей основаны на шаблонах, чувствительных к локали, которые могут измениться. в зависимости от среды выполнения Java.\nВ частности, приложения, которые полагаются на дату, время или синтаксический анализ и форматирование чисел могут столкнуться с несовместимыми изменениями в поведении при запуске на JDK 20 или выше.\nAPI форматирования аннотаций.\nИспользование стандартизированного формата ISO или конкретного шаблона, которым вы управляете, позволяет надежный системно-независимый и независимый от локали анализ и форматирование даты, времени, и числовые значения.\nAPI форматирования аннотаций.\nДля `@DateTimeFormat` использование резервных шаблонов также может помочь решить проблему. проблемы совместимости.\nAPI форматирования аннотаций."}
{"id": 584, "text": "Более подробную информацию см. https://github.com/spring-projects/spring-framework/wiki/Date-and-Time-Formatting-with-JDK-20-and-higher [Форматирование даты и времени с помощью JDK 20 и более поздних версий] страница в вики Spring Framework.\nSPI `FormatterRegistry`. «FormatterRegistry» — это SPI для регистрации форматтеров и конвертеров. «FormattingConversionService» — это реализация «FormatterRegistry», подходящая для большинство сред.\nВы можете программно или декларативно настроить этот вариант. в качестве bean-компонента Spring, например, с помощью FormattingConversionServiceFactoryBean.\nПотому что это реализация также реализует ConversionService, вы можете настроить ее напрямую для использования с Spring DataBinder и языком выражений Spring (SpEL).\n	package org.springframework.format;\n	public interface FormatterRegistry extends ConverterRegistry {\n		void addPrinter(Printer<?> printer);\n		void addParser(Parser<?> parser);\n		void addFormatter(Formatter<?> formatter);\n		void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);\n		void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);\n		void addFormatterForFieldAnnotation(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory);\nВ следующем листинге показан SPI FormatterRegistry:.\nКак показано в предыдущем листинге, вы можете зарегистрировать средства форматирования по типу поля или по аннотации."}
{"id": 585, "text": "В следующем листинге показан SPI FormatterRegistry:.\nSPI FormatterRegistry позволяет централизованно настраивать правила форматирования, а не дублирование такой конфигурации на ваших контроллерах.\nНапример, вы можете захотеть обеспечить, чтобы все поля даты были отформатированы определенным образом или чтобы поля имели определенный формат. аннотации форматируются определенным образом.\nС помощью общего «FormatterRegistry» вы определяете эти правила применяются один раз, и они применяются всякий раз, когда требуется форматирование.\nSPI `FormatterRegistrar`. «FormatterRegistrar» — это SPI для регистрации форматтеров и конвертеров через Реестр форматтера.\nВ следующем листинге показано определение его интерфейса:\n	package org.springframework.format;\n	public interface FormatterRegistrar {\n		void registerFormatters(FormatterRegistry registry);\nSPI `FormatterRegistrar`. «FormatterRegistrar» полезен при регистрации нескольких связанных конвертеров и средства форматирования для данной категории форматирования, например форматирования даты.\nЭто также может быть полезно там, где декларативная регистрация недостаточна — например, когда форматтер необходимо индексировать по определенному типу поля, отличному от его собственного `<T>`, или когда регистрация пары «Принтер»/«Парсер».\nВ следующем разделе представлена дополнительная информация о регистрация конвертера и форматтера.\nНастройка форматирования в Spring MVC.\nСм.\nПреобразование и форматирование в главе Spring MVC."}
{"id": 586, "text": "Функции.\nВы можете расширить SpEL, зарегистрировав определяемые пользователем функции, которые можно вызывать внутри выражения с использованием синтаксиса `#functionName(...)` и аналогично стандартному методу. вызовы, также поддерживаются varargs для вызовов функций.\nФункции могут быть зарегистрированы как _переменные_ в реализациях `EvaluationContext` через Метод `setVariable()`.\nФункции. [СОВЕТ] = `StandardEvaluationContext` также определяет методы `registerFunction(...)`, которые предоставляют удобный способ зарегистрировать функцию как `java.lang.reflect.Method` или `java.lang.invoke.MethodHandle`.\nФункции. [ВНИМАНИЕ] = Поскольку функции имеют общее пространство имен с необходимо следить за тем, чтобы имена функций и имена переменных не перекрывались.\nФункции.\nВ следующем примере показано, как зарегистрировать определяемую пользователем функцию для вызова через отражение с использованием `java.lang.reflect.Method`:\nJava\n	Method method = ...;\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	context.setVariable(\"myFunction\", method);\nJava\n	public abstract class StringUtils {\n		public static String reverseString(String input) {\n			return new StringBuilder(input).reverse().toString();\nНапример, рассмотрим следующий служебный метод, который переворачивает строку:.\nВы можете зарегистрировать и использовать предыдущий метод, как показано в следующем примере:\nJava"}
{"id": 587, "text": "ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	context.setVariable(\"reverseString\",\n			StringUtils.class.getMethod(\"reverseString\", String.class));\n	// оценивается как «оллех»\n	String helloWorldReversed = parser.parseExpression(\n			\"#reverseString('hello')\").getValue(context, String.class);\nНапример, рассмотрим следующий служебный метод, который переворачивает строку:.\nФункцию также можно зарегистрировать как java.lang.invoke.MethodHandle.\nЭто позволяет потенциально более эффективные варианты использования, если цель и параметры `MethodHandle` имеют были полностью связаны до регистрации; однако частично связанные дескрипторы также поддерживается.\nНапример, рассмотрим следующий служебный метод, который переворачивает строку:.\nРассмотрим метод экземпляра `String#formatted(Object...)`, который создает сообщение по шаблону и переменному количеству аргументов (varargs).\nНапример, рассмотрим следующий служебный метод, который переворачивает строку:.\nВы можете зарегистрировать и использовать метод «formatted» как «MethodHandle», как показано ниже. пример показывает:\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	MethodHandle mh = MethodHandles.lookup().findVirtual(String.class, \"formatted\","}
{"id": 588, "text": "MethodType.methodType(String.class, Object[].class));\n	context.setVariable(\"message\", mh);\n	// оценивается как «Простое сообщение: <Hello World>»\n	String message = parser.parseExpression(\"#message('Simple message: <%s>', 'Hello World', 'ignored')\")\n			.getValue(context, String.class);\nНапример, рассмотрим следующий служебный метод, который переворачивает строку:.\nКак упоминалось выше, привязка MethodHandle и регистрация привязанного MethodHandle также поддерживается.\nВероятно, это будет более эффективно, если и цель, и все аргументы связаны.\nВ этом случае в выражении SpEL аргументы не требуются, так как следующий пример показывает:\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	String template = \"This is a %s message with %s words: <%s>\";\n	Object varargs = new Object[] { \"prerecorded\", 3, \"Oh Hello World!\", \"ignored\" };\n	MethodHandle mh = MethodHandles.lookup().findVirtual(String.class, \"formatted\",\n		MethodType.methodType(String.class, Object[].class))\n			.bindTo(template)\n			// Здесь мы должны предоставить аргументы в одной привязке массива:"}
{"id": 589, "text": ".bindTo(varargs);\n	context.setVariable(\"message\", mh);\n	// оценивается как «Это заранее записанное сообщение из трех слов: <Oh Hello World!>»\n	String message = parser.parseExpression(\"#message()\")\n			.getValue(context, String.class);"}
{"id": 590, "text": "Общие соображения по интеграции ORM.\nВ этом разделе освещены соображения, применимые ко всем технологиям ORM.\nВ разделе Hibernate представлена более подробная информация, а также показаны эти функции и конфигурации в конкретном контексте.\nОбщие соображения по интеграции ORM.\nОсновная цель интеграции ORM в Spring — четкое многоуровневое представление приложений (с любыми данными). технологии доступа и транзакций), а для слабой связи объектов приложения - нет больше зависимостей бизнес-сервисов от доступа к данным или стратегии транзакций, не более жестко запрограммированные поиски ресурсов, больше нет труднозаменяемых одиночных элементов, больше нет настраиваемых сервисов реестры.\nЦель состоит в том, чтобы иметь один простой и последовательный подход к подключению объектов приложения, сохраняя они максимально пригодны для повторного использования и свободны от контейнерных зависимостей.\nВсе индивидуально функции доступа к данным можно использовать сами по себе, но они прекрасно интегрируются с Spring. концепция контекста приложения, обеспечивающая конфигурацию на основе XML и перекрестные ссылки на простые экземпляры JavaBean, которые не обязательно поддерживают Spring.\nВ типичном приложении Spring многие важные объекты являются JavaBeans: шаблоны доступа к данным, объекты доступа к данным, менеджеры транзакций, бизнес-сервисы, использующие объекты доступа к данным и транзакции менеджеры, преобразователи веб-представлений, веб-контроллеры, использующие бизнес-сервисы, и т. д.\nУправление ресурсами и транзакциями.\nТипичные бизнес-приложения перегружены повторяющимся кодом управления ресурсами."}
{"id": 591, "text": "Многие проекты пытаются изобрести собственные решения, иногда жертвуя правильным обращением. отказов для удобства программирования.\nSpring выступает за простые решения для правильного обработка ресурсов, а именно IoC посредством шаблонов в случае JDBC и применения AOP перехватчики для технологий ОРМ.\nУправление ресурсами и транзакциями.\nИнфраструктура обеспечивает правильную обработку ресурсов и соответствующее преобразование определенные исключения API в непроверяемой иерархии исключений инфраструктуры.\nВесна представляет иерархию исключений DAO, применимую к любой стратегии доступа к данным.\nДля прямого JDBC, класс JdbcTemplate, упомянутый в файле предыдущий раздел обеспечивает обработку соединений и правильное преобразование `SQLException` в Иерархия DataAccessException, включая перевод ошибок SQL, специфичных для базы данных. коды для значимых классов исключений.\nИнформацию о технологиях ORM см. преимущества перевода.\nУправление ресурсами и транзакциями.\nКогда дело доходит до управления транзакциями, класс JdbcTemplate подключается к Spring. поддержка транзакций и поддерживает транзакции JTA и JDBC через соответствующие Spring менеджеры транзакций.\nДля поддерживаемых технологий ORM Spring предлагает Hibernate. и поддержка JPA через менеджеры транзакций Hibernate и JPA, а также поддержку JTA.\nПодробную информацию о поддержке транзакций см. в главе «Управление транзакциями».\nПеревод исключений.\nКогда вы используете Hibernate или JPA в DAO, вы должны решить, как обрабатывать постоянство. собственные классы исключений технологии.\nDAO выдает подкласс HibernateException. или PersistenceException, в зависимости от технологии.\nВсе эти исключения относятся к среде выполнения. исключения и не должны быть объявлены или перехвачены."}
{"id": 592, "text": "Возможно, вам также придется иметь дело с IllegalArgumentException и IllegalStateException.\nЭто означает, что вызывающие абоненты могут только рассматривать исключения как фатальные, если только они не хотят зависеть от устойчивости собственная структура исключений технологии.\nВыявление конкретных причин (таких как оптимистичный настрой) сбой блокировки) невозможен без привязки вызывающего объекта к стратегии реализации.\nЭтот компромисс может быть приемлемым для приложений, которые сильно основаны на ORM или не требуют какой-либо специальной обработки исключений (или того и другого).\nОднако Spring допускает исключение перевод может применяться прозрачно через аннотацию `@Repository`.\nСледующие примеры (один для конфигурации Java и один для конфигурации XML) показывают, как это сделать:\nJava\n	@Repository\n	public class ProductDaoImpl implements ProductDao {\n		// классное тело здесь...\n	@Repository\n	class ProductDaoImpl : ProductDao {\n		// классное тело здесь...\n	<beans>\n		<!-- Exception translation bean post processor -->\n		<bean class=\"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\"/>\n		<bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/>\n	</beans>\nПеревод исключений.\nПостпроцессор автоматически ищет все трансляторы исключений (реализации интерфейс PersistenceExceptionTranslator) и сообщает всем bean-компонентам, отмеченным значком аннотацию `@Repository`, чтобы обнаруженные переводчики могли перехватить и применить соответствующий перевод по выброшенным исключениям.\nПеревод исключений."}
{"id": 593, "text": "Таким образом, вы можете реализовать DAO на основе API простой технологии персистентности и аннотации, сохраняя при этом преимущества транзакций, управляемых Spring, зависимости внедрение и прозрачное преобразование исключений (при желании) в пользовательские Spring иерархии исключений."}
{"id": 594, "text": "Использование дженериков в качестве квалификаторов автоподключения.\nВ дополнение к аннотации `@Qualifier` вы можете использовать универсальные типы Java. как неявная форма квалификации.\nНапример, предположим, что у вас есть следующее конфигурация:\nJava\n	@Configuration\n	public class MyConfiguration {\n		@Bean\n		public StringStore stringStore() {\n			return new StringStore();\n		@Bean\n		public IntegerStore integerStore() {\n			return new IntegerStore();\n	@Configuration\n	class MyConfiguration {\nИспользование дженериков в качестве квалификаторов автоподключения.\nПредполагая, что предыдущие bean-компоненты реализуют общий интерфейс (то есть Store<String>` и `Store<Integer>`), вы можете `@Autowire` использовать интерфейс `Store`, и его общий вид используется в качестве квалификатора, как показано в следующем примере:\nJava\n	@Autowired\n	private Store<String> s1; // <String> qualifier, injects the stringStore bean\n	@Autowired\n	private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean\nИспользование дженериков в качестве квалификаторов автоподключения.\nОбщие квалификаторы также применяются при автоматическом связывании списков, экземпляров Map и массивов.\nВ следующем примере автоматически подключается общий `List`:\nJava\n	// Внедрить все bean-компоненты Store, если они имеют общий <Integer>\n	// Компоненты Store<String> не будут отображаться в этом списке.\n	@Autowired\n	private List<Store<Integer>> s;"}
{"id": 595, "text": "Спящий режим.\nМы начнем с описания https://hibernate.org/[Hibernate] в среде Spring. используя его для демонстрации подхода Spring к интеграции преобразователей OR.\nВ этом разделе подробно рассматриваются многие проблемы и показаны различные варианты DAO. реализации и разграничение транзакций.\nБольшинство из этих шаблонов могут быть непосредственно переведен на все другие поддерживаемые инструменты ORM.\nПоследующие разделы этой главы затем осветите другие технологии ORM и покажите краткие примеры.\nСпящий режим. [ПРИМЕЧАНИЕ] = Учитывая Spring Framework 7.0, Spring требует Hibernate ORM 7.x для Spring. `HibernateJpaVendorAdapter`.\nСпящий режим.\nПакет `org.springframework.orm.jpa.hibernate` заменяет прежний `orm.hibernate5`: теперь для использования с Hibernate ORM 7.x, тесно интегрированным с HibernateJpaVendorAdapter а также поддержка собственного стиля Hibernate `SessionFactory.getCurrentSession()`.\nНастройка SessionFactory в контейнере Spring.\nЧтобы избежать привязки объектов приложения к жестко запрограммированному поиску ресурсов, вы можете определить ресурсы (такие как DataSource JDBC или SessionFactory Hibernate) в виде bean-компонентов в Пружинный контейнер.\nОбъекты приложения, которым необходим доступ к ресурсам, получают ссылки. к таким предопределенным экземплярам через ссылки на компоненты, как показано в DAO. определение в файле следующий раздел.\nНастройка SessionFactory в контейнере Spring.\nВ следующем отрывке из определения контекста приложения XML показано, как настроить JDBC DataSource и Hibernate SessionFactory поверх него:\n	<beans>"}
{"id": 596, "text": "<bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n			<property name=\"driverClassName\" value=\"org.hsqldb.jdbcDriver\"/>\n			<property name=\"url\" value=\"jdbc:hsqldb:hsql://localhost:9001\"/>\n			<property name=\"username\" value=\"sa\"/>\n			<property name=\"password\" value=\"\"/>\n		</bean>\n		<bean id=\"mySessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n			<property name=\"dataSource\" ref=\"myDataSource\"/>\n			<property name=\"mappingResources\">\n				<list>\n					<value>product.hbm.xml</value>\n				</list>\n			</property>\n			<property name=\"hibernateProperties\">\n				<value>\n					hibernate.dialect=org.hibernate.dialect.HSQLDialect\n				</value>\n			</property>\n		</bean>\n	</beans>\nНастройка SessionFactory в контейнере Spring.\nПереключение с локального источника базовых данных Jakarta Commons DBCP на источник, расположенный в JNDI. `DataSource` (обычно управляемый сервером приложений) — это всего лишь вопрос конфигурации, как показано в следующем примере:\n	<beans>"}
{"id": 597, "text": "<jee:jndi-lookup id=\"myDataSource\" jndi-name=\"java:comp/env/jdbc/myds\"/>\n	</beans>\nНастройка SessionFactory в контейнере Spring.\nВы также можете получить доступ к расположенной в JNDI `SessionFactory`, используя Spring `JndiObjectFactoryBean` / `<jee:jndi-lookup>`, чтобы получить и предоставить его.\nОднако это обычно не распространено вне контекста EJB.\nНастройка SessionFactory в контейнере Spring. [ПРИМЕЧАНИЕ] = Spring также предоставляет вариант LocalSessionFactoryBuilder, легко интегрирующий с конфигурацией в стиле `@Bean` и программной настройкой (без использования `FactoryBean`).\nНастройка SessionFactory в контейнере Spring.\nИ LocalSessionFactoryBean, и LocalSessionFactoryBuilder поддерживают фон. загрузка, при этом инициализация Hibernate выполняется параллельно с приложением поток начальной загрузки для данного исполнителя начальной загрузки (например, SimpleAsyncTaskExecutor).\nВ LocalSessionFactoryBean это доступно через bootstrapExecutor. собственность.\nВ программном файле LocalSessionFactoryBuilder имеется перегруженный Метод buildSessionFactory, который принимает аргумент исполнителя начальной загрузки.\nНастройка SessionFactory в контейнере Spring.\nТакая собственная настройка Hibernate также может предоставлять JPA `EntityManagerFactory` для стандартных Взаимодействие JPA рядом с собственным доступом к Hibernate.\nПодробности см. в Встроенная настройка Hibernate для JPA.\nРеализация DAO на основе Plain Hibernate API.\nВ Hibernate есть функция, называемая контекстными сеансами, при которой Hibernate сам управляет одна текущая «сессия» на транзакцию."}
{"id": 598, "text": "Это примерно эквивалентно Spring синхронизация одного сеанса Hibernate на транзакцию.\nСоответствующий DAO реализация напоминает следующий пример, основанный на простом API Hibernate:\nJava\n	public class ProductDaoImpl implements ProductDao {\n		private SessionFactory sessionFactory;\n		public void setSessionFactory(SessionFactory sessionFactory) {\n			this.sessionFactory = sessionFactory;\n		public Collection loadProductsByCategory(String category) {\n			return this.sessionFactory.getCurrentSession()\n					.createQuery(\"from test.Product product where product.category=?\")\n					.setParameter(0, category)\n					.list();\nРеализация DAO на основе Plain Hibernate API.\nЭтот стиль похож на стиль справочной документации и примеров Hibernate. за исключением хранения SessionFactory в переменной экземпляра.\nМы настоятельно рекомендуем такая настройка на основе экземпляра поверх старого статического класса HibernateUtil из Пример приложения CaveatEmptor от Hibernate. (Как правило, не храните какие-либо ресурсы в `статические` переменные, кроме случаев крайней необходимости.)\nРеализация DAO на основе Plain Hibernate API.\nПредыдущий пример DAO соответствует шаблону внедрения зависимостей.\nОн прекрасно вписывается в Spring IoC. контейнер, как если бы он был закодирован с помощью Spring HibernateTemplate.\nВы также можете настроить такой DAO на простой Java (например, в модульных тестах).\nДля этого создайте его экземпляр и вызовите `setSessionFactory(..)` с желаемой ссылкой на фабрику.\nКак Определение компонента Spring, DAO будет выглядеть следующим образом:\n	<beans>"}
{"id": 599, "text": "<bean id=\"myProductDao\" class=\"product.ProductDaoImpl\">\n			<property name=\"sessionFactory\" ref=\"mySessionFactory\"/>\n		</bean>\n	</beans>\nРеализация DAO на основе Plain Hibernate API.\nОсновное преимущество этого стиля DAO заключается в том, что он зависит только от Hibernate API.\nНет импорта любого класса Spring требуется.\nЭто привлекательно из-за неинвазивности перспективу и может показаться более естественным разработчикам Hibernate.\nРеализация DAO на основе Plain Hibernate API.\nОднако DAO выдает простое исключение HibernateException (которое не отмечено, поэтому у него нет быть объявлены или перехвачены), что означает, что вызывающая сторона может рассматривать исключения только как обычно фатально - если только они не хотят зависеть от собственной иерархии исключений Hibernate.\nВыявить конкретные причины (например, оптимистичный сбой блокировки) невозможно без привязка вызывающего абонента к стратегии реализации.\nЭтот компромисс может быть приемлемым для приложения, основанные на Hibernate, не нуждаются в каких-либо специальных исключениях. лечение, или и то, и другое.\nРеализация DAO на основе Plain Hibernate API.\nК счастью, Spring LocalSessionFactoryBean поддерживает Hibernate.\nМетод SessionFactory.getCurrentSession() для любой стратегии транзакций Spring, возврат текущего транзакционного сеанса, управляемого Spring, даже при `HibernateTransactionManager`.\nСтандартное поведение этого метода остается для возврата текущего сеанса, связанного с текущей транзакцией JTA, если таковая имеется."}
{"id": 600, "text": "Такое поведение применяется независимо от того, используете ли вы Spring `JtaTransactionManager`, транзакции, управляемые контейнером EJB (CMT), или JTA.\nРеализация DAO на основе Plain Hibernate API.\nТаким образом, вы можете реализовать DAO на основе простого API Hibernate, оставаясь при этом возможность участвовать в транзакциях, управляемых Spring.\nДекларативная демаркация транзакций.\nМы рекомендуем вам использовать поддержку декларативных транзакций Spring, которая позволяет вам замените вызовы API явного разграничения транзакций в вашем коде Java на AOP перехватчик транзакций.\nВы можете настроить этот перехватчик транзакций в Spring контейнер с помощью аннотаций Java или XML.\nЭта возможность декларативной транзакции позволяет избавить бизнес-сервисы от кода разграничения повторяющихся транзакций и сосредоточьтесь на добавлении бизнес-логики, которая и является реальной ценностью вашего приложения.\nДекларативная демаркация транзакций.\nПРИМЕЧАНИЕ.\nПрежде чем продолжить, мы настоятельно рекомендуем вам прочитать Декларативное управление транзакциями. если вы еще этого не сделали.\nДекларативная демаркация транзакций.\nВы можете аннотировать уровень сервиса аннотациями `@Transactional` и указать Spring-контейнер для поиска этих аннотаций и предоставления транзакционной семантики для эти аннотированные методы.\nВ следующем примере показано, как это сделать:\nJava\n	public class ProductServiceImpl implements ProductService {\n		private ProductDao productDao;\n		public void setProductDao(ProductDao productDao) {\n			this.productDao = productDao;\n		@Transactional\n		public void increasePriceOfAllProductsInCategory(final String category) {\n			List productsToChange = this.productDao.loadProductsByCategory(category);\n		@Transactional(readOnly = true)"}
{"id": 601, "text": "public List<Product> findAllProducts() {\n			return this.productDao.findAllProducts();\nДекларативная демаркация транзакций.\nВ контейнере вам необходимо настроить реализацию PlatformTransactionManager. (как bean-компонент) и запись `<tx:annotation-driven/>`, выбрав `@Transactional` обработка во время выполнения.\nВ следующем примере показано, как это сделать:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xmlns:tx=\"http://www.springframework.org/schema/tx\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/tx\n			https://www.springframework.org/schema/tx/spring-tx.xsd\n			http://www.springframework.org/schema/aop"}
{"id": 602, "text": "https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<!-- SessionFactory, DataSource, etc. omitted -->\n		<bean id=\"transactionManager\"\n				class=\"org.springframework.orm.jpa.hibernate.HibernateTransactionManager\">\n			<property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n		</bean>\n		<tx:annotation-driven/>\n		<bean id=\"myProductService\" class=\"product.SimpleProductService\">\n			<property name=\"productDao\" ref=\"myProductDao\"/>\n		</bean>\n	</beans>\nПрограммное разграничение транзакций.\nВы можете разграничить транзакции на более высоком уровне приложения, поверх услуги доступа к данным нижнего уровня, охватывающие любое количество операций.\nТакже нет ограничений существуют на реализацию окружающих бизнес-услуг.\nНужна только весна `Менеджер ПлатформыТранзакций`.\nОпять же, последнее может прийти откуда угодно, но желательно в качестве ссылки на компонент через метод setTransactionManager(..)`.\nКроме того, `productDAO` должен быть установлен методом `setProductDao(..)`.\nСледующая пара фрагментов показывает менеджер транзакций и определение бизнес-сервиса в контексте приложения Spring и пример реализации бизнес-метода:\n	<beans>\n		<bean id=\"myTxManager\" class=\"org.springframework.orm.jpa.hibernate.HibernateTransactionManager\">"}
{"id": 603, "text": "<property name=\"sessionFactory\" ref=\"mySessionFactory\"/>\n		</bean>\n		<bean id=\"myProductService\" class=\"product.ProductServiceImpl\">\n			<property name=\"transactionManager\" ref=\"myTxManager\"/>\n			<property name=\"productDao\" ref=\"myProductDao\"/>\n		</bean>\n	</beans>\nJava\n	public class ProductServiceImpl implements ProductService {\n		private TransactionTemplate transactionTemplate;\n		private ProductDao productDao;\n		public void setTransactionManager(PlatformTransactionManager transactionManager) {\n			this.transactionTemplate = new TransactionTemplate(transactionManager);\n		public void setProductDao(ProductDao productDao) {\n			this.productDao = productDao;\n		public void increasePriceOfAllProductsInCategory(final String category) {\n			this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n				public void doInTransactionWithoutResult(TransactionStatus status) {\n					List productsToChange = this.productDao.loadProductsByCategory(category);\n					// поднимите цену...\nПрограммное разграничение транзакций.\nSpring TransactionInterceptor позволяет выдавать любое проверенное исключение приложения. с кодом обратного вызова, а `TransactionTemplate` ограничен непроверенным исключения в обратном вызове. `TransactionTemplate` запускает откат в случае непроверенное исключение приложения или если транзакция помечена как «только откат» приложение (установив TransactionStatus).\nПо умолчанию TransactionInterceptor. ведет себя так же, но позволяет настраивать политику отката для каждого метода.\nСтратегии управления транзакциями."}
{"id": 604, "text": "И TransactionTemplate, и TransactionInterceptor делегируют фактическую транзакцию. обработка экземпляра PlatformTransactionManager (который может быть HibernateTransactionManager (для одной Hibernate SessionFactory) с помощью `ThreadLocal` `Session` под капотом) или `JtaTransactionManager` (делегирование JTA-подсистема контейнера) для приложений Hibernate.\nВы даже можете использовать собственный Реализация PlatformTransactionManager.\nПереключение с собственной транзакции Hibernate управление JTA (например, при возникновении требований к распределенным транзакциям для определенных развертывания вашего приложения) — это только вопрос конфигурации.\nВы можете заменить менеджер транзакций Hibernate с реализацией транзакций Spring JTA. оба код разграничения транзакций и код доступа к данным работают без изменений, поскольку они используйте общие API-интерфейсы управления транзакциями.\nСтратегии управления транзакциями.\nДля распределенных транзакций между несколькими фабриками сеансов Hibernate вы можете комбинировать `JtaTransactionManager` как стратегия транзакций с несколькими Определения LocalSessionFactoryBean.\nЗатем каждый DAO получает одну конкретную SessionFactory. ссылка передается в соответствующее свойство компонента.\nЕсли все базовые данные JDBC источники являются транзакционными контейнерами, бизнес-сервис может разграничивать транзакции через любое количество DAO и любое количество фабрик сеансов без особого внимания, поскольку пока он использует JtaTransactionManager в качестве стратегии.\nСтратегии управления транзакциями.\nИ HibernateTransactionManager, и JtaTransactionManager позволяют правильно Обработка кэша на уровне JVM с помощью Hibernate без диспетчера транзакций для конкретного контейнера. поиск или соединитель JCA (если вы не используете EJB для инициации транзакций).\nСтратегии управления транзакциями."}
{"id": 605, "text": "HibernateTransactionManager может экспортировать соединение Hibernate JDBC в обычный JDBC. код доступа для определенного `DataSource`.\nЭта способность позволяет достичь высокого уровня. разграничение транзакций со смешанным доступом к данным Hibernate и JDBC полностью без JTA, при условии доступа только к одной базе данных. `HibernateTransactionManager` автоматически предоставляет транзакцию Hibernate как транзакцию JDBC, если вы настроили переданную `SessionFactory` с `DataSource` через свойство `dataSource` Класс LocalSessionFactoryBean.\nАльтернативно, вы можете явно указать `DataSource`, для которого транзакции должны быть доступны через Свойство dataSource класса HibernateTransactionManager.\nСтратегии управления транзакциями.\nДля отложенного получения фактических подключений к ресурсам в стиле JTA Spring предоставляет соответствующий прокси-класс `DataSource` для целевого пула соединений: см. {spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].\nЭто особенно полезно для транзакций Hibernate, доступных только для чтения, которые часто могут обрабатываться из локального кэша, а не обращаться к базе данных.\nСравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.\nВы можете переключаться между управляемым контейнером JNDI SessionFactory и локально определенным без необходимости изменения ни одной строки кода приложения.\nСтоит ли сохранять определения ресурсов в контейнере или локально внутри приложения — это в основном Вопрос в стратегии транзакции, которую вы используете.\nПо сравнению с локалом, определенным Spring `SessionFactory`, зарегистрированная вручную JNDI `SessionFactory`, не предоставляет никаких преимущества."}
{"id": 606, "text": "Развертывание SessionFactory через JCA-коннектор Hibernate обеспечивает дополнительная выгода от участия в инфраструктуре управления сервера Jakarta EE, но не добавляйте фактической ценности сверх этого.\nСравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.\nПоддержка транзакций Spring не привязана к контейнеру.\nПри настройке любой стратегии Помимо JTA, поддержка транзакций также работает в автономной или тестовой среде.\nОсобенно в типичном случае транзакций с одной базой данных Spring с одним ресурсом Поддержка локальных транзакций — это легкая и мощная альтернатива JTA.\nКогда вы используете локальные сессионные компоненты EJB без сохранения состояния для управления транзакциями, вы зависите как от EJB, так и от EJB. контейнере и на JTA, даже если вы обращаетесь только к одной базе данных и используете только без сохранения состояния сессионные компоненты для обеспечения декларативных транзакций посредством управляемых контейнером транзакции.\nДля прямого программного использования JTA также требуется среда Jakarta EE.\nСравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.\nТранзакции, управляемые Spring, также могут работать с локально определенным Hibernate. «SessionFactory», как и в случае с локальным источником данных JDBC, при условии, что они имеют доступ к единая база данных.\nТаким образом, вам нужно использовать стратегию транзакций Spring JTA только тогда, когда вы имеют распределенные требования к транзакциям.\nДля соединителя JCA требуется специфичный для контейнера этапы развертывания и (очевидно) поддержка JCA в первую очередь."}
{"id": 607, "text": "Эта конфигурация требует больше работы, чем развертывание простого веб-приложения с локальным ресурсом определения и транзакции, управляемые Spring.\nСравнение ресурсов, управляемых контейнером, и ресурсов, определяемых локально.\nУчитывая все обстоятельства, если вы не используете EJB, придерживайтесь локальной настройки SessionFactory. и Spring HibernateTransactionManager или JtaTransactionManager.\nВы получаете все преимущества, включая правильное транзакционное кэширование на уровне JVM и распределенную транзакции без неудобств, связанных с развертыванием контейнера.\nРегистрация JNDI Hibernate `SessionFactory` через соединитель JCA добавляет ценность только при использовании в сочетании с EJB.\nЛожные предупреждения сервера приложений в режиме Hibernate.\nВ некоторых средах JTA с очень строгой реализацией XADataSource (в настоящее время некоторые версии WebLogic Server и WebSphere), когда Hibernate настроен без относительно менеджера транзакций JTA для этой среды, ложных предупреждений или исключения могут отображаться в журнале сервера приложений.\nЭти предупреждения или исключения указывают, что соединение, к которому осуществляется доступ, больше не действительно или доступ JDBC невозможен. больше действителен, возможно, потому, что транзакция больше не активна.\nВ качестве примера: вот фактическое исключение из WebLogic:\n[буквальный] [subs=\"дословно,цитаты\"]. java.sql.SQLException: транзакция больше не активна — статус: «Зафиксировано».\nНет в рамках этой транзакции разрешен дальнейший доступ JDBC.\n[буквальный] [subs=\"дословно,цитаты\"]."}
{"id": 608, "text": "Другая распространенная проблема — утечка соединения после транзакций JTA в Hibernate. сеансы (и, возможно, лежащие в основе соединения JDBC) не закрываются должным образом.\n[буквальный] [subs=\"дословно,цитаты\"].\nВы можете решить такие проблемы, сообщив Hibernate о менеджере транзакций JTA. с которым он синхронизируется (вместе со Spring).\nУ вас есть два варианта сделать это:\n* Передайте bean-компонент Spring `JtaTransactionManager` в настройки Hibernate. Самый простой\n[буквальный] [subs=\"дословно,цитаты\"]. way — это ссылка на компонент в свойстве jtaTransactionManager для вашего Компонент LocalSessionFactoryBean (см. ссылку:data-access/transaction/strategies.adoc#transaction-strategies-hibernate [Настройка транзакции Hibernate]).\nЗатем Spring делает соответствующие стратегии JTA доступными для Hibernate.\n* Вы также можете явно настроить свойства Hibernate, связанные с JTA, в частности\n[буквальный] [subs=\"дословно,цитаты\"]. \"hibernate.transaction.coordinator_class\", \"hibernate.connection.handling_mode\" и, возможно, «hibernate.transaction.jta.platform» в ваших «hibernateProperties». в `LocalSessionFactoryBean` (подробную информацию об этих свойствах см. в руководстве Hibernate).\n[буквальный] [subs=\"дословно,цитаты\"]."}
{"id": 609, "text": "Оставшаяся часть этого раздела описывает последовательность событий, которые происходят с и без ведома Hibernate о JTA PlatformTransactionManager.\n[буквальный] [subs=\"дословно,цитаты\"].\nКогда Hibernate не настроен с учетом диспетчера транзакций JTA, при фиксации транзакции JTA происходят следующие события:\n* Транзакция JTA фиксируется.\n* Spring `JtaTransactionManager` синхронизируется с транзакцией JTA, поэтому\n[буквальный] [subs=\"дословно,цитаты\"]. вызывается через обратный вызов afterCompletion менеджером транзакций JTA.\n* Помимо прочего, эта синхронизация может вызвать обратный вызов Spring для\n[буквальный] [subs=\"дословно,цитаты\"].\nHibernate через обратный вызов Hibernate afterTransactionCompletion (используется для очистки кэш Hibernate), за которым следует явный вызов close() в сеансе Hibernate, что заставляет Hibernate попытаться закрыть() соединение JDBC.\n* В некоторых средах вызов Connection.close() вызывает предупреждение или\n[буквальный] [subs=\"дословно,цитаты\"]. ошибка, поскольку сервер приложений больше не считает «Соединение» пригодным для использования, поскольку транзакция уже зафиксирована.\n[буквальный] [subs=\"дословно,цитаты\"].\nКогда Hibernate настроен с учетом диспетчера транзакций JTA, при фиксации транзакции JTA происходят следующие события:\n* Транзакция JTA готова к фиксации.\n* Spring `JtaTransactionManager` синхронизируется с транзакцией JTA, поэтому"}
{"id": 610, "text": "[буквальный] [subs=\"дословно,цитаты\"]. транзакция вызывается обратно через обратный вызов «beforeCompletion» со стороны JTA менеджер транзакций.\n* Spring знает, что Hibernate сам синхронизируется с транзакцией JTA и\n[буквальный] [subs=\"дословно,цитаты\"]. ведет себя иначе, чем в предыдущем сценарии.\nВ частности, это соответствует Управление транзакционными ресурсами Hibernate.\n* Транзакция JTA фиксируется.\n* Hibernate синхронизируется с транзакцией JTA, поэтому транзакция вызывается обратно.\n[буквальный] [subs=\"дословно,цитаты\"]. через обратный вызов afterCompletion менеджера транзакций JTA и может правильно очистите его кеш."}
{"id": 611, "text": "HTTP/2-соединения Reactor Netty, Tomcat и Jetty.\nОднако существуют соображения, связанные с конфигурацией сервера.\nБолее подробную информацию см. {spring-framework-wiki}/HTTP-2-support[вики-страница HTTP/2]."}
{"id": 612, "text": "`HttpEntity` более или менее идентичен использованию `@RequestBody`, но основан на объект-контейнер, который предоставляет заголовки и тело запроса.\nВ следующем примере используется `HttpEntity`:\nJava\n	@PostMapping(\"/accounts\")\n	public void handle(HttpEntity<Account> entity) {"}
{"id": 613, "text": "Инициализация источника данных.\nПакет `org.springframework.jdbc.datasource.init` обеспечивает поддержку инициализации существующий «Источник данных».\nПоддержка встроенной базы данных предоставляет один из вариантов создания и инициализация источника данных для приложения.\nОднако иногда вам может потребоваться инициализировать экземпляр, который работает где-то на сервере.\nИнициализация базы данных с использованием Spring XML.\nЕсли вы хотите инициализировать базу данных и можете предоставить ссылку на DataSource bean, вы можете использовать тег `initialize-database` в пространстве имен `spring-jdbc`:\n	<jdbc:initialize-database data-source=\"dataSource\">\n		<jdbc:script location=\"classpath:com/foo/sql/db-schema.sql\"/>\n		<jdbc:script location=\"classpath:com/foo/sql/db-test-data.sql\"/>\n	</jdbc:initialize-database>\nИнициализация базы данных с использованием Spring XML.\nВ предыдущем примере выполняются два указанных сценария для базы данных.\nПервый скрипт создает схему, а второй заполняет таблицы тестовым набором данных.\nСценарий местоположения также могут быть шаблонами с подстановочными знаками в обычном стиле Ant, используемом для ресурсов.\nSpring (например, `classpath{asterisk}:/com/foo/{asterisk}{asterisk}/sql/{asterisk}-data.sql`)."}
{"id": 614, "text": "Если вы используете шаблон, сценарии выполняются в лексическом порядке их URL-адресов или имен файлов.\nИнициализация базы данных с использованием Spring XML.\nПоведение инициализатора базы данных по умолчанию — безоговорочный запуск предоставленного сценарии.\nЭто не всегда может быть тем, что вам нужно — например, если вы запустите сценарии для базы данных, в которой уже есть тестовые данные.\nВероятность вероятность случайного удаления данных снижается за счет следования общей схеме (показанной ранее) сначала создавать таблицы, а затем вставлять данные.\nПервый шаг не удался, если таблицы уже существуют.\nИнициализация базы данных с использованием Spring XML.\nОднако, чтобы получить больший контроль над созданием и удалением существующих данных, XML пространство имен предоставляет несколько дополнительных опций.\nПервый — это флаг переключения инициализация включается и выключается.\nВы можете установить это в соответствии с окружающей средой (например, при извлечении логическое значение из свойств системы или из компонента среды).\nВ следующем примере получается значение из системного свойства:\n	<jdbc:initialize-database data-source=\"dataSource\"\n		enabled=\"#{systemProperties.INITIALIZE_DATABASE}\"> <1>\n		<jdbc:script location=\"...\"/>\n	</jdbc:initialize-database>\nИнициализация базы данных с использованием Spring XML. <1> Получите значение «включено» из системного свойства с именем «INITIALIZE_DATABASE».\nИнициализация базы данных с использованием Spring XML."}
{"id": 615, "text": "Второй вариант контроля над тем, что происходит с существующими данными, — это быть более терпимыми к неудачи.\nС этой целью вы можете контролировать возможность инициализатора игнорировать определенные ошибки в SQL-коде, который он запускает из сценариев, как показано в следующем примере:\n	<jdbc:initialize-database data-source=\"dataSource\" ignore-failures=\"DROPS\">\n		<jdbc:script location=\"...\"/>\n	</jdbc:initialize-database>\nИнициализация базы данных с использованием Spring XML.\nВ предыдущем примере мы говорим, что ожидаем, что иногда сценарии будут запускаться против пустой базы данных, и в сценариях есть несколько операторов `DROP`, которые следовательно, потерпит неудачу.\nТаким образом, неудачные операторы SQL `DROP` будут игнорироваться, но другие ошибки вызовет исключение.\nЭто полезно, если ваш диалект SQL не поддерживает `DROP...\nIF EXISTS` (или аналогичный), но вы хотите безоговорочно удалить все тестовые данные перед воссоздавая его заново.\nВ этом случае первый сценарий обычно представляет собой набор операторов DROP. за которым следует набор операторов CREATE.\nИнициализация базы данных с использованием Spring XML.\nОпция `ignore-failures` может быть установлена на `NONE` (по умолчанию), `DROPS` (игнорировать сбой). падений) или «ВСЕ» (игнорировать все сбои).\nИнициализация базы данных с использованием Spring XML."}
{"id": 616, "text": "Каждый оператор должен быть разделен символом `;` или новой строкой, если символ `;` не указан. вообще присутствует в сценарии.\nВы можете контролировать это глобально или сценарий за сценарием, как следующий пример показывает:\n	<jdbc:initialize-database data-source=\"dataSource\" separator=\"@@\"> <1>\n		<jdbc:script location=\"classpath:com/myapp/sql/db-schema.sql\" separator=\";\"/> <2>\n		<jdbc:script location=\"classpath:com/myapp/sql/db-test-data-1.sql\"/>\n		<jdbc:script location=\"classpath:com/myapp/sql/db-test-data-2.sql\"/>\n	</jdbc:initialize-database>\nИнициализация базы данных с использованием Spring XML. <1> Установите в качестве скриптов-разделителей значение `@@`. <2> Установите разделитель для `db-schema.sql` на `;`.\nИнициализация базы данных с использованием Spring XML.\nВ этом примере два сценария `test-data` используют `@@` в качестве разделителя операторов и только `db-schema.sql` использует `;`."}
{"id": 617, "text": "Эта конфигурация указывает, что разделитель по умолчанию имеет значение `@@` и переопределяет значение по умолчанию для сценария `db-schema`.\nИнициализация базы данных с использованием Spring XML.\nЕсли вам нужно больше контроля, чем вы получаете от пространства имен XML, вы можете использовать DataSourceInitializer напрямую и определите его как компонент вашего приложения.\nИнициализация других компонентов, зависящих от базы данных.\nБольшой класс приложений (тех, которые не используют базу данных до тех пор, пока не будет создан контекст Spring). запущен) может использовать инициализатор базы данных без каких-либо дальнейших действий. осложнения.\nЕсли ваше приложение не входит в их число, возможно, вам придется прочитать остальное. этого раздела.\nИнициализация других компонентов, зависящих от базы данных.\nИнициализатор базы данных зависит от экземпляра DataSource и запускает сценарии. предоставленный в обратном вызове инициализации (аналог `init-method` в XML bean определение, метод `@PostConstruct` в компоненте или `afterPropertiesSet()` метод в компоненте, реализующем `InitializingBean`).\nЕсли другие компоненты зависят от тот же источник данных и использовать источник данных в обратном вызове инициализации, там может быть проблемой, поскольку данные еще не инициализированы.\nТипичный пример это кеш, который быстро инициализируется и загружает данные из базы данных в приложении запуск.\nИнициализация других компонентов, зависящих от базы данных."}
{"id": 618, "text": "Чтобы обойти эту проблему, у вас есть два варианта: изменить стратегию инициализации кэша. на более поздний этап или убедитесь, что инициализатор базы данных инициализирован первым.\nИнициализация других компонентов, зависящих от базы данных.\nИзменить стратегию инициализации кэша может быть легко, если приложение находится под вашим контролем, а не иначе.\nНекоторые предложения по реализации этого включают в себя:\n* Сделайте кеш ленивой инициализацией при первом использовании, что улучшает запуск приложений.\nИнициализация других компонентов, зависящих от базы данных. время.\n* Имейте свой кеш или отдельный компонент, который инициализирует реализацию кеша.\nИнициализация других компонентов, зависящих от базы данных. «Жизненный цикл» или «SmartLifecycle».\nКогда контекст приложения запускается, вы можете автоматически запустить `SmartLifecycle`, установив его флаг `autoStartup`, и вы можете вручную запустите «Жизненный цикл», вызвав «ConfigurableApplicationContext.start()» на включающем контексте.\n* Используйте Spring `ApplicationEvent` или аналогичный механизм пользовательского наблюдателя для запуска\nИнициализация других компонентов, зависящих от базы данных. инициализация кэша. `ContextRefreshedEvent` всегда публикуется контекстом, когда он готов к использованию (после того, как все компоненты были инициализированы), так что это часто бывает полезно. хук (именно так работает SmartLifecycle по умолчанию).\nИнициализация других компонентов, зависящих от базы данных.\nГарантировать, что инициализатор базы данных инициализируется первым, также может быть легко."}
{"id": 619, "text": "Некоторые предложения о том, как это реализовать, включают в себя:\n* Полагайтесь на поведение Spring `BeanFactory` по умолчанию, которое заключается в том, что bean-компоненты\nИнициализация других компонентов, зависящих от базы данных. инициализируется в порядке регистрации.\nВы можете легко это организовать, приняв общие практика набора элементов `<import/>` в конфигурации XML, которые упорядочивают ваши прикладные модули и обеспечение того, чтобы база данных и ее инициализация были указан первым.\n* Разделите источник данных и бизнес-компоненты, которые его используют, и контролируйте их.\nИнициализация других компонентов, зависящих от базы данных. порядок запуска, поместив их в отдельные экземпляры ApplicationContext (например, родительский контекст содержит DataSource, а дочерний контекст содержит бизнес-контекст. компоненты).\nЭта структура распространена в веб-приложениях Spring, но может быть и более обычно применяется."}
{"id": 620, "text": "Встроенные списки.\nВы можете напрямую выражать списки в выражении, используя нотацию `{}`.\nJava\n	// вернуть список Java, состоящее из четырех чисел\n	List numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context);\n	List listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\nВстроенные списки. `{}` сам по себе означает пустой список.\nПо соображениям производительности, если список сам по себе полностью состоящий из фиксированных литералов, создается постоянный список для представления выражение (вместо того, чтобы создавать новый список для каждой оценки)."}
{"id": 621, "text": "Встроенные карты.\nВы также можете напрямую выразить карты в выражении, используя нотацию `{key:value}`. следующий пример показывает, как это сделать:\nJava\n	// выпишите карту Java, содержащую две записи\n	Map inventorInfo = (Map) parser.parseExpression(\"{name:'Nikola',dob:'10-July-1856'}\").getValue(context);\n	Map mapOfMaps = (Map) parser.parseExpression(\"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}\").getValue(context);\nВстроенные карты. `{:}` сам по себе означает пустую карту.\nИз соображений производительности, если карта сама по себе состоит из фиксированных литералов или других вложенных константных структур (списков или карт), постоянная карта создается для представления выражения (вместо построения новой карты на основе каждая оценка).\nЗаключение ключей карты в кавычки не является обязательным (если ключ не содержит точку (`.`)).\nВ приведенных выше примерах не используются ключи в кавычках."}
{"id": 622, "text": "Создание экземпляра контейнера Spring с помощью AnnotationConfigApplicationContext.\nВ следующих разделах документируется Spring AnnotationConfigApplicationContext, представленный в Spring.\n3.0.\nЭта универсальная реализация ApplicationContext способна принимать не только Классы `@Configuration` в качестве входных данных, а также простые классы и классы `@Component` аннотированный метаданными JSR-330.\nКогда в качестве входных данных предоставляются классы `@Configuration`, сам класс `@Configuration` регистрируется как определение компонента и все объявленные методы `@Bean` внутри класса также регистрируются как определения bean-компонентов.\nКогда предоставляются классы `@Component` и JSR-330, они регистрируются как bean-компонент. определения, и предполагается, что метаданные DI, такие как `@Autowired` или `@Inject`, используется внутри этих классов там, где это необходимо.\nПростая конструкция.\nВо многом так же, как XML-файлы Spring используются в качестве входных данных при создании экземпляра `ClassPathXmlApplicationContext`, вы можете использовать классы `@Configuration` в качестве входных данных, когда создание экземпляра AnnotationConfigApplicationContext.\nЭто позволяет полностью Использование контейнера Spring без XML, как показано в следующем примере:\nJava\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n		MyService myService = ctx.getBean(MyService.class);\n		myService.doStuff();\nПростая конструкция."}
{"id": 623, "text": "Как упоминалось ранее, AnnotationConfigApplicationContext не ограничивается работой только с классами `@Configuration`.\nЛюбой аннотированный класс `@Component` или JSR-330 может быть предоставлен. в качестве входных данных для конструктора, как показано в следующем примере:\nJava\n	public static void main(String[] args) {\n		ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);\n		MyService myService = ctx.getBean(MyService.class);\n		myService.doStuff();\nПростая конструкция.\nВ предыдущем примере предполагается, что MyServiceImpl, Dependency1 и Dependency2 используют Spring. аннотации внедрения зависимостей, такие как `@Autowired`.\nПрограммное построение контейнера с помощью `register(Class<?>...)`.\nВы можете создать экземпляр AnnotationConfigApplicationContext, используя конструктор без аргументов. а затем настройте его с помощью метода Register().\nЭтот подход особенно полезен при программном создании AnnotationConfigApplicationContext.\nСледующие пример показывает, как это сделать:\nJava\n	public static void main(String[] args) {\n		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n		ctx.register(AppConfig.class, OtherConfig.class);\n		ctx.register(AdditionalConfig.class);\n		ctx.refresh();\n		MyService myService = ctx.getBean(MyService.class);\n		myService.doStuff();\nВключение сканирования компонентов с помощью `scan(String...)`."}
{"id": 624, "text": "Чтобы включить сканирование компонентов, вы можете аннотировать свой класс @Configuration следующим образом:\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"com.acme\") // <1>\n	public class AppConfig  {\nВключение сканирования компонентов с помощью `scan(String...)`. <1> Эта аннотация включает сканирование компонентов.\n	@Configuration\n	@ComponentScan(basePackages = [\"com.acme\"]) // <1>\n	class AppConfig  {\nВключение сканирования компонентов с помощью `scan(String...)`. <1> Эта аннотация включает сканирование компонентов.\nВключение сканирования компонентов с помощью `scan(String...)`. [СОВЕТ] = Опытные пользователи Spring могут быть знакомы с эквивалентом объявления XML из Пространство имен Spring `context:`, показанное в следующем примере:\n	<beans>\n		<context:component-scan base-package=\"com.acme\"/>\n	</beans>\nВключение сканирования компонентов с помощью `scan(String...)`.\nВ предыдущем примере пакет com.acme сканируется на наличие каких-либо Классы, аннотированные `@Component`, и эти классы регистрируются как Spring bean определения внутри контейнера. `AnnotationConfigApplicationContext` предоставляет `scan(String...)`, чтобы обеспечить ту же функциональность сканирования компонентов, что и метод следующий пример показывает:\nJava"}
{"id": 625, "text": "public static void main(String[] args) {\n		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n		ctx.scan(\"com.acme\");\n		ctx.refresh();\n		MyService myService = ctx.getBean(MyService.class);\nВключение сканирования компонентов с помощью `scan(String...)`.\nПРИМЕЧАНИЕ.\nПомните, что классы `@Configuration` с `@Component`, поэтому они являются кандидатами на сканирование компонентов.\nВ предыдущем примере предполагая, что AppConfig объявлен в пакете com.acme (или в любом пакете внизу), он считывается во время вызова Scan().\nПри `refresh()` все его `@Bean` методы обрабатываются и регистрируются как определения компонентов внутри контейнера.\nВключение сканирования компонентов с помощью `scan(String...)`.\nПоддержка веб-приложений с помощью AnnotationConfigWebApplicationContext.\nВключение сканирования компонентов с помощью `scan(String...)`.\nДоступен вариант WebApplicationContext для AnnotationConfigApplicationContext. с AnnotationConfigWebApplicationContext.\nВы можете использовать эту реализацию, когда настройка прослушивателя сервлетов Spring `ContextLoaderListener`, Spring MVC «DispatcherServlet» и так далее.\nСледующий фрагмент `web.xml` настраивает типичный Веб-приложение Spring MVC (обратите внимание на использование контекстного параметра contextClass и инициализирующий параметр):\n	<web-app>\n		<!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext\n			instead of the default XmlWebApplicationContext -->"}
{"id": 626, "text": "<context-param>\n			<param-name>contextClass</param-name>\n			<param-value>\n				org.springframework.web.context.support.AnnotationConfigWebApplicationContext\n			</param-value>\n		</context-param>\n		<!-- Configuration locations must consist of one or more comma- or space-delimited\n			полноценные классы @Configuration. Полноценные пакеты также могут быть\n			specified for component-scanning -->\n		<context-param>\n			<param-name>contextConfigLocation</param-name>\n			<param-value>com.acme.AppConfig</param-value>\n		</context-param>\n		<!-- Bootstrap the root application context as usual using ContextLoaderListener -->\n		<listener>\n			<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n		</listener>\n		<!-- Declare a Spring MVC DispatcherServlet as usual -->\n		<servlet>\n			<servlet-name>dispatcher</servlet-name>\n			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n			<!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext\n				instead of the default XmlWebApplicationContext -->\n			<init-param>\n				<param-name>contextClass</param-name>\n				<param-value>"}
{"id": 627, "text": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext\n				</param-value>\n			</init-param>\n			<!-- Again, config locations must consist of one or more comma- or space-delimited\n				and fully-qualified @Configuration classes -->\n			<init-param>\n				<param-name>contextConfigLocation</param-name>\n				<param-value>com.acme.web.MvcConfig</param-value>\n			</init-param>\n		</servlet>\n		<!-- map all requests for /app/* to the dispatcher servlet -->\n		<servlet-mapping>\n			<servlet-name>dispatcher</servlet-name>\n			<url-pattern>/app/*</url-pattern>\n		</servlet-mapping>\n	</web-app>\nВключение сканирования компонентов с помощью `scan(String...)`.\nПРИМЕЧАНИЕ.\nВ случаях программного использования GenericWebApplicationContext можно использовать в качестве альтернатива AnnotationConfigWebApplicationContext.\nСм. {spring-framework-api}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`] javadoc для получения подробной информации."}
{"id": 628, "text": "Модели реализации аспектов.\nПРИМЕЧАНИЕ.\nЭто сложная тема.\nЕсли вы только начинаете работать с АОП, вы можете спокойно пропустить это на потом.\nМодели реализации аспектов.\nПо умолчанию в приложении существует один экземпляр каждого аспекта. контекст.\nAspectJ называет это моделью создания одноэлементного экземпляра.\nМожно определить аспекты с альтернативными жизненными циклами.\nSpring поддерживает `perthis`, `pertarget` и модели реализации `pertypewithin`; `percflow` и `percflowbelow` в настоящее время не поддерживаются. поддерживается.\nМодели реализации аспектов.\nВы можете объявить аспект Perthis, указав предложение Perthis в параметре @Aspect. аннотация.\nРассмотрим следующий пример:\nJava\n	@Aspect(\"perthis(execution(* com.xyz..service.*.*(..)))\")\n	public class MyAspect {\n		private int someState;\n		@Before(\"execution(* com.xyz..service.*.*(..))\")\n		public void recordServiceUsage() {\n	@Aspect(\"perthis(execution(* com.xyz..service.*.*(..)))\")\n	class MyAspect {\nМодели реализации аспектов.\nВ предыдущем примере эффект предложения perthis заключается в том, что один экземпляр аспекта создается для каждого уникального объекта службы, выполняющего бизнес-услугу (каждый уникальный объект, привязанный к `this` в точках соединения, соответствующих выражению pointcut)."}
{"id": 629, "text": "Аспект Экземпляр создается при первом вызове метода объекта службы. аспект выходит за рамки, когда объект службы выходит за рамки.\nПеред аспектом экземпляр создан, ни один из советов, содержащихся в нем, не выполняется.\nКак только экземпляр аспекта создан, объявленный в нем совет выполняется в соответствующих точках соединения, но только когда объект службы является тем, с которым связан этот аспект.\nСм. аспектJ Руководство по программированию для получения дополнительной информации о предложениях per.\nМодели реализации аспектов.\nМодель реализации `pertarget` работает точно так же, как `perthis`, но она создает один экземпляр аспекта для каждого уникального целевого объекта в совпадающих точках соединения."}
{"id": 630, "text": "Перехватчики.\nВы можете зарегистрировать перехватчики для применения к входящим запросам, как показано в следующем примере: См. пример кода в исходном документе.\nПерехватчики.\nВНИМАНИЕ: перехватчики не идеально подходят в качестве уровня безопасности из-за возможности несоответствие аннотированному пути контроллера.\nКак правило, мы рекомендуем использовать Spring Безопасность или, альтернативно, аналогичный подход, интегрированный с цепочкой фильтров сервлетов, и применять как можно раньше.\nПерехватчики.\nПРИМЕЧАНИЕ.\nВ конфигурации XML перехватчики объявляются как bean-компоненты MappedInterceptor, и они находятся в Turn обнаруживается любым bean-компонентом HandlerMapping, в том числе из других фреймворков.\nНапротив, конфигурация Java передает перехватчики только bean-компонентам HandlerMapping, которыми она управляет.\nЧтобы повторно использовать одни и те же перехватчики в Spring MVC и других платформах HandlerMapping. bean-компоненты с конфигурацией Java MVC, либо объявите bean-компоненты MappedInterceptor (и не вручную добавьте их в конфиг Java) или настройте одни и те же перехватчики в обоих конфигурация Java и другие bean-компоненты HandlerMapping."}
{"id": 631, "text": "Концепции АОП.\nДавайте начнем с определения некоторых основных концепций и терминологии АОП.\nЭти условия не Специально для весны.\nК сожалению, терминология АОП не совсем интуитивно понятна.\nОднако было бы еще больше путаницы, если бы Spring использовал собственную терминологию.\n* Аспект: модульность проблемы, охватывающая несколько классов.\nКонцепции АОП.\nУправление транзакциями является хорошим примером сквозной проблемы в корпоративной Java. приложения.\nВ Spring AOP аспекты реализуются с помощью обычных классов. (подход на основе схемы) или обычные классы, помеченные Аннотация `@Aspect` (стиль @AspectJ).\n* Точка соединения: точка во время выполнения программы, например, выполнение\nКонцепции АОП. метод или обработка исключения.\nВ Spring AOP точка соединения всегда представляет выполнение метода.\n* Совет: действие, выполняемое аспектом в определенной точке соединения. Различные типы\nКонцепции АОП.\nСоветы включают советы «вокруг», «до» и «после». (Виды советов обсуждаются позже.) Многие АОП-фреймворки, включая Spring, моделируют совет как перехватчик и поддерживать цепочку перехватчиков вокруг точки соединения.\n* Pointcut: предикат, соответствующий точкам соединения. Совет связан с\nКонцепции АОП. выражение pointcut и выполняется в любой точке соединения, соответствующей pointcut (например, выполнение метода с определенным именем).\nКонцепция точек соединения как совпадающих с помощью выражений pointcut является центральным элементом АОП, а Spring использует pointcut AspectJ. язык выражений по умолчанию."}
{"id": 632, "text": "* Введение: объявление дополнительных методов или полей от имени типа. Весна\nКонцепции АОП.\nАОП позволяет вам добавлять новые интерфейсы (и соответствующую реализацию) к любому посоветовал объект.\nНапример, вы можете использовать введение, чтобы заставить компонент реализовать Интерфейс IsModified для упрощения кэширования. (Введение известно как межтиповое объявление в сообществе AspectJ.)\n* Целевой объект: Объект, которому сообщается один или несколько аспектов. Также упоминается как\nКонцепции АОП. «советуемый объект».\nПоскольку Spring AOP реализован с использованием прокси-серверов времени выполнения, это объект всегда является прокси-объектом.\n* Прокси-сервер AOP: объект, созданный средой AOP для реализации аспекта\nКонцепции АОП. контракты (исполнение методов рекомендаций и т. д.).\nВ Spring Framework прокси-сервер AOP является динамическим прокси-сервером JDK или прокси-сервером CGLIB.\n* Переплетение: связывание аспектов с другими типами приложений или объектами для создания\nКонцепции АОП. посоветовал объект.\nЭто можно сделать во время компиляции (используя компилятор AspectJ, например например), во время загрузки или во время выполнения.\nSpring AOP, как и другие среды AOP на чистом Java, выполняет переплетение во время выполнения.\n* Совет перед: совет, который выполняется перед точкой соединения, но не имеет\nSpring AOP включает следующие типы советов:. возможность предотвратить движение потока выполнения к точке соединения (если только он не выдает исключение)."}
{"id": 633, "text": "* После возврата совета: совет будет запущен после завершения точки соединения.\nSpring AOP включает следующие типы советов:. обычно (например, если метод возвращает значение, не выдавая исключения).\n* После выдачи совета: совет будет выполняться, если метод завершается путем выдачи\nSpring AOP включает следующие типы советов:. исключение.\n* После (наконец) совета: совет следует выполнять независимо от того, с помощью чего\nSpring AOP включает следующие типы советов:. выходы из точки соединения (нормальный или исключительный возврат).\n* Вокруг совета: совет, окружающий точку соединения, например вызов метода.\nSpring AOP включает следующие типы советов:.\nЭто самый действенный совет.\nВокруг совета можно выполнять индивидуальное поведение. до и после вызова метода.\nОн также отвечает за выбор того, следует ли перейти к точке соединения или сократить выполнение рекомендованного метода, вернув его собственное возвращаемое значение или выдача исключения.\nSpring AOP включает следующие типы советов:.\nВокруг совета – это самый общий вид совета.\nПоскольку Spring AOP, как и AspectJ, предоставляет полный набор типов советов, мы рекомендуем использовать наименее мощные тип совета, который может реализовать требуемое поведение.\nНапример, если вам нужно только обновить кеш возвращаемым значением метода, вам лучше реализовать после ответа на совет, чем обходной совет, хотя обходной совет может принести пользу то же самое.\nИспользование наиболее конкретного типа рекомендаций обеспечивает более простую модель программирования. с меньшей вероятностью ошибок."}
{"id": 634, "text": "Например, вам не нужно вызывать `proceed()` метод в «JoinPoint», используемый для получения рекомендаций, и, следовательно, вы не можете не вызвать его.\nSpring AOP включает следующие типы советов:.\nВсе параметры рекомендаций статически типизированы, поэтому вы можете работать с параметрами рекомендаций соответствующий тип (например, тип возвращаемого значения при выполнении метода), а не чем массивы `Object`.\nSpring AOP включает следующие типы советов:.\nКонцепция точек соединения, соответствующих точечным разрезам, является ключом к АОП, который отличает это из старых технологий, предлагающих только перехват.\nPointcuts позволяют давать советы нацелены независимо от объектно-ориентированной иерархии.\nНапример, вы можете применить вокруг рекомендаций, обеспечивающих декларативное управление транзакциями для набора методов, охватывающих несколько объектов (например, все бизнес-операции на уровне обслуживания)."}
{"id": 635, "text": "АОП-прокси.\nSpring AOP по умолчанию использует стандартные динамические прокси JDK для прокси AOP.\nЭто позволяет проксировать любой интерфейс (или набор интерфейсов).\nАОП-прокси.\nSpring AOP также может использовать прокси-серверы CGLIB.\nЭто необходимо для прокси-классов, а не интерфейсы.\nПо умолчанию CGLIB используется, если бизнес-объект не реализует интерфейс.\nПоскольку хорошей практикой является программирование для интерфейсов, а не для классов, бизнес классы обычно реализуют один или несколько бизнес-интерфейсов.\nЭто возможно нужно посоветовать метод, который не объявлен на интерфейсе или где нужно передать прокси-объект методу как конкретный тип.\nАОП-прокси.\nВажно понимать тот факт, что Spring AOP основан на прокси-сервере.\nСм. для тщательного изучения того, что именно означает эта деталь реализации."}
{"id": 636, "text": "Возможности и цели Spring AOP.\nSpring AOP реализован на чистой Java.\nНет необходимости в специальной компиляции процесс.\nSpring AOP не нуждается в управлении иерархией загрузчика классов и поэтому подходит для использования в контейнере сервлетов или сервере приложений.\nВозможности и цели Spring AOP.\nSpring AOP в настоящее время поддерживает только точки соединения выполнения метода (рекомендуя выполнение методов на компонентах Spring).\nПерехват полей не реализован, хотя поддержка перехват полей можно добавить, не нарушая основные API Spring AOP.\nЕсли вам нужно чтобы рекомендовать доступ к полям и обновлять точки соединения, рассмотрите такой язык, как AspectJ.\nВозможности и цели Spring AOP.\nПодход Spring AOP к АОП отличается от подхода большинства других инфраструктур АОП.\nЦель состоит в том, не для обеспечения наиболее полной реализации АОП (хотя Spring AOP вполне способен).\nСкорее, цель состоит в том, чтобы обеспечить тесную интеграцию между реализацией АОП и Spring IoC для решения распространенных проблем в корпоративных приложениях.\nВозможности и цели Spring AOP.\nТак, например, функциональность AOP Spring Framework обычно используется в сочетании с контейнером Spring IoC.\nАспекты настраиваются с использованием обычного bean-компонента. синтаксис определения (хотя это обеспечивает мощные возможности «автоматического проксирования»).\nЭто существенное отличие от других реализаций АОП.\nВы не можете делать некоторые вещи легко и эффективно с помощью Spring AOP, например, советовать очень мелкозернистые объекты (обычно объекты домена).\nAspectJ — лучший выбор в таких случаях."}
{"id": 637, "text": "Однако наш опыт показывает, что Spring AOP обеспечивает отличное решение большинства проблем в корпоративные Java-приложения, совместимые с АОП.\nВозможности и цели Spring AOP.\nSpring AOP никогда не стремится конкурировать с AspectJ в предоставлении комплексного АОП. решение.\nМы считаем, что как прокси-фреймворки, такие как Spring AOP, так и полноценные такие фреймворки, как AspectJ, ценны и дополняют друг друга, а не конкуренция.\nSpring легко интегрирует Spring AOP и IoC с AspectJ, чтобы обеспечить все виды использования АОП в едином приложении на основе Spring архитектура.\nЭта интеграция не влияет на Spring AOP API или AOP Alliance.\nAPI.\nSpring AOP остается обратно совместимым.\nСм. следующую главу для обсуждения API Spring AOP.\nВозможности и цели Spring AOP. [ПРИМЕЧАНИЕ] = Одним из центральных принципов Spring Framework является принцип неинвазивности.\nЭто заключается в том, что вас не следует заставлять вводить классы, специфичные для платформы, и интерфейсы с вашей бизнес-моделью или моделью домена.\nОднако в некоторых местах Spring Framework дает вам возможность ввести зависимости, специфичные для Spring Framework, в ваш кодовая база.\nОбоснование предоставления вам таких вариантов заключается в том, что в определенных сценариях это может быть просто проще читать или кодировать какую-то конкретную часть функциональности в таком путь."}
{"id": 638, "text": "Однако Spring Framework (почти) всегда предлагает вам выбор: у вас есть свобода принятия обоснованного решения относительно того, какой вариант лучше всего подходит для вашего конкретного использования случай или сценарий.\nВозможности и цели Spring AOP.\nОдним из таких вариантов, имеющих отношение к этой главе, является выбор того, какая структура АОП (и какой стиль АОП) выбрать.\nУ вас есть выбор: AspectJ, Spring AOP или оба. ты также есть выбор либо подхода в стиле аннотаций @AspectJ, либо Spring XML. подход в стиле конфигурации.\nТот факт, что в этой главе решено представить Подход в стиле @AspectJ не следует воспринимать как признак того, что команда Spring предпочитает подход в стиле аннотации @AspectJ стилю конфигурации Spring XML.\nВозможности и цели Spring AOP.\nДополнительную информацию см. в Выбор стиля объявления АОП. полное обсуждение преимуществ и недостатков каждого стиля."}
{"id": 639, "text": "Введение в ORM с помощью Spring.\nSpring Framework поддерживает интеграцию с Java Persistence API (JPA) и поддерживает встроенный Hibernate для управления ресурсами, реализации объектов доступа к данным (DAO), и стратегии транзакций.\nНапример, для Hibernate имеется первоклассная поддержка с несколько удобных функций IoC, которые решают многие типичные проблемы интеграции Hibernate.\nВы можете настроить все поддерживаемые функции для сопоставления OR (реляционного объекта). инструменты посредством внедрения зависимостей.\nОни могут участвовать в ресурсе Spring и управление транзакциями и соответствуют общим транзакциям Spring и DAO. иерархии исключений.\nРекомендуемый стиль интеграции — кодировать DAO вместо простых API-интерфейсы Hibernate или JPA.\nВведение в ORM с помощью Spring.\nSpring добавляет значительные улучшения к выбранному вами слою ORM при создании приложения доступа к данным.\nВы можете использовать столько поддержки интеграции, сколько захотите. желанию, и вам следует сравнить эти усилия по интеграции со стоимостью и риском создания аналогичная инфраструктура внутри компании.\nВы можете использовать большую часть поддержки ORM так же, как и библиотека, вне зависимости от технологии, ведь все спроектировано как набор многоразовых JavaBeans.\nORM в контейнере Spring IoC упрощает настройку и развертывание.\nТаким образом, большинство примеров в этом разделе показывают конфигурацию внутри контейнера Spring.\nВведение в ORM с помощью Spring.\nПреимущества использования Spring Framework для создания ORM DAO включают в себя:\n* *Упрощенное тестирование.* Подход Spring IoC позволяет легко менять реализации."}
{"id": 640, "text": "Введение в ORM с помощью Spring. и расположение конфигурации экземпляров Hibernate `SessionFactory`, JDBC `DataSource` экземпляры, менеджеры транзакций и реализации сопоставленных объектов (при необходимости).\nЭто в свою очередь, значительно упрощает тестирование каждого фрагмента кода, связанного с персистентностью, в изоляция.\n* *Общие исключения доступа к данным.* Spring может обертывать исключения из вашего инструмента ORM,\nВведение в ORM с помощью Spring. преобразование их из проприетарных (потенциально проверяемых) исключений в общую среду выполнения Иерархия DataAccessException.\nЭта функция позволяет вам обрабатывать большую часть настойчивости исключения, которые не подлежат восстановлению, только в соответствующих слоях, без надоедливые шаблонные перехваты, выдачи и объявления исключений.\nВы все еще можете поймать и обрабатывать исключения по мере необходимости.\nПомните, что исключения JDBC (включая Диалекты, специфичные для БД), также преобразуются в ту же иерархию, что означает, что вы можете выполнять некоторые операции с JDBC в рамках согласованной модели программирования.\n* *Общее управление ресурсами.* Контексты приложений Spring могут обрабатывать местоположение.\nВведение в ORM с помощью Spring. и настройка экземпляров Hibernate SessionFactory, JPA EntityManagerFactory. экземпляры, экземпляры JDBC `DataSource` и другие связанные ресурсы.\nЭто делает эти ценности, которыми легко управлять и изменять.\nSpring предлагает эффективное, простое и безопасное обращение с ресурсы персистентности."}
{"id": 641, "text": "Например, связанный код, использующий Hibernate, обычно требует используйте тот же сеанс Hibernate, чтобы обеспечить эффективность и правильную обработку транзакций.\nSpring позволяет легко создавать и прозрачно привязывать сеанс к текущему потоку. путем предоставления текущего сеанса через Hibernate SessionFactory.\nТаким образом, весна решает многие хронические проблемы типичного использования Hibernate для любого локального или JTA-сервера. среда транзакций.\n* *Интегрированное управление транзакциями.* Вы можете обернуть свой код ORM декларативным,\nВведение в ORM с помощью Spring. перехватчик метода аспектно-ориентированного программирования (АОП) либо через аннотацию `@Transactional` или явно настроив рекомендации AOP транзакции в XML-файл конфигурации.\nВ обоих случаях семантика транзакций и обработка исключений (откат и т. д.) обрабатываются за вас.\nКак обсуждалось в вы также можете поменять местами различные менеджеры транзакций, не затрагивая код, связанный с ORM.\nНапример, вы можете переключаться между локальными транзакциями и JTA с тем же полным набором услуг. (например, декларативные транзакции), доступные в обоих сценариях.\nКроме того, Код, связанный с JDBC, может полностью интегрироваться транзакционно с кодом, который вы используете для ORM.\nЭто полезно для доступа к данным, который не подходит для ORM (например, пакетная обработка и потоковая передача BLOB), но для этого все равно необходимо использовать общие транзакции с операциями ORM.\nВведение в ORM с помощью Spring."}
{"id": 642, "text": "СОВЕТ: Для более полной поддержки ORM, включая поддержку альтернативной базы данных таких технологий, как MongoDB, вы можете ознакомиться с Набор проектов {spring-site-projects}/spring-data/[Spring Data].\nЕсли вы пользователь JPA, {spring-site-guides}/gs/accessing-data-jpa/[Начало работы с доступом Руководство «Данные с JPA» с https://spring.io представляет собой отличное введение."}
{"id": 643, "text": "Введение.\nВведения (известные как объявления между типами в AspectJ) позволяют аспекту объявлять что рекомендуемые объекты реализуют заданный интерфейс и обеспечивают реализацию этот интерфейс от имени этих объектов.\nВведение.\nВы можете представиться, используя аннотацию @DeclareParents.\nЭта аннотация используется для объявления того, что соответствующие типы имеют нового родителя (отсюда и название).\nНапример, учитывая интерфейс с именем UsageTracked и реализацию этого интерфейса с именем `DefaultUsageTracked`, следующий аспект заявляет, что все разработчики службы интерфейсы также реализуют интерфейс UsageTracked (например, для статистики через JMX):\nJava\n	@Aspect\n	public class UsageTracking {\n		@DeclareParents(value=\"com.xyz.service.*+\", defaultImpl=DefaultUsageTracked.class)\n		public static UsageTracked mixin;\n		@Before(\"execution(* com.xyz..service.*.*(..)) && this(usageTracked)\")\n		public void recordUsage(UsageTracked usageTracked) {\n			usageTracked.incrementUseCount();\n	@Aspect\n	class UsageTracking {\nВведение.\nРеализуемый интерфейс определяется типом аннотируемого поля.\nАтрибут value в аннотации @DeclareParents представляет собой шаблон типа AspectJ.\nЛюбой Компонент соответствующего типа реализует интерфейс UsageTracked.\nОбратите внимание, что в Перед советом предыдущего примера служебные bean-компоненты можно напрямую использовать как реализации интерфейса UsageTracked.\nЕсли доступ к компоненту осуществляется программно, вы бы написали следующее:\nJava"}
{"id": 644, "text": "UsageTracked usageTracked = context.getBean(\"myService\", UsageTracked.class);"}
{"id": 645, "text": "Джексон JSON.\nSpring предлагает поддержку библиотеки Jackson JSON.\nПросмотры JSON.\nSpring WebFlux предоставляет встроенную поддержку {baeldung-blog}/jackson-json-view-annotation [Представления сериализации Джексона], который позволяет отображать только подмножество всех полей в объекте.\nЧтобы использовать его с Методы контроллера `@ResponseBody` или `ResponseEntity`, вы можете использовать методы Джексона.\nАннотация `@JsonView` для активации класса представления сериализации, как показано в следующем примере:\nJava\n	@RestController\n	public class UserController {\n		@GetMapping(\"/user\")\n		@JsonView(User.WithoutPasswordView.class)\n		public User getUser() {\n			return new User(\"eric\", \"7!jd#h23\");\n	public class User {\n		public interface WithoutPasswordView {};\n		public interface WithPasswordView extends WithoutPasswordView {};\n		private String username;\n		private String password;\n		public User() {\n		public User(String username, String password) {\n			this.username = username;\n			this.password = password;\n		@JsonView(WithoutPasswordView.class)\n		public String getUsername() {\n			return this.username;\n		@JsonView(WithPasswordView.class)\n		public String getPassword() {\n			return this.password;\n	@RestController\n	class UserController {\nПросмотры JSON.\nПРИМЕЧАНИЕ. `@JsonView` допускает использование массива классов представлений, но вы можете указать только один для каждого. метод контроллера."}
{"id": 646, "text": "Используйте составной интерфейс, если вам нужно активировать несколько представлений."}
{"id": 647, "text": "Конфигурация контейнера на основе Java.\nВ этом разделе описано, как использовать аннотации в коде Java для настройки Spring. контейнер."}
{"id": 648, "text": "Доступ к данным с помощью JDBC.\nЦенность, предоставляемая абстракцией JDBC Spring Framework, возможно, лучше всего демонстрируется Последовательность действий изложена в следующей таблице.\nВ таблице показано, какие действия Spring о чем заботится и за какие действия вы несете ответственность.\nДоступ к данным с помощью JDBC. .Spring JDBC – кто что делает? |=== | Действие| Весна| ты\n| Подготовьте и запустите заявление. | Х |. | Настройте цикл для перебора результатов (если таковые имеются). | Х |\n| Обрабатывать транзакции. | Х |. | Закройте соединение, оператор и набор результатов. | Х | |===\n| Обрабатывать транзакции. | Х |.\nSpring Framework заботится обо всех деталях низкого уровня, которые могут сделать JDBC таким утомительный API."}
{"id": 649, "text": "Spring JPA, доступный в пакете org.springframework.orm.jpa, предлагает всесторонняя поддержка https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html[Постоянство Java API] аналогично интеграции с Hibernate, но с учетом базовую реализацию, чтобы предоставить дополнительные функции.\nТри варианта настройки JPA в среде Spring.\nПоддержка Spring JPA предлагает три способа настройки JPA `EntityManagerFactory`. который используется приложением для получения менеджера объектов.\n* с использованием `LocalEntityManagerFactoryBean`\n* Получение EntityManagerFactory из JNDI\n* с использованием `LocalContainerEntityManagerFactoryBean`\nИспользование LocalEntityManagerFactoryBean.\nЭту опцию можно использовать только в простых средах развертывания, например в изолированных средах. приложения и интеграционные тесты.\nИспользование LocalEntityManagerFactoryBean.\nLocalEntityManagerFactoryBean создает EntityManagerFactory, подходящий для простые среды развертывания, в которых приложение использует только JPA для доступа к данным.\nФабричный компонент использует механизм автоматического обнаружения JPA PersistenceProvider (согласно к начальной загрузке Java SE JPA) и в большинстве случаев требует указания только имя единицы персистентности.\nСледующий пример XML настраивает такой bean-компонент:\n	<beans>\n		<bean id=\"myEmf\" class=\"org.springframework.orm.jpa.LocalEntityManagerFactoryBean\">\n			<property name=\"persistenceUnitName\" value=\"myPersistenceUnit\"/>\n		</bean>\n	</beans>\nИспользование LocalEntityManagerFactoryBean.\nЭта форма развертывания JPA является самой простой и наиболее ограниченной."}
{"id": 650, "text": "Вы не можете ссылаться на существующее определение bean-компонента JDBC `DataSource` и отсутствие поддержки глобальных транзакций существует.\nКроме того, плетение (преобразование байт-кода) постоянных классов зависит от поставщика, часто требует указания конкретного агента JVM при запуске.\nЭто вариант достаточен только для автономных приложений и тестовых сред, для которых разработана спецификация JPA.\nПолучение EntityManagerFactory из JNDI.\nЭту опцию можно использовать при развертывании на сервере Jakarta EE.\nПроверьте документацию вашего сервера о том, как развернуть на вашем сервере собственный поставщик JPA, позволяющий использовать разные провайдера, чем сервер по умолчанию.\nПолучение EntityManagerFactory из JNDI (например, в среде Jakarta EE), является вопросом изменения конфигурации XML, как показано в следующем примере:\n	<beans>\n		<jee:jndi-lookup id=\"myEmf\" jndi-name=\"persistence/myPersistenceUnit\"/>\n	</beans>\nПолучение EntityManagerFactory из JNDI.\nЭто действие предполагает стандартную загрузку Jakarta EE.\nСервер Jakarta EE автоматически обнаруживает единицы персистентности (по сути, файлы META-INF/persistence.xml в jar-файлах приложения) и записи `persistence-unit-ref` в дескрипторе развертывания Jakarta EE (например, `web.xml`) и определяет расположение контекста именования среды для этих единиц персистентности.\nПолучение EntityManagerFactory из JNDI.\nВ таком сценарии все развертывание модуля сохраняемости, включая переплетение (преобразование байт-кода) постоянных классов зависит от сервера Jakarta EE."}
{"id": 651, "text": "JDBC DataSource определяется через местоположение JNDI в файле META-INF/persistence.xml.\nТранзакции EntityManager интегрированы с подсистемой JTA сервера.\nВесна просто использует полученную EntityManagerFactory, передавая ее объектам приложения через внедрение зависимостей и управление транзакциями для модуля персистентности (обычно через `JtaTransactionManager`).\nПолучение EntityManagerFactory из JNDI.\nЕсли вы используете несколько модулей персистентности в одном приложении, имена компонентов таких Единицы персистентности, полученные с помощью JNDI, должны соответствовать именам единиц персистентности, которые приложение использует для ссылки на них (например, в `@PersistenceUnit` и аннотации `@PersistenceContext`).\nИспользование LocalContainerEntityManagerFactoryBean.\nВы можете использовать эту опцию для получения всех возможностей JPA в среде приложений на основе Spring.\nСюда входят веб-контейнеры, такие как Tomcat, автономные приложения и интеграционные тесты со сложными требованиями к устойчивости.\nИспользование LocalContainerEntityManagerFactoryBean.\nLocalContainerEntityManagerFactoryBean дает полный контроль над Конфигурация `EntityManagerFactory` подходит для сред, где требуется тонкая настройка. `LocalContainerEntityManagerFactoryBean` создает экземпляр PersistenceUnitInfo на основе файлаpersistence.xml, предоставил стратегию dataSourceLookup и указанный loadTimeWeaver.\nТаким образом, это можно работать с пользовательскими источниками данных вне JNDI и контролировать переплетение процесс.\nВ следующем примере показано типичное определение компонента для `LocalContainerEntityManagerFactoryBean`:\n	<beans>\n		<bean id=\"myEmf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n			<property name=\"dataSource\" ref=\"someDataSource\"/>"}
{"id": 652, "text": "<property name=\"loadTimeWeaver\">\n				<bean class=\"org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver\"/>\n			</property>\n		</bean>\n	</beans>\n	<persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"1.0\">\n		<persistence-unit name=\"myUnit\" transaction-type=\"RESOURCE_LOCAL\">\n			<mapping-file>META-INF/orm.xml</mapping-file>\n			<exclude-unlisted-classes/>\n		</persistence-unit>\n	</persistence>\nВ следующем примере показан типичный файл persistence.xml:.\nПРИМЕЧАНИЕ.\nЯрлык `<exclude-unlisted-classes/>` указывает, что сканирование на наличие предполагается, что будут аннотированные классы сущностей.\nЯвное «истинное» значение (`<exclude-unlisted-classes>true</exclude-unlisted-classes/>`) также означает отсутствие сканирования. `<exclude-unlisted-classes>false</exclude-unlisted-classes/>` запускает сканирование.\nОднако мы рекомендуем опустить элемент «exclude-unlisted-classes». если вы хотите, чтобы происходило сканирование классов сущностей.\nВ следующем примере показан типичный файл persistence.xml:.\nИспользование LocalContainerEntityManagerFactoryBean — самая мощная настройка JPA. опция, позволяющая гибко локально настраивать приложение."}
{"id": 653, "text": "Он поддерживает ссылки на существующий источник данных JDBC, поддерживают как локальные, так и глобальные транзакции и так далее.\nОднако это также накладывает требования на среду выполнения, например наличие загрузчика классов с возможностью переплетения, если этого требует поставщик персистентности преобразование байт-кода.\nВ следующем примере показан типичный файл persistence.xml:.\nЭтот параметр может конфликтовать со встроенными возможностями JPA сервера Jakarta EE.\nВ полной среды Jakarta EE, рассмотрите возможность получения EntityManagerFactory от JNDI.\nАльтернативно, укажите пользовательское значение «persistenceXmlLocation» в вашем Определение `LocalContainerEntityManagerFactoryBean` (например, META-INF/my-persistence.xml) и включать в свой файл только дескриптор с таким именем. jar-файлы приложения.\nПоскольку сервер Jakarta EE ищет только значения по умолчанию `META-INF/persistence.xml`, он игнорирует такие пользовательские единицы персистентности и, следовательно, позволяет избежать конфликтов с предварительной настройкой JPA, управляемой Spring.\nВ следующем примере показан типичный файл persistence.xml:. .Когда требуется ткачество во время загрузки? **** Не всем поставщикам JPA требуется агент JVM.\nHibernate — пример того, чего нет.\nЕсли вашему провайдеру не требуется агент или у вас есть другие альтернативы, например применяя улучшения во время сборки с помощью специального компилятора или задачи Ant, вам не следует использовать время загрузки ткача. ****\nВ следующем примере показан типичный файл persistence.xml:."}
{"id": 654, "text": "Интерфейс LoadTimeWeaver — это класс, предоставленный Spring, который позволяет JPA Экземпляры ClassTransformer подключаются определенным образом, в зависимости от того, среда — это веб-контейнер или сервер приложений.\nПерехват `ClassTransformers` через {java-api}/java.instrument/java/lang/instrument/package-summary.html[агент] обычно неэффективен.\nАгенты работают на всей виртуальной машине и проверять каждый загружаемый класс, что обычно нежелательно в рабочей среде. серверная среда.\nВ следующем примере показан типичный файл persistence.xml:.\nSpring предоставляет ряд реализаций LoadTimeWeaver для различных сред. позволяя экземплярам ClassTransformer применяться только для каждого загрузчика классов, а не для каждой виртуальной машины.\nВ следующем примере показан типичный файл persistence.xml:.\nСм. конфигурация Spring в главе АОП. более подробная информация о реализациях LoadTimeWeaver и их настройке, либо универсальный или адаптированный для различных платформ (таких как Tomcat, JBoss и WebSphere).\nВ следующем примере показан типичный файл persistence.xml:.\nКак описано в конфигурация Spring, вы можете настроить контекстный `LoadTimeWeaver`, используя аннотацию `@EnableLoadTimeWeaving` или XML-элемент `context:load-time-weaver`.\nТакой глобальный вивер автоматически подхватывается всеми экземплярами JPA LocalContainerEntityManagerFactoryBean."}
{"id": 655, "text": "Следующий пример показывает предпочтительный способ настройки Weaver во время загрузки, обеспечивая автоматическое обнаружение платформы (например, загрузчик классов Tomcat с поддержкой переплетения или агент JVM Spring) и автоматическое распространение ткача на все bean-компоненты, поддерживающие ткач:\n	<context:load-time-weaver/>\n	<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n	</bean>\nВ следующем примере показан типичный файл persistence.xml:.\nОднако при необходимости вы можете вручную указать выделенного ткача через loadTimeWeaver, как показано в следующем примере:\n	<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n		<property name=\"loadTimeWeaver\">\n			<bean class=\"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\"/>\n		</property>\n	</bean>\nВ следующем примере показан типичный файл persistence.xml:.\nНезависимо от того, как настроен LTW, при использовании этого метода приложения JPA, использующие Инструментарий может работать на целевой платформе (например, Tomcat) без использования агента.\nЭто особенно важно, когда хостинговые приложения используют разные JPA. реализации, поскольку преобразователи JPA применяются только на уровне загрузчика классов и таким образом, изолированы друг от друга.\nРабота с несколькими единицами персистентности."}
{"id": 656, "text": "Для приложений, которые полагаются на несколько расположений единиц персистентности (хранящихся в различных JARS в пути к классам), Spring предлагает PersistenceUnitManager действовать как центральный репозиторий и избежать процесса обнаружения единиц персистентности, который может быть дорого.\nРеализация по умолчанию позволяет указать несколько местоположений.\nЭти места анализируется и позже извлекается по имени единицы персистентности. (По умолчанию путь к классам ищет файлы `META-INF/persistence.xml`.) В следующем примере настраиваются несколько мест:\n	<bean id=\"pum\" class=\"org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager\">\n		<property name=\"persistenceXmlLocations\">\n			<list>\n				<value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>\n				<value>classpath:/my/package/**/custom-persistence.xml</value>\n				<value>classpath*:META-INF/persistence.xml</value>\n			</list>\n		</property>\n		<property name=\"dataSources\">\n			<map>\n				<entry key=\"localDataSource\" value-ref=\"local-db\"/>\n				<entry key=\"remoteDataSource\" value-ref=\"remote-db\"/>\n			</map>\n		</property>\n		<!-- if no datasource is specified, use this one -->"}
{"id": 657, "text": "<property name=\"defaultDataSource\" ref=\"remoteDataSource\"/>\n	</bean>\n	<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n		<property name=\"persistenceUnitManager\" ref=\"pum\"/>\n		<property name=\"persistenceUnitName\" value=\"myCustomUnit\"/>\n	</bean>\nРабота с несколькими единицами персистентности.\nРеализация по умолчанию позволяет настраивать экземпляры PersistenceUnitInfo. (до того, как они будут переданы провайдеру JPA) либо декларативно (через его свойства, которые влиять на все размещенные устройства) или программно (через `PersistenceUnitPostProcessor`, который позволяет выбирать единицы персистентности).\nЕсли нет Указан `PersistenceUnitManager`, он создается и используется внутри `LocalContainerEntityManagerFactoryBean`.\nФоновая загрузка.\nLocalContainerEntityManagerFactoryBean поддерживает фоновую загрузку через свойство bootstrapExecutor, как показано в следующем примере:\n	<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n		<property name=\"bootstrapExecutor\">\n			<bean class=\"org.springframework.core.task.SimpleAsyncTaskExecutor\"/>\n		</property>\n	</bean>\nФоновая загрузка.\nФактическая загрузка поставщика JPA передается указанному исполнителю, а затем работает параллельно с потоком начальной загрузки приложения.\nОткрытая `EntityManagerFactory` прокси-сервер может быть внедрен в другие компоненты приложения и даже способен реагировать на Проверка конфигурации `EntityManagerFactoryInfo`."}
{"id": 658, "text": "Однако, как только фактический поставщик JPA к которому обращаются другие компоненты (например, вызов `createEntityManager`), эти вызовы блокируются до завершения фоновой загрузки.\nВ частности, когда вы используете Spring Data JPA, обязательно также настройте отложенную загрузку для своих репозиториев.\nФоновая загрузка.\nНачиная с версии 6.2, инициализация JPA применяется до завершения обновления контекста, ожидая асинхронная загрузка должна завершиться к тому времени.\nЭто делает доступность полностью инициализированная инфраструктура базы данных предсказуема и позволяет настраивать пост-инициализацию логика в прослушивателях `ContextRefreshedEvent` и т. д.\nРазмещение такой базы данных уровня приложения инициализация методами `@PostConstruct` и т.п. не рекомендуется; это лучше разместить в Lifecycle.start (если применимо) или в прослушивателе ContextRefreshedEvent.\nФоновая загрузка.\nРеализация DAO на основе JPA: EntityManagerFactory и EntityManager.\nФоновая загрузка.\nПРИМЕЧАНИЕ.\nХотя экземпляры EntityManagerFactory являются потокобезопасными, экземпляры EntityManager нет.\nВнедренный JPA `EntityManager` ведет себя как `EntityManager`, полученный из среда JNDI сервера приложений, как определено спецификацией JPA.\nОн делегирует все вызовы текущего транзакционного `EntityManager`, если таковые имеются.\nВ противном случае он откатится назад во вновь созданный `EntityManager` для каждой операции, что фактически делает его использование потокобезопасным.\nФоновая загрузка.\nМожно написать код на простом JPA без каких-либо зависимостей Spring, используя внедренный EntityManagerFactory или EntityManager."}
{"id": 659, "text": "Весна может понять Аннотации `@PersistenceUnit` и `@PersistenceContext` как в поле, так и в методе. уровень, если включен PersistenceAnnotationBeanPostProcessor.\nСледующий пример показана простая реализация JPA DAO, использующая аннотацию @PersistenceUnit:\nJava\n	public class ProductDaoImpl implements ProductDao {\n		private EntityManagerFactory emf;\n		@PersistenceUnit\n		public void setEntityManagerFactory(EntityManagerFactory emf) {\n			this.emf = emf;\n		public Collection loadProductsByCategory(String category) {\n			EntityManager em = this.emf.createEntityManager();\n			try {\n				Query query = em.createQuery(\"from Product as p where p.category = ?1\");\n				query.setParameter(1, category);\n				return query.getResultList();\n			finally {\n				if (em != null) {\n					em.close();\n	class ProductDaoImpl : ProductDao {\nФоновая загрузка.\nПредыдущий DAO не зависит от Spring и по-прежнему прекрасно вписывается в Spring. контекст приложения.\nБолее того, DAO использует аннотации, чтобы потребовать внедрение стандартного `EntityManagerFactory`, как показано в следующем примере определения bean-компонента:\n	<beans>\n		<!-- bean post-processor for JPA annotations -->\n		<bean class=\"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\"/>\n		<bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/>\n	</beans>\nФоновая загрузка."}
{"id": 660, "text": "В качестве альтернативы явному определению PersistenceAnnotationBeanPostProcessor: рассмотрите возможность использования XML-элемента Spring `context:annotation-config` в вашем приложении.\nКонфигурация контекста.\nПри этом автоматически регистрируются все стандарты Spring. постпроцессоры для настройки на основе аннотаций, включая `CommonAnnotationBeanPostProcessor` и так далее.\n	<beans>\n		<!-- post-processors for all standard config annotations -->\n		<context:annotation-config/>\n		<bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/>\n	</beans>\nРассмотрим следующий пример:.\nОсновная проблема такого DAO заключается в том, что он всегда создает новый EntityManager через завод.\nВы можете избежать этого, запросив транзакционный `EntityManager` (также называемый «shared EntityManager», потому что это общий потокобезопасный прокси-сервер для реальных транзакций.\nEntityManager), который будет внедрен вместо фабрики.\nВ следующем примере показано, как это сделать:\nJava\n	public class ProductDaoImpl implements ProductDao {\n		@PersistenceContext\n		private EntityManager em;\n		public Collection loadProductsByCategory(String category) {\n			Query query = em.createQuery(\"from Product as p where p.category = :category\");\n			query.setParameter(\"category\", category);\n			return query.getResultList();\n	class ProductDaoImpl : ProductDao {\nРассмотрим следующий пример:.\nАннотация `@PersistenceContext` имеет необязательный атрибут `type`, который по умолчанию в PersistenceContextType.TRANSACTION."}
{"id": 661, "text": "Вы можете использовать это значение по умолчанию для получения общего Прокси `EntityManager`.\nАльтернатива PersistenceContextType.EXTENDED — это полностью другое дело.\nВ результате получается так называемый расширенный `EntityManager`, который не является потокобезопасен и, следовательно, не должен использоваться в компоненте с одновременным доступом, таком как Одноэлементный компонент, управляемый Spring.\nРасширенные экземпляры EntityManager предназначены только для использования. в компонентах с состоянием, которые, например, находятся в сеансе, с жизненным циклом `EntityManager` не привязан к текущей транзакции, а полностью зависит от приложение.\nРассмотрим следующий пример:. .Внедрение на уровне метода и поля. **** Вы можете применять аннотации, обозначающие внедрение зависимостей (например, `@PersistenceUnit` и `@PersistenceContext`) для поля или методов внутри класса - отсюда и выражения «Внедрение на уровне метода» и «Внедрение на уровне поля».\nАннотации на уровне поля лаконичны и просты в использовании, а аннотации на уровне метода позволяют осуществлять дальнейшую обработку внедренная зависимость.\nВ обоих случаях видимость члена (общедоступная, защищенная или частная) не имеет значения.\nРассмотрим следующий пример:.\nА как насчет аннотаций уровня класса?\nРассмотрим следующий пример:.\nНа платформе Jakarta EE они используются для объявления зависимостей, а не для описания ресурсов. инъекция. ****\nРассмотрим следующий пример:.\nВнедренный `EntityManager` управляется Spring (с учетом текущей транзакции)."}
{"id": 662, "text": "Несмотря на то, что новая реализация DAO использует внедрение EntityManager на уровне метода вместо EntityManagerFactory никаких изменений в определении компонента не требуется. из-за использования аннотаций.\nРассмотрим следующий пример:.\nОсновное преимущество этого стиля DAO заключается в том, что он зависит только от Java Persistence API.\nИмпорт какого-либо класса Spring не требуется.\nБолее того, как понимаются аннотации JPA, инъекции применяются автоматически контейнером Spring.\nЭто привлекательно от перспектива неинвазивности и может показаться более естественной для разработчиков JPA.\nРассмотрим следующий пример:.\nРеализация DAO на основе @Autowired (обычно с внедрением на основе конструктора)\nРассмотрим следующий пример:. `@PersistenceUnit` и `@PersistenceContext` могут быть объявлены только для методов и полей.\nА как насчет предоставления ресурсов JPA через конструкторы и другие точки внедрения @Autowired?\nРассмотрим следующий пример:. `EntityManagerFactory` можно легко внедрить через конструкторы и поля/методы `@Autowired`. до тех пор, пока цель определена как компонент, например, через LocalContainerEntityManagerFactoryBean.\nТочка внедрения соответствует исходному определению EntityManagerFactory по типу как есть.\nРассмотрим следующий пример:.\nОднако общая ссылка на EntityManager в стиле @PersistenceContext недоступна для регулярное внедрение зависимостей «из коробки».\nЧтобы сделать его доступным для соответствия, как того требует `@Autowired`, рассмотрите возможность определения `SharedEntityManagerBean` как компаньон для вашего определения `EntityManagerFactory`:"}
{"id": 663, "text": "<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n	</bean>\n	<bean id=\"em\" class=\"org.springframework.orm.jpa.support.SharedEntityManagerBean\">\n		<property name=\"entityManagerFactory\" ref=\"emf\"/>\n	</bean>\n	@Bean(\"em\")\n	public static EntityManager sharedEntityManager(EntityManagerFactory emf) {\n		return SharedEntityManagerCreator.createSharedEntityManager(emf);\nАльтернативно вы можете определить метод @Bean на основе SharedEntityManagerCreator:.\nВ случае нескольких единиц персистентности каждое определение EntityManagerFactory должно быть сопровождается соответствующим определением bean-компонента EntityManager, в идеале с квалификаторами которые соответствуют отдельному определению EntityManagerFactory, чтобы различать единицы персистентности через `@Autowired @Qualifier(\"...\")`.\nSpring-управляемые JPA-транзакции.\nПРИМЕЧАНИЕ.\nМы настоятельно рекомендуем вам прочитать Декларативное управление транзакциями. если вы еще этого не сделали, чтобы получить более подробное описание поддержки декларативных транзакций Spring.\nSpring-управляемые JPA-транзакции.\nРекомендуемая стратегия для JPA — локальные транзакции через собственную транзакцию JPA. поддержка.\nSpring `JpaTransactionManager` предоставляет множество возможностей, известных из локальных Транзакции JDBC (такие как уровни изоляции для конкретных транзакций и уровни изоляции на уровне ресурсов). оптимизация только для чтения) для любого обычного пула соединений JDBC, не требуя координатор транзакций JTA и ресурсы с поддержкой XA."}
{"id": 664, "text": "Spring-управляемые JPA-транзакции.\nSpring JPA также позволяет настроенному JpaTransactionManager предоставлять транзакцию JPA. к коду доступа JDBC, который обращается к тому же источнику данных, при условии, что зарегистрированный `JpaDialect` поддерживает извлечение базового JDBC `Connection`.\nВесна обеспечивает диалекты для реализаций EclipseLink и Hibernate JPA.\nСм.\nSpring-управляемые JPA-транзакции.\nДля отложенного получения фактических подключений к ресурсам в стиле JTA Spring предоставляет соответствующий прокси-класс `DataSource` для целевого пула соединений: см. {spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].\nЭто особенно полезно для транзакций JPA, доступных только для чтения, которые часто могут обрабатываться из локального кэша, а не обращаться к базе данных.\nПонимание `JpaDialect` и `JpaVendorAdapter`.\nВ качестве расширенной функции JpaTransactionManager и его подклассы `AbstractEntityManagerFactoryBean` позволяет передавать пользовательский `JpaDialect` в Свойство компонента `jpaDialect`.\nРеализация `JpaDialect` может включать следующие расширенные возможности: функции, поддерживаемые Spring, обычно в зависимости от поставщика:\n* Применение определенной семантики транзакций (например, пользовательского уровня изоляции или\n* Получение транзакционного соединения JDBC (для доступа к DAO на основе JDBC).\n* Расширенный перевод PersistenceException в Spring DataAccessException.\nтайм-аут).\nЭто особенно ценно для специальной семантики транзакций и для продвинутых перевод исключения."}
{"id": 665, "text": "Реализация по умолчанию («DefaultJpaDialect») делает не предоставляют никаких особых возможностей, и, если перечисленные ранее функции необходимы, у вас есть указать соответствующий диалект.\nтайм-аут).\nСОВЕТ: В качестве еще более широкого средства адаптации поставщика, прежде всего для полнофункциональной среды Spring.\nНастройка LocalContainerEntityManagerFactoryBean, JpaVendorAdapter объединяет возможности `JpaDialect` с другими настройками по умолчанию, зависящими от поставщика.\nУказание HibernateJpaVendorAdapter или EclipseLinkJpaVendorAdapter — наиболее удобный вариант. способ автоматической настройки установки EntityManagerFactory для Hibernate или EclipseLink, соответственно.\nОбратите внимание, что эти адаптеры поставщиков в первую очередь предназначены для использования с Управление транзакциями на основе Spring (то есть для использования с JpaTransactionManager).\nтайм-аут).\nСм. {spring-framework-api}/orm/jpa/JpaDialect.html[`JpaDialect`] и {spring-framework-api}/orm/jpa/JpaVendorAdapter.html[`JpaVendorAdapter`] javadoc для более подробную информацию о его операциях и о том, как они используются в рамках поддержки Spring JPA.\nНастройка JPA с управлением транзакциями JTA.\nВ качестве альтернативы JpaTransactionManager Spring также позволяет использовать несколько ресурсов. координация транзакций через JTA либо в среде Jakarta EE, либо с помощью автономный координатор транзакций, например Atomikos.\nПомимо выбора Spring's `JtaTransactionManager` вместо `JpaTransactionManager`, вам нужно сделать еще несколько шаги:\n* Базовые пулы соединений JDBC должны поддерживать XA и быть интегрированы с"}
{"id": 666, "text": "Настройка JPA с управлением транзакциями JTA. ваш координатор транзакций.\nВ среде Jakarta EE это обычно просто. предоставление доступа к другому типу DataSource через JNDI.\nПосмотрите свой сервер приложений документация для получения подробной информации.\nАналогично, автономный координатор транзакций обычно поставляется со специальными вариантами DataSource, интегрированными с XA.\nЕще раз проверьте его документацию.\n* Настройка JPA `EntityManagerFactory` должна быть настроена для JTA. Это\nНастройка JPA с управлением транзакциями JTA. зависит от поставщика, обычно через специальные свойства, которые указываются как `jpaProperties` в `LocalContainerEntityManagerFactoryBean`.\nВ случае Hibernate эти свойства даже зависят от версии.\nПодробности смотрите в документации Hibernate.\n* HibernateJpaVendorAdapter Spring применяет определенные настройки по умолчанию, ориентированные на Spring, такие как\nНастройка JPA с управлением транзакциями JTA. в качестве режима освобождения соединения, `on-close`, который соответствует собственному умолчанию Hibernate в Hibernate 5.0, но не в Hibernate 5.1+.\nДля настройки JTA обязательно объявите тип транзакции вашей единицы персистентности — «JTA».\nАльтернативно установите Hibernate 5.2.\nСвойство `hibernate.connection.handling_mode` для `DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT` для восстановления настроек Hibernate по умолчанию.\nСоответствующие примечания см. в Предупреждения о ложных серверах приложений в Hibernate.\n* В качестве альтернативы рассмотрите возможность получения EntityManagerFactory из вашего приложения.\nНастройка JPA с управлением транзакциями JTA. сам сервер (то есть посредством поиска JNDI вместо локально объявленного `LocalContainerEntityManagerFactoryBean`)."}
{"id": 667, "text": "Предоставляемый сервером EntityManagerFactory. могут потребоваться специальные определения в конфигурации вашего сервера (что делает развертывание менее портативен), но настроен для среды JTA сервера.\nСобственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.\nСобственная настройка LocalSessionFactoryBean в сочетании с HibernateTransactionManager. позволяет взаимодействовать с @PersistenceContext и другим кодом доступа JPA.\nСпящий режим SessionFactory теперь изначально реализует интерфейс JPA EntityManagerFactory. а дескриптор сеанса Hibernate изначально является JPA `EntityManager`.\nСредства поддержки JPA Spring автоматически обнаруживают собственные сеансы Hibernate.\nСобственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.\nТаким образом, такая собственная настройка Hibernate может служить заменой стандартного JPA.\nКомбинация LocalContainerEntityManagerFactoryBean и JpaTransactionManager. во многих сценариях, позволяющих взаимодействовать с `SessionFactory.getCurrentSession()` (а также HibernateTemplate) рядом с @PersistenceContext EntityManager внутри та же локальная транзакция.\nТакая настройка также обеспечивает более сильную интеграцию Hibernate. и большую гибкость конфигурации, поскольку она не ограничена контрактами начальной загрузки JPA.\nСобственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.\nВ таком сценарии вам не нужна конфигурация HibernateJpaVendorAdapter. поскольку встроенная настройка Hibernate Spring предоставляет еще больше возможностей (например, пользовательская настройка Hibernate Integrator, интеграция контейнера компонентов Hibernate 5.3, и более сильная оптимизация для транзакций только для чтения)."}
{"id": 668, "text": "И последнее, но не менее важное: вы также можете выразить встроенную настройку Hibernate через LocalSessionFactoryBuilder, плавно интегрируется с конфигурацией стиля `@Bean` (без использования `FactoryBean`).\nСобственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA. [ПРИМЕЧАНИЕ] = LocalSessionFactoryBean и LocalSessionFactoryBuilder поддерживают фон. загрузка, так же, как это делает JPA `LocalContainerEntityManagerFactoryBean`.\nВведение см. в Фоновая загрузка.\nСобственная настройка Hibernate и собственные транзакции Hibernate для взаимодействия JPA.\nВ LocalSessionFactoryBean это доступно через bootstrapExecutor. собственность.\nВ программном файле LocalSessionFactoryBuilder перегруженный Метод buildSessionFactory принимает аргумент исполнителя начальной загрузки."}
{"id": 669, "text": "1. Введение. `kafka` модуль предоставляет высокоуровневую интеграцию Lilipup Framework с Apache Kafka: продюсеры, консьюмеры, ретраи, backoff, DLQ и наблюдаемость.\n- единый API публикации/чтения сообщений;\n- встроенные гарантии доставки и управление ошибками;\n- прозрачная интеграция с monitoring hooks.\n```xml\n```java\n    private final LilipupKafkaTemplate<String, InvoiceCreatedEvent> kafkaTemplate;\n    public BillingEventPublisher(LilipupKafkaTemplate<String, InvoiceCreatedEvent> kafkaTemplate) {\n        this.kafkaTemplate = kafkaTemplate;\n    public void publish(InvoiceCreatedEvent event) {\n        SendResult result = kafkaTemplate.send(\"billing.invoice.created\", event.invoiceId(), event);\n        // Обязательная проверка: подтверждение брокера.\n        if (!result.acknowledged()) {\n            throw new IllegalStateException(\"Kafka send is not acknowledged\");\n```java\n    @LilipupKafkaListener(\n        topic = \"billing.invoice.created\",\n        groupId = \"billing-read-model\",\n        concurrency = 4,\n        ackMode = AckMode.MANUAL\n    public void onMessage(InvoiceCreatedEvent event, KafkaAck ack) {\n        processEvent(event);\n        // Явно подтверждаем обработку только после успешной бизнес-операции.\n        ack.acknowledge();\n    private void processEvent(InvoiceCreatedEvent event) {\n        // Запись в read model.\n```yaml\n    bootstrap-servers: kafka-1:9092,kafka-2:9092"}
{"id": 670, "text": "client-id: billing-service\n    producer:\n      acks: all\n      retries: 5\n      linger-ms: 10\n      enable-idempotence: true\n      compression: zstd\n    consumer:\n      auto-offset-reset: earliest\n      max-poll-records: 500\n      session-timeout-ms: 45000\n      manual-ack: true\n    serialization:\n      key-serde: string\n      value-serde: json\n    retry:\n      attempts: 4\n      backoff-ms: 500\n      multiplier: 2.0\n    dlq:\n      enabled: true\n      topic-suffix: .dlq\n- Всегда проверяйте `SendResult.acknowledged()` после отправки.\n- Проверяйте, что ключ сообщения (`message key`) стабилен для корректного partition ordering.\n- Всегда настраивайте `acks=all` для критичных бизнес-событий.\n- Проверяйте сериализацию payload до отправки (особенно для nullable полей).\n- Не отправляйте сообщения без версии схемы (`eventVersion`) при эволюции контракта.\n```java\n    .attempts(4)\n    .initialBackoffMs(500)\n    .multiplier(2.0)\n    .maxBackoffMs(8000)\n    .retryOn(TimeoutException.class, RetriableBrokerException.class)\n    .build();\n- не используйте бесконечный retry;\n- отправляйте событие в DLQ после исчерпания попыток;\n- логируйте correlation-id на каждой попытке.\n- `KafkaSerializationException`: payload не сериализуется в выбранный формат.\n- `KafkaDeliveryTimeoutException`: брокер не подтвердил отправку вовремя."}
{"id": 671, "text": "- `KafkaListenerProcessingException`: ошибка обработки в listener.\n```java\n    private final DeadLetterPublisher deadLetterPublisher;\n    public FailedMessageHandler(DeadLetterPublisher deadLetterPublisher) {\n        this.deadLetterPublisher = deadLetterPublisher;\n    public void handle(String topic, String key, byte[] payload, Exception ex) {\n        deadLetterPublisher.publish(topic + \".dlq\", key, payload, ex.getMessage());\n- Включайте `lilipup.kafka.metrics.enabled=true` для метрик latency/throughput.\n- Используйте `trace-id` и `correlation-id` в headers.\n- Проверяйте lag по consumer-group перед релизом.\n- Делайте обработчики консьюмера идемпотентными.\n- Ограничивайте размер сообщения и избегайте передачи бинарных blob без необходимости.\n- Применяйте версионирование событий (`eventType`, `eventVersion`).\n- Разделяйте топики команд и доменных событий.\n- Периодически тестируйте сценарии «брокер недоступен» и «частичный outage»."}
{"id": 672, "text": "Справочник по языкам.\nВ этом разделе описывается, как работает язык выражений Spring."}
{"id": 673, "text": "1. Введение. `lifecycle` управляет фазами жизни компонентов: создание, инициализация, готовность к трафику, graceful shutdown и очистка ресурсов.\n- предсказуемый запуск сервиса;\n- корректное завершение без потери данных;\n- контроль готовности инфраструктурных зависимостей.\n```xml\n```java\n    @OnStart(order = 10)\n    public void initCaches() {\n        // Выполняется до открытия внешнего трафика.\n        System.out.println(\"Warming up cache...\");\n    @OnReady\n    public void signalReady() {\n        // Точка, когда компонент готов обслуживать запросы.\n        System.out.println(\"Component is ready\");\n    @OnStop(timeoutMs = 5000)\n    public void flushAndClose() {\n        // Корректно закрываем ресурсы.\n        System.out.println(\"Flushing and closing resources\");\n```yaml\n    startup-timeout-ms: 30000\n    shutdown-timeout-ms: 20000\n    readiness:\n      enabled: true\n      require-all-components: true\n    shutdown:\n      graceful: true\n      await-jobs: true\n- Всегда ставьте таймауты на `@OnStart` и `@OnStop`, чтобы избежать зависания процесса.\n- Проверяйте readiness внешних зависимостей (БД, Kafka, кэш) до `@OnReady`.\n- Не публикуйте трафик, пока не завершились критичные `@OnStart` хуки.\n- Всегда освобождайте сетевые/файловые ресурсы в `@OnStop`."}
{"id": 674, "text": "- Для background-задач проверяйте, что при shutdown они либо завершены, либо безопасно прерваны.\n- `LifecycleTimeoutException`: хук превысил таймаут.\n- `ReadinessCheckException`: не выполнена проверка готовности.\n- `ShutdownInterruptedException`: процесс завершения был прерван.\n```java\n    @Override\n    public ReadinessState check() {\n        boolean dbReachable = pingDb();\n        return dbReachable\n            ? ReadinessState.ready(\"db_ok\")\n            : ReadinessState.notReady(\"db_unreachable\");\n    private boolean pingDb() {\n        // Здесь реальная проверка соединения.\n        return true;\n- Разделяйте быстрые и тяжелые `@OnStart` действия по `order`.\n- Делайте shutdown идемпотентным: повторный вызов не должен ломать состояние.\n- Логируйте длительность каждого lifecycle-hook.\n- Используйте readiness-пробы как контракт между сервисом и orchestrator.\n- Тестируйте сценарий «kill во время старта» и «kill во время long-running job»."}
{"id": 675, "text": "Буквальные выражения.\nSpEL поддерживает следующие типы литеральных выражений.\nБуквальные выражения.\nСтрока Строки могут быть разделены одинарными кавычками (`'`) или двойными кавычками. («`»`).\nЧтобы включить одинарную кавычку в строковый литерал, заключенный в одинарные кавычки, используйте два соседних символа одинарных кавычек.\nАналогично, чтобы включать двойные кавычки в строковый литерал, заключенный в двойные кавычки знаки, используйте два соседних символа двойных кавычек.\nНомер Числа поддерживают использование отрицательного знака, экспоненциальной записи и десятичных точек.\n  * Целое число: `int` или `long`\n  * Шестнадцатеричный: `int` или `long`\n  * Настоящее: «плавающее» или «двойное».\nБуквальные выражения. ** По умолчанию действительные числа анализируются с помощью Double.parseDouble(). логическое значение «правда» или «ложь» Ноль `ноль`\nБуквальные выражения. [ПРИМЕЧАНИЕ] = Благодаря разработке и реализации языка выражений Spring, буквальные числа всегда хранятся внутри как положительные числа.\nБуквальные выражения.\nНапример, `-2` сохраняется внутри как положительное `2`, которое затем инвертируется, пока оценка выражения (путем вычисления значения `0 - 2`).\nБуквальные выражения.\nЭто означает, что невозможно представить отрицательное буквальное число, равное минимальное значение этого типа числа в Java."}
{"id": 676, "text": "Например, минимальное поддерживаемое значение для `int` в Java используется `Integer.MIN_VALUE`, который имеет значение `-2147483648`.\nОднако, если вы включите `-2147483648` в выражение SpEL, будет выдано исключение, информирующее вы понимаете, что значение `2147483648` не может быть проанализировано как `int` (поскольку оно превышает значение `Integer.MAX_VALUE`, которое равно `2147483647`).\nБуквальные выражения.\nЕсли вам нужно использовать минимальное значение для определенного типа числа в SpEL выражение, вы можете либо ссылаться на константу `MIN_VALUE` для соответствующей оболочки введите (например, «Integer.MIN_VALUE», «Long.MIN_VALUE» и т. д.) или вычислите минимальное значение. ценность.\nНапример, чтобы использовать минимальное целое значение:\n- `T(Integer).MIN_VALUE` -- требуется `StandardEvaluationContext`\n- `-2^31` -- может использоваться с любым типом `EvaluationContext`\nБуквальные выражения.\nВ следующем листинге показано простое использование литералов.\nКак правило, они не используются в такая изоляция, а, скорее, как часть более сложного выражения — например, использование литерала на одной стороне оператора логического сравнения или в качестве аргумента метод.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	// оценивается как «Hello World»"}
{"id": 677, "text": "String helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n	// оценивается как «Пицца Тони».\n	String pizzaParlor = (String) parser.parseExpression(\"'Tony''s Pizza'\").getValue();\n	double avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n	// оценивается как 2147483647\n	int maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n	boolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n	Object nullValue = parser.parseExpression(\"null\").getValue();"}
{"id": 678, "text": "Матричные переменные. {rfc-site}/rfc3986#section-3.3[RFC 3986] обсуждает пары имя-значение в сегменты пути.\nВ Spring WebFlux мы называем их «матричными переменными», основанными на https://www.w3.org/DesignIssues/MatrixURIs.html[\"`old post`\"] Тима Бернерса-Ли, но они также могут называться параметрами пути URI.\nМатричные переменные.\nПеременные матрицы могут появляться в любом сегменте пути, при этом каждая переменная отделяется точкой с запятой и несколько значений, разделенных запятыми, например `\"/cars;color=red,green;year=2012\"`.\nНесколько значения также могут быть указаны с помощью повторяющихся имен переменных, например, `\"color=red;color=green;color=blue\"`.\nМатричные переменные.\nВ отличие от Spring MVC, в WebFlux наличие или отсутствие матричных переменных в URL-адресе не учитывается. не влияет на сопоставления запросов.\nДругими словами, вам не обязательно использовать переменную URI. для маскировки содержимого переменной.\nТем не менее, если вы хотите получить доступ к матричным переменным из метод контроллера, вам необходимо добавить переменную URI в сегмент пути, где находится матрица ожидаются переменные.\nВ следующем примере показано, как это сделать:\nJava\n	// ПОЛУЧИТЬ /pets/42;q=11;r=22"}
{"id": 679, "text": "@GetMapping(\"/pets/{petId}\")\n	public void findPet(@PathVariable String petId, @MatrixVariable int q) {\n		// идентификатор питомца == 42\n		// q == 11\n	// ПОЛУЧИТЬ /pets/42;q=11;r=22\n		// идентификатор питомца == 42\n		// q == 11\nМатричные переменные.\nУчитывая, что все сегменты пути могут содержать матричные переменные, иногда вам может потребоваться устранить неоднозначность, в какой переменной пути должна находиться матричная переменная, как показано в следующем примере:\nJava\n	// ПОЛУЧИТЬ /owners/42;q=11/pets/21;q=22\n	@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n	public void findPet(\n			@MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1,\n			@MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) {\n		// q1 == 11\n		// q2 == 22\n		// q1 == 11\n		// q2 == 22\nМатричные переменные.\nВы можете определить матричную переменную как необязательную и указать значение по умолчанию. как показано в следующем примере:\nJava\n	// ПОЛУЧИТЬ /pets/42\n	@GetMapping(\"/pets/{petId}\")"}
{"id": 680, "text": "public void findPet(@MatrixVariable(required=false, defaultValue=\"1\") int q) {\n		// q == 1\n	// ПОЛУЧИТЬ /pets/42\n		// q == 1\nМатричные переменные.\nЧтобы получить все переменные матрицы, используйте MultiValueMap, как показано в следующем примере:\nJava\n	// ПОЛУЧИТЬ /owners/42;q=11;r=12/pets/21;q=22;s=23\n	@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n	public void findPet(\n			@MatrixVariable MultiValueMap<String, String> matrixVars,\n			@MatrixVariable(pathVar=\"petId\") MultiValueMap<String, String> petMatrixVars) {\n		// матрицаVars: [\"q\": [11,22], \"r\": 12, \"s\": 23]\n		// petMatrixVars: [\"q\": 22, \"s\": 23]\n	// ПОЛУЧИТЬ /owners/42;q=11;r=12/pets/21;q=22;s=23\n		// матрицаVars: [\"q\": [11,22], \"r\": 12, \"s\": 23]\n		// petMatrixVars: [\"q\": 22, \"s\": 23]"}
{"id": 681, "text": "Конвертеры сообщений.\nВы можете настроить экземпляры HttpMessageConverter, переопределив {spring-framework-api}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters(org.springframework.http.converter.HttpMessageConverters.Builder)[`configureMessageConverters()`].\nКонвертеры сообщений.\nВ следующем примере настраиваются пользовательские преобразователи Jackson JSON и XML с настроенными преобразователями вместо стандартных.\nСм. пример кода в исходном документе."}
{"id": 682, "text": "Методы.\nВы можете вызывать методы, используя типичный синтаксис программирования Java.\nВы также можете вызвать методы непосредственно для литералов, таких как строки или числа.\nМетоды.\nВ следующих примерах показано, как вызывать методы.\nJava\n	// строковый литерал, имеет значение «bc»\n	String bc = parser.parseExpression(\"'abc'.substring(1, 3)\").getValue(String.class);\n	// оценивается как правда\n	boolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n			societyContext, Boolean.class);"}
{"id": 683, "text": "Смешение типов аспектов.\nВполне возможно смешивать аспекты стиля @AspectJ, используя поддержку автоматического проксирования. определенные в схеме аспекты `<aop:aspect>`, `<aop:advisor>` объявленные советники и даже прокси и перехватчики других стилей в той же конфигурации.\nВсе это реализовано используя один и тот же базовый механизм поддержки, и могут без каких-либо затруднений сосуществовать."}
{"id": 684, "text": "`@ModelAttribute`.\nАннотация параметра метода `@ModelAttribute` связывает данные формы, параметры запроса, Переменные пути URI и заголовки запросов к объекту модели.\nНапример:\nJava\n	@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n	public String processSubmit(@ModelAttribute Pet pet) { } // <1>\n`@ModelAttribute`. <1> Привязка к экземпляру Pet.\n`@ModelAttribute`.\nДанные формы и параметры запроса имеют приоритет над переменными URI и заголовками, которые включаются только в том случае, если они не переопределяют параметры запроса с тем же именем.\nТире удалено из названий заголовков.\n* Доступен из модели, где он мог быть добавлен с помощью\n* Доступен из сеанса HTTP, если атрибут модели был указан в\nЭкземпляр `Pet` может быть:. ссылка на уровне класса:web/webflux/controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`].\n* Создается с помощью конструктора по умолчанию.\n* Создается с помощью «основного конструктора» с аргументами, соответствующими сервлету.\nЭкземпляр `Pet` может быть:. параметры запроса.\nИмена аргументов определяются с помощью параметра, сохраняемого во время выполнения. имена в байт-коде.\nЭкземпляр `Pet` может быть:."}
{"id": 685, "text": "По умолчанию и конструктор, и свойство Проектирование модельного объекта требует тщательного рассмотрения, и по соображениям безопасности это рекомендуется рекомендуется либо использовать объект, специально предназначенный для веб-привязки, либо применить только привязка конструктора.\nЕсли привязку свойств все еще необходимо использовать, тогда _allowedFields_ шаблоны должны быть установлены для ограничения того, какие свойства могут быть установлены.\nДля получения более подробной информации об этом и пример конфигурации см.\nЭкземпляр `Pet` может быть:.\nПри использовании привязки конструктора вы можете настроить имена параметров запроса с помощью Аннотация `@BindParam`.\nНапример:\nJava\n	class Account {\n		private final String firstName;\n		public Account(@BindParam(\"first-name\") String firstName) {\n			this.firstName = firstName;\nЭкземпляр `Pet` может быть:.\nПРИМЕЧАНИЕ. `@BindParam` также может быть помещен в поля, соответствующие конструктору. параметры.\nХотя `@BindParam` поддерживается \"из коробки\", вы также можете использовать другую аннотацию, установив DataBinder.NameResolver в DataBinder.\nЭкземпляр `Pet` может быть:.\nПривязка конструктора поддерживает аргументы List, Map и массива, преобразованные из одну строку, например список, разделенный запятыми, или на основе индексированных ключей, таких как `accounts[2].name` или `account[KEY].name`.\nЭкземпляр `Pet` может быть:."}
{"id": 686, "text": "WebFlux, в отличие от Spring MVC, поддерживает в модели реактивные типы, например Mono<Account>.\nВы можете объявить аргумент `@ModelAttribute` с оболочкой реактивного типа или без нее, и он будет решен в соответствии с фактическим значением.\nЭкземпляр `Pet` может быть:.\nЕсли привязка данных приводит к ошибкам, по умолчанию возникает исключение WebExchangeBindException. но вы также можете добавить аргумент BindingResult непосредственно рядом с @ModelAttribute. для обработки таких ошибок в методе контроллера.\nНапример:\nJava\n	@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n	public String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) { <1>\n		if (result.hasErrors()) {\n			return \"petForm\";\nЭкземпляр `Pet` может быть:. <1> Добавление BindingResult.\nЭкземпляр `Pet` может быть:.\nЧтобы использовать аргумент BindingResult, вы должны объявить аргумент @ModelAttribute перед это без оболочки реактивного типа.\nЕсли вы хотите использовать реактивность, вы можете обрабатывать ошибки прямо через него.\nНапример:\nJava\n	@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n	public Mono<String> processSubmit(@Valid @ModelAttribute(\"pet\") Mono<Pet> petMono) {\n		return petMono\n			.flatMap(pet -> {"}
{"id": 687, "text": ".onErrorResume(ex -> {\nЭкземпляр `Pet` может быть:.\nВы можете автоматически применить проверку после привязки данных, добавив аннотация `jakarta.validation.Valid` или аннотация Spring `@Validated` (см.\nJava\n	@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n	public String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) { // <1>\n		if (result.hasErrors()) {\n			return \"petForm\";\nЭкземпляр `Pet` может быть:. <1> Использование `@Valid` для аргумента атрибута модели.\nЭкземпляр `Pet` может быть:.\nЕсли проверка метода применяется, поскольку другие параметры имеют аннотации @Constraint, тогда вместо этого будет вызвано HandlerMethodValidationException.\nСм. раздел о метод контроллера Validation.\nЭкземпляр `Pet` может быть:.\nСОВЕТ: Использование @ModelAttribute не является обязательным.\nПо умолчанию любой аргумент, который не является простым тип значения, определенный {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty] _AND_, который не разрешается каким-либо другим преобразователем аргументов, рассматривается как неявный `@ModelAttribute`.\nЭкземпляр `Pet` может быть:."}
{"id": 688, "text": "ВНИМАНИЕ: При компиляции собственного образа с помощью GraalVM неявный `@ModelAttribute` описанная выше поддержка не позволяет правильно сделать предварительный вывод связанных данных. подсказки по обязательному отражению.\nКак следствие, рекомендуется явно аннотировать параметры метода с `@ModelAttribute` для использования в собственном образе GraalVM."}
{"id": 689, "text": "1. Введение. `monitoring` предоставляет единые хуки для метрик, структурированных логов и интеграции с Prometheus/Alerting.\n- наблюдаемость производительности и надежности;\n- быстрый root-cause анализ инцидентов;\n- единый стандарт telemetry для всех модулей.\n```xml\n```java\n    private final MetricsHook metrics;\n    public PaymentService(MetricsHook metrics) {\n        this.metrics = metrics;\n    public void processPayment(String paymentId) {\n        long startedAt = System.nanoTime();\n        try {\n            // Бизнес-операция.\n            metrics.counter(\"payments_processed_total\").increment();\n        } catch (Exception ex) {\n            metrics.counter(\"payments_failed_total\").increment();\n            throw ex;\n        } finally {\n            long durationMs = (System.nanoTime() - startedAt) / 1_000_000;\n            metrics.timer(\"payments_duration_ms\").record(durationMs);\n```java\n    private final LogHook log;\n    public OrderLogger(LogHook log) {\n        this.log = log;\n    public void logOrderEvent(String orderId, String status) {\n        log.info(\"order_event\", Map.of(\n            \"orderId\", orderId,\n            \"status\", status,\n            \"component\", \"order-service\"\n```yaml\n    metrics:\n      enabled: true\n      export:\n        prometheus:\n          enabled: true\n          endpoint: /internal/metrics\n    logging:\n      format: json"}
{"id": 690, "text": "include-trace-id: true\n      redact-fields:\n        - password\n        - accessToken\n        - cardNumber\n    tracing:\n      enabled: true\n      sampler: 0.2\n- Всегда проверяйте, что endpoint метрик защищен и недоступен публично.\n- Не логируйте чувствительные поля: токены, пароли, PAN/PII.\n- Проверяйте наличие `trace-id` в логах для распределенной трассировки.\n- Для каждой критичной операции добавляйте минимум одну success и одну failure метрику.\n- Убедитесь, что cardinality label-ов ограничена (не используйте userId как label).\n- `MetricRegistryOverflowException`: слишком много уникальных label-комбинаций.\n- `PrometheusExportException`: ошибка публикации метрик.\n- `LogSerializationException`: проблема сериализации structured-log payload.\n```java\n    private final MetricsHook metrics;\n    public SafeMetricPublisher(MetricsHook metrics) {\n        this.metrics = metrics;\n    public void publishRequestMetric(String endpoint, int statusCode) {\n        String normalizedEndpoint = endpoint.replaceAll(\"/[0-9]+\", \"/{id}\");\n        metrics.counter(\"http_requests_total\")\n            .tag(\"endpoint\", normalizedEndpoint)\n            .tag(\"status\", String.valueOf(statusCode))\n            .increment();\n- Стройте SLI/SLO на основе latency, error-rate и saturation."}
{"id": 691, "text": "- Используйте единый naming convention для метрик (`<domain>_<metric>_<unit>`).\n- Сохраняйте баланс между детализацией логов и стоимостью хранения.\n- Делайте алерты action-oriented, чтобы было понятно, что делать on-call инженеру.\n- Регулярно проводите game-day с проверкой мониторинга и alert-routing."}
{"id": 692, "text": "Преимущества модели поддержки транзакций Spring Framework.\nТрадиционно у разработчиков приложений EE было два варианта управления транзакциями: глобальные или локальные транзакции, обе из которых имеют глубокие ограничения.\nГлобальный и управление локальными транзакциями рассматривается в следующих двух разделах, за которыми следует обсуждение того, как поддержка управления транзакциями Spring Framework решает ограничения глобальных и локальных моделей транзакций.\nГлобальные транзакции позволяют работать с несколькими транзакционными ресурсами, обычно реляционные базы данных и очереди сообщений.\nСервер приложений управляет глобальным транзакции через JTA, который представляет собой громоздкий API (частично из-за его модель исключения).\nКроме того, JTA `UserTransaction` обычно должен быть получен из JNDI, что означает, что вам также необходимо использовать JNDI, чтобы использовать JTA.\nИспользование глобальных транзакций ограничивает любое потенциальное повторное использование кода приложения, поскольку JTA обычно доступен только в среде сервера приложений.\nГлобальные транзакции.\nРаньше предпочтительным способом использования глобальных транзакций было использование EJB CMT. (Транзакция, управляемая контейнером).\nCMT — это форма декларативной транзакции. управление (в отличие от программного управления транзакциями).\nЭЖБ СМТ устраняет необходимость поиска JNDI, связанного с транзакциями, хотя использование EJB сам по себе требует использования JNDI.\nЭто устраняет большую часть, но не всю необходимость писать Java-код для управления транзакциями.\nСущественным недостатком является то, что CMT привязан к JTA. и среда сервера приложений."}
{"id": 693, "text": "Кроме того, это доступно только в том случае, если вы решите реализовать бизнес-логику в EJB (или, по крайней мере, за транзакционным фасадом EJB).\nНедостатки EJB в целом настолько велики, что это непривлекательное предложение, особенно перед лицом убедительных альтернатив декларативному управлению транзакциями.\nЛокальные транзакции зависят от ресурса, например транзакция, связанная с JDBC. соединение.\nЛокальные транзакции могут быть проще в использовании, но имеют существенный недостаток: Они не могут работать с несколькими транзакционными ресурсами.\nНапример, код, который управляет транзакции с использованием соединения JDBC не могут выполняться в рамках глобальной транзакции JTA.\nПотому что сервер приложений не участвует в управлении транзакциями, он не может гарантировать корректность на нескольких ресурсах. (Следует отметить, что большинство приложений используют единый ресурс транзакции.) Еще одним недостатком является то, что локальные транзакции являются инвазивными. к модели программирования.\nСогласованная модель программирования Spring Framework.\nSpring устраняет недостатки глобальных и локальных транзакций.\nЭто позволяет разработчики приложений используют единую модель программирования в любой среде.\nВы пишете свой код один раз, и он может получить выгоду от другого управления транзакциями. стратегии в различных средах.\nSpring Framework предоставляет как декларативные, так и программное управление транзакциями.\nБольшинство пользователей предпочитают декларативные транзакции управление, которое мы рекомендуем в большинстве случаев.\nСогласованная модель программирования Spring Framework.\nБлагодаря программному управлению транзакциями разработчики работают с Spring Framework. абстракция транзакции, которая может работать над любой базовой инфраструктурой транзакций."}
{"id": 694, "text": "При использовании предпочтительной декларативной модели разработчики обычно пишут мало кода или вообще его не пишут. связаны с управлением транзакциями и, следовательно, не зависят от Spring Framework API транзакций или любой другой API транзакций.\nСогласованная модель программирования Spring Framework. .Нужен ли вам сервер приложений для управления транзакциями? **** Поддержка управления транзакциями Spring Framework меняет традиционные правила относительно когда корпоративному Java-приложению требуется сервер приложений.\nСогласованная модель программирования Spring Framework.\nВ частности, вам не нужен сервер приложений исключительно для декларативных транзакций. через EJB.\nФактически, даже если ваш сервер приложений обладает мощными возможностями JTA, вы можете решить, что декларативные транзакции Spring Framework предлагают больше возможностей и более продуктивная модель программирования, чем EJB CMT.\nСогласованная модель программирования Spring Framework.\nОбычно возможности JTA сервера приложений требуются только в том случае, если вашему приложению требуется обрабатывать транзакции между несколькими ресурсами, что не является обязательным для многих приложения.\nМногие высокопроизводительные приложения используют одну хорошо масштабируемую базу данных (например, вместо этого Oracle RAC).\nАвтономные менеджеры транзакций (например, https://www.atomikos.com/[Atomikos Transactions]) есть другие варианты.\nКонечно, вам могут понадобиться и другие возможности сервера приложений, например Служба сообщений Java (JMS) и архитектура соединителя Jakarta EE (JCA).\nСогласованная модель программирования Spring Framework.\nSpring Framework дает вам выбор, когда масштабировать приложение до полной загруженный сервер приложений."}
{"id": 695, "text": "Прошли те времена, когда единственной альтернативой использованию EJB CMT или JTA должны были писать код с локальными транзакциями (например, в соединениях JDBC). и вам придется серьезно переработать, если вам нужно, чтобы этот код выполнялся в глобальных, управляемых контейнером транзакции.\nПри использовании Spring Framework только некоторые определения компонентов в вашем необходимо изменить файл конфигурации (а не ваш код). ****"}
{"id": 696, "text": "Многочастный контент.\nКак объяснено в Multipart Data, `ServerWebExchange` обеспечивает доступ к составным данным. содержание.\nЛучший способ обработки формы загрузки файла (например, из браузера) в контроллере осуществляется посредством привязки данных к файлу командный объект, как показано в следующем примере:\nJava\n	class MyForm {\n		private String name;\n		private FilePart file;\n	@Controller\n	public class FileUploadController {\n		@PostMapping(\"/form\")\n		public String handleFormUpload(MyForm form, BindingResult errors) {\n	@Controller\n	class FileUploadController {\nМногочастный контент.\nВы также можете отправлять составные запросы от клиентов, не являющихся браузерами, в службе RESTful. сценарий.\nВ следующем примере файл используется вместе с JSON:\nPOST /someUrl Content-Type: multipart/mixed. --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name=\"meta-data\" Content-Type: application/json; charset=UTF-8 Content-Transfer-Encoding: 8bit\n	\"name\": \"value\"\nPOST /someUrl Content-Type: multipart/mixed. } --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\" Content-Type: text/xml Content-Transfer-Encoding: 8bit...\nДанные файла...\nPOST /someUrl Content-Type: multipart/mixed."}
{"id": 697, "text": "Вы можете получить доступ к отдельным частям с помощью `@RequestPart`, как показано в следующем примере:\nJava\n	@PostMapping(\"/\")\n	public String handle(@RequestPart(\"meta-data\") Part metadata, // <1>\n			@RequestPart(\"file-data\") FilePart file) { // <2>\nPOST /someUrl Content-Type: multipart/mixed. <1> Использование `@RequestPart` для получения метаданных. <2> Использование `@RequestPart` для получения файла.\nPOST /someUrl Content-Type: multipart/mixed.\nЧтобы десериализовать необработанное содержимое части (например, в JSON — аналогично `@RequestBody`), вы можете объявить конкретную цель «Объект» вместо «Часть», как показано в следующем примере:\nJava\n	@PostMapping(\"/\")\n	public String handle(@RequestPart(\"meta-data\") MetaData metadata) { // <1>\nPOST /someUrl Content-Type: multipart/mixed. <1> Использование `@RequestPart` для получения метаданных.\nPOST /someUrl Content-Type: multipart/mixed.\nВы можете использовать @RequestPart в сочетании с jakarta.validation.Valid или Spring.\nАннотация `@Validated`, которая вызывает применение стандартной проверки компонента.\nВалидация ошибки приводят к возникновению исключения WebExchangeBindException, которое приводит к ответу 400 (BAD_REQUEST)."}
{"id": 698, "text": "Исключение содержит BindingResult с подробностями об ошибке и также может быть обработано. в методе контроллера, объявив аргумент с асинхронной оболочкой, а затем используя Операторы, связанные с ошибками:\nJava\n	@PostMapping(\"/\")\n	public String handle(@Valid @RequestPart(\"meta-data\") Mono<MetaData> metadata) {\n		// используйте один из операторов onError*...\nPOST /someUrl Content-Type: multipart/mixed.\nЕсли проверка метода применяется, поскольку другие параметры имеют аннотации @Constraint, тогда вместо этого возникает HandlerMethodValidationException.\nСм. раздел о\nPOST /someUrl Content-Type: multipart/mixed.\nЧтобы получить доступ ко всем составным данным как к MultiValueMap, вы можете использовать @RequestBody, как показано в следующем примере:\nJava\n	@PostMapping(\"/\")\n	public String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { // <1>\nPOST /someUrl Content-Type: multipart/mixed. <1> Использование `@RequestBody`.\n- Поля формы будут создавать *один* `FormPartEvent`, содержащий значение поля.\n- Загрузка файлов будет создавать *один или несколько* объектов FilePartEvent, содержащих используемое имя файла.\n`PartEvent`. при загрузке.\nЕсли файл достаточно велик, чтобы его можно было разделить на несколько буферов, первый За FilePartEvent последуют последующие события.\n`PartEvent`."}
{"id": 699, "text": "Например: См. пример кода в исходном документе.\n`PartEvent`.\nПолученные события детали также можно передать в другую службу с помощью WebClient.\nСм. ссылку:web/webflux-webclient/client-body.adoc#webflux-client-body-multipart [Multipart Data]."}
{"id": 700, "text": "Асинхронные запросы.\nSpring MVC имеет обширную интеграцию с асинхронным запросом сервлета.\n* `DeferredResult`,\nАсинхронные запросы. в методах контроллера обеспечивается поддержка одного асинхронного возвращаемого значения.\n* Контроллеры могут использовать несколько значений, включая\n* Контроллеры могут использовать реактивные клиенты и возвращать\nАсинхронные запросы.\nОбзор того, чем это отличается от Spring WebFlux, см. в разделе ниже.\n`Отложенный результат`.\nКак только функция асинхронной обработки запросов станет доступной. в контейнере сервлетов методы контроллера могут обертывать любой поддерживаемый метод контроллера. возвращаемое значение с помощью `DeferredResult`, как показано в следующем примере:\nJava\n	@GetMapping(\"/quotes\")\n	@ResponseBody\n	public DeferredResult<String> quotes() {\n		DeferredResult<String> deferredResult = new DeferredResult<>();\n		// Сохраните где-нибудь отложенный результат.\n		return deferredResult;\n	// Из какой-то другой темы...\n	deferredResult.setResult(result);\n	// Из какой-то другой темы...\n	deferredResult.setResult(result)\n`Отложенный результат`.\nКонтроллер может выдавать возвращаемое значение асинхронно из другого потока — для например, в ответ на внешнее событие (сообщение JMS), запланированное задание или другое событие.\n`Вызывной`.\nКонтроллер может обернуть любое поддерживаемое возвращаемое значение в `java.util.concurrent.Callable`, как показано в следующем примере:\nJava\n	@PostMapping"}
{"id": 701, "text": "public Callable<String> processUpload(final MultipartFile file) {\n		return () -> \"someView\";\n`WebAsyncTask` можно сравнить с использованием Callable но позволяет настраивать дополнительные параметры, такие как значение тайм-аута запроса и `AsyncTaskExecutor` для выполнения `java.util.concurrent.Callable` вместо этого из значений по умолчанию, установленных глобально для Spring MVC.\nНиже приведен пример использования WebAsyncTask:\nJava\n	@GetMapping(\"/callable\")\n	WebAsyncTask<String> handle() {\n		return new WebAsyncTask<String>(20000L,()->{\n			Thread.sleep(10000); //simulate long-running task\n			return \"asynchronous request completed\";\n* ServletRequest можно перевести в асинхронный режим, вызвав request.startAsync().\nВот очень краткий обзор асинхронной обработки запросов сервлета:.\nОсновной эффект от этого заключается в том, что сервлет (как и любые фильтры) может выйти, но ответ остается открытым, чтобы обработка могла завершиться позже.\n* Вызов `request.startAsync()` возвращает `AsyncContext`, который вы можете использовать для\nВот очень краткий обзор асинхронной обработки запросов сервлета:. дальнейший контроль над асинхронной обработкой.\nНапример, он предоставляет метод `dispatch`, который аналогичен пересылке из API сервлетов, за исключением того, что он позволяет обработка запроса на возобновление приложения в потоке контейнера сервлетов."}
{"id": 702, "text": "* ServletRequest предоставляет доступ к текущему DispatcherType, который вы можете\nВот очень краткий обзор асинхронной обработки запросов сервлета:. используйте, чтобы различать обработку первоначального запроса, асинхронную диспетчеризация, пересылка и другие типы диспетчеров.\n* Контроллер возвращает DeferredResult и сохраняет его в памяти.\nОбработка `DeferredResult` работает следующим образом:. очередь или список, где к нему можно получить доступ.\n* Spring MVC вызывает `request.startAsync()`.\n* При этом `DispatcherServlet` и все настроенные фильтры завершают запрос.\nОбработка `DeferredResult` работает следующим образом:. поток обработки, но ответ остается открытым.\n* Приложение устанавливает DeferredResult из какого-то потока, а Spring MVC\nОбработка `DeferredResult` работает следующим образом:. отправляет запрос обратно в контейнер сервлетов.\n* DispatcherServlet вызывается снова, и обработка возобновляется с\nОбработка `DeferredResult` работает следующим образом:. асинхронно созданное возвращаемое значение.\n* Контроллер возвращает Callable.\n* Spring MVC вызывает `request.startAsync()` и отправляет `Callable` в\nОбработка `Callable` работает следующим образом:. `AsyncTaskExecutor` для обработки в отдельном потоке.\n* Тем временем, DispatcherServlet и все фильтры выходят из потока контейнера сервлетов,\nОбработка `Callable` работает следующим образом:. но ответ остается открытым.\n* В конце концов Callable выдает результат, и Spring MVC отправляет запрос обратно."}
{"id": 703, "text": "Обработка `Callable` работает следующим образом:. в контейнер сервлетов для завершения обработки.\n* DispatcherServlet вызывается снова, и обработка возобновляется с\nОбработка `Callable` работает следующим образом:. асинхронно созданное возвращаемое значение из Callable.\nОбработка `Callable` работает следующим образом:.\nДля получения дополнительной информации и контекста вы также можете прочитать {spring-site-blog}/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[the сообщения в блоге], которые представили поддержку асинхронной обработки запросов в Spring MVC 3.2.\nОбработка исключений.\nКогда вы используете DeferredResult, вы можете выбрать, вызывать ли setResult или `setErrorResult` с исключением.\nВ обоих случаях Spring MVC отправляет запрос обратно. в контейнер сервлетов для завершения обработки.\nТогда это рассматривается либо так, как если бы Метод контроллера вернул заданное значение или как если бы он вызвал данное исключение.\nЗатем исключение проходит через обычный механизм обработки исключений (например, вызов методы `@ExceptionHandler`).\nОбработка исключений.\nКогда вы используете `Callable`, происходит аналогичная логика обработки, основное отличие состоит в том, что результат возвращается из Callable или им создается исключение.\nПерехват.\nЭкземпляры HandlerInterceptor могут иметь тип AsyncHandlerInterceptor, чтобы получать Обратный вызов afterConcurrentHandlingStarted для первоначального запроса, который запускается асинхронно. обработка (вместо postHandle и afterCompletion).\nПерехват."}
{"id": 704, "text": "Реализации HandlerInterceptor также могут зарегистрировать CallableProcessingInterceptor. или DeferredResultProcessingInterceptor для более глубокой интеграции с жизненный цикл асинхронного запроса (например, для обработки события тайм-аута).\nСм. {spring-framework-api}/web/servlet/AsyncHandlerInterceptor.html[`AsyncHandlerInterceptor`] для более подробной информации.\nПерехват.\nDeferredResult предоставляет обратные вызовы onTimeout(Runnable) и onCompletion(Runnable).\nСм. {spring-framework-api}/web/context/request/async/DeferredResult.html[javadoc of `DeferredResult`] для более подробной информации. `Callable` можно заменить на `WebAsyncTask`, который предоставляет дополнительные методы для таймаута и обратных вызовов завершения.\nAsync Spring MVC по сравнению с WebFlux.\nAPI сервлетов изначально был создан для выполнения одного прохода через Filter-Servlet. цепь.\nАсинхронная обработка запросов позволяет приложениям выйти из цепочки Фильтр-сервлет. но оставьте ответ открытым для дальнейшей обработки.\nАсинхронная поддержка Spring MVC построен вокруг этого механизма.\nКогда контроллер возвращает DeferredResult, Цепочка фильтр-сервлет завершается, и поток контейнера сервлетов освобождается.\nПозже, когда установлен `DeferredResult`, выполняется `ASYNC` отправка (на тот же URL-адрес), во время которой контроллер снова отображается, но вместо его вызова используется значение DeferredResult. (как если бы контроллер вернул его), чтобы возобновить обработку.\nAsync Spring MVC по сравнению с WebFlux."}
{"id": 705, "text": "Напротив, Spring WebFlux не построен на API сервлетов и не нуждается в таком интерфейсе. функция асинхронной обработки запросов, поскольку она асинхронна по своей конструкции.\nАсинхронный обработка встроена во все фреймворковые контракты и поддерживается всеми этапы обработки запроса.\nAsync Spring MVC по сравнению с WebFlux.\nС точки зрения модели программирования, Spring MVC и Spring WebFlux поддерживают асинхронный и в качестве возвращаемых значений в методах контроллера.\nSpring MVC даже поддерживает потоковую передачу, включая реактивное обратное давление.\nОднако отдельные записи в ответ остаются блокирующими (и выполняются в отдельном потоке), в отличие от WebFlux, который опирается на неблокирующий ввод-вывод и не требует дополнительного потока для каждой записи.\nAsync Spring MVC по сравнению с WebFlux.\nЕще одно фундаментальное отличие состоит в том, что Spring MVC не поддерживает асинхронный или реактивный режим. типы аргументов метода контроллера (например, `@RequestBody`, `@RequestPart` и другие), и при этом он не имеет явной поддержки асинхронных и реактивных типов в качестве атрибутов модели.\nSpring WebFlux все это поддерживает.\nAsync Spring MVC по сравнению с WebFlux.\nНаконец, с точки зрения конфигурации должна быть реализована функция асинхронной обработки запросов.\nHTTP-потоковая передача.\nВы можете использовать DeferredResult и Callable для одного асинхронного возвращаемого значения.\nЧто делать, если вы хотите создать несколько асинхронных значений и записать их в ответ?\nВ этом разделе описывается, как это сделать.\nОбъекты."}
{"id": 706, "text": "Вы можете использовать возвращаемое значение ResponseBodyEmitter для создания потока объектов, где каждый объект сериализуется с помощью ответ, как показано в следующем примере:\nJava\n	@GetMapping(\"/events\")\n	public ResponseBodyEmitter handle() {\n		ResponseBodyEmitter emitter = new ResponseBodyEmitter();\n		// Сохраните эмиттер куда-нибудь.\n		return emitter;\n	// В какой-то другой теме\n	emitter.send(\"Hello once\");\n	// и еще раз позже\n	emitter.send(\"Hello again\");\n	// и сделано в какой-то момент\n	emitter.complete();\n	// В какой-то другой теме\n	emitter.send(\"Hello once\")\n	// и еще раз позже\n	emitter.send(\"Hello again\")\n	// и сделано в какой-то момент\n	emitter.complete()\nОбъекты.\nВы также можете использовать ResponseBodyEmitter в качестве тела ResponseEntity, что позволит вам настроить статус и заголовки ответа.\nОбъекты.\nКогда «эмиттер» выдает «IOException» (например, если удаленный клиент ушел), приложения не несут ответственности за очистку соединения и не должны вызывать `emitter.complete` или `emitter.completeWithError`.\nВместо этого контейнер сервлетов автоматически инициирует Уведомление об ошибке AsyncListener, в котором Spring MVC выполняет вызов CompleteWithError."}
{"id": 707, "text": "Этот вызов, в свою очередь, выполняет заключительную отправку ASYNC приложению, во время которой Spring MVC вызывает настроенные преобразователи исключений и завершает запрос.\nОбъекты.\nSseEmitter (подкласс ResponseBodyEmitter) обеспечивает поддержку https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events], где события, отправленные с сервера. форматируются в соответствии со спецификацией W3C SSE.\nДля создания SSE поток от контроллера, верните SseEmitter, как показано в следующем примере:\nJava\n	@GetMapping(path=\"/events\", produces=MediaType.TEXT_EVENT_STREAM_VALUE)\n	public SseEmitter handle() {\n		SseEmitter emitter = new SseEmitter();\n		// Сохраните эмиттер куда-нибудь.\n		return emitter;\n	// В какой-то другой теме\n	emitter.send(\"Hello once\");\n	// и еще раз позже\n	emitter.send(\"Hello again\");\n	// и сделано в какой-то момент\n	emitter.complete();\n	// В какой-то другой теме\n	emitter.send(\"Hello once\")\n	// и еще раз позже\n	emitter.send(\"Hello again\")\n	// и сделано в какой-то момент\n	emitter.complete()\nОбъекты.\nХотя SSE является основным вариантом потоковой передачи в браузеры, обратите внимание, что Internet Explorer не поддерживает события, отправленные сервером."}
{"id": 708, "text": "Рассмотрите возможность использования Spring широкий выбор браузеров.\nОбъекты.\nСм. также ссылку:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-objects[предыдущий раздел] для получения примечаний по обработке исключений.\nНеобработанные данные.\nИногда полезно обойти преобразование сообщения и передать его непосредственно в ответ. `OutputStream` (например, для загрузки файла).\nВы можете использовать `StreamingResponseBody` для этого введите тип возвращаемого значения, как показано в следующем примере:\nJava\n	@GetMapping(\"/download\")\n	public StreamingResponseBody handle() {\n		return new StreamingResponseBody() {\n			@Override\n			public void writeTo(OutputStream outputStream) throws IOException {\n				// писать...\nНеобработанные данные.\nВы можете использовать StreamingResponseBody в качестве тела в ResponseEntity для настроить статус и заголовки ответа.\nРеактивные типы.\nSpring MVC поддерживает использование реактивных клиентских библиотек в контроллере (также читайте Сюда входит «WebClient» из «spring-webflux» и другие, такие как Spring Data. реактивные хранилища данных.\nВ таких случаях удобно иметь возможность вернуть реактивные типы из метода контроллера.\n* Промис с одним значением адаптирован, аналогично использованию DeferredResult. Примеры\nРеактивные возвращаемые значения обрабатываются следующим образом:. включают CompletionStage (JDK), Mono (Reactor) и Single (RxJava).\n* Многозначный поток с типом потокового мультимедиа (например, `application/x-ndjson`"}
{"id": 709, "text": "Реактивные возвращаемые значения обрабатываются следующим образом:. или `text/event-stream`), аналогично использованию `ResponseBodyEmitter` или `SseEmitter`.\nПримеры включают Flux (Reactor) или Observable (RxJava).\nПриложения также могут возвращать Flux<ServerSentEvent> или Observable<ServerSentEvent>.\n* Адаптирован многозначный поток с любым другим типом мультимедиа (например, application/json).\nРеактивные возвращаемые значения обрабатываются следующим образом:. to, аналогично использованию `DeferredResult<List<?>>`.\nРеактивные возвращаемые значения обрабатываются следующим образом:.\nСОВЕТ: Spring MVC поддерживает Reactor и RxJava через {spring-framework-api}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`] из `spring-core`, который позволяет ему адаптироваться из нескольких реактивных библиотек.\nРеактивные возвращаемые значения обрабатываются следующим образом:.\nДля потоковой передачи в ответ поддерживается реактивное обратное давление, но запись в ответ все еще блокируется и запускается в отдельном потоке через `AsyncTaskExecutor`, чтобы избежать блокировки восходящего источника, такого как возвращаемый `Flux`. из `Вебклиента`.\nРаспространение контекста.\nОбычно контекст передается через `java.lang.ThreadLocal`.\nЭто работает прозрачно для обработки в одном потоке, но требует дополнительной работы для асинхронной обработки в нескольких потоках."}
{"id": 710, "text": "Микрометр https://github.com/micrometer-metrics/context-propagation#context-propagation-library [Распространение контекста] библиотека упрощает распространение контекста между потоками и механизмами контекста, такими как как значения ThreadLocal, Реактор {реактор-сайт}/docs/core/release/reference/#context[context], GraphQL Java https://www.graphql-java.com/documentation/concerns/#context-objects[контекст], и другие.\nРаспространение контекста.\nЕсли распространение контекста микрометра присутствует в пути к классам, когда метод контроллера возвращает [реактивный тип], например Flux или Mono, все Значения `ThreadLocal`, для которых есть зарегистрированный `io.micrometer.ThreadLocalAccessor`, записываются в Reactor `Context` как пары ключ-значение с использованием ключа, назначенного `ThreadLocalAccessor`.\nРаспространение контекста.\nДля других сценариев асинхронной обработки вы можете использовать библиотеку распространения контекста. напрямую.\nНапример:\n	// Захват оценок ThreadLocal из основного потока...\n	ContextSnapshot snapshot = ContextSnapshot.captureAll();\n	// В другом потоке: восстанавливаем значения ThreadLocal\n	try (ContextSnapshot.Scope scope = snapshot.setThreadLocals()) {\n* `LocaleContextThreadLocalAccessor` — распространяет `LocaleContext` через `LocaleContextHolder`\n* `RequestAttributesThreadLocalAccessor` — передает `RequestAttributes` через `RequestContextHolder`\nСледующие реализации ThreadLocalAccessor предоставляются «из коробки»:.\nВышеуказанное не регистрируется автоматически."}
{"id": 711, "text": "Вам необходимо зарегистрировать их через `ContextRegistry.getInstance()` при запуске.\nСледующие реализации ThreadLocalAccessor предоставляются «из коробки»:.\nБолее подробную информацию можно найти в {micrometer-context-propagation-docs}/[документации] Библиотека распространения контекста Micrometer.\nОтключает.\nAPI сервлетов не отправляет никаких уведомлений при выходе удаленного клиента.\nПоэтому при потоковой передаче ответа, будь то через SseEmitter или реактивные типы, важно периодически отправлять данные, поскольку запись не удалась, если клиент отключился.\nОтправка может принимать форму пустое (только для комментариев) событие SSE или любые другие данные, которые другая сторона должна будет интерпретировать как сердцебиение и игнорировать.\nОтключает.\nВ качестве альтернативы рассмотрите возможность использования решений для обмена веб-сообщениями (например, которые имеют встроенный механизм сердцебиения.\nКонфигурация.\nФункция асинхронной обработки запросов должна быть включена на уровне контейнера сервлетов.\nКонфигурация MVC также предоставляет несколько вариантов асинхронных запросов.\nКонтейнер сервлетов.\nОбъявления фильтров и сервлетов имеют флаг asyncSupported, для которого необходимо установить значение true. чтобы включить асинхронную обработку запросов.\nКроме того, сопоставления фильтров должны быть объявлен для обработки ASYNC `jakarta.servlet.DispatchType`.\nКонтейнер сервлетов.\nВ конфигурации Java, когда вы используете «AbstractAnnotationConfigDispatcherServletInitializer» для инициализации контейнера сервлетов это делается автоматически.\nКонтейнер сервлетов."}
{"id": 712, "text": "В конфигурации `web.xml` вы можете добавить `<async-supported>true</async-supported>` к `DispatcherServlet` и `Filter` для объявлений и добавить `<dispatcher>ASYNC</dispatcher>` для фильтрации сопоставлений.\n* Конфигурация Java: используйте обратный вызов configureAsyncSupport в WebMvcConfigurer.\n* Пространство имен XML: используйте элемент `<async-support>` в `<mvc:annotation-driven>`.\n* Значение таймаута по умолчанию для асинхронных запросов зависит\nВы можете настроить следующее:. в базовом контейнере сервлетов, если это не задано явно.\n* `AsyncTaskExecutor` для блокировки записи при потоковой передаче с помощью\nВы можете настроить следующее:. выполнение экземпляров Callable, возвращаемых методами контроллера.\nТот, который используется по умолчанию, не подходит для производства под нагрузкой.\n* Реализации `DeferredResultProcessingInterceptor` и `CallableProcessingInterceptor`.\nВы можете настроить следующее:.\nОбратите внимание, что вы также можете установить значение таймаута по умолчанию для DeferredResult, ResponseBodyEmitter и SseEmitter.\nДля Callable вы можете использовать `WebAsyncTask`, чтобы указать значение тайм-аута."}
{"id": 713, "text": "Реакции на ошибки.\nОбщим требованием к службам REST является включение подробностей в текст ошибки. ответы.\nSpring Framework поддерживает «Подробности проблем для HTTP API». спецификация, {rfc-сайт}/rfc9457[RFC 9457].\n- `ProblemDetail` — представление подробностей проблемы RFC 9457; простой контейнер\nНиже приведены основные абстракции для этой поддержки:. как для стандартных полей, определенных в спецификации, так и для нестандартных.\n- `ErrorResponse` — контракт для предоставления подробностей ответа об ошибке HTTP, включая HTTP.\nНиже приведены основные абстракции для этой поддержки:. статус, заголовки ответа и тело в формате RFC 9457; это позволяет исключениям инкапсулировать и раскрывать подробности того, как они сопоставляются с ответом HTTP.\nВсе весенние MVC исключения реализуют это.\n- `ErrorResponseException` -- базовая реализация `ErrorResponse`, которую другие\nНиже приведены основные абстракции для этой поддержки:. можно использовать как удобный базовый класс.\n- `ResponseEntityExceptionHandler` -- удобный базовый класс для\nНиже приведены основные абстракции для этой поддержки:. и любое `ErrorResponseException` и отображает ответ об ошибке с телом.\nРендеринг.\nВы можете вернуть «ProblemDetail» или «ErrorResponse» из любого «@ExceptionHandler» или из любой метод @RequestMapping для обработки ответа RFC 9457.\nЭто обрабатывается следующим образом:\n- Свойство `status` `ProblemDetail` определяет статус HTTP."}
{"id": 714, "text": "- Свойство `instance` для `ProblemDetail` устанавливается на основе текущего URL-пути, если это не так.\nРендеринг. уже установлен.\n- Кодеки Jackson JSON и XML используют «application/problem+json» или\nРендеринг. «application/problem+xml» соответственно в качестве типов воспроизводимых носителей для «ProblemDetail». чтобы гарантировать, что им будет отдано предпочтение при обсуждении содержания.\nРендеринг.\nЧтобы включить ответы RFC 9457 для исключений Spring MVC и для любых `ErrorResponseException`, расширьте `ResponseEntityExceptionHandler` и объявите его как имеет метод @ExceptionHandler, который обрабатывает любое исключение ErrorResponse, которое включает все встроенные веб-исключения.\nВы можете добавить больше методов обработки исключений и используйте защищенный метод для сопоставления любого исключения с «ProblemDetail».\nРендеринг.\nВы можете зарегистрировать перехватчики `ErrorResponse` через любой ответ RFC 9457 и предпримите какие-либо действия.\nНестандартные поля.\nВы можете расширить ответ RFC 9457 нестандартными полями одним из двух способов.\nНестандартные поля.\nВо-первых, вставьте в «свойства» «Карту» «ProblemDetail».\nПри использовании Джексона библиотека, Spring Framework регистрирует `ProblemDetailJacksonMixin`, который обеспечивает это «Свойства» `Карта` разворачивается и отображается как свойства JSON верхнего уровня в ответ, и аналогично любое неизвестное свойство во время десериализации вставляется в эта `Карта`.\nНестандартные поля.\nВы также можете расширить «ProblemDetail», чтобы добавить специальные нестандартные свойства."}
{"id": 715, "text": "Конструктор копирования в «ProblemDetail» позволяет упростить создание подкласса. из существующего «ProblemDetail».\nЭто можно сделать централизованно, например, из `@ControllerAdvice`, например `ResponseEntityExceptionHandler`, который воссоздает `ProblemDetail` исключения в подкласс с дополнительными нестандартными полями.\nНестандартные поля.\nСОВЕТ: В Spring Boot свойство Spring.mvc.problemdetails.enabled настраивается автоматически. `ResponseEntityExceptionHandler`, который обрабатывает встроенные исключения с подробностями проблемы.\nВ этом случае вы можете предпочесть создать еще один `@ControllerAdvice` вместо расширения `ResponseEntityExceptionHandler`, если вы хотите взять на себя обработку определенного встроенное исключение.\nВам необходимо убедиться, что ваш обработчик заказан раньше, чем тот, который настроенный Spring Boot, порядок которого равен 0.\nКастомизация и i18n.\nОбщепринятым требованием является настройка и интернационализация сведений об ошибках.\nТакже рекомендуется настроить сведения о проблеме для исключений Spring MVC. чтобы не раскрывать детали реализации.\nВ этом разделе описывается поддержка этого.\nКастомизация и i18n. `ErrorResponse` предоставляет коды сообщения для «типа», «заголовка» и «детали», а также Аргументы кода сообщения для поля «подробности». `ResponseEntityExceptionHandler` разрешает это через MessageSource и соответствующим образом обновляет соответствующие поля «ProblemDetail».\n* \"type\": `problemDetail.type.[полное имя класса исключения]`\n* \"title\": `problemDetail.title.[полное имя класса исключения]`"}
{"id": 716, "text": "* \"detail\": `problemDetail.[полное имя класса исключения][суффикс]`\nСтратегия по умолчанию для кодов сообщений следующая:. `ErrorResponse` может предоставлять более одного кода сообщения, обычно с добавлением суффикса. к коду сообщения по умолчанию.\nВ таблице ниже перечислены коды сообщений и аргументы для Исключения Spring MVC:\nСтратегия по умолчанию для кодов сообщений следующая:. [cols=\"1,1,2\", options=\"header\"] |=== | Исключение | Код сообщения | Аргументы кода сообщения\n| `AsyncRequestTimeoutException` | (по умолчанию). | `ConversionNotSupportedException` | (по умолчанию) | `+{0}+` имя свойства, `+{1}+` значение свойства\n| `AsyncRequestTimeoutException` | (по умолчанию). | `HandlerMethodValidationException` | (по умолчанию) | `+{0}+` выводит список всех ошибок проверки.\nКоды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.\n| `AsyncRequestTimeoutException` | (по умолчанию). | `HttpMediaTypeNotAcceptableException` | (по умолчанию) | `+{0}+` список поддерживаемых типов мультимедиа"}
{"id": 717, "text": "| `HttpMediaTypeNotAcceptableException` | (по умолчанию) + «.parseError». | `HttpMediaTypeNotSupportedException` | (по умолчанию) | `+{0}+` тип носителя, который не поддерживается, `+{1}+` список поддерживаемых типов мультимедиа\n| `HttpMessageNotWritableException` | (по умолчанию). | `HttpRequestMethodNotSupportedException` | (по умолчанию) | `+{0}+` текущий метод HTTP, `+{1}+` список поддерживаемых методов HTTP\n| `HttpMessageNotWritableException` | (по умолчанию). | `MethodArgumentNotValidException` | (по умолчанию) | `+{0}+` список глобальных ошибок, `+{1}+` список ошибок полей.\nКоды сообщений и аргументы для каждой ошибки также разрешаются через MessageSource.\n| `NoHandlerFoundException` | (по умолчанию). | `NoResourceFoundException` | (по умолчанию) | `+{0}+` путь запроса (или его часть), используемый для поиска ресурса\n| `NoHandlerFoundException` | (по умолчанию). | `TypeMismatchException` | (по умолчанию) | `+{0}+` имя свойства, `+{1}+` значение свойства, `+{2}+` простое имя требуемого типа\n| `UnsatisfiedServletRequestParameterException` | (по умолчанию) | `+{0}+` список условий параметра.\nПРИМЕЧАНИЕ."}
{"id": 718, "text": "В отличие от других исключений, аргументы сообщения для `MethodArgumentNotValidException` и `HandlerMethodValidationException` основаны на списке Ошибки MessageSourceResolvable, которые также можно настроить с помощью пакет ресурсов.\nСм. для более подробной информации.\nОбработка клиентов.\nКлиентское приложение может перехватить исключение WebClientResponseException при использовании WebClient. или RestClientResponseException при использовании RestTemplate и используйте их `getResponseBodyAs` для декодирования тела ответа об ошибке в любой целевой тип, например `ProblemDetail` или подкласс `ProblemDetail`."}
{"id": 719, "text": "HTTP-кэширование может значительно повысить производительность веб-приложения.\nHTTP-кэширование вращается вокруг заголовка ответа Cache-Control и, следовательно, условного запроса. заголовки (такие как Last-Modified и ETag). `Cache-Control` советует приватное (например, браузер) и публичные (например, прокси) кэши о том, как кэшировать и повторно использовать ответы.\nИспользуется заголовок `ETag`. сделать условный запрос, который может привести к 304 (NOT_MODIFIED) без тела, если содержимое не изменилось. `ETag` можно рассматривать как более продвинутого преемника заголовок «Last-Modified».\nHTTP-кэширование.\nВ этом разделе описаны параметры, связанные с HTTP-кэшированием, доступные в Spring Web MVC.\n`КэшКонтроль`. {spring-framework-api}/http/CacheControl.html[`CacheControl`] обеспечивает поддержку настройка параметров, связанных с заголовком Cache-Control и принимаемых в качестве аргумента в ряде мест:\n* {spring-framework-api}/web/servlet/mvc/WebContentInterceptor.html[`WebContentInterceptor`]\n* {spring-framework-api}/web/servlet/support/WebContentGenerator.html[`WebContentGenerator`]\n* Контроллеры\n* Статические ресурсы\n`КэшКонтроль`."}
{"id": 720, "text": "Хотя {rfc-site}/rfc7234#section-5.2.2[RFC 7234] описывает все возможные директивы для заголовка ответа Cache-Control, тип CacheControl принимает используйте подход, ориентированный на конкретные случаи, который фокусируется на общих сценариях:\nJava\n	// Кэш на час - \"Cache-Control: max-age=3600\"\n	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);\n	// Запретить кеширование — «Cache-Control: no-store»\n	CacheControl ccNoStore = CacheControl.noStore();\n	// Кэш на десять дней в публичных и частных тайниках,\n	// публичные кэши не должны трансформировать ответ\n	// «Cache-Control: max-age=864000, общедоступный, без преобразования»\n	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();\n`КэшКонтроль`. `WebContentGenerator` также принимает более простое свойство `cachePeriod` (определяемое в секундах), которое работает следующим образом:\n* Значение `-1` не генерирует заголовок ответа `Cache-Control`.\n* Значение «0» предотвращает кэширование с помощью директивы «Cache-Control: no-store».\n* Значение `n > 0` кэширует данный ответ на `n` секунд с помощью\n`КэшКонтроль`."}
{"id": 721, "text": "Директива `'Cache-Control: max-age=n'`.\nКонтроллеры могут добавлять явную поддержку HTTP-кэширования.\nМы рекомендовали это сделать, поскольку Значение `lastModified` или `ETag` для ресурса необходимо вычислить, прежде чем его можно будет сравнить. против заголовков условных запросов.\nКонтроллер может добавить заголовок ETag и Cache-Control. настройки на `ResponseEntity`, как показано в следующем примере:\nJava\n	@GetMapping(\"/book/{id}\")\n	public ResponseEntity<Book> showBook(@PathVariable Long id) {\n		Book book = findBook(id);\n		String version = book.getVersion();\n		return ResponseEntity\n				.ok()\n				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n				.eTag(version) // также доступен LastModified\n				.body(book);\n		return ResponseEntity\n				.ok()\n				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n				.eTag(version) // также доступен LastModified\n				.body(book)\nКонтроллеры.\nВ предыдущем примере отправляется ответ 304 (NOT_MODIFIED) с пустым телом, если сравнение к заголовкам условного запроса указывает, что содержимое не изменилось.\nВ противном случае К ответу добавляются заголовки `ETag` и `Cache-Control`.\nКонтроллеры.\nВы также можете проверить заголовки условных запросов в контроллере, как показано в следующем примере:\nJava\n	@RequestMapping"}
{"id": 722, "text": "public String myHandleMethod(WebRequest request, Model model) {\n		long eTag = ... // <1>\n		if (request.checkNotModified(eTag)) {\n			return null; // <2>\n		model.addAttribute(...); // <3>\n		return \"myViewName\";\nКонтроллеры. <1> Расчет для конкретного приложения. <2> Ответу присвоено значение 304 (NOT_MODIFIED) – дальнейшей обработки не требуется. <3> Продолжить обработку запроса.\n		if (request.checkNotModified(eTag)) {\n			return null // <2>\n		model[...] = ... // <3>\n		return \"myViewName\"\nКонтроллеры. <1> Расчет для конкретного приложения. <2> Ответу присвоено значение 304 (NOT_MODIFIED) – дальнейшей обработки не требуется. <3> Продолжить обработку запроса.\nКонтроллеры.\nСуществует три варианта проверки условных запросов на соответствие значениям eTag:lastModified. ценности, или и то, и другое.\nДля условных запросов GET и HEAD вы можете установить ответ на 304 (НЕ_МОДИФИЦИРОВАНО).\nДля условных POST, PUT и DELETE вы можете вместо этого установить ответ до 412 (PRECONDITION_FAILED), чтобы предотвратить одновременное изменение.\nСтатические ресурсы.\nВы должны обслуживать статические ресурсы с помощью Cache-Control и заголовков условного ответа. для оптимальной производительности.\nСм. раздел о настройке Статические ресурсы.\nФильтр `ETag`."}
{"id": 723, "text": "Вы можете использовать ShallowEtagHeaderFilter, чтобы добавить «поверхностные» значения eTag, вычисленные на основе содержимое ответа и, таким образом, экономить пропускную способность, но не время процессора.\nСм. ссылку:web/webmvc/filters.adoc#filters-shallow-etag[Shallow ETag]."}
{"id": 724, "text": "Конфигурация MVC Java и пространство имен MVC XML предоставляют конфигурацию по умолчанию. подходит для большинства приложений и API конфигурации для его настройки.\nКонфигурация MVC.\nДля более сложных настроек, которые недоступны в API конфигурации, см.\nРасширенная конфигурация Java и Расширенная конфигурация XML.\nКонфигурация MVC.\nВам не нужно понимать базовые bean-компоненты, созданные конфигурацией Java MVC. и пространство имен MVC.\nЕсли вы хотите узнать больше, см.\nСпециальные типы компонентов. и Web MVC Config."}
{"id": 725, "text": "Аннотированные контроллеры.\nSpring MVC предоставляет модель программирования на основе аннотаций, в которой `@Controller` и Компоненты `@RestController` используют аннотации для выражения сопоставления запросов, ввода запроса, обработка исключений и многое другое.\nАннотированные контроллеры имеют гибкие сигнатуры методов и не нужно расширять базовые классы или реализовывать определенные интерфейсы.\nВ следующем примере показан контроллер, определенный аннотациями:\nJava\n	@Controller\n	public class HelloController {\n		@GetMapping(\"/hello\")\n		public String handle(Model model) {\n			model.addAttribute(\"message\", \"Hello World!\");\n			return \"index\";\n	@Controller\n	class HelloController {\nАннотированные контроллеры.\nВ предыдущем примере метод принимает «Модель» и возвращает имя представления в виде «Строка». но существует множество других вариантов, которые будут объяснены позже в этой главе.\nАннотированные контроллеры.\nСОВЕТ: Руководства и учебные пособия на сайте {spring-site-guides}[spring.io] используют основанную на аннотациях модель программирования, описанная в этом разделе."}
{"id": 726, "text": "HTTP/2.\nКонтейнеры Servlet 4 необходимы для поддержки HTTP/2, а Spring Framework требует API сервлетов 6.1.\nС точки зрения модели программирования нет ничего конкретного, что приложения нужно делать.\nОднако есть соображения, связанные с конфигурацией сервера.\nБолее подробную информацию см. {spring-framework-wiki}/HTTP-2-support[вики-страница HTTP/2]."}
{"id": 727, "text": "Запросы диапазона.\nSpring MVC поддерживает https://datatracker.ietf.org/doc/html/rfc9110#section-14[RFC 9110] запросы диапазона.\nДля обзора см. https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests[Запросы рейнджеров] Руководство по Мозилле.\nЗапросы диапазона.\nЗаголовок Range анализируется и прозрачно обрабатывается в Spring MVC, когда аннотированный контроллер возвращает Resource или ResponseEntity<Resource> или функциональную конечную точку. поддержка также прозрачно обрабатывается при обслуживании\nЗапросы диапазона.\nСОВЕТ: «Ресурс» не должен быть «InputStreamResource» и с «ResponseEntity<Resource>», статус ответа должен быть 200.\nЗапросы диапазона.\nБазовая поддержка находится в классе HttpRange, который предоставляет методы для анализа. заголовки Range и разделить Resource на List<ResourceRegion>, который, в свою очередь, может быть затем записывается в ответ через ResourceRegionHttpMessageConverter."}
{"id": 728, "text": "Веб-безопасность.\nПроект {spring-site-projects}/spring-security[Spring Security] обеспечивает поддержку. для защиты веб-приложений от вредоносных эксплойтов.\nСм. весеннюю безопасность справочная документация, в том числе:\n* {docs-spring-security}/servlet/integrations/mvc.html [Spring MVC Security]\n* {docs-spring-security}/servlet/test/mockmvc/setup.html [Поддержка тестирования Spring MVC]\n* {docs-spring-security}/features/exploits/csrf.html#csrf-protection [защита CSRF]\n* {docs-spring-security}/features/exploits/headers.html[Заголовки ответов безопасности]\nВеб-безопасность. https://github.com/hdiv/hdiv[HDIV] — еще одна платформа веб-безопасности, интегрируемая с Spring MVC."}
{"id": 729, "text": "Диспетчерсервлет.\nSpring MVC, как и многие другие веб-фреймворки, построен на основе фронт-контроллера. шаблон, в котором центральный сервлет, DispatcherServlet, предоставляет общий алгоритм для обработки запросов, в то время как фактическую работу выполняют настраиваемые компоненты делегата.\nЭта модель является гибкой и поддерживает разнообразные рабочие процессы.\nДиспетчерсервлет.\nDispatcherServlet, как и любой другой сервлет, необходимо объявить и сопоставить в соответствии с в спецификацию сервлета, используя конфигурацию Java или в `web.xml`.\nВ свою очередь, DispatcherServlet использует конфигурацию Spring для обнаружения компоненты делегата, необходимые для сопоставления запросов, разрешения представлений, исключений обработка, ссылка:web/webmvc/mvc-servlet/special-bean-types.adoc[и многое другое].\nДиспетчерсервлет.\nВ следующем примере показана программная регистрация и инициализация `DispatcherServlet`, который автоматически обнаруживается контейнером сервлетов (см. ссылку:web/webmvc/mvc-servlet/container-config.adoc [Servlet Config]), а также эквивалент `web.xml`: См. пример кода в исходном документе.\nДиспетчерсервлет.\nПРИМЕЧАНИЕ.\nПомимо прямого использования API ServletContext, вы также можете расширить `AbstractAnnotationConfigDispatcherServletInitializer` и переопределить определенные методы (см. пример в разделе «Иерархия контекста»).\nДиспетчерсервлет.\nПРИМЕЧАНИЕ.\nВ случаях программного использования GenericWebApplicationContext можно использовать в качестве альтернатива AnnotationConfigWebApplicationContext."}
{"id": 730, "text": "См. {spring-framework-api}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`] javadoc для получения подробной информации.\nДиспетчерсервлет.\nПРИМЕЧАНИЕ.\nSpring Boot использует другую последовательность инициализации.\nВместо того, чтобы подключиться к жизненный цикл контейнера сервлетов, Spring Boot использует конфигурацию Spring для сам загрузчик и встроенный контейнер сервлетов.\nОбъявления `Filter` и `Servlet` обнаруживаются в конфигурации Spring и регистрируются в контейнере сервлетов.\nБолее подробную информацию см. {spring-boot-docs-ref}/web/servlet.html#web.servlet.embedded-container [документация Spring Boot]."}
{"id": 731, "text": "URI-ссылки.\nВ этом разделе описаны различные параметры, доступные в Spring Framework для работы с URI.\nОтносительные запросы сервлетов.\nВы можете использовать ServletUriComponentsBuilder для создания URI относительно текущего запроса. как показано в следующем примере:\nJava\n	HttpServletRequest request = ...\n	// Повторно использует схему, хост, порт, путь и строку запроса...\n	URI uri = ServletUriComponentsBuilder.fromRequest(request)\n			.replaceQueryParam(\"accountId\", \"{id}\")\n			.build(\"123\");\n	// Повторно использует схему, хост, порт, путь и строку запроса...\nОтносительные запросы сервлетов.\nВы можете создавать URI относительно контекстного пути, как показано в следующем примере:\nJava\n	HttpServletRequest request = ...\n	// Повторно использует схему, хост, порт и контекстный путь...\n	URI uri = ServletUriComponentsBuilder.fromContextPath(request)\n			.path(\"/accounts\")\n			.build()\n			.toUri();\n	// Повторно использует схему, хост, порт и контекстный путь...\nОтносительные запросы сервлетов.\nВы можете создавать URI относительно сервлета (например, `/main/{asterisk}`), как показано в следующем примере:\nJava\n	HttpServletRequest request = ...\n	// Повторно использует схему, хост, порт, контекстный путь и префикс сопоставления сервлетов...\n	URI uri = ServletUriComponentsBuilder.fromServletMapping(request)"}
{"id": 732, "text": ".path(\"/accounts\")\n			.build()\n			.toUri();\n	// Повторно использует схему, хост, порт, контекстный путь и префикс сопоставления сервлетов...\nОтносительные запросы сервлетов.\nПРИМЕЧАНИЕ.\nНачиная с версии 5.1, ServletUriComponentsBuilder игнорирует информацию из Forwarded и Заголовки `X-Forwarded-*`, которые указывают адрес, исходящий от клиента.\nРассмотрите возможность использования такие заголовки.\nСсылки на контроллеры.\nSpring MVC предоставляет механизм подготовки ссылок на методы контроллера.\nНапример, следующий контроллер MVC позволяет создавать ссылки:\nJava\n	@Controller\n	@RequestMapping(\"/hotels/{hotel}\")\n	public class BookingController {\n		@GetMapping(\"/bookings/{booking}\")\n		public ModelAndView getBooking(@PathVariable Long booking) {\n	@Controller\n	@RequestMapping(\"/hotels/{hotel}\")\n	class BookingController {\nСсылки на контроллеры.\nВы можете подготовить ссылку, ссылаясь на метод по имени, как показано в следующем примере:\nJava\n	UriComponents uriComponents = MvcUriComponentsBuilder\n		.fromMethodName(BookingController.class, \"getBooking\", 21).buildAndExpand(42);\n	URI uri = uriComponents.encode().toUri();\nСсылки на контроллеры.\nВ предыдущем примере мы предоставляем фактические значения аргументов метода (в данном случае длинное значение: `21`). для использования в качестве переменной пути и вставки в URL-адрес."}
{"id": 733, "text": "Кроме того, мы предоставляем значение `42`, чтобы заполнить все оставшиеся переменные URI, такие как унаследованная переменная `hotel`. из сопоставления запросов на уровне типа.\nЕсли бы у метода было больше аргументов, мы могли бы указать значение null для аргументы не нужны для URL.\nОбычно используются только аргументы `@PathVariable` и `@RequestParam`. имеют отношение к построению URL.\nСсылки на контроллеры.\nСуществуют дополнительные способы использования MvcUriComponentsBuilder.\nНапример, вы можете использовать технику похоже на макетное тестирование через прокси, чтобы избежать обращения к методу контроллера по имени, как показано в следующем примере. (в примере предполагается статический импорт MvcUriComponentsBuilder.on):\nJava\n	UriComponents uriComponents = MvcUriComponentsBuilder\n		.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);\n	URI uri = uriComponents.encode().toUri();\nСсылки на контроллеры.\nПРИМЕЧАНИЕ.\nСигнатуры методов контроллера ограничены по своей конструкции, если предполагается, что их можно использовать для создание ссылки с помощью fromMethodCall.\nПомимо необходимости правильной подписи параметра, существует техническое ограничение на тип возвращаемого значения (а именно, создание прокси-сервера времени выполнения для вызовов компоновщика ссылок), поэтому тип возвращаемого значения не должен быть `final`.\nВ частности, общий тип возврата `String` для имен представлений здесь не работает."}
{"id": 734, "text": "Вы должны использовать ModelAndView. или даже вместо этого простой `Object` (с возвращаемым значением `String`).\nСсылки на контроллеры.\nВ предыдущих примерах используются статические методы в MvcUriComponentsBuilder.\nВнутренне они полагаются в `ServletUriComponentsBuilder`, чтобы подготовить базовый URL-адрес из схемы, хоста, порта, контекстный путь и путь сервлета текущего запроса.\nВ большинстве случаев это работает хорошо.\nОднако иногда этого может быть недостаточно.\nНапример, вы можете находиться вне контекста запрос (например, пакетный процесс подготовки ссылок) или, возможно, вам нужно вставить путь префикс (например, префикс локали, который был удален из пути запроса и должен быть повторно вставлен в ссылки).\nСсылки на контроллеры.\nВ таких случаях вы можете использовать статические перегруженные методы fromXxx, которые принимают `UriComponentsBuilder` для использования базового URL-адреса.\nАльтернативно вы можете создать экземпляр MvcUriComponentsBuilder. с базовым URL-адресом, а затем использовать методы withXxx на основе экземпляра.\nНапример, в следующем листинге используется withMethodCall:\nJava\n	UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path(\"/en\");\n	MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);\n	builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);\n	URI uri = uriComponents.encode().toUri();\nСсылки на контроллеры.\nПРИМЕЧАНИЕ."}
{"id": 735, "text": "Начиная с версии 5.1, MvcUriComponentsBuilder игнорирует информацию из Заголовки `X-Forwarded-*`, которые указывают адрес, исходящий от клиента.\nРассмотрите возможность использования такие заголовки.\nСсылки в представлениях.\nВ таких представлениях, как Thymeleaf, FreeMarker или JSP, вы можете создавать ссылки на аннотированные контроллеры. путем ссылки на неявно или явно назначенное имя для каждого сопоставления запроса.\nJava\n	@RequestMapping(\"/people/{id}/addresses\")\n	public class PersonAddressController {\n		@RequestMapping(\"/{country}\")\n		public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }\n	@RequestMapping(\"/people/{id}/addresses\")\n	class PersonAddressController {\nРассмотрим следующий пример:.\nУчитывая предыдущий контроллер, вы можете подготовить ссылку из JSP следующим образом:\nРассмотрим следующий пример:. <%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"s\" %>... <a href=\"${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}\">Get Address</a>\nРассмотрим следующий пример:."}
{"id": 736, "text": "Предыдущий пример основан на функции mvcUrl, объявленной в библиотеке тегов Spring. (то есть META-INF/spring.tld), но можно легко определить собственную функцию или подготовить аналогичный для других технологий шаблонов.\nРассмотрим следующий пример:.\nВот как это работает.\nПри запуске каждому `@RequestMapping` присваивается имя по умолчанию. через HandlerMethodMappingNamingStrategy, реализация которого по умолчанию использует заглавные буквы класса и имени метода (например, метод getThing в `ThingController` становится \"TC#getThing\").\nЕсли есть конфликт имен, вы можете использовать `@RequestMapping(name=\"..\")`, чтобы назначить явное имя или реализовать свое собственное `HandlerMethodMappingNamingStrategy`."}
{"id": 737, "text": "Обзор.\nПочему был создан Spring WebFlux?\nОбзор.\nЧастично ответ заключается в необходимости неблокирующего веб-стека для обработки параллелизма с помощью небольшое количество потоков и масштабирование с меньшим количеством аппаратных ресурсов.\nНеблокирующий ввод-вывод сервлетов уводит от остальной части API сервлетов, где контракты синхронны («Фильтр», «Сервлет») или блокировку («getParameter», «getPart»).\nЭто была мотивация для нового общего API, который будет служить основой для любой неблокирующей среды выполнения.\nЭто важно, поскольку серверы (такие как Netty) хорошо зарекомендовали себя в асинхронном режиме, неблокирующее пространство.\nОбзор.\nДругая часть ответа — функциональное программирование.\nПримерно так же, как добавление аннотаций в Java 5 появились возможности (такие как аннотированные контроллеры REST или модульные тесты), добавление лямбда-выражений в Java 8 создало возможности для функциональных API в Java.\nЭто благо для неблокирующих приложений и API-интерфейсов продолжения (популяризированных от `CompletableFuture` и https://reactivex.io/[ReactiveX]), которые допускают декларативный состав асинхронной логики.\nНа уровне модели программирования Java 8 поддерживает Spring.\nWebFlux предлагает функциональные конечные веб-точки наряду с аннотированными контроллерами.\nДайте определение «реактивному».\nМы затронули понятия «неблокирующий» и «функциональный», но что означает реактивный?\nДайте определение «реактивному»."}
{"id": 738, "text": "Термин «реактивный» относится к моделям программирования, построенным на реагировании на изменения. сетевые компоненты, реагирующие на события ввода-вывода, контроллеры пользовательского интерфейса, реагирующие на события мыши, и другие.\nВ этом смысле неблокировка является реактивной, потому что вместо того, чтобы быть заблокированными, мы теперь находимся в режиме реагирования на уведомления по мере завершения операций или доступности данных.\nДайте определение «реактивному».\nЕсть еще один важный механизм, который мы в команде Spring связываем с «реактивным». и это неблокирующее противодавление.\nВ синхронном императивном коде блокировка вызовов служат естественной формой обратного давления, которая заставляет звонящего ждать.\nВ неблокирующем режиме кода становится важным контролировать скорость событий, чтобы быстрый производитель не превзойти пункт назначения.\nДайте определение «реактивному».\nРеактивные потоки — это {reactive-streams-spec}[маленькая спецификация] (также {java-api}/java.base/java/util/concurrent/Flow.html [принято] в Java 9) который определяет взаимодействие асинхронных компонентов с противодавлением."}
{"id": 739, "text": "Например, хранилище данных (действующее как {reactive-streams-site}/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html[Publisher]) может генерировать данные, которые HTTP-сервер (действуя как {reactive-streams-site}/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html[Подписчик]) потом могу написать в ответ.\nОсновная цель Reactive Streams — позволить подписчик контролирует, насколько быстро или медленно издатель создает данные.\nДайте определение «реактивному».\nПРИМЕЧАНИЕ. *Общий вопрос: что, если издатель не может замедлить работу?* + Целью Reactive Streams является лишь установление механизма и границ.\nЕсли издатель не может замедлить работу, он должен решить, следует ли буферизовать, удалить или потерпеть неудачу.\nРеактивный API.\nReactive Streams играет важную роль в обеспечении совместимости.\nПредставляет интерес для библиотек. и компоненты инфраструктуры, но менее полезен в качестве API приложения, поскольку он слишком низкоуровневый.\nПриложениям необходим высокоуровневый и более богатый функциональный API для составить асинхронную логику — аналогично API Stream в Java 8, но не только для коллекций.\nИменно эту роль играют реактивные библиотеки.\nРеактивный API. {reactor-github-org}/reactor[Reactor] — реактивная библиотека, которую выбирают для Весенний вебфлюкс."}
{"id": 740, "text": "Он обеспечивает {reactor-site}/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] и {reactor-site}/docs/core/release/api/reactor/core/publisher/Flux.html[`Flux`] Типы API работать с последовательностями данных 0..1 («Моно») и 0..N («Поток») с помощью богатого набора операторов, согласованных с ReactiveX https://reactivex.io/documentation/operators.html[словарь операторов].\nReactor — это библиотека Reactive Streams, поэтому все ее операторы поддерживают неблокирующее обратное давление.\nReactor уделяет большое внимание серверной Java.\nОн разработан в тесном сотрудничестве с Spring.\nРеактивный API.\nWebFlux требует Reactor в качестве основной зависимости, но он совместим с другими реактивными библиотеки через Reactive Streams.\nКак правило, API WebFlux принимает простой `Publisher`. в качестве входных данных, внутренне адаптирует его к типу Reactor, использует его и возвращает либо «Flux» или «Mono» в качестве выхода.\nИтак, вы можете передать в качестве входных данных любого «Издателя» и применить операции над выводом, но вам необходимо адаптировать вывод для использования с другой реактивной библиотекой.\nВсякий раз, когда это возможно (например, аннотированные контроллеры), WebFlux прозрачно адаптируется к использованию RxJava или другой реактивной библиотеки."}
{"id": 741, "text": "Дополнительную информацию см. в Реактивные библиотеки.\nМодели программирования.\nМодуль Spring-Web содержит реактивную основу, лежащую в основе Spring WebFlux. включая абстракции HTTP, Reactive Streams [адаптеры] для поддерживаемых серверов: web/webflux/reactive-spring.adoc#webflux-codecs[кодеки] и ядро API сервлетов, но с неблокирующими контрактами.\nМодели программирования.\nИсходя из этого, Spring WebFlux предоставляет на выбор две модели программирования:\n* Аннотированные контроллеры: соответствует Spring MVC и основано на\nМодели программирования. те же аннотации из модуля Spring-Web.\nКонтроллеры Spring MVC и WebFlux поддерживают реактивную (Reactor и RxJava), поэтому отличить их друг от друга непросто.\nОдин примечательный разница в том, что WebFlux также поддерживает реактивные аргументы @RequestBody.\n* Функциональные конечные точки: облегченный, основанный на лямбде,\nМодели программирования. и модель функционального программирования.\nВы можете думать об этом как о небольшой библиотеке или наборе утилиты, которые приложение может использовать для маршрутизации и обработки запросов.\nБольшая разница с аннотированными контроллерами заключается в том, что приложение отвечает за обработку запросов. от начала до конца вместо объявления о намерении посредством аннотаций и обратного вызова.\nПрименимость.\nSpring MVC или WebFlux?\nПрименимость.\nЕстественный вопрос, но он создает необоснованную дихотомию.\nНа самом деле, оба Работайте вместе, чтобы расширить диапазон доступных опций."}
{"id": 742, "text": "Оба предназначены для преемственность и согласованность друг с другом, они доступны бок о бок, и обратная связь с каждой стороны выгоды обеим сторонам.\nНа следующей диаграмме показано, как эти два понятия связаны, что они имеют общее и что каждый поддерживает уникально:\n* Если у вас есть приложение Spring MVC, которое работает нормально, вносить изменения не нужно.\nМы предлагаем вам обратить внимание на следующие конкретные моменты:.\nИмперативное программирование — это самый простой способ писать, понимать и отлаживать код.\nУ вас максимальный выбор библиотек, поскольку исторически большинство из них блокируются.\n* Если вы уже покупаете неблокирующий веб-стек, Spring WebFlux предлагает то же самое.\nМы предлагаем вам обратить внимание на следующие конкретные моменты:.\nМодель выполнения имеет преимущества, как и другие в этой области, а также обеспечивает выбор серверов. (контейнеры Netty, Tomcat, Jetty и Servlet), выбор моделей программирования. (аннотированные контроллеры и функциональные веб-конечные точки), а также выбор реактивных библиотек. (Reactor, RxJava или другое).\n* В микросервисной архитектуре вы можете использовать сочетание приложений с Spring MVC.\nМы предлагаем вам обратить внимание на следующие конкретные моменты:. или контроллеры Spring WebFlux или с функциональными конечными точками Spring WebFlux.\nИмея поддержку для одной и той же модели программирования на основе аннотаций в обеих средах упрощает повторно использовать знания, одновременно выбирая правильный инструмент для правильной работы."}
{"id": 743, "text": "* Простой способ оценить приложение — проверить его зависимости. Если у вас есть блокировка\nМы предлагаем вам обратить внимание на следующие конкретные моменты:.\nAPI сохранения (JPA, JDBC) или сетевые API, Spring MVC — лучший выбор. по крайней мере, для обычных архитектур.\nТехнически это осуществимо как с Reactor, так и с RxJava для выполнения блокирующих вызовов в отдельном потоке, но вы не будете выполнять большая часть неблокирующего веб-стека.\n* Если у вас есть приложение Spring MVC с вызовами удаленных сервисов, попробуйте реактивный `WebClient`.\nМы предлагаем вам обратить внимание на следующие конкретные моменты:.\nВы можете возвращать реактивные типы (Reactor, RxJava, или другие). непосредственно из методов контроллера Spring MVC.\nЧем больше задержка на вызов или взаимозависимость между вызовами, тем более существенными будут преимущества.\nSpring MVC-контроллеры может вызывать и другие реактивные компоненты.\n* Если у вас большая команда, имейте в виду, что переход на неблокирующую технологию потребует сложного обучения.\nМы предлагаем вам обратить внимание на следующие конкретные моменты:. функциональное и декларативное программирование.\nПрактичный способ запуска без полного переключения заключается в использовании реактивного `WebClient`.\nПомимо этого, начните с малого и оцените выгоды.\nМы ожидаем, что для широкого спектра приложений в этом сдвиге нет необходимости."}
{"id": 744, "text": "Если вы не знаете, какие преимущества искать, начните с изучения того, как работает неблокирующий ввод-вывод (например, параллелизм в однопоточном Node.js) и его последствия.\nСерверы.\nSpring WebFlux поддерживается в контейнерах Tomcat, Jetty, Servlet, а также в среды выполнения, не относящиеся к сервлетам, такие как Netty.\nВсе сервера адаптированы под низкоуровневый,\nСерверы.\nSpring WebFlux не имеет встроенной поддержки запуска или остановки сервера.\nОднако это легко собрать приложение из конфигурации Spring и строки кода.\nСерверы.\nSpring Boot имеет стартер WebFlux, который автоматизирует эти шаги.\nПо умолчанию стартер использует Netty, но можно легко переключиться на Tomcat или Jetty, изменив Зависимости Maven или Gradle.\nSpring Boot по умолчанию использует Netty, поскольку он более широко распространен. используется в асинхронном, неблокирующем пространстве и позволяет клиенту и серверу совместно использовать ресурсы.\nСерверы.\nTomcat и Jetty можно использовать как с Spring MVC, так и с WebFlux.\nИмейте в виду, однако, что способы их использования очень разные.\nSpring MVC полагается на блокировку ввода-вывода сервлетов и позволяет приложениям использовать API сервлетов напрямую, если им это необходимо.\nВесенний WebFlux опирается на неблокирующий ввод-вывод сервлетов и использует API сервлетов за низкоуровневым адаптер.\nОн не предназначен для прямого использования.\nСерверы.\nПРИМЕЧАНИЕ.\nНастоятельно рекомендуется не сопоставлять фильтры сервлетов или напрямую манипулировать API сервлетов в контексте приложения WebFlux."}
{"id": 745, "text": "По причинам, перечисленным выше, сочетание блокирующего и неблокирующего ввода-вывода в одном контексте приведет к проблемам во время выполнения.\nПроизводительность имеет множество характеристик и значений.\nРеактивный и неблокирующий в целом не заставляйте приложения работать быстрее.\nВ некоторых случаях они могут – например, при использовании `WebClient` для параллельного выполнения удаленных вызовов.\nОднако для этого требуется больше работы все происходит неблокирующим способом, и это может немного увеличить необходимое время обработки.\nПроизводительность.\nКлючевым ожидаемым преимуществом реактивного и неблокирующего подхода является возможность масштабирования с небольшими затратами. фиксированное количество потоков и меньше памяти.\nЭто делает приложения более устойчивыми под нагрузкой, потому что они масштабируются более предсказуемо.\nОднако для того, чтобы воспользоваться этими преимуществами, вам должна иметь некоторую задержку (включая сочетание медленного и непредсказуемого сетевого ввода-вывода).\nИменно здесь реактивный стек начинает проявлять свои сильные стороны, и различия могут быть очевидны. драматичный.\nМодель параллелизма.\nИ Spring MVC, и Spring WebFlux поддерживают аннотированные контроллеры, но есть ключевой момент: разница в модели параллелизма и предположениях по умолчанию для блокировки и потоков.\nМодель параллелизма.\nВ Spring MVC (и сервлет-приложениях в целом) предполагается, что приложения могут заблокировать текущий поток (например, для удаленных вызовов).\nПо этой причине контейнеры сервлетов используйте большой пул потоков для устранения потенциальной блокировки во время обработки запроса.\nМодель параллелизма."}
{"id": 746, "text": "В Spring WebFlux (и неблокирующих серверах в целом) предполагается, что приложения не блокируйте.\nПоэтому неблокирующие серверы используют небольшой пул потоков фиксированного размера. (работники цикла событий) для обработки запросов.\nМодель параллелизма.\nСОВЕТ: «Масштабирование» и «малое количество потоков» могут показаться противоречивыми, но никогда не блокируйте текущий поток (и вместо этого полагаться на обратные вызовы) означает, что вам не нужны дополнительные потоки, поскольку нет никаких блокирующих вызовов, которые нужно поглотить.\nВызов API блокировки.\nЧто делать, если вам нужно использовать библиотеку блокировки?\nИ Reactor, и RxJava предоставляют Оператор `publishOn` для продолжения обработки в другом потоке.\nЭто означает, что существует удобный аварийный люк.\nОднако имейте в виду, что блокирующие API не подходят для эта модель параллелизма.\nИзменяемое состояние.\nВ Reactor и RxJava вы объявляете логику через операторы.\nВо время выполнения реактивный формируется конвейер, в котором данные обрабатываются последовательно, на отдельных этапах.\nКлючевое преимущество заключается в том, что он освобождает приложения от необходимости защищать изменяемое состояние, поскольку код приложения в этом конвейере никогда не вызывается одновременно.\nМодель резьбы.\nКакие потоки следует ожидать на сервере, работающем под управлением Spring WebFlux?\n* На «ванильном» сервере Spring WebFlux (например, без доступа к данным или других дополнительных опций)."}
{"id": 747, "text": "Модель резьбы. зависимости), вы можете ожидать один поток для сервера и несколько других для запроса. обработки (обычно столько же, сколько ядер ЦП).\nОднако контейнеры сервлетов может начинаться с большего количества потоков (например, 10 на Tomcat) для поддержки как сервлетного (блокирующего) ввода-вывода и использование сервлета 3.1 (неблокирующего) ввода-вывода.\n* Реактивный `WebClient` работает в стиле цикла событий. Таким образом, вы можете увидеть небольшой фиксированный\nМодель резьбы. количество связанных с этим потоков обработки (например, `reactor-http-nio-` с Reactor Разъем Netty).\nОднако если Reactor Netty используется как для клиента, так и для сервера, оба по умолчанию совместно использовать ресурсы цикла событий.\n* Reactor и RxJava предоставляют абстракции пула потоков, называемые планировщиками, для использования с\nМодель резьбы.\nОператор «publishOn», который используется для переключения обработки на другой пул потоков.\nПланировщики имеют имена, предполагающие конкретную стратегию параллелизма, например «параллельный». (для работы с привязкой к ЦП и ограниченным количеством потоков) или «эластичный» (для работы с привязкой к вводу/выводу с большое количество потоков).\nЕсли вы видите такие потоки, это означает, что какой-то код использует конкретная стратегия «Планировщика» пула потоков.\n* Библиотеки доступа к данным и другие сторонние зависимости также могут создавать и использовать потоки.\nМодель резьбы. свои собственные."}
{"id": 748, "text": "Настройка.\nSpring Framework не обеспечивает поддержку запуска и остановки. вам необходимо использовать API-интерфейсы конфигурации для конкретного сервера или, если вы используете Spring Boot, проверьте параметры конфигурации Spring Boot для каждого сервера.\nВы можете Для всех остальных библиотек смотрите соответствующую документацию."}
{"id": 749, "text": "Нулевая безопасность.\nХотя Java пока не позволяет выражать маркеры нулевого значения с помощью своей системы типов, кодовая база Spring Framework снабжен аннотациями https://jspecify.dev/docs/start-here/[JSpecify], чтобы объявить об отсутствии значений своих API, поля и использование связанных типов.\nЧтение https://jspecify.dev/docs/user-guide/[руководства пользователя JSpecify] очень важно. рекомендуется для ознакомления с этими аннотациями и семантикой.\nАннотирование библиотек с помощью аннотаций JSpecify.\nНачиная с Spring Framework 7, кодовая база Spring Framework использует аннотации JSpecify для предоставления нулевых API-интерфейсов. и проверить согласованность этих объявлений об отсутствии значений с помощью https://github.com/uber/NullAway[NullAway] как часть его сборки.\nРекомендуется для каждой библиотеки в зависимости от проектов Spring Framework и портфолио Spring. а также другие библиотеки, связанные с экосистемой Spring (проекты сообщества Reactor, Micrometer и Spring), сделать то же самое.\nИспользование аннотаций JSpecify в приложениях Spring.\nПри желании разработчики приложений Spring могут аннотировать свою кодовую базу и использовать плагины сборки, такие как https://github.com/uber/NullAway[NullAway] для обеспечения нулевой безопасности на уровне приложения во время сборки.\nРекомендации.\nЦель этого раздела — поделиться некоторыми предлагаемыми рекомендациями по явному указанию возможности обнуления.\nБиблиотеки или приложения, связанные с Spring.\nПо умолчанию ненулевое значение."}
{"id": 750, "text": "Ключевым моментом, который следует понимать, является то, что нулевые типы типов по умолчанию неизвестны в Java, и что использование ненулевых типов встречается гораздо чаще, чем использование с нулевым значением.\nЧтобы сохранить читабельность кодовой базы, мы обычно хотим определить по умолчанию использование этого типа не равно нулю, если оно не помечено как допускающее значение NULL для определенной области.\nЭто именно цель https://jspecify.dev/docs/api/org/jspecify/annotations/NullMarked.html[`@NullMarked`], который обычно устанавливается в проектах Spring на уровне пакета через файл package-info.java, например:\nЯвная возможность обнуления.\nВ коде `@NullMarked` использование типа, допускающего значение NULL, определяется явно с помощью https://jspecify.dev/docs/api/org/jspecify/annotations/Nullable.html[`@Nullable`].\nЯвная возможность обнуления.\nКлючевое различие между аннотациями JSpecify `@Nullable`/`@NonNull` и большинством других вариантов заключается в том, что JSpecify annotations are meta-annotated with `@Target(ElementType.TYPE_USE)`, so they apply only to type usage."}
{"id": 751, "text": "Это влияет где такие аннотации должны быть размещены, либо для соблюдения https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4 [связанные спецификации Java] или следовать коду лучшие практики стиля.\nС точки зрения стиля рекомендуется учитывать характер использования типов этих аннотаций. помещая их на той же строке, что и аннотированный тип, и непосредственно перед ним.\n                                     @Nullable Throwable cause) {\npublic @Nullable String buildMessage(@Nullable String message,. [ПРИМЕЧАНИЕ] = При переопределении метода аннотации JSpecify не наследуются от оригинала. метод.\nЭто означает, что аннотации JSpecify должны быть скопированы в переопределяющий метод, если вы хотите переопределить реализацию и сохранить ту же семантику обнуления.\npublic @Nullable String buildMessage(@Nullable String message,. https://jspecify.dev/docs/api/org/jspecify/annotations/NonNull.html[`@NonNull`] и https://jspecify.dev/docs/api/org/jspecify/annotations/NullUnmarked.html[`@NullUnmarked`] редко требуется для типичные случаи использования.\nМассивы и варарги.\nПри работе с массивами и переменными аргументами вам необходимо уметь отличать нулевое значение элементов от нулевого значения. сам массив."}
{"id": 752, "text": "Обратите внимание на синтаксис https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4 [определено спецификацией Java], что может быть изначально удивительно.\nНапример, в коде @NullMarked:\n- `@Nullable Object[] array` означает, что отдельные элементы могут быть `null`, но сам массив не может.\n- `Object @Nullable [] array` означает, что отдельные элементы не могут быть `null`, но сам массив может иметь значение null.\n- `@Nullable Object @Nullable [] array` означает, что как отдельные элементы, так и массив могут быть `null`.\n - `List<String>` означает список ненулевых элементов (эквивалент `List<@NonNull String>`)\n - `List<@Nullable String>` означает список элементов, допускающих значение NULL.\nАннотации JSpecify также применимы к дженерикам.\nНапример, в коде @NullMarked:.\nВсе немного сложнее, когда вы объявляете универсальные типы или универсальные методы.\nСм. соответствующие https://jspecify.dev/docs/user-guide/#generics [документация по дженерикам JSpecify] для получения более подробной информации.\nАннотации JSpecify также применимы к дженерикам.\nНапример, в коде @NullMarked:."}
{"id": 753, "text": "ВНИМАНИЕ: Обнуляемость универсальных типов и универсальных методов. https://github.com/uber/NullAway/issues?q=is%3Aissue+is%3Aopen+label%3Ajspecify [NullAway еще не полностью поддерживает].\nВложенные и полностью определенные типы.\nСпецификация Java также требует, чтобы аннотации, определенные с помощью `@Target(ElementType.TYPE_USE)` – например, JSpecify Аннотация `@Nullable` – должна быть объявлена после последней точки (`.`) во внутренних или полных именах типов:\n- `Cache.@Nullable ValueWrapper`\n- `jakarta.validation.@Nullable Validator`\n - `NullAway:OnlyNullMarked=true` для выполнения проверок на обнуляемость только для пакетов, помеченных `@NullMarked`.\n - `NullAway:CustomContractAnnotations=org.springframework.lang.Contract`, который сообщает NullAway о\nРекомендуемая конфигурация:. аннотация {spring-framework-api}/lang/Contract.html[@Contract] в пакете `org.springframework.lang`, которая может использоваться для выражения дополнительной семантики, чтобы избежать ненужных предупреждений в вашей кодовой базе.\nРекомендуемая конфигурация:."}
{"id": 754, "text": "Хороший пример преимуществ декларации `@Contract` можно увидеть с помощью {spring-framework-api}/util/Assert.html#notNull(java.lang.Object,java.lang.String)[`Assert.notNull()`] который помечен `@Contract(\"null, _ -> error\")`.\nБлагодаря этому заявлению о контракте NullAway поймет что значение, переданное в качестве параметра, не может быть нулевым после успешного вызова Assert.notNull().\nРекомендуемая конфигурация:.\nПри желании можно установить NullAway:JSpecifyMode=true, чтобы включить https://github.com/uber/NullAway/wiki/JSpecify-Support [проверяет полную семантику JSpecify], включая аннотации к массивы, varargs и дженерики.\nИмейте в виду, что этот режим https://github.com/uber/NullAway/issues?q=is%3Aissue+is%3Aopen+label%3Ajspecify[все еще в разработке] и требует JDK 22 или новее (обычно в сочетании с флагом компилятора Java `--release` для настройки ожидаемый базовый уровень).\nРекомендуется включать режим JSpecify только на втором этапе, после того как убедитесь, что кодовая база не генерирует никаких предупреждений при рекомендуемой конфигурации, упомянутой ранее в этом разделе.\nПодавление предупреждений.\nСуществует несколько допустимых случаев использования, когда NullAway неправильно обнаруживает проблемы с обнулением."}
{"id": 755, "text": "В таких случаях рекомендуется отключить соответствующие предупреждения и задокументировать причину:\n - `@SuppressWarnings(\"NullAway.Init\")` на уровне поля, конструктора или класса можно использовать, чтобы избежать ненужных предупреждений.\nПодавление предупреждений. из-за ленивой инициализации полей – например, из-за реализации класса {spring-framework-api}/beans/factory/InitializingBean.html[`InitializingBean`].\n - `@SuppressWarnings(\"NullAway\") // Ограничение анализа потока данных` может использоваться, когда анализ потока данных NullAway не используется.\nПодавление предупреждений. способен обнаружить, что путь, включающий проблему обнуления, никогда не произойдет.\n - `@SuppressWarnings(\"NullAway\") // Lambda` может использоваться, когда NullAway не учитывает выполненные утверждения\nПодавление предупреждений. вне лямбды для пути кода внутри лямбды.\n- `@SuppressWarnings(\"NullAway\") // Reflection` может использоваться для некоторых операций отражения, которые, как известно, возвращают\nПодавление предупреждений. ненулевые значения, даже если они не могут быть выражены API.\n- `@SuppressWarnings(\"NullAway\") // Хорошо известные ключи карты` могут использоваться, когда вызовы `Map#get` выполняются с помощью ключей\nПодавление предупреждений. которые, как известно, присутствуют, и когда ранее были вставлены ненулевые связанные значения."}
{"id": 756, "text": "- `@SuppressWarnings(\"NullAway\") // Переопределенный метод не определяет допустимость значений NULL` может использоваться, когда суперкласс это делает\nПодавление предупреждений. не определять допустимость значений NULL (обычно, когда суперкласс возникает из внешней зависимости).\n- `@SuppressWarnings(\"NullAway\") // См. https://github.com/uber/NullAway/issues/1075` можно использовать, когда NullAway не может обнаружить ненулевое значение переменной типа в универсальных методах.\nМиграция с аннотаций нулевой безопасности Spring.\nКлючевое отличие состоит в том, что устаревшие аннотации Spring с нулевой безопасностью, которые соответствуют семантике JSR 305, применяются к полям, параметры и возвращаемые значения; в то время как аннотации JSpecify применяются к использованию типов.\nЭта тонкая разница на практике очень важно, поскольку позволяет разработчикам различать нулевое значение элементов и нулевое значение массивов/varargs, а также для определения нулевого значения универсальных типов.\nМиграция с аннотаций нулевой безопасности Spring.\nЭто означает, что объявления нулевой безопасности массива и varargs должны быть обновлены, чтобы сохранить ту же семантику.\nНапример `@Nullable Object[] array` с аннотациями Spring необходимо изменить на `Object @Nullable[] array` с помощью JSpecify аннотации.\nТо же самое относится и к varargs.\nМиграция с аннотаций нулевой безопасности Spring.\nТакже рекомендуется переместить аннотации полей и возвращаемых значений ближе к типу и на одной строке, например:"}
{"id": 757, "text": "- Для полей вместо `@Nullable Private String Field` с аннотациями Spring используйте `private @Nullable String Field`.\nМиграция с аннотаций нулевой безопасности Spring. с аннотациями JSpecify.\n- Для типов возвращаемых методов вместо `@Nullable public String Method()` с аннотациями Spring используйте\nМиграция с аннотаций нулевой безопасности Spring. `public @Nullable String метод()` с аннотациями JSpecify.\nМиграция с аннотаций нулевой безопасности Spring.\nКроме того, с помощью JSpecify вам не нужно указывать @NonNull при переопределении использования типа, аннотированного с помощью @Nullable. в методе super, чтобы «отменить» объявление, допускающее значение NULL, в коде, помеченном нулем.\nПросто объявите его без аннотаций, и Будут применяться значения по умолчанию, помеченные нулевым значением (использование типа считается ненулевым, если явно не указано, что оно допускает значение NULL)."}
{"id": 758, "text": "Моделирование операций JDBC как объектов Java.\nПакет `org.springframework.jdbc.object` содержит классы, которые позволяют вам получить доступ к базу данных более объектно-ориентированным способом.\nВ качестве примера вы можете запускать запросы и получить результаты обратно в виде списка, содержащего бизнес-объекты с реляционной данные столбца, сопоставленные со свойствами бизнес-объекта.\nВы также можете запустить сохраненный процедуры и запускать операторы обновления, удаления и вставки.\nМоделирование операций JDBC как объектов Java. [ПРИМЕЧАНИЕ] = Многие разработчики Spring считают, что различные классы операций РСУБД, описанные ниже, (за исключением класса `StoredProcedure`) часто может быть заменены прямыми вызовами `JdbcTemplate`.\nЗачастую проще написать DAO метод, который вызывает метод JdbcTemplate напрямую (в отличие от инкапсуляция запроса как полноценный класс).\nМоделирование операций JDBC как объектов Java.\nОднако если вы получаете измеримую пользу от использования классов операций РСУБД, вам следует продолжать использовать эти классы.\nПонимание `SqlQuery`. `SqlQuery` — это многоразовый, потокобезопасный класс, инкапсулирующий SQL-запрос.\nПодклассы должен реализовать метод newRowMapper(..)`, чтобы предоставить экземпляр RowMapper, который может создавать по одному объекту для каждой строки, полученной в результате итерации по созданному `ResultSet` во время выполнения запроса.\nКласс SqlQuery редко используется напрямую, поскольку подкласс MappingSqlQuery обеспечивает гораздо более удобную реализацию для сопоставление строк с классами Java."}
{"id": 759, "text": "Другие реализации, расширяющие `SqlQuery`: MappingSqlQueryWithParameters и UpdatableSqlQuery.\nИспользование MappingSqlQuery.\nMappingSqlQuery — это запрос многократного использования, в котором конкретные подклассы должны реализовать абстрактный метод `mapRow(..)` для преобразования каждой строки предоставленного `ResultSet` в объект указанного типа.\nВ следующем примере показан пользовательский запрос, который сопоставляет данные из отношения t_actor к экземпляру класса Actor:\nJava\n	public class ActorMappingQuery extends MappingSqlQuery<Actor> {\n		public ActorMappingQuery(DataSource ds) {\n			super(ds, \"select id, first_name, last_name from t_actor where id = ?\");\n			declareParameter(new SqlParameter(\"id\", Types.INTEGER));\n			compile();\n		@Override\n		protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {\n			Actor actor = new Actor();\n			actor.setId(rs.getLong(\"id\"));\n			actor.setFirstName(rs.getString(\"first_name\"));\n			actor.setLastName(rs.getString(\"last_name\"));\n			return actor;\n		init {\n			declareParameter(SqlParameter(\"id\", Types.INTEGER))\n			compile()\nИспользование MappingSqlQuery.\nКласс расширяет MappingSqlQuery, параметризованный типом Actor.\nКонструктор для этого запроса клиента единственным параметром является DataSource.\nВ этом конструктор, вы можете вызвать конструктор суперкласса с помощью DataSource и SQL который следует запустить для получения строк для этого запроса."}
{"id": 760, "text": "Этот SQL используется для создайте `PreparedStatement`, чтобы он мог содержать заполнители для любых параметров, которые будут передано во время исполнения.\nВы должны объявить каждый параметр, используя `declareParameter` метод передачи `SqlParameter`. `SqlParameter` принимает имя и тип JDBC. как определено в `java.sql.Types`.\nПосле определения всех параметров вы можете вызвать `compile()`, чтобы оператор мог быть подготовлен и позже запущен.\nЭтот класс потокобезопасен после компиляции, поэтому, пока эти экземпляры создаются, когда DAO инициализируется, их можно сохранить как переменные экземпляра и использовать повторно.\nСледующие пример показывает, как определить такой класс:\nJava\n	private ActorMappingQuery actorMappingQuery;\n	@Autowired\n	public void setDataSource(DataSource dataSource) {\n		this.actorMappingQuery = new ActorMappingQuery(dataSource);\n	public Actor getActor(Long id) {\n		return actorMappingQuery.findObject(id);\nИспользование MappingSqlQuery.\nМетод в предыдущем примере извлекает актера с идентификатором, который передается в качестве единственный параметр.\nПоскольку мы хотим, чтобы возвращался только один объект, мы вызываем функцию findObject. метод с `id` в качестве параметра.\nЕсли бы вместо этого у нас был запрос, возвращающий список объектов и взяли дополнительные параметры, мы бы использовали один из `execute` методы, которые принимают массив значений параметров, передаваемых как переменные аргументы.\nСледующие пример показывает такой метод:\nJava"}
{"id": 761, "text": "public List<Actor> searchForActors(int age, String namePattern) {\n		return actorSearchMappingQuery.execute(age, namePattern);\nИспользование `SqlUpdate`.\nКласс SqlUpdate инкапсулирует обновление SQL.\nКак и в случае с запросом, объект обновления можно использовать повторно, и, как и все классы RdbmsOperation, обновление может иметь параметры и определено в SQL.\nЭтот класс предоставляет ряд методов `update(..)`, аналогичных методу `execute(..)` методы объектов запроса.\nКласс SqlUpdate является конкретным.\nЭто может быть подклассы — например, чтобы добавить собственный метод обновления.\nОднако вам не обязательно создавать подкласс SqlUpdate. класс, поскольку его можно легко параметризовать, задав SQL и объявив параметры.\nВ следующем примере создается пользовательский метод обновления с именем «execute»:\nJava\n	import java.sql.Types;\n	import javax.sql.DataSource;\n	import org.springframework.jdbc.core.SqlParameter;\n	import org.springframework.jdbc.object.SqlUpdate;\n	public class UpdateCreditRating extends SqlUpdate {\n		public UpdateCreditRating(DataSource ds) {\n			setDataSource(ds);\n			setSql(\"update customer set credit_rating = ? where id = ?\");\n			declareParameter(new SqlParameter(\"creditRating\", Types.NUMERIC));\n			declareParameter(new SqlParameter(\"id\", Types.NUMERIC));\n			compile();\n		 * @param идентификатор Клиента, который будет обновлен."}
{"id": 762, "text": "* @param rating the new value for credit rating\n		 * @return number of rows updated\n		public int execute(int id, int rating) {\n			return update(rating, id);\n		init {\n			setDataSource(ds)\n			sql = \"update customer set credit_rating = ? where id = ?\"\n			declareParameter(SqlParameter(\"creditRating\", Types.NUMERIC))\n			declareParameter(SqlParameter(\"id\", Types.NUMERIC))\n			compile()\nИспользование StoredProcedure.\nКласс StoredProcedure — это «абстрактный» суперкласс для абстракций объектов СУБД. хранимые процедуры.\nИспользование StoredProcedure.\nУнаследованное свойство sql — это имя хранимой процедуры в СУБД.\nИспользование StoredProcedure.\nЧтобы определить параметр для класса StoredProcedure, вы можете использовать SqlParameter или один своих подклассов.\nВ конструкторе необходимо указать имя параметра и тип SQL, как показано в следующем фрагменте кода:\nJava\n	new SqlParameter(\"in_id\", Types.NUMERIC),\n	new SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n	SqlParameter(\"in_id\", Types.NUMERIC),\n	SqlOutParameter(\"out_first_name\", Types.VARCHAR),\nИспользование StoredProcedure.\nТип SQL указывается с помощью констант java.sql.Types.\nИспользование StoredProcedure.\nПервая строка (с `SqlParameter`) объявляет параметр IN."}
{"id": 763, "text": "Вы можете использовать параметры IN как для вызовов хранимых процедур, так и для запросов с использованием `SqlQuery` и его подклассы (описаны в документе Понимание `SqlQuery`).\nИспользование StoredProcedure.\nВторая строка (с `SqlOutParameter`) объявляет параметр `out`, который будет использоваться в вызов хранимой процедуры.\nСуществует также SqlInOutParameter для параметров InOut. (параметры, которые передают процедуре значение in и которые также возвращают значение).\nИспользование StoredProcedure.\nДля параметров `in` помимо имени и типа SQL можно указать масштаб для числовых данных или имя типа для пользовательских типов баз данных.\nДля параметров `out`, вы можете предоставить RowMapper для обработки сопоставления строк, возвращаемых курсором REF.\nДругой вариант — указать SqlReturnType, который позволит вам определять индивидуальные обработка возвращаемых значений.\nИспользование StoredProcedure.\nСледующий пример простого DAO использует StoredProcedure для вызова функции. (`sysdate()`), который поставляется с любой базой данных Oracle.\nИспользование хранимой процедуры функциональность, вам необходимо создать класс, расширяющий `StoredProcedure`.\nВ этом Например, класс StoredProcedure является внутренним классом.\nОднако если вам необходимо повторно использовать `StoredProcedure`, вы можете объявить его как класс верхнего уровня.\nВ этом примере нет входных данных параметры, но выходной параметр объявляется как тип даты с помощью Класс SqlOutParameter.\nМетод `execute()` запускает процедуру и извлекает возвращенная дата из результатов `Карта`."}
{"id": 764, "text": "В «Карте» результатов есть запись для каждого объявленного выходной параметр (в данном случае только один), используя имя параметра в качестве ключа.\nВ следующем листинге показан наш собственный класс StoredProcedure:\nJava\n	import java.sql.Types;\n	import java.util.Date;\n	import java.util.HashMap;\n	import java.util.Map;\n	import javax.sql.DataSource;\n	import org.springframework.beans.factory.annotation.Autowired;\n	import org.springframework.jdbc.core.SqlOutParameter;\n	import org.springframework.jdbc.object.StoredProcedure;\n	public class StoredProcedureDao {\n		private GetSysdateProcedure getSysdate;\n		@Autowired\n		public void init(DataSource dataSource) {\n			this.getSysdate = new GetSysdateProcedure(dataSource);\n		public Date getSysdate() {\n			return getSysdate.execute();\n		private class GetSysdateProcedure extends StoredProcedure {\n			private static final String SQL = \"sysdate\";\n			public GetSysdateProcedure(DataSource dataSource) {\n				setDataSource(dataSource);\n				setFunction(true);\n				setSql(SQL);\n				declareParameter(new SqlOutParameter(\"date\", Types.DATE));\n				compile();\n			public Date execute() {\n				// процедура 'sysdate' не имеет входных параметров, поэтому остается пустая карта...\n				Map<String, Object> results = execute(new HashMap<String, Object>());"}
{"id": 765, "text": "Date sysdate = (Date) results.get(\"date\");\n				return sysdate;\n	class StoredProcedureDao(dataSource: DataSource) {\n			init {\n				setDataSource(dataSource)\n				isFunction = true\n				sql = SQL\n				declareParameter(SqlOutParameter(\"date\", Types.DATE))\n				compile()\nИспользование StoredProcedure.\nСледующий пример StoredProcedure имеет два выходных параметра (в данном случае: Курсоры Oracle REF):\nJava\n	import java.util.HashMap;\n	import java.util.Map;\n	import javax.sql.DataSource;\n	import oracle.jdbc.OracleTypes;\n	import org.springframework.jdbc.core.SqlOutParameter;\n	import org.springframework.jdbc.object.StoredProcedure;\n	public class TitlesAndGenresStoredProcedure extends StoredProcedure {\n		private static final String SPROC_NAME = \"AllTitlesAndGenres\";\n		public TitlesAndGenresStoredProcedure(DataSource dataSource) {\n			super(dataSource, SPROC_NAME);\n			declareParameter(new SqlOutParameter(\"titles\", OracleTypes.CURSOR, new TitleMapper()));\n			declareParameter(new SqlOutParameter(\"genres\", OracleTypes.CURSOR, new GenreMapper()));\n			compile();\n		public Map<String, Object> execute() {\n			// опять же, у этой процедуры нет входных параметров, поэтому предоставляется пустая карта\n			return super.execute(new HashMap<String, Object>());\n		init {"}
{"id": 766, "text": "declareParameter(SqlOutParameter(\"titles\", OracleTypes.CURSOR, TitleMapper()))\n			declareParameter(SqlOutParameter(\"genres\", OracleTypes.CURSOR, GenreMapper()))\n			compile()\nИспользование StoredProcedure.\nОбратите внимание, как перегруженные варианты метода DeclareParameter(..)`, которые были используемые в конструкторе TitlesAndGenresStoredProcedure, передаются RowMapper. экземпляры реализации.\nЭто очень удобный и мощный способ повторного использования существующих функциональность.\nСледующие два примера предоставляют код для двух реализаций RowMapper.\nИспользование StoredProcedure.\nКласс TitleMapper сопоставляет ResultSet с объектом домена Title для каждой строки в предоставленный `ResultSet`, как показано ниже:\nJava\n	import java.sql.ResultSet;\n	import java.sql.SQLException;\n	import com.foo.domain.Title;\n	import org.springframework.jdbc.core.RowMapper;\n	public final class TitleMapper implements RowMapper<Title> {\n		public Title mapRow(ResultSet rs, int rowNum) throws SQLException {\n			Title title = new Title();\n			title.setId(rs.getLong(\"id\"));\n			title.setName(rs.getString(\"name\"));\n			return title;\n	class TitleMapper : RowMapper<Title> {\nИспользование StoredProcedure.\nКласс GenreMapper сопоставляет ResultSet с объектом домена Genre для каждой строки в предоставленный `ResultSet`, как показано ниже:\nJava\n	import java.sql.ResultSet;\n	import java.sql.SQLException;"}
{"id": 767, "text": "import com.foo.domain.Genre;\n	import org.springframework.jdbc.core.RowMapper;\n	public final class GenreMapper implements RowMapper<Genre> {\n		public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {\n			return new Genre(rs.getString(\"name\"));\n	class GenreMapper : RowMapper<Genre> {\nИспользование StoredProcedure.\nЧтобы передать параметры хранимой процедуре, которая имеет один или несколько входных параметров в своей определения в СУБД, вы можете запрограммировать строго типизированный метод `execute(..)`, который бы делегируйте нетипизированный метод `execute(Map)` в суперклассе, как показано в следующем примере:\nJava\n	import java.sql.Types;\n	import java.util.Date;\n	import java.util.HashMap;\n	import java.util.Map;\n	import javax.sql.DataSource;\n	import oracle.jdbc.OracleTypes;\n	import org.springframework.jdbc.core.SqlOutParameter;\n	import org.springframework.jdbc.core.SqlParameter;\n	import org.springframework.jdbc.object.StoredProcedure;\n	public class TitlesAfterDateStoredProcedure extends StoredProcedure {\n		private static final String SPROC_NAME = \"TitlesAfterDate\";\n		private static final String CUTOFF_DATE_PARAM = \"cutoffDate\";\n		public TitlesAfterDateStoredProcedure(DataSource dataSource) {\n			super(dataSource, SPROC_NAME);\n			declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);"}
{"id": 768, "text": "declareParameter(new SqlOutParameter(\"titles\", OracleTypes.CURSOR, new TitleMapper()));\n			compile();\n		public Map<String, Object> execute(Date cutoffDate) {\n			Map<String, Object> inputs = new HashMap<String, Object>();\n			inputs.put(CUTOFF_DATE_PARAM, cutoffDate);\n			return super.execute(inputs);\n		init {\n			declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types.DATE))\n			declareParameter(SqlOutParameter(\"titles\", OracleTypes.CURSOR, TitleMapper()))\n			compile()"}
{"id": 769, "text": "Оператор Элвиса (`?:`) является сокращением синтаксиса троичного оператора и используется в язык https://www.groovy-lang.org/operators.html#_elvis_operator[Groovy].\nС синтаксис тернарного оператора, вам часто приходится повторять переменную дважды, как в следующем примере Java: пример показывает:\n	String name = \"Elvis Presley\";\n	String displayName = (name != null ? name : \"Unknown\");\nОператор Элвиса.\nВместо этого вы можете использовать оператор Элвиса (названный в честь сходства с прической Элвиса).\nВ следующем примере показано, как использовать оператор Элвиса в выражении SpEL:\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	String name = parser.parseExpression(\"name ?: 'Unknown'\").getValue(new Inventor(), String.class);\n	System.out.println(name);  // 'Unknown'\nОператор Элвиса. [ПРИМЕЧАНИЕ] = Оператор SpEL Elvis также рассматривает _пустую_ строку как нулевой объект.\nТаким образом, исходный пример Java лишь близок к эмуляции семантики оператора: он бы необходимо использовать `name!= null &&!name.isEmpty()` в качестве предиката для совместимости с семантика оператора SpEL Элвиса.\nОператор Элвиса. [СОВЕТ] = Начиная с Spring Framework 7.0, оператор SpEL Elvis поддерживает java.util.Optional с прозрачная семантика развертывания.\nОператор Элвиса."}
{"id": 770, "text": "Например, учитывая выражение `A?: B`, если `A` имеет значение null или _empty_ `Optional`, выражение оценивается как `B`.\nОднако, если `A` является непустым `Необязательным`, выражение оценивает объект, содержащийся в `Optional`, тем самым эффективно разворачивая `Необязательный`, который соответствует `A.get()`.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\n	String name = parser.parseExpression(\"name ?: 'Elvis Presley'\").getValue(context, tesla, String.class);\n	System.out.println(name);  // Nikola Tesla\n	tesla.setName(\"\");\n	name = parser.parseExpression(\"name ?: 'Elvis Presley'\").getValue(context, tesla, String.class);\n	System.out.println(name);  // Elvis Presley\nВ следующем листинге показан более сложный пример:. [СОВЕТ] = Вы можете использовать оператор Элвиса для применения значений по умолчанию в выражениях.\nСледующие пример показывает, как использовать оператор Элвиса в выражении @Value:\n	@Value(\"#{systemProperties['pop3.port'] ?: 25}\")"}
{"id": 771, "text": "В следующем листинге показан более сложный пример:.\nЭто внедрит значение системного свойства с именем pop3.port, если оно определено или `25`, если свойство не определено."}
{"id": 772, "text": "Оператор безопасной навигации (`?.`) используется, чтобы избежать `NullPointerException` и появляется из https://www.groovy-lang.org/operators.html#_safe_navigation_operator[Groovy] язык.\nОбычно, когда у вас есть ссылка на объект, вам может потребоваться проверить что оно не равно null перед доступом к методам или свойствам объекта.\nЧтобы избежать при этом оператор безопасной навигации возвращает `null` для конкретной нулевой безопасной операции. вместо того, чтобы генерировать исключение.\nОператор безопасной навигации. [ВНИМАНИЕ] = Когда оператор безопасной навигации оценивает значение null для определенного нулевого безопасного операции внутри составного выражения, оставшаяся часть составного выражения будет еще оценить.\nОператор безопасной навигации.\nПодробности см. в разделе <<выражения-оператор-безопасные-навигационные-составные-выражения>>.\nБезопасный доступ к свойствам и методам.\nВ следующем примере показано, как использовать оператор безопасной навигации для доступа к свойствам. (`?.`).\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\n	tesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n	// оценивается как «Смилян»\n	String city = parser.parseExpression(\"placeOfBirth?.city\") // <1>"}
{"id": 773, "text": ".getValue(context, tesla, String.class);\n	tesla.setPlaceOfBirth(null);\n	// измерение происходит как null – заключение NullPointerException не выдается\n	city = parser.parseExpression(\"placeOfBirth?.city\") // <2>\n			.getValue(context, tesla, String.class);\nБезопасный доступ к свойствам и методам. <1> Используйте оператор безопасной навигации для ненулевого свойства PlaceOfBirth. <2> Используйте оператор безопасной навигации для нулевого свойства PlaceOfBirth.\n	tesla.setPlaceOfBirth(null)\nБезопасный доступ к свойствам и методам. <1> Используйте оператор безопасной навигации для ненулевого свойства PlaceOfBirth. <2> Используйте оператор безопасной навигации для нулевого свойства PlaceOfBirth.\nБезопасный доступ к свойствам и методам. [ПРИМЕЧАНИЕ] = Оператор безопасной навигации также применяется к вызовам методов объекта.\nБезопасный доступ к свойствам и методам.\nFor example, the expression `#calculator?.max(4, 2)` evaluates to `null` if the Переменная `#calculator` не настроена в контексте.\nВ противном случае `max(int, int)` method will be invoked on the `#calculator`.\nБезопасный доступ к индексу.\nНачиная с Spring Framework 6.2, язык выражений Spring поддерживает безопасную навигацию по индексация в следующие типы структур.\n* arrays and collections\n* strings\n* maps\n* objects\n* custom\nБезопасный доступ к индексу."}
{"id": 774, "text": "В следующем примере показано, как использовать оператор безопасной навигации для индексации в список (`?.[]`).\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	IEEE society = new IEEE();\n	EvaluationContext context = new StandardEvaluationContext(society);\n	// оценивается как Inventor («Никола Тесла»)\n	Inventor inventor = parser.parseExpression(\"members?.[0]\") // <1>\n			.getValue(context, Inventor.class);\n	society.members = null;\n	// оценивается как ноль - не генерирует исключение\n	inventor = parser.parseExpression(\"members?.[0]\") // <2>\n			.getValue(context, Inventor.class);\nБезопасный доступ к индексу. <1> Использовать нулевой оператор индекса для непустого списка `членов` <2> Использовать нулевой оператор индекса для нулевого списка `членов`\n	society.members = null\nБезопасный доступ к индексу. <1> Использовать нулевой оператор индекса для непустого списка `членов` <2> Использовать нулевой оператор индекса для нулевого списка `членов`\nБезопасный выбор и прогнозирование коллекций.\nЯзык выражений Spring поддерживает безопасную навигацию по следующие операторы.\n* нулевой безопасный выбор: `?.?`\n* сначала выберите null-safe: `?.^`\n* нулевой выбор последнего: `?.$`"}
{"id": 775, "text": "* нулевая безопасная проекция: `?.!`\nБезопасный выбор и прогнозирование коллекций.\nВ следующем примере показано, как использовать оператор безопасной навигации для сбора данных. выбор (`?.?`).\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	IEEE society = new IEEE();\n	StandardEvaluationContext context = new StandardEvaluationContext(society);\n	String expression = \"members?.?[nationality == 'Serbian']\"; // <1>\n	// оценивается как [Изобретатель(\"Никола Тесла\")]\n	List<Inventor> list = (List<Inventor>) parser.parseExpression(expression)\n			.getValue(context);\n	society.members = null;\n	// измерение происходит как ноль – заключение NullPointerException не выдается\n	list = (List<Inventor>) parser.parseExpression(expression)\n			.getValue(context);\n	society.members = null\n	// измерение происходит как ноль – заключение NullPointerException не выдается\n	list = parser.parseExpression(expression)\n			.getValue(context) as List<Inventor>\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`.\nВ следующем примере показано, как использовать оператор «сначала выбрать с нулевой безопасностью» для коллекции (`?.^`).\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	IEEE society = new IEEE();"}
{"id": 776, "text": "StandardEvaluationContext context = new StandardEvaluationContext(society);\n	String expression =\n		\"members?.^[nationality == 'Serbian' || nationality == 'Idvor']\"; // <1>\n	// оценивается как Inventor («Никола Тесла»)\n	Inventor inventor = parser.parseExpression(expression)\n			.getValue(context, Inventor.class);\n	society.members = null;\n	// измерение происходит как ноль – заключение NullPointerException не выдается\n	inventor = parser.parseExpression(expression)\n			.getValue(context, Inventor.class);\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «сначала нулевой выбор» в потенциально нулевом списке «членов».\n	society.members = null\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «сначала нулевой выбор» в потенциально нулевом списке «членов».\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`.\nВ следующем примере показано, как использовать оператор «нулевой выбор последнего» для коллекции (`?.$`).\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	IEEE society = new IEEE();\n	StandardEvaluationContext context = new StandardEvaluationContext(society);\n	String expression ="}
{"id": 777, "text": "\"members?.$[nationality == 'Serbian' || nationality == 'Idvor']\"; // <1>\n	// оценивается как Inventor(\"Pupin\")\n	Inventor inventor = parser.parseExpression(expression)\n			.getValue(context, Inventor.class);\n	society.members = null;\n	// измерение происходит как ноль – заключение NullPointerException не выдается\n	inventor = parser.parseExpression(expression)\n			.getValue(context, Inventor.class);\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «нулевой выбор последнего» в потенциально нулевом списке «членов».\n	society.members = null\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать оператор «нулевой выбор последнего» в потенциально нулевом списке «членов».\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`.\nВ следующем примере показано, как использовать оператор безопасной навигации для сбора данных. проекция (`?.!`).\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	IEEE society = new IEEE();\n	StandardEvaluationContext context = new StandardEvaluationContext(society);\n	// оценивается как [\"Смилян\", \"Идвор\"]"}
{"id": 778, "text": "List placesOfBirth = parser.parseExpression(\"members?.![placeOfBirth.city]\") // <1>\n			.getValue(context, List.class);\n	society.members = null;\n	// измерение происходит как ноль – заключение NullPointerException не выдается\n	placesOfBirth = parser.parseExpression(\"members?.![placeOfBirth.city]\") // <2>\n			.getValue(context, List.class);\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать нулевой оператор проекции для ненулевого списка `членов` <2> Использовать нулевой оператор проекции для нулевого списка `членов`\n	society.members = null\n<1> Использовать нулевой оператор выбора для потенциально нулевого списка `членов`. <1> Использовать нулевой оператор проекции для ненулевого списка `членов` <2> Использовать нулевой оператор проекции для нулевого списка `членов`\nБезопасные операции с параметрами «Необязательно».\nНачиная с Spring Framework 7.0, нулевые операции поддерживаются в экземплярах `java.util.Optional` с прозрачной семантикой развертывания.\nБезопасные операции с параметрами «Необязательно».\nВ частности, когда к _empty_ `Optional` применяется нулевой оператор, он будет рассматривается так, как если бы `Optional` был `null`, и последующая операция будет иметь значение `ноль`."}
{"id": 779, "text": "Однако если к непустому `Optional` применяется нулевой оператор, последующая операция будет применена к объекту, содержащемуся в `Optional`, тем самым эффективно разворачивая `Optional`.\nБезопасные операции с параметрами «Необязательно».\nНапример, если `user` имеет тип `Optional<User>`, выражение `user?.name` будет оценить значение `null`, если `user` имеет значение `null` или _empty_ `Optional`, и в противном случае будет вычислить имя пользователя, фактически `user.get().getName()` или `user.get().name` для доступа к свойству или полю соответственно.\nБезопасные операции с параметрами «Необязательно». [ПРИМЕЧАНИЕ] = Вызовы методов, определенных в `Optional` API, по-прежнему поддерживаются на _empty_. `Необязательно`.\nНапример, если `name` имеет тип `Optional<String>`, выражение `name?.orElse('Unknown')` будет иметь значение `\"Unknown\"`, если `name` является пустым `Optional` и в противном случае будет вычисляться как `String`, содержащаяся в `Optional`, если `name` является непустой `Optional`, фактически `name.get()`."}
{"id": 780, "text": "Безопасные операции с параметрами «Необязательно». // ПРИМЕЧАНИЕ. ⁠ — символ Юникода «WORD JOINER», который является нежелательным переносом строки.\nБезопасные операции с параметрами «Необязательно».\nАналогично, если `names` имеет тип `Optional<List<String>>`, выражение `names?.?⁠[#this.length > 5]` будет иметь значение `null`, если `names` имеет значение `null` или _empty_ `Необязательно` и в противном случае будет оценивать последовательность, содержащую имена, длина которых больше 5, эффективно `names.get().stream().filter(s -> s.length() > 5).toList()`.\nБезопасные операции с параметрами «Необязательно».\nТа же семантика применима ко всем операторам нулевой безопасности, упомянутым ранее в этом документе. глава.\nБезопасные операции с параметрами «Необязательно».\nДля получения дополнительной информации и примеров обратитесь к javadoc для следующих операторов.\n* {spring-framework-api}/expression/spel/ast/PropertyOrFieldReference.html[`PropertyOrFieldReference`]\n* {spring-framework-api}/expression/spel/ast/MethodReference.html[`MethodReference`]\n* {spring-framework-api}/expression/spel/ast/Indexer.html[`Indexer`]"}
{"id": 781, "text": "* {spring-framework-api}/expression/spel/ast/Selection.html[`Selection`]\n* {spring-framework-api}/expression/spel/ast/Projection.html[`Projection`]\nБезопасные операции в составных выражениях.\nКак упоминалось в начале этого раздела, когда оператор безопасной навигации оценивается как `null` для конкретной операции, безопасной для нулевых значений, в составном выражении, оставшаяся часть составного выражения все равно будет оценена.\nЭто означает, что оператор безопасной навигации должен применяться во всем составном выражении, чтобы избегайте нежелательных исключений NullPointerException.\nБезопасные операции в составных выражениях.\nУчитывая выражение `#person?.address.city`, если `#person` имеет значение `null`, безопасная навигация оператор (`?.`) гарантирует, что при попытке доступа к Свойство `address` `#person`.\nОднако, поскольку `#person?.address` имеет значение null, `NullPointerException` будет выброшено при попытке доступа к свойству `city` `ноль`.\nЧтобы решить эту проблему, вы можете применить нулевую безопасную навигацию по всему соединению. выражение типа `#person?.address?.city`.\nЭто выражение будет безопасно оценено как `null` если значение `#person` или `#person?.address` равно `null`.\nБезопасные операции в составных выражениях."}
{"id": 782, "text": "В следующем примере показано, как использовать оператор «сначала выбрать с нулевой безопасностью». (`?.^`) в коллекции в сочетании с нулевым доступом к свойствам (`?.`) внутри составного соединения выражение.\nЕсли `members` имеет значение `null`, это результат оператора \"сначала выбрать с нулевой безопасностью\". (`members?.^[национальность == 'Сербский']`) оценивается как `null`, и дополнительное использование оператор безопасной навигации (`?.name`) гарантирует, что все составное выражение оценивается как null вместо выдачи исключения.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	IEEE society = new IEEE();\n	StandardEvaluationContext context = new StandardEvaluationContext(society);\n	String expression = \"members?.^[nationality == 'Serbian']?.name\"; // <1>\n	// оценивается как «Никола Тесла»\n	String name = parser.parseExpression(expression)\n			.getValue(context, String.class);\n	society.members = null;\n	// измерение происходит как ноль – заключение NullPointerException не выдается\n	name = parser.parseExpression(expression)\n			.getValue(context, String.class);\nБезопасные операции в составных выражениях. <1> Используйте операторы доступа к свойствам с нулевой безопасностью «сначала выбор» и нулевые операторы доступа к свойствам в составном выражении."}
{"id": 783, "text": "society.members = null\nБезопасные операции в составных выражениях. <1> Используйте операторы доступа к свойствам с нулевой безопасностью «сначала выбор» и нулевые операторы доступа к свойствам в составном выражении."}
{"id": 784, "text": "Тернарный оператор (если-то-иначе).\nВы можете использовать тернарный оператор для выполнения условной логики if-then-else внутри выражение.\nВ следующем листинге показан минимальный пример:\nJava\n	String falseString = parser.parseExpression(\n			\"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\nТернарный оператор (если-то-иначе).\nВ этом случае логическое значение false возвращает строковое значение falseExp.\nБолее реалистичный пример следующий:\nJava\n	parser.parseExpression(\"name\").setValue(societyContext, \"IEEE\");\n	societyContext.setVariable(\"queryName\", \"Nikola Tesla\");\n	expression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" +\n			\"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\";\n	String queryResultString = parser.parseExpression(expression)\n			.getValue(societyContext, String.class);\n	// queryResultString = \"Никола Тесла является членом общества IEEE\"\n	parser.parseExpression(\"name\").setValue(societyContext, \"IEEE\")\n	societyContext.setVariable(\"queryName\", \"Nikola Tesla\")"}
{"id": 785, "text": "expression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" + \"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\"\nТернарный оператор (если-то-иначе).\nСм. следующий раздел, посвященный оператору Элвиса, где приведен еще более короткий синтаксис тернарный оператор."}
{"id": 786, "text": "* Операторы отношения\n* Логические операторы\n* Строковые операторы\n* Математические операторы\n* Оператор присваивания\n* Перегруженные операторы\nРеляционные операторы.\nОператоры отношения (равно, не равно, меньше, меньше или равно, больше, и больше или равно) поддерживаются с использованием стандартной записи оператора.\nЭти операторы работают с типами Number, а также с типами, реализующими Comparable.\nВ следующем листинге показано несколько примеров реляционных операторов:\nJava\n	// оценивается как правда\n	boolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n	// оценивается как ложь\n	boolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n	// оценивается как правда\n	boolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n	// использует CustomValue:::compareTo\n	boolean trueValue = parser.parseExpression(\"new CustomValue(1) < new CustomValue(2)\").getValue(Boolean.class);\nРеляционные операторы. [ПРИМЕЧАНИЕ] = Сравнения \"больше\" и \"меньше\" с `null` следуют простому правилу: `null` рассматривается как ничего (это НЕ равно нулю)."}
{"id": 787, "text": "Как следствие, любое другое значение всегда больше чем `null` (`X > null` всегда `true`), и никакое другое значение не может быть меньше нуля. («X < null» всегда имеет значение «false»).\nРеляционные операторы.\nЕсли вместо этого вы предпочитаете числовые сравнения, избегайте числовых сравнений с нулевым значением. в пользу сравнения с нулем (например, `X > 0` или `X < 0`).\nРеляционные операторы.\nКаждый символьный оператор также может быть указан как чисто текстовый эквивалент.\nЭто позволяет избежать проблемы, в которых используемые символы имеют особое значение для типа документа, в котором выражение встроено (например, в XML-документ).\nТекстовые эквиваленты:\n* `lt` (`<`)\n* `gt` (`>`)\n* `le` (`\\<=`)\n* `ge` (`>=`)\n* `eq` (`==`)\n* `не` (`!=`)\nРеляционные операторы.\nВсе текстовые операторы нечувствительны к регистру.\nРеляционные операторы.\nПомимо стандартных операторов отношений, SpEL поддерживает операторы «между», `instanceof` и операторы `match` на основе регулярных выражений.\nСледующий список показаны примеры всех трех:\nJava\n	boolean result;\n	// оценивается как правда\n	result = parser.parseExpression("}
{"id": 788, "text": "\"1 between {1, 5}\").getValue(Boolean.class);\n	// оценивается как ложь\n	result = parser.parseExpression(\n			\"1 between {10, 15}\").getValue(Boolean.class);\n	// оценивается как правда\n	result = parser.parseExpression(\n			\"'elephant' between {'aardvark', 'zebra'}\").getValue(Boolean.class);\n	// оценивается как ложь\n	result = parser.parseExpression(\n			\"'elephant' between {'aardvark', 'cobra'}\").getValue(Boolean.class);\n	// оценивается как правда\n	result = parser.parseExpression(\n			\"123 instanceof T(Integer)\").getValue(Boolean.class);\n	// оценивается как ложь\n	result = parser.parseExpression(\n			\"'xyz' instanceof T(Integer)\").getValue(Boolean.class);\n	// оценивается как правда\n	result = parser.parseExpression(\n			\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n	// оценивается как ложь\n	result = parser.parseExpression("}
{"id": 789, "text": "\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\nРеляционные операторы. [ВНИМАНИЕ] = Синтаксис оператора `between`: `<input> между {<range_begin>, <range_end>}`, что фактически является ярлыком для `<input> >= <range_begin> && <input> \\<= <range_end>}`.\nРеляционные операторы.\nСледовательно, `1 между {1, 5}` оценивается как `истина`, а `1 между {5, 1}` оценивается как `истина`. на «ложь».\nРеляционные операторы.\nВНИМАНИЕ: Будьте осторожны с примитивными типами, так как они сразу же упаковываются в соответствующие места. типы оберток.\nНапример, `1 экземпляр T(int)` оценивается как `false`, а `1 экземпляр T(Integer)` оценивается как `истина`.\n* `и` (`&&`)\n* `или` (`||`)\n* `не` (`!`)\nSpEL поддерживает следующие логические («логические») операторы:.\nВсе текстовые операторы нечувствительны к регистру.\nJava\n	// -- И --\n	// оценивается как ложь"}
{"id": 790, "text": "boolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n	// оценивается как правда\n	String expression = \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\n	boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n	// -- OR --\n	// оценивается как правда\n	boolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n	// оценивается как правда\n	String expression = \"isMember('Nikola Tesla') or isMember('Albert Einstein')\";\n	boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n	// -- НЕТ --\n	// оценивается как ложь\n	boolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n	// -- И и НЕ --\n	String expression = \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\n	boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n	// -- И --\n	// -- OR --\n	// -- НЕТ --\n	// -- И и НЕ --\nСтроковые операторы."}
{"id": 791, "text": "Вы можете использовать следующие операторы в строках.\n* конкатенация (`+`)\n* вычитание (`-`)\n  - для использования со строкой, содержащей один символ\n* повторить (`*`)\nJava\n	// -- Конкатенация --\n	// оценивается как «привет, мир»\n	String helloWorld = parser.parseExpression(\"'hello' + ' ' + 'world'\")\n			.getValue(String.class);\n	// -- Вычитание символов --\n	// оценивается как «а»\n	char ch = parser.parseExpression(\"'d' - 3\")\n			.getValue(char.class);\n	// -- Повторить --\n	// оценивается как «abcabc»\n	String repeated = parser.parseExpression(\"'abc' * 2\")\n			.getValue(String.class);\n	// -- Конкатенация --\n	// -- Вычитание символов --\n	// -- Повторить --\nМатематические операторы.\nВы можете использовать следующие операторы для чисел, при этом применяется стандартный приоритет операторов.\n* дополнение (`+`)\n* вычитание (`-`)\n* приращение (`{pp}`)\n* декремент (`--`)\n* умножение (`*`)\n* деление (`/`)\n* модуль (`%`)\n* экспоненциальная степень (`^`)"}
{"id": 792, "text": "Математические операторы.\nОператоры деления и модуля также можно указать как чисто текстовый эквивалент.\nЭто позволяет избежать проблем, когда используемые символы имеют особое значение для типа документа в который встроено выражение (например, в XML-документ).\nТекстовые эквиваленты являются:\n* `div` (`/`)\n* `мод` (`%`)\nМатематические операторы.\nВсе текстовые операторы нечувствительны к регистру.\nМатематические операторы. [ПРИМЕЧАНИЕ] = Операторы увеличения и уменьшения можно использовать либо с префиксом (`{pp}A`, `--A`), либо с постфиксная (`A{pp}`, `A--`) нотация с переменными или свойствами, в которые можно записывать.\nJava\n	Inventor inventor = new Inventor();\n	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n	// -- Добавление --\n	int two = parser.parseExpression(\"1 + 1\").getValue(int.class);  // 2\n	// -- Вычитание --\n	int four = parser.parseExpression(\"1 - -3\").getValue(int.class);  // 4\n	double d = parser.parseExpression(\"1000.00 - 1e4\").getValue(double.class);  // -9000\n	// -- Приращение --"}
{"id": 793, "text": "// Свойство счетчика в Inventor имеет начальное значение 0.\n	// оценивается как 2; счетчик теперь равен 1\n	two = parser.parseExpression(\"counter++ + 2\").getValue(context, inventor, int.class);\n	// оценивается как 5; счетчик теперь равен 2\n	int five = parser.parseExpression(\"3 + ++counter\").getValue(context, inventor, int.class);\n	// -- Уменьшение --\n	// Свойство счетчика в Inventor имеет значение 2.\n	// оценивается как 6; счетчик теперь равен 1\n	int six = parser.parseExpression(\"counter-- + 4\").getValue(context, inventor, int.class);\n	// оценивается как 5; счетчик теперь равен 0\n	five = parser.parseExpression(\"5 + --counter\").getValue(context, inventor, int.class);\n	// -- Умножение --\n	six = parser.parseExpression(\"-2 * -3\").getValue(int.class);  // 6\n	double twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(double.class);  // 24.0\n	// -- Разделение --"}
{"id": 794, "text": "int minusTwo = parser.parseExpression(\"6 / -3\").getValue(int.class);  // -2\n	double one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(double.class);  // 1.0\n	// -- Модуль --\n	int three = parser.parseExpression(\"7 % 4\").getValue(int.class);  // 3\n	int oneInt = parser.parseExpression(\"8 / 5 % 2\").getValue(int.class);  // 1\n	// -- Экспоненциальная мощность --\n	int maxInt = parser.parseExpression(\"(2^31) - 1\").getValue(int.class);  // Integer.MAX_VALUE\n	int minInt = parser.parseExpression(\"-2^31\").getValue(int.class);  // Integer.MIN_VALUE\n	// -- Приоритет оператора --\n	int minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(int.class);  // -21\n	// -- Добавление --\n	// -- Вычитание --\n	// -- Приращение --\n	// Свойство счетчика в Inventor имеет начальное значение 0.\n	// -- Уменьшение --"}
{"id": 795, "text": "// Свойство счетчика в Inventor имеет значение 2.\n	// -- Умножение --\n	// -- Разделение --\n	// -- Модуль --\n	// -- Экспоненциальная мощность --\n	// -- Приоритет оператора --\nОператор присваивания.\nЧтобы установить свойство, используйте оператор присваивания (`=`).\nОбычно это делается в течение вызов setValue, но это также можно сделать внутри вызова getValue.\nСледующие В листинге показаны оба способа использования оператора присваивания:\nJava\n	Inventor inventor = new Inventor();\n	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n	parser.parseExpression(\"name\").setValue(context, inventor, \"Aleksandar Seovic\");\n	// альтернативно\n	String aleks = parser.parseExpression(\n			\"name = 'Aleksandar Seovic'\").getValue(context, inventor, String.class);\n	parser.parseExpression(\"name\").setValue(контекст, изобретатель, \"Александар Сеович\")\nПерегруженные операторы.\nПо умолчанию математические операции, определенные в перечислении Operation в SpEL («ADD», SUBTRACT, DIVIDE, MULTIPLY, MODULUS и POWER) поддерживают простые типы, такие как цифры.\nПредоставляя реализацию «OperatorOverloader», язык выражений может поддерживать эти операции на других типах.\nПерегруженные операторы."}
{"id": 796, "text": "Например, если мы хотим перегрузить оператор `ADD`, чтобы разрешить соединение двух списков. объединенные с помощью знака `+`, мы можем реализовать собственный `OperatorOverloader` как следует.\n	pubic class ListConcatenation implements OperatorOverloader {\n		@Override\n		public boolean overridesOperation(Operation operation, Object left, Object right) {\n			return (operation == Operation.ADD &&\n					left instanceof List && right instanceof List);\n		@Override\n		@SuppressWarnings(\"unchecked\")\n		public Object operate(Operation operation, Object left, Object right) {\n			if (operation == Operation.ADD &&\n					left instanceof List list1 && right instanceof List list2) {\n				List result = new ArrayList(list1);\n				result.addAll(list2);\n				return result;\n			throw new UnsupportedOperationException(\n				\"No overload for operation %s and operands [%s] and [%s]\"\n					.formatted(operation, left, right));\nПерегруженные операторы.\nЕсли мы зарегистрируем ListConcatenation как OperatorOverloader в `StandardEvaluationContext`, мы можем затем оценить выражения типа `{1, 2, 3} + {4, 5}` как показано в следующем примере.\nJava\n	StandardEvaluationContext context = new StandardEvaluationContext();\n	context.setOperatorOverloader(new ListConcatenation());\n	// возвращает новый список: [1, 2, 3, 4, 5]"}
{"id": 797, "text": "parser.parseExpression(\"{1, 2, 3} + {2 + 2, 5}\").getValue(context, List.class);\n	StandardEvaluationContext context = StandardEvaluationContext()\n	context.setOperatorOverloader(ListConcatenation())\nПерегруженные операторы. [ПРИМЕЧАНИЕ] = ОператорOverloader не меняет семантику оператора по умолчанию.\nДля например, `2 + 2` в приведенном выше примере по-прежнему оценивается как `4`.\nПерегруженные операторы. [ВНИМАНИЕ] = Любое выражение, использующее перегруженный оператор, не может быть скомпилировано.\nСм. для получения подробной информации."}
{"id": 798, "text": "Доступ к данным реляционного сопоставления объектов (ORM).\nВ этом разделе рассматривается доступ к данным при использовании реляционного сопоставления объектов (ORM)."}
{"id": 799, "text": "1. Что такое Lilipup Framework. `Lilipup Framework` — это вымышленный, но реалистичный Java-фреймворк для построения модульных backend-сервисов с акцентом на предсказуемый lifecycle, безопасную интеграцию, наблюдаемость и удобную эксплуатацию в production.\n- контейнер компонентов и внедрение зависимостей;\n- централизованную конфигурацию;\n- валидацию данных и конфигов;\n- безопасность (аутентификация, авторизация, криптография);\n- встроенный scheduler;\n- интеграцию с Kafka;\n- мониторинг, метрики и structured logging.\n- фрагментированная инфраструктура (много библиотек без единого контракта);\n- runtime-ошибки из-за слабой валидации конфигурации;\n- сложный запуск/остановка сервисов и непредсказуемый lifecycle;\n- дублирование кода для retry, ошибок, проверок безопасности и метрик;\n- слабая операционная наблюдаемость и сложная отладка инцидентов.\nLilipup придуман как ответ на типичные проблемы реальных Java-проектов:.\nГлавная идея: дать команде единый framework-слой, где лучшие практики уже встроены и по умолчанию включают безопасные и эксплуатационно-устойчивые настройки.\n- запускать новые сервисы быстрее за счёт готовых модулей;\n- снижать количество production-инцидентов через обязательные проверки и fail-fast;\n- стандартизировать кодовую базу между командами;\n- сделать поведение приложения более предсказуемым при нагрузке и сбоях;\n- упростить поддержку DevOps/SRE за счёт встроенного мониторинга и telemetry.\n- быстрый bootstrap нового сервиса;\n- декларативная конфигурация и типобезопасный binding;\n- единые правила валидации и обработки ошибок;"}
{"id": 800, "text": "- минимизация boilerplate-кода.\n- контролируемый startup/readiness/shutdown;\n- встроенные retry/backoff/DLQ-подходы для интеграций;\n- единый формат метрик и логов для observability;\n- удобная диагностика причин деградации.\n- централизованные политики доступа;\n- предсказуемая аутентификация и авторизация;\n- безопасная работа с секретами и шифрованием;\n- аудит критичных операций.\n- Java backend-разработчики, строящие микросервисы и интеграционные сервисы;\n- архитекторы, которым нужен единый технический стандарт;\n- DevOps/SRE, которым важна прозрачная эксплуатация;\n- platform-команды, создающие внутреннюю инженерную платформу.\n6. Архитектурная идея. Lilipup строится вокруг `core` контейнера и расширяется модульно.\n- `Modular by design`: каждый capability в отдельном модуле;\n- `Fail fast`: критичные ошибки ловятся на старте;\n- `Secure by default`: deny-by-default, минимальные привилегии;\n- `Observable by default`: метрики, логи, трассировка из коробки;\n- `Operationally friendly`: graceful shutdown, retries, readiness.\n- нужен production-ready фреймворк с единым стилем разработки;\n- важна строгая дисциплина конфигурации и безопасности;\n- много интеграций (Kafka, внешние API, scheduled jobs);\n- важна высокая поддерживаемость в долгом жизненном цикле продукта.\n- проект экспериментальный и требует минимального runtime-слоя;\n- нужна только тонкая библиотека без framework-ограничений;"}
{"id": 801, "text": "- команда осознанно предпочитает полностью ручную сборку стека.\n- Всегда фиксируйте обязательные модули и их версии в BOM/родительском POM.\n- Всегда поднимайте smoke-среду с production-профилем перед релизом.\n- Проверяйте, что включены security-policy, audit и monitoring.\n- Проверяйте readiness/liveness и сценарии graceful shutdown.\n- Проводите нагрузочные и отказоустойчивые тесты ключевых интеграций.\n- Начинайте с минимального набора: `core + configuration + validation + monitoring`.\n- Добавляйте `kafka`, `scheduler`, `security` по мере зрелости сервиса.\n- Держите внутренний engineering guide с примерами «как в Lilipup принято».\n- Автоматизируйте проверки конфигурации и политики безопасности в CI.\n- Регулярно пересматривайте настройки retry/timeouts/alerts по фактической нагрузке."}
{"id": 802, "text": "Введение.\nВ этой главе описывается поддержка Spring Mapping Object-XML.\nОбъект-XML Сопоставление (сокращенно сопоставление OX) — это процесс преобразования XML-документа в и из него. объект.\nЭтот процесс преобразования также известен как маршалинг XML или XML.\nСериализация.\nВ этой главе эти термины используются взаимозаменяемо.\nВведение.\nВ области сопоставления OX маршаллер отвечает за сериализацию объект (график) в XML.\nАналогичным образом демаршаллер десериализует XML в граф объекта.\nЭтот XML может принимать форму документа DOM, входного или выходного файла. поток или обработчик SAX.\n* Простота настройки\n* Согласованные интерфейсы\n* Последовательная иерархия исключений\nПростота настройки.\nФабрика компонентов Spring позволяет легко настраивать маршаллеры без необходимости создавать контекст JAXB, фабрики привязки JiBX и т. д.\nВы можете настроить маршаллеры как и любой другой компонент в контексте вашего приложения.\nКроме того, основанное на пространстве имен XML конфигурация доступна для нескольких распределительных устройств, что делает конфигурацию даже проще.\nСогласованные интерфейсы.\nСопоставление OX в Spring работает через два глобальных интерфейса: {spring-framework-api}/oxm/Marshaller.html[`Marshaller`] и {spring-framework-api}/oxm/Unmarshaller.html[`Unmarshaller`].\nЭти абстракции позволяют переключать платформы сопоставления OX. с относительной легкостью, с небольшими изменениями или вообще без них в классах, которые выполняют сортировка."}
{"id": 803, "text": "Этот подход имеет дополнительное преимущество, позволяя выполнять XML маршалинг с использованием подхода «смешивай и сопоставляй» (например, некоторый маршалинг выполняется с использованием JAXB и некоторые от XStream) ненавязчивым образом, позволяя вам использовать возможности каждого технология.\nСогласованная иерархия исключений.\nSpring обеспечивает преобразование исключений из базового инструмента сопоставления OX в его собственная иерархия исключений с XmlMappingException в качестве корневого исключения.\nЭти исключения времени выполнения оборачивают исходное исключение, чтобы никакая информация не была потеряна.\n«Маршаллер» и «Анмаршаллер».\nКак указано в документе introduction, маршаллер сериализует объект. в XML, а демаршаллер десериализует поток XML в объект.\nВ этом разделе описываются два интерфейса Spring, используемые для этой цели.\nПонимание «Маршаллера».\nSpring абстрагирует все операции сортировки, стоящие за Интерфейс `org.springframework.oxm.Marshaller`, основной метод которого следующий:\n	public interface Marshaller {\n		 * Маршалируем граф объекта с заданным корнем в предоставленный результат.\n		void marshal(Object graph, Result result) throws XmlMappingException, IOException;\nПонимание «Маршаллера».\nИнтерфейс Marshaller имеет один основной метод, который маршалирует данный объект в учитывая `javax.xml.transform.Result`.\nРезультатом является интерфейс тегов, который по сути представляет абстракцию вывода XML.\nКонкретные реализации оборачивают различные XML представления, как показано в следующей таблице:"}
{"id": 804, "text": "| `StreamResult` | `java.io.File`, `java.io.OutputStream` или `java.io.Writer` |===.\nПРИМЕЧАНИЕ.\nХотя метод marshal() принимает в качестве первого параметра простой объект, большинство Реализации Marshaller не могут обрабатывать произвольные объекты.\nВместо этого класс объекта должен быть отображен в файле сопоставления, отмечен аннотацией, зарегистрирован в marshaller или иметь общий базовый класс.\nОбратитесь к последующим разделам этой главы. чтобы определить, как ваша технология OX справляется с этим.\nПонимание «Unmarshaller».\nПодобно Marshaller, у нас есть org.springframework.oxm.Unmarshaller. интерфейс, который показан в следующем листинге:\n	public interface Unmarshaller {\n		 * Демаршалируйте предоставленный исходный код в граф объекта.\n		Object unmarshal(Source source) throws XmlMappingException, IOException;\nПонимание «Unmarshaller».\nЭтот интерфейс также имеет один метод, который читает из заданного `javax.xml.transform.Source` (абстракция ввода XML) и возвращает прочитанный объект.\nКак с «Result», «Source» — это интерфейс тегов, который имеет три конкретные реализации.\nКаждый обертывает другое представление XML, как показано в следующей таблице:\n| `StreamSource` | `java.io.File`, `java.io.InputStream` или `java.io.Reader` |===."}
{"id": 805, "text": "Несмотря на то, что существует два отдельных интерфейса маршалинга («Marshaller» и `Unmarshaller`), все реализации в Spring-WS реализуют оба в одном классе.\nЭто означает, что вы можете подключить один класс маршаллера и обращаться к нему как к маршаллер и как демаршаллер в вашем `applicationContext.xml`.\nПонимание `XmlMappingException`.\nSpring преобразует исключения из базового инструмента сопоставления OX в собственное исключение. иерархия с XmlMappingException в качестве корневого исключения.\nЭти исключения времени выполнения оборачивают исходное исключение, чтобы никакая информация не была потеряна.\nПонимание `XmlMappingException`.\nКроме того, MarshallingFailureException и UnmarshallingFailureException обеспечить различие между операциями сортировки и демаршаллинга, даже несмотря на то, что базовый инструмент сопоставления OX не делает этого.\nИспользование Marshaller и Unmarshaller.\nВы можете использовать Spring OXM для самых разных ситуаций.\nВ следующем примере мы используйте его для маршалирования настроек приложения, управляемого Spring, в виде XML-файла.\nВ следующем примере мы используйте простой JavaBean для представления настроек:\nJava\n	public class Settings {\n		private boolean fooEnabled;\n		public boolean isFooEnabled() {\n			return fooEnabled;\n		public void setFooEnabled(boolean fooEnabled) {\n			this.fooEnabled = fooEnabled;\nИспользование Marshaller и Unmarshaller.\nКласс приложения использует этот компонент для хранения своих настроек."}
{"id": 806, "text": "Помимо основного метода, Класс имеет два метода: `saveSettings()` сохраняет bean-компонент настроек в файл с именем `settings.xml` и `loadSettings()` снова загружают эти настройки.\nСледующий метод `main()` создает контекст приложения Spring и вызывает эти два метода:\nJava\n	import java.io.FileInputStream;\n	import java.io.FileOutputStream;\n	import java.io.IOException;\n	import javax.xml.transform.stream.StreamResult;\n	import javax.xml.transform.stream.StreamSource;\n	import org.springframework.context.ApplicationContext;\n	import org.springframework.context.support.ClassPathXmlApplicationContext;\n	import org.springframework.oxm.Marshaller;\n	import org.springframework.oxm.Unmarshaller;\n	public class Application {\n		private static final String FILE_NAME = \"settings.xml\";\n		private Settings settings = new Settings();\n		private Marshaller marshaller;\n		private Unmarshaller unmarshaller;\n		public void setMarshaller(Marshaller marshaller) {\n			this.marshaller = marshaller;\n		public void setUnmarshaller(Unmarshaller unmarshaller) {\n			this.unmarshaller = unmarshaller;\n		public void saveSettings() throws IOException {\n			try (FileOutputStream os = new FileOutputStream(FILE_NAME)) {\n				this.marshaller.marshal(settings, new StreamResult(os));\n		public void loadSettings() throws IOException {\n			try (FileInputStream is = new FileInputStream(FILE_NAME)) {"}
{"id": 807, "text": "this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));\n		public static void main(String[] args) throws IOException {\n			ApplicationContext appContext =\n					new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n			Application application = (Application) appContext.getBean(\"application\");\n			application.saveSettings();\n			application.loadSettings();\n	class Application {\nИспользование Marshaller и Unmarshaller.\nДля «Приложения» необходимо установить свойство «marshaller» и «unmarshaller».\nМы можно сделать это, используя следующий `applicationContext.xml`:\n	<beans>\n		<bean id=\"application\" class=\"Application\">\n			<property name=\"marshaller\" ref=\"xstreamMarshaller\" />\n			<property name=\"unmarshaller\" ref=\"xstreamMarshaller\" />\n		</bean>\n		<bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\"/>\n	</beans>\nИспользование Marshaller и Unmarshaller.\nЭтот контекст приложения использует XStream, но мы могли бы использовать любой другой маршаллер. случаи, описанные далее в этой главе.\nОбратите внимание, что по умолчанию XStream не требует любая дополнительная конфигурация, поэтому определение компонента довольно просто."}
{"id": 808, "text": "Также обратите внимание, что XStreamMarshaller реализует как Marshaller, так и Unmarshaller, поэтому мы можем обратиться к Компонент `xstreamMarshaller` как в свойстве `marshaller`, так и в `unmarshaller` приложение.\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<settings foo-enabled=\"false\"/>\nПространство имен конфигурации XML.\nМаршаллеры можно настроить более лаконично, используя теги из пространства имен OXM.\nЧтобы сделать эти теги доступными, вы должны сначала сослаться на соответствующую схему в преамбула файла конфигурации XML.\nВ следующем примере показано, как это сделать:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:oxm=\"http://www.springframework.org/schema/oxm\" <1>\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/oxm"}
{"id": 809, "text": "https://www.springframework.org/schema/oxm/spring-oxm.xsd\"> <2>\nПространство имен конфигурации XML. <1> Ссылка на схему `oxm`. <2> Укажите местоположение схемы `oxm`.\n* `jaxb2-marshaller`\n* `jibx-marshaller`\nСхема делает доступными следующие элементы:.\nКаждый тег объясняется в соответствующем разделе упорядочителя.\nОднако в качестве примера конфигурация маршаллера JAXB2 может выглядеть следующим образом:\n	<oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/>\nЯКСБ.\nКомпилятор привязки JAXB преобразует XML-схему W3C в один или несколько классов Java, файл `jaxb.properties` и, возможно, некоторые файлы ресурсов.\nJAXB также предлагает способ создать схему из аннотированных классов Java.\nЯКСБ.\nSpring поддерживает API JAXB 2.0 в качестве стратегий маршалинга XML, следуя Интерфейсы Marshaller и Unmarshaller описаны в документе `Marshaller` and `Unmarshaller`.\nСоответствующие классы интеграции находятся в файле org.springframework.oxm.jaxb. пакет.\nИспользование Jaxb2Marshaller.\nКласс Jaxb2Marshaller реализует как Spring Marshaller, так и Unmarshaller. интерфейсы.\nДля работы требуется контекстный путь.\nВы можете установить контекстный путь, установив Свойство contextPath.\nКонтекстный путь представляет собой список пакетов Java, разделенных двоеточиями. имена, содержащие производные от схемы классы."}
{"id": 810, "text": "Он также предлагает свойство classesToBeBound, который позволяет вам установить массив классов, которые будут поддерживаться маршаллером.\nСхема проверка выполняется путем указания одного или нескольких ресурсов схемы для компонента, как показано в следующем примере:\n	<beans>\n		<bean id=\"jaxb2Marshaller\" class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\">\n			<property name=\"classesToBeBound\">\n				<list>\n					<value>org.springframework.oxm.jaxb.Flight</value>\n					<value>org.springframework.oxm.jaxb.Flights</value>\n				</list>\n			</property>\n			<property name=\"schema\" value=\"classpath:org/springframework/oxm/schema.xsd\"/>\n		</bean>\n	</beans>\nПространство имен конфигурации XML.\nЭлемент `jaxb2-marshaller` настраивает `org.springframework.oxm.jaxb.Jaxb2Marshaller`, как показано в следующем примере:\n	<oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/>\nПространство имен конфигурации XML.\nАльтернативно вы можете предоставить список классов для привязки к маршаллеру, используя метод Дочерний элемент `class-to-be-bound`:\n	<oxm:jaxb2-marshaller id=\"marshaller\">"}
{"id": 811, "text": "<oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema.Airport\"/>\n		<oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema.Flight\"/>\n	</oxm:jaxb2-marshaller>\nДжиБХ.\nФреймворк JiBX предлагает решение, аналогичное тому, которое Hibernate предоставляет для ORM: определение привязки определяет правила преобразования ваших объектов Java в или из XML.\nПосле подготовки привязки и компиляции классов компилятор привязки JiBX расширяет файлы классов и добавляет код для обработки преобразования экземпляров классов. из или в XML.\nДжиБХ.\nДополнительную информацию о JiBX см. на http://jibx.sourceforge.net/[веб-сайте JiBX. сайт].\nКлассы интеграции Spring находятся в файле org.springframework.oxm.jibx. пакет.\nИспользование JibxMarshaller.\nКласс JibxMarshaller реализует как Marshaller, так и Unmarshaller. интерфейс.\nДля работы ему требуется имя класса для маршалинга, которое вы можете устанавливается с помощью свойства targetClass.\nПри желании вы можете установить имя привязки, задав параметр Свойство `bindingName`.\nВ следующем примере мы привязываем класс Flights:\n	<beans>\n		<bean id=\"jibxFlightsMarshaller\" class=\"org.springframework.oxm.jibx.JibxMarshaller\">"}
{"id": 812, "text": "<property name=\"targetClass\">org.springframework.oxm.jibx.Flights</property>\n		</bean>\n	</beans>\nИспользование JibxMarshaller.\nJibxMarshaller настроен для одного класса.\nЕсли вы хотите маршалировать несколько классов, вам необходимо настроить несколько экземпляров JibxMarshaller с разными целевыми классами. ценности недвижимости.\nПространство имен конфигурации XML.\nТег jibx-marshaller настраивает файл org.springframework.oxm.jibx.JibxMarshaller, как показано в следующем примере:\n	<oxm:jibx-marshaller id=\"marshaller\" target-class=\"org.springframework.ws.samples.airline.schema.Flight\"/>\n| `id` | Идентификатор маршаллера | Нет. | `целевой класс` | Целевой класс для этого маршаллера | Да\n| `id` | Идентификатор маршаллера | Нет. | `bindingName` | Имя привязки, используемое этим маршалером | Нет |===\nXStream — это простая библиотека для сериализации объектов в XML и обратно.\nЭто не требует любого сопоставления и генерирует чистый XML.\nXStream.\nДля получения дополнительной информации о XStream см. https://x-stream.github.io/[XStream веб-сайт].\nКлассы интеграции Spring находятся в пакет `org.springframework.oxm.xstream`.\nИспользование XStreamMarshaller.\nXStreamMarshaller не требует какой-либо настройки и может быть настроен в контекст приложения напрямую."}
{"id": 813, "text": "Для дальнейшей настройки XML вы можете установить карту псевдонимов, который состоит из псевдонимов строк, сопоставленных с классами, как показано в следующем примере:\n	<beans>\n		<bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\">\n			<property name=\"aliases\">\n				<props>\n					<prop key=\"Flight\">org.springframework.oxm.xstream.Flight</prop>\n				</props>\n			</property>\n		</bean>\n	</beans>\nИспользование XStreamMarshaller. [ВНИМАНИЕ] = По умолчанию XStream позволяет демаршаллировать произвольные классы, что может привести к небезопасные эффекты сериализации Java.\nПоэтому мы не рекомендуем использовать `XStreamMarshaller` для демаршалинга XML из внешних источников (то есть из Интернета), поскольку это может привести к уязвимостям безопасности.\nИспользование XStreamMarshaller.\nЕсли вы решите использовать XStreamMarshaller для демаршалинга XML из внешнего источника, установите свойство supportClasses в XStreamMarshaller, как показано в следующем примере:\n	<bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\">\n		<property name=\"supportedClasses\" value=\"org.springframework.oxm.xstream.Flight\"/>\n	</bean>\nИспользование XStreamMarshaller.\nЭто гарантирует, что только зарегистрированные классы будут иметь право на демаршалинг.\nИспользование XStreamMarshaller."}
{"id": 814, "text": "Дополнительно вы можете зарегистрироваться {spring-framework-api}/oxm/xstream/XStreamMarshaller.html#setConverters(com.\nThoughtworks.xstream.converters.ConverterMatcher...) [пользовательские преобразователи] чтобы убедиться, что только поддерживаемые классы могут быть демаршаллированы.\nВы можете захотеть чтобы добавить CatchAllConverter в качестве последнего конвертера в списке, в дополнение к преобразователи, которые явно поддерживают классы предметной области, которые должны поддерживаться.\nВ результате конвертеры XStream по умолчанию с более низкими приоритетами и возможной безопасностью уязвимости не вызываются.\nИспользование XStreamMarshaller.\nПРИМЕЧАНИЕ.\nОбратите внимание, что XStream — это библиотека сериализации XML, а не библиотека привязки данных.\nПоэтому он имеет ограниченную поддержку пространства имен.\nВ результате он практически непригоден для использования. внутри веб-служб."}
{"id": 815, "text": "* `core`: пакет `org.springframework.jdbc.core` содержит класс `JdbcTemplate`.\nСтруктура абстракции JDBC Spring Framework состоит из четырех различных пакетов:. и его различные интерфейсы обратного вызова, а также множество связанных классов.\nПодпакет с именем `org.springframework.jdbc.core.simple` содержит `SimpleJdbcInsert` и Классы SimpleJdbcCall.\nДругой подпакет с именем `org.springframework.jdbc.core.namedparam` содержит `NamedParameterJdbcTemplate` class и связанные с ним классы поддержки.\nСм.\n* datasource: пакет org.springframework.jdbc.datasource содержит служебный класс.\nСтруктура абстракции JDBC Spring Framework состоит из четырех различных пакетов:. для легкого доступа к DataSource и различных простых реализаций DataSource, которые вы можете используйте для тестирования и запуска немодифицированного кода JDBC вне контейнера Jakarta EE.\nПодпакет с именем `org.springframework.jdbc.datasource.embedded` обеспечивает поддержку создания встроенные базы данных с использованием механизмов баз данных Java, таких как HSQL, H2 и Derby.\nСм.\n* `object`: пакет `org.springframework.jdbc.object` содержит классы, представляющие\nСтруктура абстракции JDBC Spring Framework состоит из четырех различных пакетов:.\nЗапросы, обновления и хранимые процедуры РСУБД в виде потокобезопасных объектов многократного использования.\nСм. приводит к более объектно-ориентированному подходу, хотя объекты, возвращаемые запросами, естественно отключился от базы данных."}
{"id": 816, "text": "Этот более высокий уровень абстракции JDBC зависит на абстракции нижнего уровня в пакете org.springframework.jdbc.core.\n* `support`: пакет `org.springframework.jdbc.support` предоставляет `SQLException`\nСтруктура абстракции JDBC Spring Framework состоит из четырех различных пакетов:. функциональность перевода и некоторые служебные классы.\nИсключения, возникающие во время обработки JDBC преобразуются в исключения, определенные в пакете `org.springframework.dao`.\nЭто означает этот код, использующий уровень абстракции Spring JDBC, не нуждается в реализации JDBC или Обработка ошибок, специфичная для СУБД.\nВсе переведенные исключения не отмечены, что дает вам возможность перехвата исключений, из которых вы можете восстановиться, позволяя другим исключения передаются вызывающей стороне.\nВидеть"}
{"id": 817, "text": "Распространенные проблемы с обработкой параметров и значений данных.\nВ разных подходах существуют общие проблемы с параметрами и значениями данных. обеспечивается поддержкой JDBC Spring Framework.\nВ этом разделе рассказывается, как их решить.\nПредоставление информации о типе SQL для параметров.\nОбычно Spring определяет тип параметров SQL на основе типа параметра. передано.\nМожно явно указать тип SQL, который будет использоваться при настройке значения параметров.\nИногда это необходимо для правильной установки значений `NULL`.\n* Многие методы обновления и запроса `JdbcTemplate` принимают дополнительный параметр в\nВы можете предоставить информацию о типе SQL несколькими способами:. форма массива `int`.\nЭтот массив используется для указания типа SQL соответствующий параметр, используя константные значения из класса java.sql.Types.\nПредоставить одна запись для каждого параметра.\n* Вы можете использовать класс SqlParameterValue для переноса значения параметра, которому это необходимо.\nВы можете предоставить информацию о типе SQL несколькими способами:. дополнительная информация.\nДля этого создайте новый экземпляр для каждого значения и передайте тип SQL. и значение параметра в конструкторе.\nВы также можете предоставить дополнительную шкалу параметр для числовых значений.\n* Для методов, работающих с именованными параметрами, вы можете использовать классы SqlParameterSource.\nВы можете предоставить информацию о типе SQL несколькими способами:. `BeanPropertySqlParameterSource` или `MapSqlParameterSource`.\nУ них обоих есть методы для регистрации типа SQL для любого из значений именованного параметра.\nОбработка объектов BLOB и CLOB."}
{"id": 818, "text": "В базе данных можно хранить изображения, другие двоичные данные и большие фрагменты текста.\nЭти большие объекты называются BLOB (Binary Large OBject) для двоичных данных и CLOB (символьные объекты).\nБольшой OBject) для символьных данных.\nВ Spring вы можете обрабатывать эти большие объекты, используя непосредственно `JdbcTemplate`, а также при использовании более высоких абстракций, предоставляемых СУБД.\nОбъекты и классы SimpleJdbc.\nВсе эти подходы используют реализацию интерфейс `LobHandler` для фактического управления данными LOB (Large OBject). `LobHandler` обеспечивает доступ к классу `LobCreator` через метод `getLobCreator`. который используется для создания новых LOB-объектов, которые будут вставлены.\n* БЛОБ\n`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:. ** `byte[]`: `getBlobAsBytes` и `setBlobAsBytes` ** `InputStream`: `getBlobAsBinaryStream` и `setBlobAsBinaryStream`\n* КЛОБ\n`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:. ** `String`: `getClobAsString` и `setClobAsString` ** `InputStream`: `getClobAsAsciiStream` и `setClobAsAsciiStream` ** `Reader`: `getClobAsCharacterStream` и `setClobAsCharacterStream`\n`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:.\nВ следующем примере показано, как создать и вставить BLOB."}
{"id": 819, "text": "Позже мы покажем, как читать его обратно из базы данных.\n`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:.\nВ этом примере используется JdbcTemplate и реализация `AbstractLobCreatingPreparedStatementCallback`.\nОн реализует один метод, `установить значения`.\nЭтот метод предоставляет `LobCreator`, который мы используем для установки значений для Столбцы LOB в операторе вставки SQL.\n`LobCreator` и `LobHandler` обеспечивают следующую поддержку ввода и вывода LOB:.\nВ этом примере мы предполагаем, что существует переменная `lobHandler`, которая уже установлен экземпляр `DefaultLobHandler`.\nОбычно вы устанавливаете это значение через внедрение зависимостей.\nJava\n	final File blobIn = new File(\"spring2004.jpg\");\n	final InputStream blobIs = new FileInputStream(blobIn);\n	final File clobIn = new File(\"large.txt\");\n	final InputStream clobIs = new FileInputStream(clobIn);\n	final InputStreamReader clobReader = new InputStreamReader(clobIs);\n	jdbcTemplate.execute(\n		\"INSERT INTO lob_table (id, a_clob, a_blob) ЗНАЧЕНИЯ (?, ?, ?)\",\n		new AbstractLobCreatingPreparedStatementCallback(lobHandler) {  // <1>\n			protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {\n				ps.setLong(1, 1L);\n				lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  // <2>"}
{"id": 820, "text": "lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  // <3>\n	blobIs.close();\n	clobReader.close();\nВ следующем примере показано, как создать и вставить BLOB:. <1> Передайте `lobHandler`, который (в этом примере) является простым `DefaultLobHandler`. <2> Использование метода setClobAsCharacterStream для передачи содержимого CLOB. <3> Использование метода setBlobAsBinaryStream для передачи содержимого BLOB.\nВ следующем примере показано, как создать и вставить BLOB:. [ПРИМЕЧАНИЕ] = Если вы вызываете `setBlobAsBinaryStream`, `setClobAsAsciiStream` или Метод setClobAsCharacterStream для LobCreator, возвращенный из `DefaultLobHandler.getLobCreator()`, вы можете указать отрицательное значение. для аргумента «contentLength».\nЕсли указанная длина содержимого отрицательна, `DefaultLobHandler` использует варианты JDBC 4.0 методов set-stream без параметр длины.\nВ противном случае он передает указанную длину драйверу.\nВ следующем примере показано, как создать и вставить BLOB:.\nСм. документацию по используемому вами драйверу JDBC, чтобы убедиться, что он поддерживает потоковую передачу.\nLOB без указания длины контента.\nВ следующем примере показано, как создать и вставить BLOB:.\nТеперь пришло время прочитать данные LOB из базы данных.\nОпять же, вы используете JdbcTemplate. с той же переменной экземпляра lobHandler и ссылкой на DefaultLobHandler."}
{"id": 821, "text": "В следующем примере показано, как это сделать:\nJava\n	List<Map<String, Object>> l = jdbcTemplate.query(\"select id, a_clob, a_blob from lob_table\",\n		new RowMapper<Map<String, Object>>() {\n			public Map<String, Object> mapRow(ResultSet rs, int i) throws SQLException {\n				Map<String, Object> results = new HashMap<String, Object>();\n				String clobText = lobHandler.getClobAsString(rs, \"a_clob\");  // <1>\n				results.put(\"CLOB\", clobText);\n				byte[] blobBytes = lobHandler.getBlobAsBytes(rs, \"a_blob\");  // <2>\n				results.put(\"BLOB\", blobBytes);\n				return results;\nВ следующем примере показано, как создать и вставить BLOB:. <1> Использование метода getClobAsString для получения содержимого CLOB. <2> Использование метода getBlobAsBytes для получения содержимого BLOB.\nПередача списков значений для предложения IN.\nСтандарт SQL позволяет выбирать строки на основе выражения, включающего список переменных значений.\nТипичным примером будет `select * from T_ACTOR, где id в (1, 2, 3)`.\nЭтот список переменных не поддерживается напрямую для подготовленных операторов Стандарт JDBC.\nВы не можете объявить переменное количество заполнителей."}
{"id": 822, "text": "Вам нужен номер вариантов с нужным количеством подготовленных заполнителей или вам нужно сгенерировать строку SQL динамически, как только вы узнаете, сколько заполнителей требуется.\nНазванный поддержка параметров, обеспечиваемая в NamedParameterJdbcTemplate, использует последний подход.\nВы можете передавать значения в виде `java.util.List` (или любого `Iterable`) простых значений.\nЭтот список используется для вставки необходимых заполнителей в фактический оператор SQL. и передавать значения во время выполнения оператора.\nПередача списков значений для предложения IN.\nПРИМЕЧАНИЕ.\nБудьте осторожны при передаче большого количества значений.\nСтандарт JDBC не гарантирует, что вы можете использовать более 100 значений для списка выражений IN.\nРазличные базы данных превышают это число, но обычно они имеют жесткий предел допустимого количества значений.\nНапример, предел Oracle составляет 1000.\nПередача списков значений для предложения IN.\nВ дополнение к примитивным значениям в списке значений вы можете создать java.util.List. объектных массивов.\nЭтот список может поддерживать несколько выражений, определенных для `in` предложение, такое как `+++select * from T_ACTOR где (id, Last_name) в ((1, 'Джонсон'), (2, 'Харроп'))+++`.\nРазумеется, для этого необходимо, чтобы ваша база данных поддерживала этот синтаксис.\nОбработка сложных типов для вызовов хранимых процедур.\nПри вызове хранимых процедур иногда можно использовать сложные типы, специфичные для конкретного типа. база данных."}
{"id": 823, "text": "Чтобы разместить эти типы, Spring предоставляет SqlReturnType для обработки их, когда они возвращаются из вызова хранимой процедуры, и SqlTypeValue, когда они передаются в качестве параметра хранимой процедуры.\nОбработка сложных типов для вызовов хранимых процедур.\nИнтерфейс SqlReturnType имеет единственный метод (с именем getTypeValue), который должен быть реализовано.\nЭтот интерфейс используется как часть объявления SqlOutParameter.\nВ следующем примере показано возвращение значения объекта `java.sql.Struct` пользователя. объявленный тип `ITEM_TYPE`: См. пример кода в исходном документе.\nОбработка сложных типов для вызовов хранимых процедур.\nВы можете использовать SqlTypeValue для передачи значения объекта Java (например, TestItem) в хранимая процедура.\nИнтерфейс SqlTypeValue имеет единственный метод (с именем `createTypeValue`), который вы должны реализовать.\nАктивное соединение передается, и вы можно использовать его для создания объектов, специфичных для базы данных, таких как экземпляры `java.sql.Struct` или экземпляры java.sql.Array.\nВ следующем примере создается экземпляр java.sql.Struct: См. пример кода в исходном документе.\nОбработка сложных типов для вызовов хранимых процедур.\nТеперь вы можете добавить это SqlTypeValue к карте, содержащей входные параметры для `execute` вызов хранимой процедуры.\nОбработка сложных типов для вызовов хранимых процедур.\nДругое использование SqlTypeValue — передача массива значений в хранилище Oracle. процедура.\nВ Oracle есть метод createOracleArray для OracleConnection, который вы можете доступ, развернув его."}
{"id": 824, "text": "Вы можете использовать SqlTypeValue для создания массива и заполнения его значениями из Java `java.sql.Array`, как показано в следующем примере: См. пример кода в исходном документе."}
{"id": 825, "text": "Сопоставление путей.\nВы можете настроить параметры, связанные с сопоставлением пути и обработкой URL-адреса.\nПодробную информацию об отдельных опциях см. {spring-framework-api}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.\nСопоставление путей.\nВ следующем примере показано, как настроить сопоставление путей: См. пример кода в исходном документе."}
{"id": 826, "text": "Использование ProxyFactoryBean для создания прокси AOP.\nЕсли вы используете контейнер Spring IoC (ApplicationContext или BeanFactory) для своего бизнес-объекты (и так и должно быть!), вы хотите использовать один из Spring AOP.\nРеализации FactoryBean. (Помните, что фабричный компонент вводит уровень косвенности, позволяя он создает объекты другого типа.)\nИспользование ProxyFactoryBean для создания прокси AOP.\nПРИМЕЧАНИЕ.\nПоддержка Spring AOP также использует фабричные компоненты под обложкой.\nИспользование ProxyFactoryBean для создания прокси AOP.\nОсновной способ создания прокси-сервера AOP в Spring — использовать `org.springframework.aop.framework.ProxyFactoryBean`.\nЭто дает полный контроль над точки, любые применимые советы и их порядок.\nОднако есть более простые варианты, которые предпочтительнее, если вам не нужен такой контроль.\nОсновы.\nProxyFactoryBean, как и другие реализации Spring FactoryBean, вводит уровень косвенности.\nЕсли вы определяете ProxyFactoryBean с именем foo, объекты, которые ссылка `foo` видит не сам экземпляр `ProxyFactoryBean`, а объект созданный реализацией метода getObject() в ProxyFactoryBean.\nЭто Метод создает прокси-сервер AOP, который обертывает целевой объект.\nОсновы.\nОдно из наиболее важных преимуществ использования ProxyFactoryBean или другого компонента, поддерживающего IoC. класс для создания прокси АОП заключается в том, что советы и точки также могут быть под управлением IoC.\nЭто мощная функция, позволяющая использовать определенные подходы, которые трудно реализовать. достичь с другими платформами АОП."}
{"id": 827, "text": "Например, совет может сам ссылаться на объекты приложения (помимо цели, которая должна быть доступна в любом АОП framework), пользуясь всеми возможностями подключения, предоставляемыми Dependency Injection.\nСвойства JavaBean.\nКак и большинство реализаций FactoryBean, входящих в состав Spring, Класс ProxyFactoryBean сам по себе является JavaBean.\nЕго свойства используются для:\n* Укажите цель, которую вы хотите проксировать.\n* Укажите, следует ли использовать CGLIB (описано ниже, а также см. прокси-серверы на основе JDK и CGLIB).\nСвойства JavaBean.\nНекоторые ключевые свойства унаследованы от org.springframework.aop.framework.ProxyConfig. (суперкласс для всех прокси-фабрик AOP в Spring).\nЭти ключевые свойства включают в себя следующее:\n* `proxyTargetClass`: `true`, если целевой класс должен быть проксирован, а не\nСвойства JavaBean. интерфейсы целевого класса.\nЕсли для этого свойства установлено значение true, то прокси CGLIB создаются (но см. также прокси на основе JDK и CGLIB).\n* `optimize`: контролирует, применяется ли к прокси агрессивная оптимизация.\nСвойства JavaBean. созданный через CGLIB.\nВам не следует беспечно использовать эту настройку, если вы не полностью понять, как соответствующий прокси-сервер AOP обрабатывает оптимизацию.\nВ настоящее время это используется только для прокси CGLIB.\nЭто не имеет никакого эффекта для динамических прокси JDK."}
{"id": 828, "text": "* «заморожено»: если конфигурация прокси-сервера «заморожена», изменения в конфигурации\nСвойства JavaBean. больше не разрешено.\nЭто полезно как для небольшой оптимизации, так и для таких случаев. когда вы не хотите, чтобы вызывающие абоненты могли манипулировать прокси-сервером (через `Advised` интерфейс) после создания прокси.\nЗначение этого свойства по умолчанию: `false`, поэтому изменения (например, добавление дополнительных советов) разрешены.\n* `exposeProxy`: определяет, должен ли текущий прокси быть представлен в\nСвойства JavaBean. `ThreadLocal`, чтобы цель могла получить к нему доступ.\nЕсли цель должна получить прокси и для свойства `exposeProxy` установлено значение `true`, цель может использовать Метод `AopContext.currentProxy()`.\n* `proxyInterfaces`: массив имен интерфейсов `String`. Если это не указано, CGLIB\nДругие свойства, специфичные для ProxyFactoryBean, включают следующее:. используется прокси для целевого класса (но см. также прокси на основе JDK и CGLIB).\n* `interceptorNames`: массив `String`, содержащий имена `Advisor`, перехватчика или других советов для\nДругие свойства, специфичные для ProxyFactoryBean, включают следующее:. применить.\nЗаказ важен, он осуществляется в порядке очереди.\nТо есть что первый перехватчик в списке первым сможет перехватить призыв.\nДругие свойства, специфичные для ProxyFactoryBean, включают следующее:."}
{"id": 829, "text": "Имена — это имена компонентов в текущей фабрике, включая имена компонентов от предка. заводы.\nЗдесь нельзя упоминать ссылки на компоненты, так как это приведет к `ProxyFactoryBean` игнорирует одноэлементную настройку совета.\nДругие свойства, специфичные для ProxyFactoryBean, включают следующее:.\nВы можете добавить к имени перехватчика звездочку (`*`).\nЭто приводит к применение всех компонентов-советников, имена которых начинаются с части перед звездочкой быть применено.\nПример использования этой функции можно найти в Использование советников «`Global`'.\n* синглтон: должна ли фабрика возвращать один объект, независимо от того, как\nДругие свойства, специфичные для ProxyFactoryBean, включают следующее:. часто вызывается метод getObject().\nНесколько реализаций FactoryBean предлагают такой метод.\nЗначение по умолчанию — true.\nЕсли вы хотите использовать советы с сохранением состояния - для например, для миксинов с сохранением состояния — используйте совет по прототипу вместе с одноэлементным значением `ложь`.\nПрокси на основе JDK и CGLIB.\nЭтот раздел служит исчерпывающей документацией о том, как ProxyFactoryBean выбирает создание прокси на основе JDK или прокси на основе CGLIB для определенной цели объект (который должен быть проксирован).\nПрокси на основе JDK и CGLIB.\nПРИМЕЧАНИЕ."}
{"id": 830, "text": "Поведение ProxyFactoryBean в отношении создания на основе JDK или CGLIB. прокси изменились между версиями Spring 1.2.x и 2.0. `ProxyFactoryBean` сейчас демонстрирует аналогичную семантику в отношении интерфейсов автоматического обнаружения, что и интерфейсы Класс TransactionProxyFactoryBean.\nПрокси на основе JDK и CGLIB.\nЕсли класс целевого объекта, который должен быть проксирован (далее просто называемый целевой класс) не реализует никаких интерфейсов, прокси на основе CGLIB создано.\nЭто самый простой сценарий, поскольку прокси-серверы JDK основаны на интерфейсе, и нет интерфейсы означают, что проксирование JDK даже невозможно.\nВы можете подключить целевой компонент и укажите список перехватчиков, установив свойство interceptorNames.\nОбратите внимание, что Прокси на основе CGLIB создается, даже если свойство proxyTargetClass объекта Для ProxyFactoryBean установлено значение false. (Это не имеет смысла и лучше всего удалено из определения компонента, поскольку оно в лучшем случае избыточно, а в худшем случае сбивает с толку.)\nПрокси на основе JDK и CGLIB.\nЕсли целевой класс реализует один (или несколько) интерфейсов, тип прокси-сервера Создаваемый объект зависит от конфигурации ProxyFactoryBean.\nПрокси на основе JDK и CGLIB.\nЕсли для свойства proxyTargetClass объекта ProxyFactoryBean установлено значение true, создается прокси на основе CGLIB.\nЭто имеет смысл и соответствует принцип наименьшего неожиданности."}
{"id": 831, "text": "Даже если свойство proxyInterfaces объекта Для ProxyFactoryBean установлено одно или несколько полных имен интерфейсов. что для свойства proxyTargetClass установлено значение true, это приводит к возникновению ошибок на основе CGLIB. проксирование вступило в силу.\nПрокси на основе JDK и CGLIB.\nЕсли для свойства proxyInterfaces объекта ProxyFactoryBean установлено одно или несколько полные имена интерфейсов, создается прокси-сервер на основе JDK.\nСозданный прокси реализует все интерфейсы, указанные в `proxyInterfaces` собственность.\nЕсли целевой класс реализует гораздо больше интерфейсов, чем указанные в свойстве proxyInterfaces, это все хорошо, но те дополнительные интерфейсы не реализуются возвращаемым прокси.\nПрокси на основе JDK и CGLIB.\nЕсли свойство proxyInterfaces объекта ProxyFactoryBean не установлено, но целевой класс реализует один (или несколько) интерфейсов, `ProxyFactoryBean` автоматически определяет тот факт, что целевой класс действительно реализовать хотя бы один интерфейс, и будет создан прокси-сервер на основе JDK.\nИнтерфейсы на самом деле проксируются все интерфейсы, которые целевой класс реализует.\nПо сути, это то же самое, что предоставить список всех без исключения интерфейс, который целевой класс реализует для свойства proxyInterfaces.\nОднако, это значительно меньше работы и менее подвержено опечаткам.\nПрокси-интерфейсы.\nРассмотрим простой пример ProxyFactoryBean в действии.\nЭтот пример включает в себя:\n* Целевой компонент, который проксируется. Это определение bean-компонента personTarget в\nПрокси-интерфейсы. пример.\n* «Советник» и «Перехватчик» используются для предоставления советов."}
{"id": 832, "text": "* Определение прокси-компонента AOP для указания целевого объекта (компонент `personTarget`),\nПрокси-интерфейсы. интерфейсы для прокси и советы по применению.\n	<bean id=\"personTarget\" class=\"com.mycompany.PersonImpl\">\n		<property name=\"name\" value=\"Tony\"/>\n		<property name=\"age\" value=\"51\"/>\n	</bean>\n	<bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\">\n		<property name=\"someProperty\" value=\"Custom string property value\"/>\n	</bean>\n	<bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\">\n	</bean>\n	<bean id=\"person\"\n		class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n		<property name=\"proxyInterfaces\" value=\"com.mycompany.Person\"/>\n		<property name=\"target\" ref=\"personTarget\"/>\n		<property name=\"interceptorNames\">\n			<list>\n				<value>myAdvisor</value>\n				<value>debugInterceptor</value>\n			</list>\n		</property>\n	</bean>\nВ следующем листинге показан пример:."}
{"id": 833, "text": "Обратите внимание, что свойство interceptorNames принимает список String, который содержит имена компонентов перехватчики или советники на нынешнем заводе.\nВы можете использовать советники, перехватчики, до, после возвращается и бросает предметы-советы.\nПорядок советников имеет большое значение.\nВ следующем листинге показан пример:.\nПРИМЕЧАНИЕ.\nВам может быть интересно, почему в списке нет ссылок на компоненты.\nПричиной этого является что, если одноэлементное свойство ProxyFactoryBean установлено в значение false, оно должно иметь возможность возвращать независимые экземпляры прокси.\nЕсли какой-либо из советников сам является прототипом, независимый экземпляр необходимо будет вернуть, поэтому необходимо иметь возможность получить экземпляр прототипа с завода.\nХранить ссылку недостаточно.\nВ следующем листинге показан пример:.\nОпределение bean-компонента `person`, показанное ранее, может использоваться вместо реализации `Person`, как следует:\nJava\n	Person person = (Person) factory.getBean(\"person\");\nВ следующем листинге показан пример:.\nДругие bean-компоненты в том же контексте IoC могут выражать от него строго типизированную зависимость, например с обычным объектом Java.\nВ следующем примере показано, как это сделать:\n	<bean id=\"personUser\" class=\"com.mycompany.PersonUser\">\n		<property name=\"person\"><ref bean=\"person\"/></property>\n	</bean>\nВ следующем листинге показан пример:."}
{"id": 834, "text": "Класс PersonUser в этом примере предоставляет свойство типа Person.\nНасколько это касается того, что прокси-сервер АОП может быть прозрачно использован вместо «реального» человека. реализация.\nОднако его класс будет динамическим прокси-классом.\nЭто было бы возможно чтобы привести его к интерфейсу Advised (обсуждается позже).\nВ следующем листинге показан пример:.\nВы можете скрыть различие между целью и прокси, используя анонимный внутренний боб.\nОтличается только определение ProxyFactoryBean. советы включены только для полноты информации.\nВ следующем примере показано, как использовать анонимный внутренний компонент:\n	<bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\">\n		<property name=\"someProperty\" value=\"Custom string property value\"/>\n	</bean>\n	<bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/>\n	<bean id=\"person\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n		<property name=\"proxyInterfaces\" value=\"com.mycompany.Person\"/>\n		<!-- Use inner bean, not local reference to target -->\n		<property name=\"target\">\n			<bean class=\"com.mycompany.PersonImpl\">\n				<property name=\"name\" value=\"Tony\"/>"}
{"id": 835, "text": "<property name=\"age\" value=\"51\"/>\n			</bean>\n		</property>\n		<property name=\"interceptorNames\">\n			<list>\n				<value>myAdvisor</value>\n				<value>debugInterceptor</value>\n			</list>\n		</property>\n	</bean>\nВ следующем листинге показан пример:.\nПреимущество использования анонимного внутреннего компонента заключается в том, что существует только один объект типа Person.\nThis is useful if we want чтобы пользователи контекста приложения не могли получить ссылку на непредусмотренный объект или необходимость избежать какой-либо двусмысленности с помощью автоматического подключения Spring IoC.\nСуществует также, возможно, преимущество состоит в том, что определение ProxyFactoryBean является самодостаточным.\nОднако бывают случаи, когда удается получить неожиданную цель от Factory на самом деле может быть преимуществом (например, в определенных сценариях тестирования).\nПрокси-классы.\nЧто делать, если вам нужно проксировать класс, а не один или несколько интерфейсов?\nПрокси-классы.\nПредставьте, что в нашем предыдущем примере не было интерфейса Person.\nНам нужно было посоветовать класс под названием Person, который не реализовал никакого бизнес-интерфейса.\nВ этом случае вы можно настроить Spring для использования прокси CGLIB, а не динамических прокси.\nДля этого установите Свойству proxyTargetClass в ProxyFactoryBean, показанному ранее, присвоено значение true."}
{"id": 836, "text": "Хотя лучше всего программировать на интерфейсы, а не на классы, возможность советовать классы, которые не интерфейсы реализации могут быть полезны при работе с устаревшим кодом. (В общем, Весна не является предписывающим.\nХотя это облегчает применение передовой практики, оно позволяет избежать принуждения особый подход.)\nПрокси-классы.\nЕсли вы хотите, вы можете принудительно использовать CGLIB в любом случае, даже если у вас есть интерфейсы.\nПрокси-классы.\nПроксирование CGLIB работает путем создания подкласса целевого класса во время выполнения.\nВесна настраивает этот сгенерированный подкласс для делегирования вызовов методов исходной цели. подкласс используется для реализации шаблона Decorator, вплетая в него рекомендации.\nПрокси-классы.\nПрокси CGLIB обычно должно быть прозрачным для пользователей.\nОднако есть некоторые проблемы рассмотреть:\n* Классы `final` не могут быть проксированы, поскольку их нельзя расширить.\n* `final` методы не рекомендуются, поскольку их нельзя переопределить.\n* `private` методы не рекомендуются, поскольку их нельзя переопределить.\n* Методы, которые не видны, обычно упаковывают частные методы в родительский класс.\nПрокси-классы. из другого пакета, рекомендовать нельзя, поскольку они фактически являются частными.\nПрокси-классы.\nПРИМЕЧАНИЕ.\nНет необходимости добавлять CGLIB в ваш путь к классам.\nCGLIB переупакован и включен в JAR `spring-core`.\nДругими словами, АОП на основе CGLIB работает «из коробки», как и Динамические прокси JDK.\nПрокси-классы."}
{"id": 837, "text": "Разница в производительности между прокси CGLIB и динамическими прокси невелика.\nВ этом случае производительность не должна быть решающим фактором.\nИспользование «Глобальных» советников.\nПри добавлении звездочки к имени перехватчика все советники с именами компонентов, совпадающими часть перед звездочкой добавляется в цепочку советников.\nЭто может пригодиться если вам нужно добавить стандартный набор \"глобальных\" советников.\nВ следующем примере определяется два глобальных советника:\n	<bean id=\"proxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n		<property name=\"target\" ref=\"service\"/>\n		<property name=\"interceptorNames\">\n			<list>\n				<value>global*</value>\n			</list>\n		</property>\n	</bean>\n	<bean id=\"global_debug\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/>\n	<bean id=\"global_performance\" class=\"org.springframework.aop.interceptor.PerformanceMonitorInterceptor\"/>"}
{"id": 838, "text": "API Pointcut Spring.\nВ этом разделе описывается, как Spring реализует важную концепцию pointcut.\nКонцепции.\nМодель pointcut в Spring позволяет повторно использовать pointcut независимо от типов советов.\nВы можете нацеливайтесь на разные советы с помощью одного и того же пункта.\nКонцепции.\nИнтерфейс `org.springframework.aop.Pointcut` является центральным интерфейсом, используемым для целевые рекомендации для конкретных классов и методов.\nПолный интерфейс выглядит следующим образом:\n	public interface Pointcut {\n		ClassFilter getClassFilter();\n		MethodMatcher getMethodMatcher();\nКонцепции.\nРазделение интерфейса Pointcut на две части позволяет повторно использовать класс и метод. сопоставление частей и операции детальной композиции (например, выполнение «объединения»). с другим сопоставителем методов).\nКонцепции.\nИнтерфейс ClassFilter используется для ограничения выделения точки заданным набором целей. занятия.\nЕсли метод matches() всегда возвращает true, все целевые классы совпало.\nВ следующем листинге показано определение интерфейса ClassFilter:\n	public interface ClassFilter {\n		boolean matches(Class clazz);\n	public interface MethodMatcher {\n		boolean matches(Method m, Class<?> targetClass);\n		boolean isRuntime();\n		boolean matches(Method m, Class<?> targetClass, Object... args);\nИнтерфейс MethodMatcher обычно более важен.\nПолный интерфейс выглядит следующим образом:.\nМетод matchs(Method, Class) используется для проверки того, был ли этот срез когда-либо соответствует заданному методу целевого класса."}
{"id": 839, "text": "Эту оценку можно выполнить, когда АОП прокси создается, чтобы избежать необходимости проверки при каждом вызове метода.\nЕсли Метод matchs с двумя аргументами возвращает true для данного метода, а метод isRuntime() метод для MethodMatcher возвращает true, метод сопоставления с тремя аргументами вызывается при каждом вызове метода.\nЭто позволяет точечно просмотреть переданные аргументы. к вызову метода непосредственно перед началом целевого совета.\nИнтерфейс MethodMatcher обычно более важен.\nПолный интерфейс выглядит следующим образом:.\nБольшинство реализаций MethodMatcher являются статическими, то есть их метод isRuntime() возвращает `ложь`.\nВ этом случае метод matchs с тремя аргументами никогда не вызывается.\nИнтерфейс MethodMatcher обычно более важен.\nПолный интерфейс выглядит следующим образом:.\nСОВЕТ: Если возможно, постарайтесь сделать точечные вырезы статичными, позволяя платформе АОП кэшировать результаты оценки pointcut при создании прокси-сервера AOP.\nОперации над разрезами.\nSpring поддерживает операции (в частности, объединение и пересечение) над точками.\nОперации над разрезами.\nОбъединение означает методы, которым соответствует любой pointcut.\nПересечение означает методы, которым соответствуют оба точечных разреза.\nСоюз обычно более полезен.\nВы можете создавать точечные вырезы, используя статические методы в `org.springframework.aop.support.Pointcuts` или с помощью класса Класс ComposablePointcut в том же пакете.\nОднако использование точки AspectJ выражения обычно является более простым подходом.\nВыражение AspectJ."}
{"id": 840, "text": "Начиная с версии 2.0, наиболее важным типом pointcut, используемым Spring, является `org.springframework.aop.aspectj.AspectJExpressionPointcut`.\nЭто точка, которая использует библиотеку, поставляемую AspectJ, для анализа строки выражения pointcut AspectJ.\nВыражение AspectJ.\nСм. предыдущая глава для обсуждения поддерживаемых примитивов pointcut AspectJ.\nУдобство реализации Pointcut.\nSpring предоставляет несколько удобных реализаций pointcut.\nВы можете использовать некоторые из них напрямую; другие предназначены для создания подклассов в точках, специфичных для конкретного приложения.\nСтатические точечные вырезы основаны на методе и целевом классе и не могут учитывать аргументы метода.\nСтатических точечных вырезов достаточно (и они являются лучшими) для большинства случаев.\nSpring может оценить статический pointcut только один раз, при первом вызове метода.\nПосле этого нет необходимости заново оценивать pointcut при каждом вызове метода.\nСтатические точечные вырезы.\nВ оставшейся части этого раздела описываются некоторые реализации статических точечных вырезов, которые входит в состав Spring.\nРегулярные выражения Pointcuts.\nОдин очевидный способ указать статические точки — регулярные выражения.\nНесколько АОП фреймворки, помимо Spring, делают это возможным. `org.springframework.aop.support.JdkRegexpMethodPointcut` — это общий регулярный выражение pointcut, использующее поддержку регулярных выражений в JDK.\nРегулярные выражения Pointcuts.\nС помощью класса JdkRegexpMethodPointcut вы можете предоставить список строк шаблона."}
{"id": 841, "text": "Если какой-либо из них совпадает, то pointcut оценивается как «истина». (Как следствие, результирующий точечный разрез фактически является объединением указанных шаблонов.)\nРегулярные выражения Pointcuts.\nВ следующем примере показано, как использовать JdkRegexpMethodPointcut: См. пример кода в исходном документе.\nРегулярные выражения Pointcuts.\nSpring предоставляет удобный класс RegexpMethodPointcutAdvisor, который позволяет нам также ссылайтесь на «Совет» (помните, что «Совет» может быть перехватчиком перед советом, кидает советы и др.).\nЗа кулисами Spring использует JdkRegexpMethodPointcut.\nИспользование RegexpMethodPointcutAdvisor упрощает подключение, поскольку один компонент инкапсулирует оба компонента. pointcut и советы, как показано в следующем примере: См. пример кода в исходном документе.\nРегулярные выражения Pointcuts.\nВы можете использовать RegexpMethodPointcutAdvisor с любым типом Advice.\nPointcuts на основе атрибутов.\nВажным типом статического точечного выреза является точечный вырез, управляемый метаданными.\nПри этом используется значения атрибутов метаданных (обычно метаданные уровня источника).\nДинамические точки.\nОценка динамических точек обходится дороже, чем статических.\nОни принимают во внимание аргументы метода, а также статическую информацию.\nЭто означает, что они должны быть оценивается при каждом вызове метода и что результат не может быть кэширован, так как аргументы будут варьироваться.\nДинамические точки.\nОсновным примером является pointcut «потока управления».\nПоток управления."}
{"id": 842, "text": "Pointcuts потока управления Spring концептуально аналогичны pointcuts `cflow` в AspectJ. хотя и менее мощный. (В настоящее время невозможно указать, что pointcut выполняется ниже точки соединения, соответствующей другой точке.) Точка потока управления соответствует текущий стек вызовов.\nНапример, он может сработать, если точка соединения была вызвана методом в пакете com.mycompany.web или в классе SomeCaller.\nСрезы точек потока управления указываются с помощью класса org.springframework.aop.support.ControlFlowPointcut.\nПоток управления.\nПРИМЕЧАНИЕ.\nОценка точек потока управления во время выполнения значительно дороже, чем даже другие динамические точки.\nСтоимость Java 1.4 примерно в пять раз выше стоимости других динамических точечные разрезы.\nСуперклассы Pointcut.\nSpring предоставляет полезные суперклассы pointcut, которые помогут вам реализовать свои собственные pointcut.\nСуперклассы Pointcut.\nПоскольку статические точки наиболее полезны, вам, вероятно, следует создать подкласс `StaticMethodMatcherPointcut`.\nДля этого необходимо реализовать только один абстрактный метод (хотя вы можете переопределить другие методы для настройки поведения).\nВ следующем примере показано, как создать подкласс `StaticMethodMatcherPointcut`:\nJava\n	class TestStaticPointcut extends StaticMethodMatcherPointcut {\n		public boolean matches(Method m, Class targetClass) {\n			// вернуть true, если пользовательские критерии совпадают\n	class TestStaticPointcut : StaticMethodMatcherPointcut() {\nСуперклассы Pointcut.\nСуществуют также суперклассы для динамических точек.\nВы можете использовать пользовательские точки с любым типом рекомендаций.\nПользовательские точечные вырезы."}
{"id": 843, "text": "Поскольку точечные вырезы в Spring AOP представляют собой классы Java, а не функции языка (как в AspectJ), вы можете объявлять собственные точки, статические или динамические.\nПользовательский pointcuts в Spring могут быть сколь угодно сложными.\nОднако мы рекомендуем использовать pointcut AspectJ. язык выражения, если можете.\nПользовательские точечные вырезы.\nПРИМЕЧАНИЕ.\nБолее поздние версии Spring могут предлагать поддержку «семантических точек», предлагаемых JAC. например, «все методы, которые изменяют переменные экземпляра в целевом объекте»."}
{"id": 844, "text": "Использование `@PostConstruct` и `@PreDestroy`.\nCommonAnnotationBeanPostProcessor не только распознает аннотацию @Resource. но также аннотации жизненного цикла JSR-250: `jakarta.annotation.PostConstruct` и `jakarta.annotation.PreDestroy`.\nПредставленная в Spring 2.5 поддержка этих аннотации предлагают альтернативу механизму обратного вызова жизненного цикла, описанному в `CommonAnnotationBeanPostProcessor` регистрируется в `ApplicationContext` Spring, метод, содержащий одну из этих аннотаций, вызывается в той же точке жизненного цикла как соответствующий метод интерфейса жизненного цикла Spring или явно объявленный обратный вызов метод.\nВ следующем примере кэш предварительно заполняется при инициализации и очищается при уничтожении:\nJava\n	public class CachingMovieLister {\n		@PostConstruct\n		public void populateMovieCache() {\n			// заполняет кэш фильма при инициализации...\n		@PreDestroy\n		public void clearMovieCache() {\n			// очищает кэш фильма при уничтожении...\n	class CachingMovieLister {\nИспользование `@PostConstruct` и `@PreDestroy`.\nПодробную информацию о последствиях объединения различных механизмов жизненного цикла см.\nИспользование `@PostConstruct` и `@PreDestroy`. [ПРИМЕЧАНИЕ] = Как и @Resource, типы аннотаций @PostConstruct и @PreDestroy были частью стандартных библиотек Java от JDK 6 до 8.\nОднако весь `javax.annotation` пакет был отделен от основных модулей Java в JDK 9 и в конечном итоге удален в JDK 11."}
{"id": 845, "text": "Начиная с Jakarta EE 9, пакет теперь находится в `jakarta.annotation`.\nЕсли необходимо, артефакт `jakarta.annotation-api` необходимо получить через Maven Central сейчас, просто быть добавленным в путь к классам приложения, как и любая другая библиотека."}
{"id": 846, "text": "Программное создание прокси-серверов AOP с помощью ProxyFactory.\nПрограммно создавать прокси-серверы AOP с помощью Spring легко.\nЭто позволяет вам использовать Spring AOP без зависимости от Spring IoC.\nИнтерфейсы, реализованные целевым объектом: автоматически проксируется.\nВ следующем листинге показано создание прокси для целевого объекта с одним перехватчик и один советник:\nJava\n	ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);\n	factory.addAdvice(myMethodInterceptor);\n	factory.addAdvisor(myAdvisor);\n	MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();\nПервым шагом является создание объекта типа `org.springframework.aop.framework.ProxyFactory`.\nВы можете создать это с помощью цели объект, как в предыдущем примере, или укажите интерфейсы, которые будут проксироваться в альтернативном конструктор.\nВы можете добавить совет (с перехватчиками как специализированный вид совета), советников или и то, и другое. и манипулировать ими на протяжении всей жизни ProxyFactory.\nЕсли вы добавите `IntroductionInterceptionAroundAdvisor`, вы можете заставить прокси реализовать дополнительные интерфейсы.\nСуществуют также удобные методы ProxyFactory (унаследованные от AdvisedSupport). которые позволяют вам добавлять другие типы советов, например, предыдущие и выбрасывающие советы.\nAdvisedSupport — это суперкласс ProxyFactory и ProxyFactoryBean.\nСОВЕТ: Интеграция создания прокси-сервера AOP с платформой IoC является лучшей практикой в большинстве случаев. приложения.\nМы рекомендуем вам экспортировать конфигурацию из кода Java с помощью AOP. как и должно быть в целом."}
{"id": 847, "text": "Программная регистрация компонентов.\nНачиная с Spring Framework 7, реализована первоклассная поддержка программной регистрации компонентов. предоставляется через {spring-framework-api}/beans/factory/BeanRegistrar.html[`BeanRegistrar`] интерфейс, который можно реализовать для программной регистрации компонентов в гибком и эффективный способ.\nПрограммная регистрация компонентов.\nЭти реализации регистратора компонентов обычно импортируются с аннотацией @Import. на классах `@Configuration`.\nСм. пример кода в исходном документе.\nПрограммная регистрация компонентов.\nПРИМЕЧАНИЕ.\nВы можете использовать условные аннотации на уровне типа ({spring-framework-api}/context/annotation/Conditional.html[`@Conditional`], но и другие варианты) для условного импорта связанных регистраторов bean-компонентов.\nПрограммная регистрация компонентов.\nThe bean registrar implementation uses {spring-framework-api}/beans/factory/BeanRegistry.html[`BeanRegistry`] and {spring-framework-api}/core/env/Environment.html[`Environment`] API для программной регистрации bean-компонентов в кратком изложении и гибкий способ.\nНапример, он допускает пользовательскую регистрацию через выражение if, цикл `for` и т. д.\nСм. пример кода в исходном документе.\nПрограммная регистрация компонентов.\nПРИМЕЧАНИЕ.\nРегистраторы компонентов поддерживаются с помощью Ahead of Time Optimizations. либо на JVM, либо с собственными образами GraalVM, в том числе при использовании поставщиков экземпляров."}
{"id": 848, "text": "* TransactionTemplate или TransactionalOperator.\n* Непосредственная реализация TransactionManager.\nSpring Framework предоставляет два средства программного управления транзакциями, используя:.\nКоманда Spring обычно рекомендует TransactionTemplate для программных операций. управление транзакциями в императивных потоках и TransactionalOperator для реактивного кода.\nВторой подход аналогичен использованию JTA API UserTransaction, однако исключение обработка менее трудоемка.\nИспользование TransactionTemplate.\nTransactionTemplate использует тот же подход, что и другие шаблоны Spring, такие как `JdbcTemplate`.\nОн использует подход обратного вызова (чтобы освободить код приложения от необходимости выполнить стандартное приобретение и высвободить транзакционные ресурсы) и приводит к код, управляемый намерением, поскольку ваш код фокусируется исключительно на том, что ты хочешь сделать.\nИспользование TransactionTemplate.\nПРИМЕЧАНИЕ.\nКак показывают следующие примеры, использование TransactionTemplate абсолютно соединяет вас с инфраструктурой транзакций и API Spring.\nПрограммное или нет управление транзакциями подходит для ваших нужд разработки — это решение, которое вы придется сделать самому.\nИспользование TransactionTemplate.\nКод приложения, который должен выполняться в контексте транзакций и явно использует TransactionTemplate напоминает следующий пример.\nВы как приложение разработчик может написать реализацию TransactionCallback (обычно выражаемую как анонимный внутренний класс), содержащий код, который вам нужно запустить в контексте транзакция.\nЗатем вы можете передать экземпляр своего пользовательского TransactionCallback в Метод `execute(..)`, представленный в `TransactionTemplate`.\nВ следующем примере показано, как это сделать:\nJava\n	public class SimpleService implements Service {"}
{"id": 849, "text": "// один шаблон TransactionTemplate, общий для всех методов в этом примере.\n		private final TransactionTemplate transactionTemplate;\n		// Использовать конструктор для предоставления PlatformTransactionManager.\n		public SimpleService(PlatformTransactionManager transactionManager) {\n			this.transactionTemplate = new TransactionTemplate(transactionManager);\n		public Object someServiceMethod() {\n			return transactionTemplate.execute(new TransactionCallback() {\n				// код этого метода выполняется в контексте транзакции\n				public Object doInTransaction(TransactionStatus status) {\n					updateOperation1();\n					return resultOfUpdateOperation2();\nИспользование TransactionTemplate.\nЕсли возвращаемого значения нет, вы можете использовать удобный класс TransactionCallbackWithoutResult. с анонимным классом следующим образом:\nJava\n	transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n		protected void doInTransactionWithoutResult(TransactionStatus status) {\n			updateOperation1();\n			updateOperation2();\nИспользование TransactionTemplate.\nКод внутри обратного вызова может откатить транзакцию, вызвав метод `setRollbackOnly()` для предоставленного объекта `TransactionStatus`, как показано ниже:\nJava\n	transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n		protected void doInTransactionWithoutResult(TransactionStatus status) {\n			try {\n				updateOperation1();\n				updateOperation2();\n			} catch (SomeBusinessException ex) {\n				status.setRollbackOnly();\nУказание настроек транзакции.\nВы можете указать параметры транзакции (например, режим распространения, уровень изоляции, таймаут и т. д.) в TransactionTemplate либо программно, либо в конфигурация.\nПо умолчанию экземпляры TransactionTemplate имеют В следующем примере показана программная настройка параметров транзакций для a specific `TransactionTemplate:`\nJava"}
{"id": 850, "text": "public class SimpleService implements Service {\n		private final TransactionTemplate transactionTemplate;\n		public SimpleService(PlatformTransactionManager transactionManager) {\n			this.transactionTemplate = new TransactionTemplate(transactionManager);\n			// настройки транзакции могут быть заданы здесь явно, если это необходимо\n			this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);\n			this.transactionTemplate.setTimeout(30); // 30 seconds\n			// и так далее...\nУказание настроек транзакции.\nВ следующем примере определяется TransactionTemplate с некоторыми пользовательскими транзакционными настройки с помощью конфигурации Spring XML:\n	<bean id=\"sharedTransactionTemplate\"\n			class=\"org.springframework.transaction.support.TransactionTemplate\">\n		<property name=\"isolationLevelName\" value=\"ISOLATION_READ_UNCOMMITTED\"/>\n		<property name=\"timeout\" value=\"30\"/>\n	</bean>\nУказание настроек транзакции.\nЗатем вы можете внедрить `sharedTransactionTemplate` на столько услуг, сколько необходимо.\nУказание настроек транзакции.\nНаконец, экземпляры класса TransactionTemplate являются потокобезопасными. не поддерживать разговорного состояния.\nОднако экземпляры TransactionTemplate поддерживать состояние конфигурации.\nТаким образом, хотя несколько классов могут использовать один экземпляр TransactionTemplate, если классу необходимо использовать TransactionTemplate с другие настройки (например, другой уровень изоляции), необходимо создать два отдельных экземпляра TransactionTemplate.\nИспользование TransactionalOperator.\nTransactionalOperator имеет конструкцию оператора, аналогичную другим реактивным операторам. операторы."}
{"id": 851, "text": "Он использует подход обратного вызова (чтобы освободить код приложения от необходимости выполнять шаблонное получение и освобождение транзакционных ресурсов) и приводит к созданию кода, который управляемый намерением, поскольку ваш код фокусируется исключительно на том, что вы хотите сделать.\nИспользование TransactionalOperator.\nПРИМЕЧАНИЕ.\nКак показывают следующие примеры, использование TransactionalOperator абсолютно соединяет вас с инфраструктурой транзакций и API Spring.\nПрограммное или нет управление транзакциями подходит для ваших нужд разработки — это решение, которое у вас есть сделать себя.\nИспользование TransactionalOperator.\nКод приложения, который должен выполняться в контексте транзакций и явно использует TransactionalOperator напоминает следующий пример:\nJava\n	public class SimpleService implements Service {\n		// один транзакционный оператор, общий для всех методов в этом примере.\n		private final TransactionalOperator transactionalOperator;\n		// Использовать конструктор для предоставления ReactiveTransactionManager.\n		public SimpleService(ReactiveTransactionManager transactionManager) {\n			this.transactionalOperator = TransactionalOperator.create(transactionManager);\n		public Mono<Object> someServiceMethod() {\n			// код этого метода выполняется в контексте транзакции\n			Mono<Object> update = updateOperation1();\n			return update.then(resultOfUpdateOperation2).as(transactionalOperator::transactional);\n* В стиле оператора с использованием типов Project Reactor (`mono.as(transactionalOperator::transactional)`)\n* Стиль обратного вызова для всех остальных случаев (`transactionalOperator.execute(TransactionCallback<T>)`)\nTransactionalOperator можно использовать двумя способами:."}
{"id": 852, "text": "Код внутри обратного вызова может откатить транзакцию, вызвав setRollbackOnly(). метод для предоставленного объекта ReactiveTransaction следующим образом:\nJava\n	transactionalOperator.execute(new TransactionCallback<>() {\n		public Mono<Object> doInTransaction(ReactiveTransaction status) {\n			return updateOperation1().then(updateOperation2)\n						.doOnError(SomeBusinessException.class, e -> status.setRollbackOnly());\nОтменить сигналы.\nВ Reactive Streams «подписчик» может отменить свою «подписку» и прекратить `Издательство`.\nОператоры в Project Reactor, а также в других библиотеках, таких как `next()`, `take(long)`, `timeout(Duration)` и другие могут выдавать отмену.\nНет никакого способа знать причину отмены, является ли это ошибкой или просто отсутствием интерес потреблять дальше.\nНачиная с версии 5.3 сигналы отмены приводят к откату.\nВ результате важно учитывать операторы, используемые после транзакции. `Издательство`.\nВ частности, в случае Flux или другого многозначного издателя, весь вывод должен быть использован, чтобы транзакция завершилась.\nУказание настроек транзакции.\nВы можете указать параметры транзакции (например, режим распространения, уровень изоляции, таймаут и т. д.) для TransactionalOperator.\nПо умолчанию Экземпляры TransactionalOperator имеют В следующем примере показана настройка параметров транзакций для конкретного `ТранзакционныйОператор:`\nJava\n	public class SimpleService implements Service {\n		private final TransactionalOperator transactionalOperator;\n		public SimpleService(ReactiveTransactionManager transactionManager) {"}
{"id": 853, "text": "DefaultTransactionDefinition definition = new DefaultTransactionDefinition();\n			// настройки транзакции могут быть заданы здесь явно, если это необходимо\n			definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);\n			definition.setTimeout(30); // 30 seconds\n			// и так далее...\n			this.transactionalOperator = TransactionalOperator.create(transactionManager, definition);\nИспользование TransactionManager.\nВ следующих разделах объясняется программное использование императивных и реактивных транзакций. менеджеры.\nИспользование «PlatformTransactionManager».\nДля императивных транзакций вы можете использовать `org.springframework.transaction.PlatformTransactionManager` напрямую для управления вашими транзакция.\nДля этого передайте реализацию PlatformTransactionManager, которую вы используйте для своего компонента через ссылку на компонент.\nЗатем, используя TransactionDefinition и Объекты TransactionStatus позволяют инициировать транзакции, откатывать их и фиксировать. следующий пример показывает, как это сделать:\nJava\n	DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n	// явно указать имя транзакции можно только программно\n	def.setName(\"SomeTxName\");\n	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n	TransactionStatus status = txManager.getTransaction(def);\n	try {\n		// поместите сюда свою бизнес-логику\n	} catch (MyException ex) {\n		txManager.rollback(status);\n		throw ex;\n	txManager.commit(status);\n	txManager.commit(status)\nИспользование ReactiveTransactionManager.\nПри работе с реактивными транзакциями вы можете использовать `org.springframework.transaction.ReactiveTransactionManager` напрямую для управления вашими транзакция."}
{"id": 854, "text": "Для этого передайте реализацию `ReactiveTransactionManager`, которую вы используйте для своего компонента через ссылку на компонент.\nЗатем, используя TransactionDefinition и Объекты `ReactiveTransaction` позволяют инициировать транзакции, откатывать их и фиксировать. следующий пример показывает, как это сделать:\nJava\n	DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n	// явно указать имя транзакции можно только программно\n	def.setName(\"SomeTxName\");\n	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n	Mono<ReactiveTransaction> reactiveTx = txManager.getReactiveTransaction(def);\n	reactiveTx.flatMap(status -> {\n		Mono<Object> tx = ...; // put your business logic here\n		return tx.then(txManager.commit(status))\n				.onErrorResume(ex -> txManager.rollback(status).then(Mono.error(ex)));\n		tx.then(txManager.commit(status))\n				.onErrorResume { ex -> txManager.rollback(status).then(Mono.error(ex)) }"}
{"id": 855, "text": "Свойства, массивы, списки, карты и индексаторы.\nЯзык выражений Spring обеспечивает поддержку навигации по графам объектов и индексации. в различные структуры.\nСвойства, массивы, списки, карты и индексаторы.\nПРИМЕЧАНИЕ.\nЗначения числовых индексов начинаются с нуля, например, при доступе к элементу n^th^ массив в Java.\nСвойства, массивы, списки, карты и индексаторы.\nСОВЕТ.\nСм.\nОператор безопасной навигации. раздел для получения подробной информации о том, как перемещаться по графам объектов и индексировать различные структуры. используя нулевой безопасный оператор.\nНавигация по недвижимости.\nВы можете перемещаться по ссылкам на свойства в графе объектов, используя точку для обозначения значение вложенного свойства.\nЭкземпляры класса Inventor, Pupin и Tesla, были заполненный данными, перечисленными в переместите _вниз_ граф объекта и получите год рождения Теслы и город рождения Пупина, мы используем следующие выражения:\nJava\n	// оценивается в 1856\n	int year = (Integer) parser.parseExpression(\"birthdate.year + 1900\").getValue(context);\n	// оценивается как «Смилян»\n	String city = (String) parser.parseExpression(\"placeOfBirth.city\").getValue(context);\nНавигация по недвижимости. [ПРИМЕЧАНИЕ] = Для первых букв имен свойств допускается нечувствительность к регистру."}
{"id": 856, "text": "Таким образом, выражения в приведенном выше примере могут быть записаны как «Дата рождения.Год + 1900» и `МестоРождения.Город` соответственно.\nКроме того, к свойствам можно получить доступ через вызовы методов — например, `getPlaceOfBirth().getCity()` вместо `месторождения.город`.\nИндексирование в массивы и коллекции.\nЭлемент n^th^ массива или коллекции (например, Set или List) может быть получается с использованием квадратных скобок, как показано в следующем примере.\nИндексирование в массивы и коллекции. [ПРИМЕЧАНИЕ] = Если индексированная коллекция представляет собой `java.util.List`, будет доступен элемент n^th^. напрямую через `list.get(n)`.\nИндексирование в массивы и коллекции.\nДля любого другого типа «Коллекции» доступ к элементу n^th^ будет осуществляться путем итерации коллекция использует свой Iterator и возвращает встретившийся элемент n^th^.\nJava\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n	// Массив изобретений\n	// оценивается как «Асинхронный двигатель»\n	String invention = parser.parseExpression(\"inventions[3]\").getValue(\n			context, tesla, String.class);\n	// Список участников\n	// оценивается как «Никола Тесла»"}
{"id": 857, "text": "String name = parser.parseExpression(\"members[0].name\").getValue(\n			context, ieee, String.class);\n	// Индексация списков и массивов\n	// оценивается как «Беспроводная связь»\n	String invention = parser.parseExpression(\"members[0].inventions[6]\").getValue(\n			context, ieee, String.class);\n	// Массив изобретений\n	// Список участников\n	// Индексация списков и массивов\nИндексирование в строки.\nСимвол n^th^ строки можно получить, указав индекс внутри квадрата. скобки, как показано в следующем примере.\nИндексирование в строки.\nПРИМЕЧАНИЕ.\nСимвол n^th^ строки будет оцениваться как `java.lang.String`, а не как `java.lang.Character`.\nJava\n	// оценивается как «Т» (8-я буква имени «Никола Тесла»)\n	String character = parser.parseExpression(\"members[0].name[7]\")\n			.getValue(societyContext, String.class);\nИндексирование в Картах.\nСодержимое карт получается путем указания значения ключа в квадратных скобках.\nВ В следующем примере, поскольку ключи для карты офицеров являются строками, мы можем указать строковые литералы, такие как `'президент'`:\nJava\n	// Офицерская карта\n	// оценивается как Inventor(\"Pupin\")"}
{"id": 858, "text": "Inventor pupin = parser.parseExpression(\"officers['president']\")\n			.getValue(societyContext, Inventor.class);\n	// оценивается как «Идвор»\n	String city = parser.parseExpression(\"officers['president'].placeOfBirth.city\")\n			.getValue(societyContext, String.class);\n	String countryExpression = \"officers['advisors'][0].placeOfBirth.country\";\n	// установка значений\n	parser.parseExpression(countryExpression)\n			.setValue(societyContext, \"Croatia\");\n	// оценивается как «Хорватия»\n	String country = parser.parseExpression(countryExpression)\n			.getValue(societyContext, String.class);\n	// Офицерская карта\n	// установка значений\n	parser.parseExpression(countryExpression)\n			.setValue(societyContext, \"Croatia\")\nИндексирование в объекты.\nСвойство объекта можно получить, указав имя свойства внутри квадратные скобки.\nЭто аналогично доступу к значению карты на основе ее ключа.\nВ следующем примере показано, как _index_ в объект для получения определенного собственность.\nJava\n	// Создание изобретателя для использования в качестве объекта корневого контекста.\n	Inventor tesla = new Inventor(\"Nikola Tesla\");\n	// оценивается как «Никола Тесла»\n	String name = parser.parseExpression(\"#root['name']\")\n			.getValue(context, tesla, String.class);\nИндексирование в пользовательские структуры."}
{"id": 859, "text": "Начиная с Spring Framework 6.2, язык выражений Spring поддерживает индексацию в пользовательские структуры, позволяя разработчикам реализовать и зарегистрировать IndexAccessor с помощью `Контекст оценки`.\nЕсли вы хотите поддержать выражения, которые полагаются на пользовательский метод доступа к индексу, этот метод доступа к индексу должен реализовывать SPI `CompilableIndexAccessor`.\nИндексирование в пользовательские структуры.\nДля поддержки распространенных случаев использования Spring предоставляет встроенный ReflectiveIndexAccessor, который это гибкий IndexAccessor, который использует отражение для чтения и, при необходимости, записи. индексированная структура целевого объекта.\nДоступ к индексированной структуре можно получить через «публичный» метод чтения (при чтении) или «публичный» метод записи (при записи).\nОтношения между методом чтения и методом записи основаны на соглашении, согласно которому применим для типичных реализаций индексированных структур.\nИндексирование в пользовательские структуры.\nПРИМЕЧАНИЕ.\nReflectiveIndexAccessor также реализует CompilableIndexAccessor для поддержка компиляция в байт-код для доступа на чтение.\nОднако обратите внимание, что настроенный метод чтения должен быть можно вызвать через общедоступный класс или общедоступный интерфейс для успешной компиляции.\nИндексирование в пользовательские структуры.\nСледующие листинги кода определяют перечисление Color и тип FruitMap, которые ведут себя как map, но не реализует интерфейс java.util.Map.\nТаким образом, если вы хотите индексировать в FruitMap в выражении SpEL, вам необходимо зарегистрировать IndexAccessor.\n	package example;\n	public enum Color {\n		RED, ORANGE, YELLOW\n	public class FruitMap {"}
{"id": 860, "text": "private final Map<Color, String> map = new HashMap<>();\n		public FruitMap() {\n			this.map.put(Color.RED, \"cherry\");\n			this.map.put(Color.ORANGE, \"orange\");\n			this.map.put(Color.YELLOW, \"banana\");\n		public String getFruit(Color color) {\n			return this.map.get(color);\n		public void setFruit(Color color, String fruit) {\n			this.map.put(color, fruit);\nИндексирование в пользовательские структуры.\nДоступный только для чтения «IndexAccessor» для «FruitMap» можно создать с помощью «new ReflectiveIndexAccessor(FruitMap.class, Color.class, \"getFruit\")`.\nС этим аксессуаром зарегистрирован, а FruitMap зарегистрирован как переменная с именем #fruitMap, SpEL выражение `#fruitMap[T(example.Color).RED]` будет иметь значение `\"вишня\"`.\nИндексирование в пользовательские структуры. «IndexAccessor» для чтения и записи для FruitMap можно создать с помощью «new ReflectiveIndexAccessor(FruitMap.class, Color.class, «getFruit», «setFruit»)`."}
{"id": 861, "text": "С этим зарегистрирован метод доступа, а FruitMap зарегистрирован как переменная с именем #fruitMap, SpEL выражение `#fruitMap[T(example.Color).RED] = 'strawberry'` можно использовать для изменения отображение фруктов для красного цвета от «вишни» до «клубники».\nИндексирование в пользовательские структуры.\nВ следующем примере показано, как зарегистрировать ReflectiveIndexAccessor для индексации. в FruitMap, а затем индексировать в FruitMap в выражении SpEL.\nJava\n	// Создаем ReflectiveIndexAccessor для FruitMap\n	IndexAccessor fruitMapAccessor = new ReflectiveIndexAccessor(\n			FruitMap.class, Color.class, \"getFruit\", \"setFruit\");\n	// Регистрируемый IndexAccessor для FruitMap\n	context.addIndexAccessor(fruitMapAccessor);\n	// Зарегистрируйте переменную FruitMap\n	context.setVariable(\"fruitMap\", new FruitMap());\n	// оценивается как \"вишня\"\n	String fruit = parser.parseExpression(\"#fruitMap[T(example.Color).RED]\")\n			.getValue(context, String.class);\n	// Регистрируемый IndexAccessor для FruitMap\n	context.addIndexAccessor(fruitMapAccessor)\n	// Зарегистрируйте переменную FruitMap\n	context.setVariable(\"fruitMap\", FruitMap())"}
{"id": 862, "text": "Механизмы проксирования.\nSpring AOP использует либо динамические прокси JDK, либо CGLIB для создания прокси для заданного целевой объект.\nДинамические прокси JDK встроены в JDK, тогда как CGLIB является обычным библиотека определения классов с открытым исходным кодом (переупакованная в `spring-core`).\nМеханизмы проксирования.\nЕсли целевой объект, который будет проксирован, реализует хотя бы один интерфейс, динамический JDK используется прокси, и все интерфейсы, реализованные целевым типом, проксируются.\nЕсли целевой объект не реализует никаких интерфейсов, создается прокси-сервер CGLIB, который является подклассом целевого типа, созданным во время выполнения.\nМеханизмы проксирования.\nЕсли вы хотите принудительно использовать проксирование CGLIB (например, проксировать каждый метод определенные для целевого объекта, а не только те, которые реализованы его интерфейсами), вы можете это сделать.\nОднако вам следует рассмотреть следующие вопросы:\n* Классы `final` не могут быть проксированы, поскольку их нельзя расширить.\n* `final` методы не рекомендуются, поскольку их нельзя переопределить.\n* `private` методы не рекомендуются, поскольку их нельзя переопределить.\n* Методы, которые не видны — например, частные методы родительского класса.\nМеханизмы проксирования. из другого пакета – рекомендовать нельзя, поскольку они фактически являются частными.\n* Конструктор вашего проксируемого объекта не будет вызываться дважды, поскольку прокси-сервер CGLIB\nМеханизмы проксирования. экземпляр создается через Objenesis."}
{"id": 863, "text": "Однако, если ваша JVM не позволяет обход конструктора, вы можете увидеть двойные вызовы и соответствующий журнал отладки записи из поддержки Spring AOP.\n* Использование прокси-сервера CGLIB может столкнуться с ограничениями из-за системы модулей Java. Как типичный\nМеханизмы проксирования.\nВ этом случае вы не можете создать прокси CGLIB для класса из пакета `java.lang`, когда развертывание по пути модуля.\nВ таких случаях требуется флаг начальной загрузки JVM. `--add-opens=java.base/java.lang=ALL-UNNAMED` который недоступен для модулей.\nПринудительное использование определенных типов прокси-серверов AOP.\nЧтобы принудительно использовать прокси CGLIB, установите значение атрибута proxy-target-class. элемента `<aop:config>` в true следующим образом:\n	<aop:config proxy-target-class=\"true\">\n		<!-- other beans defined here... -->\n	</aop:config>\nПринудительное использование определенных типов прокси-серверов AOP.\nЧтобы принудительно проксировать CGLIB при использовании поддержки автоматического прокси @AspectJ, установите атрибут proxy-target-class элемента `<aop:aspectj-autoproxy>` на `true`, следующим образом:\n	<aop:aspectj-autoproxy proxy-target-class=\"true\"/>"}
{"id": 864, "text": "Принудительное использование определенных типов прокси-серверов AOP. [ПРИМЕЧАНИЕ] = Несколько разделов `<aop:config/>` свернуты в один единый автоматический прокси-создатель. во время выполнения, который применяет самые _сильные_ настройки прокси-сервера, которые доступны любому из Указаны разделы `<aop:config/>` (обычно из разных файлов определений XML-компонентов).\nЭто также относится к `<tx:annotation-driven/>` и `<aop:aspectj-autoproxy/>` элементы.\nПринудительное использование определенных типов прокси-серверов AOP.\nЧтобы внести ясность, используя `proxy-target-class=\"true\"` для `<tx:annotation-driven/>`, Элементы `<aop:aspectj-autoproxy/>` или `<aop:config/>` требуют использования CGLIB прокси _для всех троих_.\nПринудительное использование определенных типов прокси-серверов AOP. `@EnableAspectJAutoProxy`, `@EnableTransactionManagement` и связанные с ними конфигурации. аннотации предлагают соответствующий атрибут proxyTargetClass.\nОни свернуты в единого унифицированного создателя автоматических прокси, эффективно применяя _сильнейшие_ настройки прокси во время выполнения.\nНачиная с версии 7.0, это относится к отдельным прокси-процессорам. а также, например, `@EnableAsync`, последовательно участвуя в едином глобальном настройки по умолчанию для всех попыток автоматического проксирования в данном приложении."}
{"id": 865, "text": "Принудительное использование определенных типов прокси-серверов AOP.\nТип глобального прокси-сервера по умолчанию может различаться в зависимости от настройки.\nХотя основная структура по умолчанию предлагает прокси на основе интерфейса, Spring Boot может - в зависимости от свойства конфигурации — включить прокси на основе классов по умолчанию.\nПринудительное использование определенных типов прокси-серверов AOP.\nНачиная с версии 7.0, принудительное использование определенного типа прокси для отдельных компонентов возможно через аннотация `@Proxyable` для данного метода `@Bean` или класса `@Component`, с `@Proxyable(INTERFACES)` или `@Proxyable(TARGET_CLASS)`, переопределяя любые глобальные настроено по умолчанию.\nДля очень специфических целей вы можете даже указать прокси интерфейс(ы) для использования через `@Proxyable(interfaces=...)`, ограничивая воздействие к выбранным интерфейсам, а не ко всем интерфейсам, которые реализует целевой компонент.\nПонимание прокси-серверов AOP.\nSpring AOP основан на прокси.\nКрайне важно понять семантику что на самом деле означает это последнее утверждение, прежде чем вы напишете свои собственные аспекты или воспользуетесь каким-либо из них. аспекты Spring на основе AOP, поставляемые вместе со Spring Framework.\nПонимание прокси-серверов AOP.\nСначала рассмотрим сценарий, в котором у вас есть обычная ссылка на объект без проксирования. как показано в следующем фрагменте кода:\nJava\n	public class SimplePojo implements Pojo {\n		public void foo() {"}
{"id": 866, "text": "// Следующий метод вызова является вызовом ссылки this\n			this.bar();\n		public void bar() {\n			// немного логики...\n	class SimplePojo : Pojo {\nПонимание прокси-серверов AOP.\nЕсли вы вызываете метод по ссылке на объект, этот метод вызывается непосредственно по ссылке. эта ссылка на объект, как показано на следующем изображении и в листинге:\nJava\n	public class Main {\n		public static void main(String[] args) {\n			Pojo pojo = new SimplePojo();\n			// это метод прямого вызова по ссылке pojo\n			pojo.foo();\nизображение::aop-proxy-plain-pojo-call.png[].\nСитуация немного меняется, когда ссылка на клиентский код является прокси.\nРассмотрим следующая диаграмма и фрагмент кода:\nJava\n	public class Main {\n		public static void main(String[] args) {\n			ProxyFactory factory = new ProxyFactory(new SimplePojo());\n			factory.addInterface(Pojo.class);\n			factory.addAdvice(new RetryAdvice());\n			Pojo pojo = (Pojo) factory.getProxy();\n			// это вызов метода на прокси!\n			pojo.foo();\nизображение::aop-proxy-call.png[].\nЗдесь важно понимать, что клиентский код внутри метода main(..)` класса Main имеет ссылку на прокси."}
{"id": 867, "text": "Это означает, что метод вызывает это ссылка на объект — это вызовы прокси.\nВ результате прокси-сервер может делегировать полномочия всем перехватчики (советы), относящиеся к этому конкретному вызову метода.\nОднако, как только вызов наконец достигнет целевого объекта (ссылка SimplePojo в данном случае), любые вызовы методов, которые он может выполнить сам по себе, например `this.bar()` или `this.foo()` будут вызываться по ссылке `this`, а не по прокси.\nЭто имеет важные последствия.\nЭто означает, что самовызов не приведет к результату в совете, связанном с вызовом метода, получающим возможность запуска.\nДругими словами, Самовызов через явную или неявную ссылку this позволит обойти совет.\nизображение::aop-proxy-call.png[].\nЧтобы решить эту проблему, у вас есть следующие варианты.\nизображение::aop-proxy-call.png[].\nИзбегайте самовызова Лучший подход (термин «лучший» здесь используется в широком смысле) — провести рефакторинг вашего кода таким образом, чтобы что самовызов не происходит.\nЭто требует некоторой работы с вашей стороны, но это лучший и наименее инвазивный подход.\nВнедрить ссылку на самого себя Альтернативный подход заключается в использовании и вызывать методы прокси-сервера через ссылку на себя, а не через `this`."}
{"id": 868, "text": "Используйте `AopContext.currentProxy()` Этот последний подход крайне не рекомендуется, и мы не решаемся указать на него в пользу предыдущие варианты.\nОднако в крайнем случае вы можете связать логику внутри ваш класс в Spring AOP, как показано в следующем примере.\nJava\n	public class SimplePojo implements Pojo {\n		public void foo() {\n			// Это работает, но по возможности этого следует избегать.\n			((Pojo) AopContext.currentProxy()).bar();\n		public void bar() {\n			// немного логики...\n	class SimplePojo : Pojo {\nизображение::aop-proxy-call.png[].\nИспользование AopContext.currentProxy() полностью связывает ваш код со Spring AOP, и это сообщает самому классу о том, что он используется в контексте АОП, что уменьшает некоторые преимущества АОП.\nТакже требуется, чтобы ProxyFactory была настроен для предоставления прокси-сервера, как показано в следующем примере:\nJava\n	public class Main {\n		public static void main(String[] args) {\n			ProxyFactory factory = new ProxyFactory(new SimplePojo());\n			factory.addInterface(Pojo.class);\n			factory.addAdvice(new RetryAdvice());\n			factory.setExposeProxy(true);\n			Pojo pojo = (Pojo) factory.getProxy();\n			// это вызов метода на прокси!\n			pojo.foo();"}
{"id": 869, "text": "изображение::aop-proxy-call.png[].\nПРИМЕЧАНИЕ.\nПереплетение во время компиляции и загрузки AspectJ не имеет такого самовызова. проблема, потому что они применяют советы в байт-коде, а не через прокси."}
{"id": 870, "text": "Доступ к данным с помощью R2DBC. https://r2dbc.io[R2DBC] («Реактивное подключение к реляционным базам данных») — это проект, управляемый сообществом. попытка спецификации стандартизировать доступ к базам данных SQL с использованием реактивных шаблонов.\n* `core`: пакет `org.springframework.r2dbc.core` содержит `DatabaseClient`\nСтруктура абстракции R2DBC Spring Framework состоит из двух разных пакетов:. класс плюс множество связанных классов.\nСм.\n* `connection`: пакет `org.springframework.r2dbc.connection` содержит служебный класс.\nСтруктура абстракции R2DBC Spring Framework состоит из двух разных пакетов:. для простого доступа к ConnectionFactory и различных простых реализаций ConnectionFactory. который вы можете использовать для тестирования и запуска немодифицированного R2DBC.\nСм.\nСтруктура абстракции R2DBC Spring Framework состоит из двух разных пакетов:.\nИспользование основных классов R2DBC для управления базовой обработкой R2DBC и обработкой ошибок\nСтруктура абстракции R2DBC Spring Framework состоит из двух разных пакетов:.\nВ этом разделе описывается, как использовать базовые классы R2DBC для управления базовой обработкой R2DBC. включая обработку ошибок.\nОн включает в себя следующие темы:\n* Использование `DatabaseClient`\n* Выполнение операторов\n* Запрос (`SELECT`)\n* Обновление (`INSERT`, `UPDATE` и `DELETE`) с помощью `DatabaseClient`\n* Фильтры операторов\n* Получение автоматически сгенерированных ключей\nИспользование `DatabaseClient`."}
{"id": 871, "text": "DatabaseClient — это центральный класс основного пакета R2DBC.\nОн обрабатывает создание и выпуск ресурсов, что помогает избежать типичных ошибок, таких как забыл закрыть соединение.\nОн выполняет основные задачи ядра R2DBC. рабочий процесс (например, создание и выполнение операторов), оставляя код приложения обеспечивать SQL и извлечь результаты.\nКласс DatabaseClient:\n* Выполняет SQL-запросы\n* Операторы обновления и вызовы хранимых процедур.\n* Выполняет итерацию по экземплярам `Result`\n* Перехватывает исключения R2DBC и преобразует их в общий, более информативный,\nИспользование `DatabaseClient`. иерархия исключений, определенная в пакете `org.springframework.dao`. (См. ссылку:data-access/dao.adoc#dao-Exceptions [Согласованная иерархия исключений].)\nИспользование `DatabaseClient`.\nКлиент имеет функциональный, гибкий API, использующий реактивные типы для декларативной композиции.\nИспользование `DatabaseClient`.\nКогда вы используете `DatabaseClient` для своего кода, вам нужно только реализовать интерфейсы `java.util.function`, давая им четко определенный контракт.\nУчитывая `Соединение`, предоставляемое классом `DatabaseClient`, `Function` обратный вызов создает `Publisher`.\nТо же самое верно и для отображения функций, которые извлеките результат `Row`.\nИспользование `DatabaseClient`."}
{"id": 872, "text": "Вы можете использовать DatabaseClient в реализации DAO посредством прямого создания экземпляра. со ссылкой ConnectionFactory или вы можете настроить его в контейнере Spring IoC. и передайте его DAO в качестве ссылки на компонент.\nИспользование `DatabaseClient`.\nСамый простой способ создать объект DatabaseClient — использовать статический фабричный метод, как показано ниже:\nJava\n	DatabaseClient client = DatabaseClient.create(connectionFactory);\nИспользование `DatabaseClient`.\nПРИМЕЧАНИЕ.\nConnectionFactory всегда следует настраивать как компонент в Spring IoC. контейнер.\nИспользование `DatabaseClient`.\nПредыдущий метод создает DatabaseClient с настройками по умолчанию.\nИспользование `DatabaseClient`.\nВы также можете получить экземпляр `Builder` из `DatabaseClient.builder()`.\nВы можете настроить клиента, вызвав следующие методы:\n* `….bindMarkers(…)`: укажите конкретную `BindMarkersFactory` для настройки именованного\nИспользование `DatabaseClient`. параметр для перевода маркера привязки базы данных.\n* `….executeFunction(…)`: установите для `ExecuteFunction` способ получения объектов `Statement`.\nИспользование `DatabaseClient`. беги.\n* `….namedParameters(false)`: отключить расширение именованных параметров. Включено по умолчанию.\nИспользование `DatabaseClient`.\nСОВЕТ.\nДиалекты разрешаются с помощью {spring-framework-api}/r2dbc/core/binding/BindMarkersFactoryResolver.html[`BindMarkersFactoryResolver`] из ConnectionFactory, обычно путем проверки ConnectionFactoryMetadata.\nИспользование `DatabaseClient`."}
{"id": 873, "text": "Вы можете позволить Spring автоматически обнаруживать вашу BindMarkersFactory, зарегистрировав класс, реализующий `org.springframework.r2dbc.core.binding.BindMarkersFactoryResolver$BindMarkerFactoryProvider` через `META-INF/spring.factories`. `BindMarkersFactoryResolver` обнаруживает реализации поставщика маркеров привязки из путь к классу с использованием SpringFactoriesLoader.\n* Н2\n* МарияДБ\n* Microsoft SQL-сервер.\n* MySQL\n* Постгрес\nВ настоящее время поддерживаются следующие базы данных:.\nВесь SQL, выдаваемый этим классом, регистрируется на уровне DEBUG в категории соответствующее полному имени класса экземпляра клиента (обычно `DefaultDatabaseClient`).\nКроме того, каждое выполнение регистрирует контрольную точку в реактивная последовательность для облегчения отладки.\nВ настоящее время поддерживаются следующие базы данных:.\nВ следующих разделах представлены некоторые примеры использования DatabaseClient.\nЭти примеры не являются исчерпывающим списком всех функций, предоставляемых `DatabaseClient`.\nДля этого обратитесь к помощнику {spring-framework-api}/r2dbc/core/DatabaseClient.html[javadoc].\nВыполнение операторов. `DatabaseClient` обеспечивает базовую функциональность выполнения оператора.\nВ следующем примере показано, что вам нужно включить для минимального, но полностью функционального код, создающий новую таблицу:\nJava\n	Mono<Void> completion = client.sql(\"CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);\")\n			.then();"}
{"id": 874, "text": "client.sql(\"CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);\")\n			.await()\nВыполнение операторов. `DatabaseClient` разработан для удобного и свободного использования.\nОн предоставляет промежуточные, продолжающие и терминальные методы на каждом этапе спецификация исполнения.\nВ предыдущем примере выше используется then() для возврата завершения. `Publisher`, который завершается, как только запрос (или запросы, если запрос SQL содержит несколько операторов) завершается.\nВыполнение операторов.\nПРИМЕЧАНИЕ. `execute(…)` принимает либо строку запроса SQL, либо запрос `Supplier<String>` чтобы отложить фактическое создание запроса до его выполнения.\nЗапрос («ВЫБРАТЬ»).\nSQL-запросы могут возвращать значения через объекты Row или количество затронутых строк. `DatabaseClient` может возвращать количество обновленных строк или сами строки. в зависимости от выданного запроса.\nJava\n	Mono<Map<String, Object>> first = client.sql(\"SELECT id, name FROM person\")\n			.fetch().first();\nJava\n	Mono<Map<String, Object>> first = client.sql(\"SELECT id, name FROM person WHERE first_name = :fn\")\n			.bind(\"fn\", \"Joe\")\n			.fetch().first();\nСледующий запрос использует переменную связывания:."}
{"id": 875, "text": "Возможно, вы заметили использование fetch() в приведенном выше примере. `fetch()` — это оператор продолжения, который позволяет указать, сколько данных вы хотите использовать.\nСледующий запрос использует переменную связывания:.\nВызов first() возвращает первую строку результата и отбрасывает оставшиеся строки.\nВы можете использовать данные с помощью следующих операторов:\nСледующий запрос использует переменную связывания:.\nБез указания дополнительных деталей сопоставления запросы возвращают результаты в виде таблицы. как `Map`, ключи которого представляют собой имена столбцов без учета регистра, которые сопоставляются со значением их столбца.\nСледующий запрос использует переменную связывания:.\nВы можете взять под контроль сопоставление результатов, предоставив `Function<Row, T>`, которая получает вызывается для каждой строки, чтобы она могла возвращать произвольные значения (единичные значения, коллекции, карты и предметы).\nJava\n	Flux<String> names = client.sql(\"SELECT name FROM person\")\n			.map(row -> row.get(\"name\", String.class))\n			.all();\n	Flux<String> names = client.sql(\"SELECT name FROM person\")\n			.mapValue(String.class)\n			.all();\nВ качестве альтернативы существует ярлык для сопоставления с одним значением:.\nИли вы можете сопоставить объект результата со свойствами компонента или компонентами записи:\n	// принимая свойство name для Person"}
{"id": 876, "text": "Flux<Person> persons = client.sql(\"SELECT name FROM person\")\n			.mapProperties(Person.class)\n			.all();\nВ качестве альтернативы существует ярлык для сопоставления с одним значением:. .А как насчет `null`? **** Результаты реляционной базы данных могут содержать нулевые значения.\nСпецификация Reactive Streams запрещает передачу нулевых значений.\nЭто требование требует правильной обработки `null` в функции извлечения.\nХотя вы можете получить нулевые значения из строки, вы не должны выдавать нулевые значения. ценность.\nВы должны обернуть в объект любые `null` значения (например, `Optional`). для сингулярных значений), чтобы гарантировать, что значение `null` никогда не возвращается напрямую. вашей функцией экстрактора. ****\nВ качестве альтернативы существует ярлык для сопоставления с одним значением:.\nОбновление (INSERT, UPDATE и DELETE) с помощью DatabaseClient.\nВ качестве альтернативы существует ярлык для сопоставления с одним значением:.\nЕдинственное отличие модифицирующих операторов состоит в том, что эти операторы обычно не возвращайте табличные данные, поэтому для получения результатов используйте `rowsUpdated()`.\nВ качестве альтернативы существует ярлык для сопоставления с одним значением:.\nВ следующем примере показан оператор `UPDATE`, который возвращает число. обновленных строк:\nJava\n	Mono<Integer> affectedRows = client.sql(\"UPDATE person SET first_name = :fn\")"}
{"id": 877, "text": ".bind(\"fn\", \"Joe\")\n			.fetch().rowsUpdated();\nПривязка значений к запросам.\nТипичному приложению требуются параметризованные операторы SQL для выбора или обновить строки в соответствии с некоторыми входными данными.\nОбычно это операторы `SELECT`. ограничено предложением WHERE или операторами INSERT и UPDATE, которые принимают входные параметры.\nПараметризованные операторы несут риск SQL-инъекции, если параметры не экранируются должным образом. `DatabaseClient` использует R2DBC. `bind` API для устранения риска SQL-инъекции для параметров запроса.\nВы можете предоставить параметризованный оператор SQL с помощью оператора `execute(…)`. и привязать параметры к фактическому `Statement`.\nЗатем ваш драйвер R2DBC запускается оператор с использованием подготовленных операторов и подстановки параметров.\n* По индексу, используя индексы параметров, отсчитываемые от нуля.\n* По имени, используя имя-заполнитель.\n	db.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n			.bind(\"id\", \"joe\")\n			.bind(\"name\", \"Joe\")\n			.bind(\"age\", 34);\n	Map<String, Object> params = new LinkedHashMap<>();\n	params.put(\"id\", \"joe\");\n	params.put(\"name\", \"Joe\");"}
{"id": 878, "text": "params.put(\"age\", 34);\n	db.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n			.bindValues(params);\nАльтернативно вы можете передать карту имен и значений:.\nИли вы можете передать объект параметра со свойствами компонента или компонентами записи:\n	// Предполагаемые свойства id, имя, возраст для Person\n	db.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n			.bindProperties(new Person(\"joe\", \"Joe\", 34);\nАльтернативно вы можете передать карту имен и значений:.\nАльтернативно вы можете использовать позиционные параметры для привязки значений к операторам.\nИндексы отсчитываются от нуля.\n	db.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n			.bind(0, \"joe\")\n			.bind(1, \"Joe\")\n			.bind(2, 34);\nАльтернативно вы можете передать карту имен и значений:.\nЕсли ваше приложение привязано ко многим параметрам, того же можно добиться одним вызовом:\n	List<?> values = List.of(\"joe\", \"Joe\", 34);"}
{"id": 879, "text": "db.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n			.bindValues(values);\nАльтернативно вы можете передать карту имен и значений:.\nСобственные маркеры привязки.R2DBC **** R2DBC использует собственные маркеры привязки базы данных, которые зависят от фактического поставщика базы данных.\nНапример, Postgres использует индексированные маркеры, такие как `$1`, `$2`, `$n`.\nДругим примером является SQL Server, который использует именованные маркеры привязки с префиксом `@`.\nАльтернативно вы можете передать карту имен и значений:.\nЭто отличается от JDBC, который требует `?` в качестве маркеров привязки.\nВ JDBC настоящие драйверы переводят маркеры привязки `?` в собственные базы данных. маркеры как часть выполнения их оператора.\nАльтернативно вы можете передать карту имен и значений:.\nПоддержка R2DBC в Spring Framework позволяет использовать собственные маркеры привязки или именованную привязку. маркеры с синтаксисом `:name`.\nАльтернативно вы можете передать карту имен и значений:.\nПоддержка именованных параметров использует экземпляр BindMarkersFactory для расширения именованных параметров. параметры для собственных маркеров привязки во время выполнения запроса, что дает вам определенная степень переносимости запросов между различными поставщиками баз данных. ****\nАльтернативно вы можете передать карту имен и значений:."}
{"id": 880, "text": "Препроцессор запроса разворачивает именованные параметры «Коллекция» в серию привязок. маркеры, чтобы исключить необходимость создания динамических запросов на основе количества аргументов.\nМассивы вложенных объектов расширены, чтобы обеспечить возможность использования (например) списков выбора.\nРассмотрим следующий запрос:.\nВЫБЕРИТЕ идентификатор, имя, штат ИЗ таблицы ГДЕ (имя, возраст) В (('Джон', 35), ('Энн', 50))\nJava\n	List<Object[]> tuples = new ArrayList<>();\n	tuples.add(new Object[] {\"John\", 35});\n	tuples.add(new Object[] {\"Ann\",  50});\n	client.sql(\"ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ (имя, возраст) В (:tuples)\")\n			.bind(\"tuples\", tuples);\n	client.sql(\"ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ (имя, возраст) В (:tuples)\")\n			.bind(\"tuples\", tuples)\nПредыдущий запрос можно параметризовать и выполнить следующим образом:.\nПРИМЕЧАНИЕ.\nИспользование списков выбора зависит от поставщика.\nПредыдущий запрос можно параметризовать и выполнить следующим образом:.\nВ следующем примере показан более простой вариант с использованием предикатов IN:\nJava"}
{"id": 881, "text": "client.sql(\"ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ возраст В (:ages)\")\n			.bind(\"ages\", Arrays.asList(35, 50));\n	client.sql(\"ВЫБЕРИТЕ идентификатор, имя, состояние ИЗ таблицы ГДЕ возраст В (:ages)\")\n			.bind(\"ages\", arrayOf(35, 50))\nПредыдущий запрос можно параметризовать и выполнить следующим образом:.\nПРИМЕЧАНИЕ.\nСам R2DBC не поддерживает значения типа Collection.\nТем не менее, расширение данного списка в приведенном выше примере работает для именованных параметров. в поддержке Spring R2DBC, например, для использования в предложениях IN, как показано выше.\nОднако вставка или обновление столбцов с типом массива (например, в Postgres) требуется тип массива, который поддерживается базовым драйвером R2DBC: обычно массив Java, например `String[]` для обновления столбца `text[]`.\nНе передавайте `Collection<String>` или что-то подобное в качестве параметра массива.\nФильтры операторов.\nИногда вам нужно настроить параметры самого `Statement`. прежде чем он запустится.\nДля этого зарегистрируйте фильтр `Statement`. (`StatementFilterFunction`) с `DatabaseClient` для перехвата и модифицируйте операторы во время их выполнения, как показано в следующем примере:\nJava"}
{"id": 882, "text": "client.sql(\"Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)\")\n			.filter((s, next) -> next.execute(s.returnGeneratedValues(\"id\")))\n			.bind(\"name\", …)\n			.bind(\"state\", …);\n	client.sql(\"Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)\")\n			.filter { s: Statement, next: ExecuteFunction -> next.execute(s.returnGeneratedValues(\"id\")) }\n			.bind(\"name\", …)\n			.bind(\"state\", …)\nФильтры операторов. `DatabaseClient` также предоставляет упрощенную перегрузку `filter(…)`, которая принимает a `Function<Statement, Statement>`:\nJava\n	client.sql(\"Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)\")\n			.filter(statement -> s.returnGeneratedValues(\"id\"));\n	client.sql(\"ВЫБРАТЬ идентификатор, имя, состояние ИЗ таблицы\")\n			.filter(statement -> s.fetchSize(25));\n	client.sql(\"Таблица INSERT INTO (имя, состояние) ЗНАЧЕНИЯ(:имя, :состояние)\")"}
{"id": 883, "text": ".filter { statement -> s.returnGeneratedValues(\"id\") }\n	client.sql(\"ВЫБРАТЬ идентификатор, имя, состояние ИЗ таблицы\")\n			.filter { statement -> s.fetchSize(25) }\nФильтры операторов.\nРеализации StatementFilterFunction позволяют фильтровать `Statement` и фильтрация объектов `Result`.\nРекомендации по использованию `DatabaseClient`.\nЭкземпляры класса DatabaseClient после настройки являются потокобезопасными.\nЭто важно, потому что это означает, что вы можете настроить один экземпляр `DatabaseClient` а затем безопасно внедрить эту общую ссылку в несколько DAO (или репозиториев).\nDatabaseClient имеет состояние, поскольку он поддерживает ссылку на ConnectionFactory. но это состояние не является разговорным.\nРекомендации по использованию `DatabaseClient`.\nОбычной практикой при использовании класса DatabaseClient является настройка ConnectionFactory. в файле конфигурации Spring, а затем внедрить зависимость этот общий bean-компонент ConnectionFactory в ваших классах DAO. `DatabaseClient` создается в установщик для ConnectionFactory.\nЭто приводит к созданию DAO, которые напоминают следующее:\nJava\n	public class R2dbcCorporateEventDao implements CorporateEventDao {\n		private DatabaseClient databaseClient;\n		public void setConnectionFactory(ConnectionFactory connectionFactory) {\n			this.databaseClient = DatabaseClient.create(connectionFactory);\n		// Реализация методов CorporateEventDao, терапевтические R2DBC, далее...\nРекомендации по использованию `DatabaseClient`.\nАльтернативой явной конфигурации является использование сканирования компонентов и аннотаций. поддержка внедрения зависимостей."}
{"id": 884, "text": "В этом случае вы можете аннотировать класс с помощью @Component. (что делает его кандидатом на сканирование компонентов) и аннотировать установщик ConnectionFactory метод с `@Autowired`.\nВ следующем примере показано, как это сделать:\nJava\n	@Component // <1>\n	public class R2dbcCorporateEventDao implements CorporateEventDao {\n		private DatabaseClient databaseClient;\n		@Autowired // <2>\n		public void setConnectionFactory(ConnectionFactory connectionFactory) {\n			this.databaseClient = DatabaseClient.create(connectionFactory); // <3>\n		// Реализация методов CorporateEventDao, терапевтические R2DBC, далее...\nРекомендации по использованию `DatabaseClient`. <1> Аннотируйте класс с помощью `@Component`. <2> Аннотируйте метод установки `ConnectionFactory` с помощью `@Autowired`. <3> Создайте новый `DatabaseClient` с `ConnectionFactory`.\n		// Реализация методов CorporateEventDao, терапевтические R2DBC, далее...\nРекомендации по использованию `DatabaseClient`. <1> Аннотируйте класс с помощью `@Component`. <2> Внедрение в конструктор `ConnectionFactory`. <3> Создайте новый `DatabaseClient` с `ConnectionFactory`.\nРекомендации по использованию `DatabaseClient`.\nНезависимо от того, какой из приведенных выше стилей инициализации шаблона вы решите использовать (или нет), редко возникает необходимость создавать новый экземпляр класса DatabaseClient каждый раз. время, когда вы хотите запустить SQL.\nПосле настройки экземпляр DatabaseClient становится потокобезопасным."}
{"id": 885, "text": "Если ваше приложение обращается к нескольким баз данных, вам может понадобиться несколько экземпляров `DatabaseClient`, для чего потребуется несколько `ConnectionFactory` и, как следствие, несколько по-разному настроенных `DatabaseClient` экземпляры.\nПолучение автоматически сгенерированных ключей.\nОператоры INSERT могут генерировать ключи при вставке строк в таблицу. который определяет столбец автоинкремента или идентификатора.\nЧтобы получить полный контроль над имя столбца, который нужно сгенерировать, просто зарегистрируйте `StatementFilterFunction`, который запрашивает сгенерированный ключ для нужного столбца.\nJava\n	Mono<Integer> generatedId = client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n			.filter(statement -> s.returnGeneratedValues(\"id\"))\n			.map(row -> row.get(\"id\", Integer.class))\n			.first();\n	//GeneratedId выдает сгенерированный ключ после выполнения инструкции INSERT.\n* Использование `ConnectionFactory`\n* Использование `ConnectionFactoryUtils`\n* Использование `SingleConnectionFactory`\n* Использование `TransactionAwareConnectionFactoryProxy`\n* Использование `R2dbcTransactionManager`\nИспользование ConnectionFactory.\nSpring получает соединение R2DBC с базой данных через ConnectionFactory.\nConnectionFactory является частью спецификации R2DBC и является общей точкой входа. для водителей.\nЭто позволяет контейнеру или фреймворку скрывать пул соединений. и проблемы управления транзакциями из кода приложения.\nКак разработчик, вам не нужно знать подробности о том, как подключиться к базе данных."}
{"id": 886, "text": "Это ответственность администратора, который настраивает ConnectionFactory. ты скорее всего, вы будете выполнять обе роли при разработке и тестировании кода, но вы этого не делаете. обязательно нужно знать, как настроен источник производственных данных.\nИспользование ConnectionFactory.\nКогда вы используете уровень R2DBC Spring, вы можете настроить свой собственный с помощью реализация пула соединений, предоставленная третьей стороной.\nПопулярный реализация — пул R2DBC («r2dbc-pool»).\nРеализации Spring распределения предназначены только для целей тестирования и не обеспечивают объединение в пул.\nЧтобы настроить ConnectionFactory:. .\nПолучите соединение с ConnectionFactory, как вы обычно получаете R2DBC ConnectionFactory..\nУкажите URL-адрес R2DBC (Правильное значение см. в документации вашего драйвера).\nJava\n	ConnectionFactory factory = ConnectionFactories.get(\"r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\");\nИспользование ConnectionFactoryUtils.\nКласс ConnectionFactoryUtils — удобный и мощный вспомогательный класс. который предоставляет `статические` методы для получения соединений из `ConnectionFactory` и закройте соединения (при необходимости).\nИспользование ConnectionFactoryUtils.\nОн поддерживает абонентские ``контекстные`` соединения, например, `R2dbcTransactionManager`.\nИспользование SingleConnectionFactory.\nКласс SingleConnectionFactory является реализацией DelegatingConnectionFactory. интерфейс, который окружает одно соединение, которое не закрывается после каждого использования.\nИспользование SingleConnectionFactory."}
{"id": 887, "text": "Если какой-либо клиентский код вызывает метод close, предполагая соединение из пула (как при использовании инструменты сохранения), вам следует установить для свойства `suppressClose` значение `true`.\nЭта настройка возвращает прокси-сервер с подавлением закрытия, который оборачивает физическое соединение.\nОбратите внимание, что вы можете больше не привязывайте это к собственному `Connection` или подобному объекту.\nИспользование SingleConnectionFactory. `SingleConnectionFactory` — это прежде всего тестовый класс, который может использоваться для конкретных требований. например, конвейерная обработка, если ваш драйвер R2DBC разрешает такое использование.\nВ отличие от объединенной в пул ConnectionFactory, она постоянно использует одно и то же соединение, избегая чрезмерное создание физических соединений.\nИспользование TransactionAwareConnectionFactoryProxy.\nTransactionAwareConnectionFactoryProxy — это прокси для целевой ConnectionFactory.\nПрокси-сервер обертывает цель ConnectionFactory, чтобы добавить осведомленность о транзакциях, управляемых Spring.\nИспользование TransactionAwareConnectionFactoryProxy.\nПРИМЕЧАНИЕ.\nИспользование этого класса необходимо, если вы используете клиент R2DBC, который в противном случае не интегрирован. с поддержкой Spring R2DBC.\nВ этом случае вы все равно можете использовать этот клиент и, по адресу в то же время этот клиент должен участвовать в управляемых транзакциях Spring.\nОбычно это предпочтительнее интегрировать клиент R2DBC с правильным доступом к ConnectionFactoryUtils. для управления ресурсами.\nИспользование TransactionAwareConnectionFactoryProxy.\nСм. {spring-framework-api}/r2dbc/connection/TransactionAwareConnectionFactoryProxy.html[`TransactionAwareConnectionFactoryProxy`] javadoc для более подробной информации.\nИспользование R2dbcTransactionManager."}
{"id": 888, "text": "Класс R2dbcTransactionManager представляет собой реализацию ReactiveTransactionManager для один R2DBC ConnectionFactory.\nОн связывает соединение R2DBC из указанного ConnectionFactory к подписчику Context, что потенциально позволяет использовать одного подписчика. `Соединение` для каждой `ConnectionFactory`.\nИспользование R2dbcTransactionManager.\nКод приложения необходим для получения соединения R2DBC через `ConnectionFactoryUtils.getConnection(ConnectionFactory)` вместо стандартного R2DBC `ConnectionFactory.create()`.\nВсе классы фреймворка (такие как DatabaseClient) используют это стратегия неявно.\nЕсли стратегия поиска не используется с менеджером транзакций, она ведет себя точно так же, как `ConnectionFactory.create()` и поэтому может использоваться в любом случае."}
{"id": 889, "text": "Запросы диапазона.\nSpring WebFlux поддерживает https://datatracker.ietf.org/doc/html/rfc9110#section-14[RFC 9110] запросы диапазона.\nДля обзора см. https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests[Запросы рейнджеров] Руководство по Мозилле.\nЗапросы диапазона.\nЗаголовок Range анализируется и прозрачно обрабатывается в WebFlux, когда аннотированный контроллер возвращает Resource или ResponseEntity<Resource> или функциональную конечную точку. поддержка также прозрачно обрабатывается при обслуживании\nЗапросы диапазона.\nСОВЕТ: «Ресурс» не должен быть «InputStreamResource» и с «ResponseEntity<Resource>», статус ответа должен быть 200.\nЗапросы диапазона.\nБазовая поддержка находится в классе HttpRange, который предоставляет методы для анализа. заголовки Range и разделить Resource на List<ResourceRegion>, который, в свою очередь, может быть затем записывается в ответ через ResourceRegionEncoder и ResourceHttpMessageWriter."}
{"id": 890, "text": "* Для обработки запросов к серверу предусмотрено два уровня поддержки.\nМодуль Spring-Web содержит следующую базовую поддержку реактивной сети. приложения:. ** HttpHandler: базовый контракт для обработки HTTP-запросов с помощью неблокирующий ввод-вывод и обратное давление Reactive Streams, а также адаптеры для Reactor Netty, Tomcat, Jetty и любой контейнер сервлетов. ** `WebHandler` API: веб-API общего назначения чуть более высокого уровня для обработка запросов, поверх которой конкретные модели программирования, такие как аннотированные построены контроллеры и функциональные конечные точки.\n* На стороне клиента существует базовый контракт ClientHttpConnector для выполнения HTTP.\nМодуль Spring-Web содержит следующую базовую поддержку реактивной сети. приложения:. запросы с неблокирующим вводом-выводом и противодавлением реактивных потоков, а также адаптеры для {reactor-github-org}/reactor-netty[Reactor Netty], реактивный https://github.com/jetty-project/jetty-reactive-httpclient[Jetty HttpClient] и https://hc.apache.org/[Apache HttpComponents].\nБолее высокий уровень WebClient, используемый в приложениях. основывается на этом базовом контракте.\n* Для клиента и сервера: web/webflux/reactive-spring.adoc#webflux-codecs[codecs] для сериализации и\nМодуль Spring-Web содержит следующую базовую поддержку реактивной сети. приложения:. десериализация содержимого HTTP-запроса и ответа."}
{"id": 891, "text": "`HttpHandler`. {spring-framework-api}/http/server/reactive/HttpHandler.html[HttpHandler] — это простой контракт с одним методом для обработки запроса и ответа.\nЭто намеренно минимален, и его главная и единственная цель — быть минимальной абстракцией. через различные API-интерфейсы HTTP-сервера.\nВ следующей таблице описаны поддерживаемые API сервера:. [cols=\"1,2,2\", options=\"header\"] |=== | Имя сервера | Используемый серверный API | Поддержка реактивных потоков\n| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty]. | Томкэт | Неблокирующий ввод-вывод сервлетов; API Tomcat для чтения и записи ByteBuffers против byte[] | Spring-Web: мост неблокирующего ввода-вывода сервлетов к реактивным потокам\n| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty]. | Пристань | Неблокирующий ввод-вывод сервлетов; Jetty API для записи ByteBuffers против byte[] | Spring-Web: мост неблокирующего ввода-вывода сервлетов к реактивным потокам"}
{"id": 892, "text": "| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty]. | Контейнер сервлетов | Неблокирующий ввод-вывод сервлетов | Spring-Web: мост неблокирующего ввода-вывода сервлетов к реактивным потокам |===\n| Нетти | Нетти API | {reactor-github-org}/reactor-netty [Reactor Netty].\nВ следующей таблице описаны зависимости сервера (см. также {spring-framework-wiki}/What%27s-New-in-the-Spring-Framework[поддерживаемые версии]):\n|Пристань |org.eclipse.jetty |jetty-servlet, причал-сервлет |===.\nВ приведенных ниже фрагментах кода показано использование адаптеров HttpHandler с API каждого сервера.\nJava\n	HttpHandler handler = ...\n	ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);\n	HttpServer.create().host(host).port(port).handle(adapter).bindNow();\nJava\n	HttpHandler handler = ...\n	Servlet servlet = new TomcatHttpHandlerAdapter(handler);\n	Tomcat server = new Tomcat();\n	File base = new File(System.getProperty(\"java.io.tmpdir\"));\n	Context rootContext = server.addContext(\"\", base.getAbsolutePath());\n	Tomcat.addServlet(rootContext, \"main\", servlet);"}
{"id": 893, "text": "rootContext.addServletMappingDecoded(\"/\", \"main\");\n	server.setHost(host);\n	server.setPort(port);\n	server.start();\nJava\n	HttpHandler handler = ...\n	JettyCoreHttpHandlerAdapter adapter = new JettyCoreHttpHandlerAdapter(handler);\n	Server server = new Server();\n	server.setHandler(adapter);\n	ServerConnector connector = new ServerConnector(server);\n	connector.setHost(host);\n	connector.setPort(port);\n	server.addConnector(connector);\n	server.start();\n	server.start()\n*Пристань*.\nСОВЕТ: В Spring Framework 6.2 JettyHttpHandlerAdapter устарел в пользу JettyCoreHttpHandlerAdapter, который напрямую интегрируется с API Jetty 12. без слоя сервлетов.\n*Пристань*.\nВместо этого, чтобы развернуть WAR в контейнере сервлетов, используйте {spring-framework-api}/web/server/adapter/AbstractReactiveWebInitializer.html[`AbstractReactiveWebInitializer`], адаптировать HttpHandler к сервлету через ServletHttpHandlerAdapter.\nAPI `WebHandler`."}
{"id": 894, "text": "Пакет `org.springframework.web.server` основан на предоставить универсальный веб-API для обработки запросов через цепочку нескольких {spring-framework-api}/web/server/WebExceptionHandler.html[`WebExceptionHandler`], несколько {spring-framework-api}/web/server/WebFilter.html[`WebFilter`] и один Компонент {spring-framework-api}/web/server/WebHandler.html[`WebHandler`].\nЦепь может можно объединить с WebHttpHandlerBuilder, просто указав на Spring `ApplicationContext`, где находятся компоненты. со застройщиком.\nAPI `WebHandler`.\nХотя у `HttpHandler` есть простая цель - абстрагировать использование различных HTTP-серверов, API WebHandler призван предоставить более широкий набор функций, обычно используемых в веб-приложениях. такие как:\n* Пользовательская сессия с атрибутами.\n* Атрибуты запроса.\n* Решены `Locale` или `Principal` для запроса.\n* Доступ к анализируемым и кэшированным данным формы.\n* Абстракции для составных данных.\n* и многое другое..\nСпециальные типы бобов.\nВ таблице ниже перечислены компоненты, которые WebHttpHandlerBuilder может автоматически обнаружить в Spring ApplicationContext или который можно зарегистрировать непосредственно в нем:\nСпециальные типы бобов. [cols=\"2,2,1,3\", options=\"header\"] |=== | Имя фасоли | Тип фасоли | Граф | Описание"}
{"id": 895, "text": "Специальные типы бобов. | <любой> | `WebExceptionHandler` | 0..Н | Обеспечить обработку исключений из цепочки экземпляров WebFilter и цели. `ВебХандлер`.\nДля получения более подробной информации см. ссылку:web/webflux/reactive-spring.adoc#webflux-Exception-handler [Исключения].\nСпециальные типы бобов. | <любой> | `ВебФильтер` | 0..Н | Примените логику стиля перехвата до и после остальной части цепочки фильтров и целевой `WebHandler`.\nДля получения более подробной информации см. ссылку:web/webflux/reactive-spring.adoc#webflux-filters[Filters].\nСпециальные типы бобов. | `webHandler` | `Вебхандлер` | 1 | Обработчик запроса.\nСпециальные типы бобов. | `webSessionManager` | `WebSessionManager` | 0..1 | Менеджер экземпляров WebSession, предоставляемый через метод ServerWebExchange. `DefaultWebSessionManager` по умолчанию.\nСпециальные типы бобов. | `serverCodecConfigurer` | `ServerCodecConfigurer` | 0..1 | Для доступа к экземплярам HttpMessageReader для анализа данных формы и составных данных, которые затем предоставляется с помощью методов ServerWebExchange. `ServerCodecConfigurer.create()` по умолчанию.\nСпециальные типы бобов. | `localeContextResolver` | `LocaleContextResolver` | 0..1 | Резолвер для LocaleContext, предоставляемый через метод ServerWebExchange. «AcceptHeaderLocaleContextResolver» по умолчанию."}
{"id": 896, "text": "Специальные типы бобов. | `forwardedHeaderTransformer` | `ForwardedHeaderTransformer` | 0..1 | Для обработки заголовков пересылаемых типов либо путем их извлечения и удаления, либо только путем их удаления.\nНе используется по умолчанию. |===\nJava\n	Mono<MultiValueMap<String, String>> getFormData();\n`ServerWebExchange` предоставляет следующий метод доступа к данным формы:.\nDefaultServerWebExchange использует настроенный HttpMessageReader для анализа данных формы. (`application/x-www-form-urlencoded`) в `MultiValueMap`.\nПо умолчанию FormHttpMessageReader настроен для использования bean-компонентом ServerCodecConfigurer. (см. ссылку:web/webflux/reactive-spring.adoc#webflux-web-handler-api [API веб-обработчика]).\nJava\n	Mono<MultiValueMap<String, Part>> getMultipartData();\n`ServerWebExchange` предоставляет следующий метод доступа к составным данным:. `DefaultServerWebExchange` использует настроенный `HttpMessageReader<MultiValueMap<String, Part>>` для анализа `multipart/form-data`, «многочастный/смешанный» и «многочастный/связанный» контент в «MultiValueMap».\nПо умолчанию это `DefaultPartHttpMessageReader`, который не имеет никаких сторонних зависимости.\nВ качестве альтернативы можно использовать SynchronossPartHttpMessageReader, основанный на https://github.com/synchronoss/nio-multipart [Библиотека Synchronoss NIO Multipart]."}
{"id": 897, "text": "Оба настраиваются через bean-компонент ServerCodecConfigurer. (см. ссылку:web/webflux/reactive-spring.adoc#webflux-web-handler-api [API веб-обработчика]).\n`ServerWebExchange` предоставляет следующий метод доступа к составным данным:.\nДля анализа составных данных в потоковом режиме вы можете использовать Flux<PartEvent>, возвращаемый из `PartEventHttpMessageReader` вместо использования `@RequestPart`, поскольку это подразумевает доступ, подобный `Map` на отдельные части по имени и, следовательно, требует полного анализа составных данных.\nНапротив, вы можете использовать @RequestBody для декодирования содержимого в Flux<PartEvent> без сбор в MultiValueMap.\nForwardedHeaderTransformer. «ForwardedHeaderTransformer» — это компонент, который изменяет хост, порт и схему запрос на основе перенаправленных заголовков, а затем удаляет эти заголовки.\nЕсли вы заявите это как bean-компонент с именем «forwardedHeaderTransformer», он будет\nВопросы безопасности.\nСуществуют соображения безопасности для пересылаемых заголовков, поскольку приложение не может знать если заголовки были добавлены прокси-сервером, как предполагалось, или вредоносным клиентом.\nВот почему прокси-сервер на границе доверия должен быть настроен для удаления поступающего ненадежного перенаправленного трафика. снаружи.\nВы также можете настроить ForwardedHeaderTransformer с помощью `removeOnly=true`, в этом случае заголовки удаляются, но не используются.\nФильтры."}
{"id": 898, "text": "В API-интерфейсе Web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] вы можете использовать `WebFilter` для применения стиля перехвата. логика до и после остальной части цепочки обработки фильтров и цели `ВебХандлер`.\nПри использовании WebFlux Config регистрация `WebFilter` очень проста. как объявление его как bean-компонента Spring и (необязательно) выражение приоритета с помощью `@Order` в объявление bean-компонента или путем реализации Ordered.\nКОРС.\nSpring WebFlux обеспечивает детальную поддержку конфигурации CORS посредством аннотаций на контроллеры.\nОднако, когда вы используете его с Spring Security, мы советуем полагаться на встроенный `CorsFilter`, который необходимо заказывать перед цепочкой фильтров Spring Security.\nКОРС.\nДополнительные сведения см. в разделах CORS и CORS `WebFilter`.\nОбработчик URL-адресов.\nВозможно, вы захотите, чтобы конечные точки вашего контроллера соответствовали маршрутам с косой чертой в конце URL-пути или без нее.\nНапример, и «GET /home», и «GET /home/» должны обрабатываться методом контроллера, аннотированным `@GetMapping(\"/home\")`.\nОбработчик URL-адресов.\nSpring предоставляет UrlHandlerFilter, который удаляет конечную косую черту из URL-путей, чтобы обеспечить согласованное представление путей с конечной косой чертой или без нее."}
{"id": 899, "text": "Это важно, чтобы избежать несоответствия между решениями об авторизации на основе URL-адресов и сопоставлениями запросов веб-платформы.\nФильтр может удалить косую черту одним из нескольких способов:\n* ответить статусом перенаправления HTTP, который отправляет клиентов по одному и тому же пути без косой черты в конце.\n* изменить запрос на удаление косой черты в конце.\nОбработчик URL-адресов.\nВот как вы можете создать и настроить UrlHandlerFilter для приложения блога: См. пример кода в исходном документе.\n- корневой путь `\"/\"` исключен из обработки косой черты.\n- `@RequestMapping(\"/\")` добавляет конечную косую черту к сопоставлению уровня типа и, следовательно, будет\nИмейте в виду следующее:. не отображать, когда применяется обработка косой черты; вместо этого используйте `@RequestMapping` (без атрибута пути).\nИсключения.\nВ API-интерфейсе Web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] вы можете использовать `WebExceptionHandler` для обработки исключения из цепочки экземпляров WebFilter и целевого WebHandler.\nПри использовании Spring bean и (необязательно) выражение приоритета с помощью `@Order` в объявлении bean-компонента или путем реализации Ordered."}
{"id": 900, "text": "[cols=\"1,2\", options=\"header\"] |=== | Обработчик исключений | Описание. | `ResponseStatusExceptionHandler` | Обеспечивает обработку исключений типа {spring-framework-api}/web/server/ResponseStatusException.html[`ResponseStatusException`] установив ответ на код состояния HTTP исключения.\n[cols=\"1,2\", options=\"header\"] |=== | Обработчик исключений | Описание. | `WebFluxResponseStatusExceptionHandler` | Расширение ResponseStatusExceptionHandler, которое также может определять статус HTTP. код аннотации @ResponseStatus для любого исключения.\n[cols=\"1,2\", options=\"header\"] |=== | Обработчик исключений | Описание.\nЭтот обработчик объявлен в файле WebFlux Config.\nКодеки.\nМодули Spring-Web и Spring-Core обеспечивают поддержку сериализации и десериализация байтового содержимого в объекты более высокого уровня и обратно посредством неблокирующего ввода-вывода с помощью Противодавление реактивных потоков.\nНиже описывается эта поддержка:\n* {spring-framework-api}/core/codec/Encoder.html[`Encoder`] и\nКодеки. {spring-framework-api}/core/codec/Decoder.html[`Decoder`] — это контракты низкого уровня для кодировать и декодировать контент независимо от HTTP."}
{"id": 901, "text": "* {spring-framework-api}/http/codec/HttpMessageReader.html[`HttpMessageReader`] и\nКодеки. {spring-framework-api}/http/codec/HttpMessageWriter.html[`HttpMessageWriter`] – это контракты. для кодирования и декодирования содержимого HTTP-сообщения.\n* Encoder можно обернуть EncoderHttpMessageWriter, чтобы адаптировать его для использования в сети.\nКодеки. приложение, а `Decoder` можно обернуть `DecoderHttpMessageReader`.\n* {spring-framework-api}/core/io/buffer/DataBuffer.html[`DataBuffer`] абстрагирует разные\nКодеки. представления байтовых буферов (например, Netty `ByteBuf`, `java.nio.ByteBuffer` и т. д.) и на чем работают все кодеки.\nСм.\nБуферы данных и кодеки в Раздел «Spring Core» содержит дополнительную информацию по этой теме.\nКодеки.\nМодуль Spring-core предоставляет byte[], ByteBuffer, DataBuffer, Resource и Реализации кодировщика и декодера `String`.\nМодуль Spring-Web предоставляет Джексону JSON, Jackson Smile, JAXB2, Protocol Buffers и другие кодеры и декодеры, а также веб-реализации чтения и записи HTTP-сообщений для данных форм, многочастного содержимого, события, отправленные сервером, и другие.\nКодеки.\nClientCodecConfigurer и ServerCodecConfigurer обычно используются для настройки и настроить кодеки для использования в приложении.\nСм. раздел о настройке\nДжексон JSON."}
{"id": 902, "text": "JSON и двоичный JSON ({jackson-github-org}/smile-format-specification[Smile]) оба поддерживаются при наличии библиотеки Джексона.\n* Асинхронный неблокирующий анализатор Джексона используется для агрегирования потока байтовых фрагментов.\n«JacksonJsonDecoder» работает следующим образом:. в TokenBuffer, каждый из которых представляет объект JSON.\n* Каждый TokenBuffer передается в JsonMapper Джексона для создания объекта более высокого уровня.\n* При декодировании в издатель с одним значением (например, Mono) используется один TokenBuffer.\n* При декодировании многозначному издателю (например, Flux) каждый TokenBuffer передается в\n«JacksonJsonDecoder» работает следующим образом:. `JsonMapper`, как только будет получено достаточно байтов для полностью сформированного объекта. входным содержимым может быть массив JSON или любой другой https://en.wikipedia.org/wiki/JSON_streaming[JSON с разделителями строк], например NDJSON, Строки JSON или текстовые последовательности JSON.\n* Для издателя с одним значением (например, Mono) просто сериализуйте его через\n«JacksonJsonEncoder» работает следующим образом:. `JsonMapper`.\n* Для издателя с несколькими значениями, использующего `application/json`, по умолчанию значения собираются с помощью\n«JacksonJsonEncoder» работает следующим образом:. `Flux#collectToList()`, а затем сериализовать полученную коллекцию.\n* Для издателя с несколькими значениями и типом потокового мультимедиа, например"}
{"id": 903, "text": "«JacksonJsonEncoder» работает следующим образом:. `application/x-ndjson` или `application/stream+x-jackson-smile`, кодируйте, записывайте и очистить каждое значение индивидуально, используя https://en.wikipedia.org/wiki/JSON_streaming[формат JSON, разделенный строками].\nДругое Типы потокового мультимедиа могут быть зарегистрированы в кодере.\n* Для SSE JacksonJsonEncoder вызывается для каждого события, а выходные данные сбрасываются для обеспечения\n«JacksonJsonEncoder» работает следующим образом:. доставка без задержек.\n«JacksonJsonEncoder» работает следующим образом:. [ПРИМЕЧАНИЕ] = По умолчанию и «JacksonJsonEncoder», и «JacksonJsonDecoder» не поддерживают элементы типа `Строка`.\nВместо этого по умолчанию предполагается, что строка или последовательность строк представляют сериализованный контент JSON, который будет отображаться с помощью CharSequenceEncoder.\nЕсли что вам нужно визуализировать массив JSON из Flux<String>, использовать Flux#collectToList() и закодируйте `Mono<List<String>>`.\nДанные формы.\nFormHttpMessageReader и FormHttpMessageWriter поддерживают декодирование и кодирование.\nСодержимое `application/x-www-form-urlencoded`.\nДанные формы.\nНа стороне сервера, где часто требуется доступ к содержимому формы из нескольких мест. `ServerWebExchange` предоставляет специальный метод `getFormData()`, который анализирует содержимое. через FormHttpMessageReader, а затем кэширует результат для повторного доступа.\nСм.\nДанные формы в\nДанные формы."}
{"id": 904, "text": "После использования getFormData() исходное необработанное содержимое больше не может быть прочитано из тело запроса.\nПо этой причине ожидается, что приложения будут проходить через «ServerWebExchange». последовательно для доступа к кэшированным данным формы, а не для чтения из необработанного тела запроса.\nМногочастный.\nMultipartHttpMessageReader и MultipartHttpMessageWriter поддерживают декодирование и кодирование «многочастного/формированного» контента, «многочастного/смешанного» и «многочастного/связанного» контента.\nВ свою очередь, MultipartHttpMessageReader делегирует другому HttpMessageReader. для фактического анализа в `Flux<Part>`, а затем просто собирает части в `MultiValueMap`.\nПо умолчанию используется `DefaultPartHttpMessageReader`, но это можно изменить с помощью `Конфигуратор Серверкодека`.\nДополнительную информацию о DefaultPartHttpMessageReader см. {spring-framework-api}/http/codec/multipart/DefaultPartHttpMessageReader.html [javadoc `DefaultPartHttpMessageReader`].\nМногочастный.\nНа стороне сервера, где к содержимому многочастной формы может потребоваться доступ из нескольких местах, ServerWebExchange предоставляет специальный метод getMultipartData(), который анализирует содержимое через MultipartHttpMessageReader, а затем кэширует результат для повторного доступа.\nСм.\nMultipart Data в разделе\nМногочастный.\nПосле использования getMultipartData() исходный необработанный контент больше не может быть прочитан из тело запроса.\nПо этой причине приложения должны постоянно использовать getMultipartData(). для повторного доступа к частям, как на карте, или иным образом полагаться на `SynchronossPartHttpMessageReader` для однократного доступа к `Flux<Part>`."}
{"id": 905, "text": "Буферы протоколов. `ProtobufEncoder` и `ProtobufDecoder`, поддерживающие декодирование и кодирование \"application/x-protobuf\", \"application/octet-stream\" и содержимое application/vnd.google.protobuf для типов com.google.protobuf.Message.\nОни также поддерживают поток значений если контент получен/отправлен с параметром «delimited» в соответствии с типом контента (например, «application/x-protobuf;delimited=true»).\nДля этого требуется библиотека com.google.protobuf:protobuf-java версии 3.29 и выше.\nБуферы протоколов.\nВарианты ProtobufJsonDecoder и ProtobufJsonEncoder поддерживают чтение и запись документов JSON в сообщения Protobuf и обратно.\nДля них требуется зависимость «com.google.protobuf:protobuf-java-util».\nОбратите внимание: варианты JSON не поддерживают чтение потока сообщений. дополнительную информацию см. в {spring-framework-api}/http/codec/protobuf/Protobuf/ProtobufJsonDecoder.html[javadoc of `ProtobufJsonDecoder`].\nГугл Гсон.\nПриложения могут использовать GsonEncoder и GsonDecoder для сериализации и десериализации документов JSON благодаря библиотеке https://google.github.io/gson/[Google Gson].\nЭтот кодек поддерживает как типы мультимедиа JSON, так и формат NDJSON для потоковой передачи."}
{"id": 906, "text": "Гугл Гсон. [ПРИМЕЧАНИЕ] = Gson не поддерживает неблокирующий анализ, поэтому GsonDecoder не поддерживает десериализацию. к типам `Flux<*>`.\nНапример, если этот декодер используется для десериализации потока JSON или даже списка элементов как `Flux<*>`, во время выполнения будет выброшено `UnsupportedOperationException`.\nВместо этого приложения должны сосредоточиться на десериализации ограниченных коллекций и использовать Mono<List<*>>` в качестве целевых типов.\nПределы.\nРеализации `Decoder` и `HttpMessageReader`, которые буферизуют часть или весь ввод. поток может быть настроен с ограничением максимального количества байтов для буферизации в памяти.\nВ некоторых случаях буферизация происходит потому, что ввод агрегируется и представляется как единое целое. объект — например, метод контроллера с `@RequestBody byte[]`, данные `x-www-form-urlencoded` и так далее.\nБуферизация также может происходить при потоковой передаче, когда разделение входного потока — например, текста с разделителями, потока объектов JSON и так далее.\nДля таких случаев потоковой передачи ограничение применяется к количеству связанных байтов. с одним объектом в потоке.\nПределы.\nЧтобы настроить размеры буфера, вы можете проверить, используется ли данный `Decoder` или `HttpMessageReader` предоставляет свойство maxInMemorySize, и если да, то в Javadoc будет подробная информация о значении по умолчанию. ценности."}
{"id": 907, "text": "На стороне сервера ServerCodecConfigurer предоставляет единое место, откуда можно установите все кодеки, см. кодеки сообщений HTTP.\nНа стороне клиента лимит на все кодеки можно изменить в\nПределы.\nДля Многочастный анализ ограничение свойства maxInMemorySize размер нефайловых частей.\nДля частей файла он определяет порог, при котором часть записывается на диск.\nДля частей файла, записываемых на диск, существует дополнительный Свойство maxDiskUsagePerPart для ограничения объема дискового пространства на каждую часть.\nСуществует также свойство maxParts для ограничения общего количества частей в многочастном запросе.\nЧтобы настроить все три в WebFlux, вам необходимо предоставить предварительно настроенный экземпляр от MultipartHttpMessageReader до ServerCodecConfigurer.\nПотоковое вещание.\nПри потоковой передаче ответа HTTP (например, `text/event-stream`, `application/x-ndjson`), важно периодически отправлять данные, чтобы надежно обнаружить отключенного клиента раньше, чем позже.\nТакая отправка может быть только для комментариев, пустое событие SSE или любые другие «неактивные» данные, которые эффективно могут служить сердцебиение.\n`Буфер данных`. `DataBuffer` — это представление байтового буфера в WebFlux.\nЧасть Spring Core в этой ссылке есть дополнительная информация об этом в разделе, посвященном на таких серверах, как Netty, байтовые буферы объединяются в пул, подсчитываются ссылки и должны быть освобождены. при потреблении, чтобы избежать утечек памяти.\n`Буфер данных`."}
{"id": 908, "text": "Приложениям WebFlux обычно не нужно беспокоиться о таких проблемах, если только они не использовать или создавать буферы данных напрямую, а не полагаться на кодеки для преобразования в и из объектов более высокого уровня, или если они не захотят создавать собственные кодеки.\nДля таких В таких случаях ознакомьтесь с информацией в Буферы данных и кодеки. особенно раздел Using DataBuffer.\nВедение журнала уровня DEBUG в Spring WebFlux спроектировано так, чтобы быть компактным, минимальным и дружелюбный к человеку.\nОн фокусируется на ценных битах информации, которые полезны в любое время. снова по сравнению с другими, которые полезны только при отладке конкретной проблемы.\nВедение журнала уровня TRACE обычно следует тем же принципам, что и DEBUG (и, например, также не должен быть пожарным шлангом), но может использоваться для устранения любой проблемы.\nКроме того, некоторые журналы сообщения могут иметь разный уровень детализации: TRACE и DEBUG.\nВедение журнала.\nХорошее ведение журнала приходит с опытом использования журналов.\nЕсли вы заметите что-нибудь, что делает не соответствует заявленным целям, пожалуйста, сообщите нам об этом.\nИдентификатор журнала.\nВ WebFlux один запрос может выполняться в нескольких потоках, и идентификатор потока бесполезен для корреляции сообщений журнала, принадлежащих конкретному запросу.\nВот почему По умолчанию сообщения журнала WebFlux имеют префикс идентификатора конкретного запроса.\nИдентификатор журнала."}
{"id": 909, "text": "На стороне сервера идентификатор журнала хранится в атрибуте ServerWebExchange. ({spring-framework-api}/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]), а полностью отформатированный префикс на основе этого идентификатора доступен по адресу `ServerWebExchange#getLogPrefix()`.\nНа стороне `WebClient` идентификатор журнала хранится в Атрибут `ClientRequest` ({spring-framework-api}/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]), а полностью отформатированный префикс доступен из `ClientRequest#logPrefix()`.\nКонфиденциальные данные.\nЖурналы `DEBUG` и `TRACE` могут регистрировать конфиденциальную информацию.\nВот почему параметры формы и заголовки по умолчанию маскируются, и вам необходимо явно включить их полную регистрацию.\nКонфиденциальные данные.\nВ следующем примере показано, как это сделать для запросов на стороне сервера:\nJava\n	@Configuration\n	class MyConfig implements WebFluxConfigurer {\n		@Override\n		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n			configurer.defaultCodecs().enableLoggingRequestDetails(true);\n	@Configuration\n	class MyConfig : WebFluxConfigurer {\nКонфиденциальные данные.\nВ следующем примере показано, как это сделать для запросов на стороне клиента:\nJava\n	Consumer<ClientCodecConfigurer> consumer = configurer ->\n			configurer.defaultCodecs().enableLoggingRequestDetails(true);\n	WebClient webClient = WebClient.builder()\n			.exchangeStrategies(strategies -> strategies.codecs(consumer))"}
{"id": 910, "text": ".build();\nАппендеры.\nБиблиотеки журналирования, такие как SLF4J и Log4J 2, предоставляют асинхронные средства журналирования, которые позволяют избежать блокировка.\nХотя у них есть свои недостатки, такие как потенциальное удаление сообщений. которые нельзя поставить в очередь для регистрации, на данный момент это лучшие доступные варианты для использования в реактивном, неблокирующем приложении.\nПользовательские кодеки.\nПриложения могут регистрировать собственные кодеки для поддержки дополнительных типов мультимедиа. или определенное поведение, которое не поддерживается кодеками по умолчанию.\nПользовательские кодеки.\nНекоторые параметры конфигурации, предложенные разработчиками, применяются к кодекам по умолчанию.\nПользовательские кодеки могут захотеть получить возможность согласовать эти предпочтения, например обеспечение ограничений буферизации или регистрация конфиденциальных данных.\nПользовательские кодеки.\nВ следующем примере показано, как это сделать для запросов на стороне клиента:\nJava\n	WebClient webClient = WebClient.builder()\n			.codecs(configurer -> {\n				CustomDecoder decoder = new CustomDecoder();\n				configurer.customCodecs().registerWithDefaultConfig(decoder);\n			.build();"}
{"id": 911, "text": "`@RequestAttribute`.\nАналогично @SessionAttribute, вы можете использовать аннотацию @RequestAttribute для получить доступ к уже существующим атрибутам запроса, созданным ранее (например, с помощью `WebFilter`), как показано в следующем примере:\nJava\n	@GetMapping(\"/\")\n	public String handle(@RequestAttribute Client client) { <1>\n`@RequestAttribute`. <1> Использование `@RequestAttribute`."}
{"id": 912, "text": "`@RequestBody`.\nВы можете использовать аннотацию @RequestBody, чтобы прочитать тело запроса и десериализовать его в `Объект` через ссылку:web/webflux/reactive-spring.adoc#webflux-codecs[HttpMessageReader].\nВ следующем примере используется аргумент @RequestBody:\nJava\n	@PostMapping(\"/accounts\")\n	public void handle(@RequestBody Account account) {\n`@RequestBody`.\nВ отличие от Spring MVC, в WebFlux аргумент метода @RequestBody поддерживает реактивные типы. и полностью неблокирующее чтение и потоковую передачу (клиент-сервер).\nJava\n	@PostMapping(\"/accounts\")\n	public void handle(@RequestBody Mono<Account> account) {\n`@RequestBody`.\nЧтобы настроить или настроить программы чтения сообщений.\n`@RequestBody`.\nВы можете использовать @RequestBody в сочетании с jakarta.validation.Valid или Spring.\nАннотация `@Validated`, которая вызывает применение стандартной проверки компонента.\nВалидация ошибки вызывают исключение WebExchangeBindException, что приводит к ответу 400 (BAD_REQUEST).\nИсключение содержит BindingResult с подробностями об ошибке и может быть обработано в метод контроллера, объявив аргумент с помощью асинхронной оболочки, а затем используя ошибку. связанные операторы:\nJava\n	@PostMapping(\"/accounts\")\n	public void handle(@Valid @RequestBody Mono<Account> account) {\n		// используйте один из операторов onError*...\n`@RequestBody`."}
{"id": 913, "text": "Вы также можете объявить параметр «Errors» для доступа к ошибкам проверки, но в этом случае тело запроса не должно быть «Mono» и будет обработано первым:\nJava\n	@PostMapping(\"/accounts\")\n	public void handle(@Valid @RequestBody Account account, Errors errors) {\n		// используйте один из операторов onError*...\n`@RequestBody`.\nЕсли проверка метода применяется, поскольку другие параметры имеют аннотации @Constraint, тогда вместо этого возникает HandlerMethodValidationException.\nБолее подробную информацию см. раздел Validation."}
{"id": 914, "text": "`@RequestHeader`.\nВы можете использовать аннотацию @RequestHeader для привязки заголовка запроса к аргументу метода в контроллер.\n[буквальный] [subs=\"дословно,цитаты\"].\nHost localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300\nJava\n	@GetMapping(\"/demo\")\n	public void handle(\n			@RequestHeader(\"Accept-Encoding\") String encoding, // <1>\n			@RequestHeader(\"Keep-Alive\") long keepAlive) { // <2>\nВ следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:. <1> Получите значение заголовка Accept-Encoding. <2> Получите значение заголовка Keep-Alive.\nВ следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:.\nПреобразование типов применяется автоматически, если тип параметра целевого метода не `Строка`.\nСм. ссылку:web/webflux/controller/ann-methods/typeconversion.adoc [Преобразование типов]."}
{"id": 915, "text": "В следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:.\nКогда аннотация `@RequestHeader` используется в `Map<String, String>`, Аргумент MultiValueMap<String, String> или HttpHeaders, карта заполняется. со всеми значениями заголовка.\nВ следующем примере получается значение заголовков Accept-Encoding и Keep-Alive:.\nСОВЕТ.\nДоступна встроенная поддержка преобразования строки, разделенной запятыми, в массив или коллекция строк или других типов, известных системе преобразования типов.\nДля Например, параметр метода, помеченный `@RequestHeader(\"Accept\")`, может иметь тип `String`, но также `String[]` или `List<String>`."}
{"id": 916, "text": "`@RequestParam`.\nВы можете использовать аннотацию @RequestParam для привязки параметров запроса к аргументу метода в контроллер.\nСледующий фрагмент кода показывает использование:\nJava\n	@Controller\n	@RequestMapping(\"/pets\")\n	public class EditPetForm {\n		@GetMapping\n		public String setupForm(@RequestParam(\"petId\") int petId, Model model) { <1>\n			Pet pet = this.clinic.loadPet(petId);\n			model.addAttribute(\"pet\", pet);\n			return \"petForm\";\n`@RequestParam`. <1> Использование `@RequestParam`.\n	@Controller\n	@RequestMapping(\"/pets\")\n	class EditPetForm {\n`@RequestParam`. <1> Использование `@RequestParam`.\n`@RequestParam`.\nСОВЕТ: Концепция Servlet API «параметр запроса» объединяет параметры запроса, форму данные и объединяются в одну.\nОднако в WebFlux доступ к каждому из них осуществляется индивидуально через `СерверВебExchange`.\nХотя `@RequestParam` привязывается только к параметрам запроса, вы можете использовать привязка данных для применения параметров запроса, данных формы и составных частей к\n`@RequestParam`.\nПараметры метода, использующие аннотацию @RequestParam, являются обязательными по умолчанию, но вы можете указать, что параметр метода является необязательным, установив обязательный флаг `@RequestParam` значение false или объявив аргумент с помощью java.util.Optional. обертка.\n`@RequestParam`."}
{"id": 917, "text": "Преобразование типов применяется автоматически, если тип параметра целевого метода не `Строка`.\nСм. ссылку:web/webflux/controller/ann-methods/typeconversion.adoc [Преобразование типов].\n`@RequestParam`.\nКогда аннотация `@RequestParam` объявлена в `Map<String, String>` или `MultiValueMap<String, String>`, карта заполняется всеми параметрами запроса.\n`@RequestParam`.\nОбратите внимание, что использование @RequestParam не является обязательным — например, для установки его атрибутов.\nАвтор по умолчанию любой аргумент, который является простым типом значения (как определено {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]) и не разрешается никаким другим преобразователем аргументов, рассматривается как если бы он был аннотирован с `@RequestParam`."}
{"id": 918, "text": "Характеристики устойчивости.\nНачиная с версии 7.0, ядро Spring Framework включает в себя общие функции обеспечения устойчивости, в частности <<resilience-annotations-retryable>> и <<resilience-annotations-concurrencylimit>> аннотации для вызовов методов, а также <<resilience-programmatic-retry, поддержка программных повторов>>.\n`@Retryable`. {spring-framework-api}/resilience/annotation/Retryable.html[`@Retryable`] — это аннотация. который определяет характеристики повтора для отдельного метода (с аннотацией объявлено на уровне метода) или для всех методов, вызываемых прокси-сервером, в данной иерархии классов. (с аннотацией, объявленной на уровне типа).\n    this.jmsClient.destination(\"notifications\").send(...);\n@Retryable public void sendNotification() {.\nПо умолчанию вызов метода будет повторен для любого возникшего исключения: не более 3 повторные попытки (`maxRetries = 3`) после первоначального сбоя и задержка в 1 секунду. между попытками.\n@Retryable public void sendNotification() {. [ПРИМЕЧАНИЕ] = Метод `@Retryable` будет вызван хотя бы один раз и повторен не более чем `maxRetries`. раз, где maxRetries — максимальное количество повторных попыток.\nВ частности, `общее количество попыток = 1 начальная попытка + попытки maxRetries`."}
{"id": 919, "text": "@Retryable public void sendNotification() {.\nНапример, если для параметра maxRetries установлено значение 4, метод @Retryable будет вызываться при минимум один раз и максимум 5 раз.\n@Retryable public void sendNotification() {.\nПри необходимости это можно специально адаптировать для каждого метода — например, путем сужения исключения для повторной попытки через атрибуты «includes» и «excludes».\nПоставляемый типы исключений также будут сопоставляться с исключением, вызванным неудачным вызовом. как вложенные причины.\n    this.jmsClient.destination(\"notifications\").send(...);\n@Retryable(MessageDeliveryException.class) public void sendNotification() {.\nПРИМЕЧАНИЕ. `@Retryable(MessageDeliveryException.class)` — это ярлык для `@Retryable(includes{nbsp}={nbsp}MessageDeliveryException.class)`.\n@Retryable(MessageDeliveryException.class) public void sendNotification() {. [СОВЕТ] = Для расширенных случаев использования вы можете указать собственный `MethodRetryPredicate` через атрибут `predicate` в `@Retryable`, и предикат будет использоваться для определения того, будет ли повторить неудачный вызов метода на основе «Метода» и данного «Throwable» — для например, проверив сообщение `Throwable`.\n@Retryable(MessageDeliveryException.class) public void sendNotification() {."}
{"id": 920, "text": "Пользовательские предикаты можно комбинировать с «включает» и «исключает»; однако, обычай предикаты всегда будут применяться после применения «включает» и «исключает».\n@Retryable(MessageDeliveryException.class) public void sendNotification() {.\nИли для 4 повторных попыток и экспоненциальной стратегии отсрочки с небольшим джиттером:\n@Retryable(MessageDeliveryException.class) public void sendNotification() {. @Retryable(includes = MessageDeliveryException.class, maxRetries = 4, delay = 100, jitter = 10, multiplier = 2, maxDelay = 1000) public void sendNotification() {\n    this.jmsClient.destination(\"notifications\").send(...);\n@Retryable(MessageDeliveryException.class) public void sendNotification() {.\nИ последнее, но не менее важное: `@Retryable` также работает для реактивных методов с реактивным возвратом. type, украшая конвейер возможностями повтора Reactor:\n    return Mono.from(...); // <1>\n@Retryable(maxRetries = 4, delay = 100) public Mono<Void> sendNotification() {. <1> Этот необработанный `Mono` будет украшен спецификацией повтора.\n@Retryable(maxRetries = 4, delay = 100) public Mono<Void> sendNotification() {."}
{"id": 921, "text": "Подробную информацию о различных характеристиках см. в доступных атрибутах аннотаций в разделе {spring-framework-api}/resilience/annotation/Retryable.html[`@Retryable`].\n@Retryable(maxRetries = 4, delay = 100) public Mono<Void> sendNotification() {.\nСОВЕТ: Некоторые атрибуты в `@Retryable` имеют варианты `String`, которые предоставляют свойство поддержка заполнителя и SpEL в качестве альтернативы специально напечатанной аннотации. атрибуты, используемые в приведенных выше примерах.\n`@ConcurrencyLimit`. {spring-framework-api}/resilience/annotation/ConcurrencyLimit.html[`@ConcurrencyLimit`] аннотация, определяющая предел параллелизма для отдельного метода (с параметром аннотация, объявленная на уровне метода), или для всех методов, вызываемых прокси в данном иерархия классов (с аннотацией, объявленной на уровне типа).\n    this.jmsClient.destination(\"notifications\").send(...);\n@ConcurrencyLimit(10) public void sendNotification() {.\nЭто предназначено для защиты целевого ресурса от доступа слишком большого количества потоков одновременно. в то же время, аналогично эффекту ограничения размера пула для пула потоков или пул соединений, который блокирует доступ, если достигнут его предел.\n@ConcurrencyLimit(10) public void sendNotification() {."}
{"id": 922, "text": "При желании вы можете установить ограничение на «1», эффективно блокируя доступ к целевому компоненту. пример:\n    this.jmsClient.destination(\"notifications\").send(...);\n@ConcurrencyLimit(1) public void sendNotification() {.\nТакое ограничение особенно полезно для виртуальных потоков, где обычно нет Установлено ограничение пула потоков.\nДля асинхронных задач это можно ограничить {spring-framework-api}/core/task/SimpleAsyncTaskExecutor.html[`SimpleAsyncTaskExecutor`].\nДля синхронных вызовов эта аннотация обеспечивает эквивалентное поведение через {spring-framework-api}/aop/interceptor/ConcurrencyThrottleInterceptor.html[`ConcurrencyThrottleInterceptor`] который доступен начиная с Spring Framework 1.0 для программного использования с АОП. рамки.\n@ConcurrencyLimit(1) public void sendNotification() {.\nСОВЕТ: `@ConcurrencyLimit` также имеет атрибут `limitString`, который предоставляет свойство поддержка заполнителя и SpEL в качестве альтернативы приведенным выше примерам на основе int.\nВключение устойчивых методов.\nКак и многие основные функции Spring, основанные на аннотациях, @Retryable и @ConcurrencyLimit. представляют собой метаданные, которые вы можете принять или игнорировать.\nСамый удобный способ чтобы включить обработку аннотаций устойчивости, необходимо объявить {spring-framework-api}/resilience/annotation/EnableResilientMethods.html[`@EnableResilientMethods`] в соответствующем классе `@Configuration`.\nВключение устойчивых методов."}
{"id": 923, "text": "Альтернативно, эти аннотации можно включить индивидуально, определив RetryAnnotationBeanPostProcessor или компонент ConcurrencyLimitBeanPostProcessor в контекст.\nПоддержка программных повторов.\nВ отличие от <<resilience-annotations-retryable>>, который обеспечивает декларативный подход для указания семантики повторов для методов внутри bean-компонентов, зарегистрированных в `Контекст приложения`, {spring-framework-api}/core/retry/RetryTemplate.html[`RetryTemplate`] предоставляет программный API для повтора произвольных блоков кода.\nПоддержка программных повторов.\nВ частности, RetryTemplate выполняет и потенциально повторяет попытку {spring-framework-api}/core/retry/Retryable.html[`Retryable`] операция на основе настроен {spring-framework-api}/core/retry/RetryPolicy.html[`RetryPolicy`].\n    retryTemplate.execute(\n            () -> jmsClient.destination(\"notifications\").send(...));\nПоддержка программных повторов. <1> Неявно используется `RetryPolicy.withDefaults()`.\nПоддержка программных повторов.\nПо умолчанию повторяемая операция будет повторена для любого возникшего исключения: не более 3 повторные попытки (`maxRetries = 3`) после первоначального сбоя и задержка в 1 секунду. между попытками.\nПоддержка программных повторов.\nЕсли вам нужно настроить только количество повторных попыток, вы можете использовать Фабричный метод RetryPolicy.withMaxRetries(), как показано ниже."}
{"id": 924, "text": "Поддержка программных повторов. [ПРИМЕЧАНИЕ] = Повторяемая операция будет выполнена хотя бы один раз и повторена не более чем `maxRetries`. раз, где maxRetries — максимальное количество повторных попыток.\nВ частности, `общее количество попыток = 1 начальная попытка + попытки maxRetries`.\nПоддержка программных повторов.\nНапример, если для параметра maxRetries установлено значение 4, повторная операция будет вызвана при минимум один раз и максимум 5 раз.\n    retryTemplate.execute(\n            () -> jmsClient.destination(\"notifications\").send(...));\nПоддержка программных повторов. <1> Явно использует `RetryPolicy.withMaxRetries(4)`.\nПоддержка программных повторов.\nЕсли вам нужно сузить типы исключений для повторной попытки, это можно сделать с помощью Методы построения `includes()` и `excludes()`.\nПредоставленные типы исключений будут сопоставляется с исключением, вызванным неудачной операцией, а также с вложенными причинами.\n    retryTemplate.execute(\n            () -> jmsClient.destination(\"notifications\").send(...));\nПоддержка программных повторов. <1> Укажите один или несколько типов исключений, которые необходимо включить. <2> Укажите один или несколько типов исключений, которые необходимо исключить."}
{"id": 925, "text": "Поддержка программных повторов. [СОВЕТ] = Для расширенных случаев использования вы можете указать собственный `Predicate<Throwable>` через `predicate()` в `RetryPolicy.Builder`, и предикат будет использоваться для определить, следует ли повторять неудачную операцию на основе данного `Throwable` — например, проверив сообщение `Throwable`.\nПоддержка программных повторов.\nПользовательские предикаты можно комбинировать с «включает» и «исключает»; однако, обычай предикаты всегда будут применяться после применения «включает» и «исключает».\nПоддержка программных повторов.\nВ следующем примере показано, как настроить RetryPolicy с 4 повторными попытками. и экспоненциальная стратегия отсрочки с небольшим джиттером.\n    retryTemplate.execute(\n            () -> jmsClient.destination(\"notifications\").send(...));\nПоддержка программных повторов. [СОВЕТ] = {spring-framework-api}/core/retry/RetryListener.html[`RetryListener`] можно зарегистрировать. с помощью RetryTemplate для реагирования на события, опубликованные во время ключевых фаз повтора (перед повторная попытка, после повторной попытки и т. д.), и вы можете составить несколько прослушивателей через {spring-framework-api}/core/retry/support/CompositeRetryListener.html[`CompositeRetryListener`].\nПоддержка программных повторов."}
{"id": 926, "text": "Хотя фабричные методы и API-интерфейс построителя для RetryPolicy охватывают наиболее распространенные сценариях конфигурации вы можете реализовать собственную `RetryPolicy` для полного контроля. над типами исключений, которые должны вызывать повторную попытку, а также Стратегия {spring-framework-api}/util/backoff/BackOff.html[`BackOff`] для использования.\nОбратите внимание, что вы также можно настроить собственную стратегию BackOff с помощью метода backOff() в `RetryPolicy.Builder`."}
{"id": 927, "text": "Injection with `@Resource`.\nSpring также поддерживает внедрение с помощью аннотации JSR-250 `@Resource`. (`jakarta.annotation.Resource`) для полей или методов установки свойств компонента.\nЭто распространенный шаблон в Jakarta EE: например, в bean-компонентах, управляемых JSF, и JAX-WS. конечные точки.\nSpring также поддерживает этот шаблон для объектов, управляемых Spring.\nInjection with `@Resource`. `@Resource` принимает атрибут имени.\nПо умолчанию Spring интерпретирует это значение как имя bean-компонента, который будет внедрен.\nДругими словами, оно следует семантике имен, как показано в следующем примере:\nJava\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Resource(name=\"myMovieFinder\") // <1>\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\nInjection with `@Resource`. <1> Эта строка вводит `@Resource`.\nclass SimpleMovieLister {. <1> Эта строка вводит `@Resource`.\nclass SimpleMovieLister {.\nЕсли имя явно не указано, имя по умолчанию получается из имени поля или метод установки.\nВ случае поля оно принимает имя поля.\nВ случае метода установки, он принимает имя свойства компонента.\nВ следующем примере будет компонент имя `movieFinder` введено в его метод установки:\nJava\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Resource"}
{"id": 928, "text": "public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n	class SimpleMovieLister {\nclass SimpleMovieLister {.\nПРИМЕЧАНИЕ.\nИмя, указанное в аннотации, разрешается как имя компонента `ApplicationContext`, о котором `CommonAnnotationBeanPostProcessor` знает.\nИмена могут быть разрешены через JNDI, если вы настроите Spring {spring-framework-api}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`] явно.\nОднако мы рекомендуем вам полагаться на поведение по умолчанию и используйте возможности поиска Spring JNDI, чтобы сохранить уровень косвенности.\nclass SimpleMovieLister {.\nВ исключительном случае использования @Resource без явного указания имени и т.п. до `@Autowired`, `@Resource` находит совпадение основного типа вместо конкретного именованного компонента и разрешает хорошо известные разрешимые зависимости: BeanFactory, `ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher` и `MessageSource` интерфейсы.\nclass SimpleMovieLister {.\nТаким образом, в следующем примере поле customerPreferenceDao сначала ищет bean-компонент. с именем «customerPreferenceDao», а затем возвращается к основному совпадению типа для типа `CustomerPreferenceDao`:\nJava\n	public class MovieRecommender {\n		@Resource\n		private CustomerPreferenceDao customerPreferenceDao;\n		@Resource\n		private ApplicationContext context; // <1>\n		public MovieRecommender() {\nclass SimpleMovieLister {. <1> Поле context вводится на основе известного разрешимого типа зависимости: `Контекст приложения`.\n	class MovieRecommender {"}
{"id": 929, "text": "class SimpleMovieLister {. <1> Поле context вводится на основе известного разрешимого типа зависимости: `Контекст приложения`."}
{"id": 930, "text": "* ссылка:++https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html++[\nДля получения дополнительной информации о поддержке транзакций Spring Framework см.:.\nРаспределенные транзакции в Spring с XA и без него] — это презентация JavaWorld в Дэвид Сайер из Spring проведет вас через семь шаблонов распределенных транзакций. в приложениях Spring три из них с XA и четыре без.\n* https://www.infoq.com/minibooks/JTDS[_Java Transaction Design Strategies_] — это книга.\nДля получения дополнительной информации о поддержке транзакций Spring Framework см.:. доступен по адресу https://www.infoq.com/[InfoQ], где представлено подробное введение. к транзакциям в Java.\nОн также включает в себя параллельные примеры настройки и используйте транзакции как с Spring Framework, так и с EJB3."}
{"id": 931, "text": "`@ResponseBody`.\nВы можете использовать аннотацию @ResponseBody для метода, чтобы сериализовать возвращаемый результат. в тело ответа через файл HttpMessageWriter.\nСледующие пример показывает, как это сделать:\nJava\n	@GetMapping(\"/accounts/{id}\")\n	@ResponseBody\n	public Account handle() {\n`@ResponseBody` также поддерживается на уровне класса, и в этом случае он наследуется все методы контроллера.\nЭто эффект `@RestController`, который не более того. чем метааннотация, отмеченная `@Controller` и `@ResponseBody`.\n`@ResponseBody` поддерживает реактивные типы, что означает, что вы можете возвращать Reactor или RxJava. типы и отображать асинхронные значения, которые они производят, в ответ.\nДля получения дополнительной информации см. ссылку:web/webflux/reactive-spring.adoc#webflux-codecs-streaming[Streaming] и рендеринг JSON.\n`@ResponseBody`.\nВы можете комбинировать методы @ResponseBody с представлениями сериализации JSON.\nПодробности см. в Jackson JSON.\n`@ResponseBody`.\nВы можете использовать кодеки сообщений HTTP опция WebFlux Config для настройки или настройки написания сообщений."}
{"id": 932, "text": "Java\n	@GetMapping(\"/something\")\n	public ResponseEntity<String> handle() {\n		String body = ... ;\n		String etag = ... ;\n		return ResponseEntity.ok().eTag(etag).body(body);\n`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.\nНапример:.\nWebFlux поддерживает использование одного значения reactive type для создавать ResponseEntity асинхронно и/или реактивные типы с одним и несколькими значениями для тела.\nЭто позволяет использовать различные асинхронные ответы с помощью ResponseEntity следующим образом:\n* `ResponseEntity<Mono<T>>` или `ResponseEntity<Flux<T>>` определяют статус ответа и\n`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.\nНапример:. заголовки известны сразу, а тело предоставляется асинхронно позднее.\nИспользуйте Mono, если тело состоит из значений 0..1, или Flux, если оно может выдавать несколько значений.\n* `Mono<ResponseEntity<T>>` предоставляет все три — статус ответа, заголовки и тело,\n`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.\nНапример:. асинхронно в более поздний момент.\nЭто позволяет изменять статус ответа и заголовки. в зависимости от результата обработки асинхронного запроса."}
{"id": 933, "text": "* `Mono<ResponseEntity<Mono<T>>>` или `Mono<ResponseEntity<Flux<T>>>` — еще один\n`ResponseEntity` похож на `@ResponseBody` но со статусом и заголовками.\nНапример:. возможная, хотя и менее распространенная альтернатива.\nОни предоставляют статус ответа и заголовки. сначала асинхронно, а затем тело ответа, также асинхронно, во-вторых."}
{"id": 934, "text": "Возвращаемые значения.\nВ следующей таблице показаны возвращаемые значения поддерживаемого метода контроллера.\nОбратите внимание, что реактивный типы из таких библиотек, как Reactor, RxJava, или другие обычно поддерживается для всех возвращаемых значений.\nВозвращаемые значения.\nДля типов возврата, таких как Flux, когда ожидается несколько значений, элементы передаются по мере их поступления. и не буферизуются.\nЭто поведение по умолчанию, поскольку в памяти сохраняется потенциально большое количество элементов. не является эффективным.\nЕсли тип носителя подразумевает бесконечный поток (например, `application/json+stream`), значения записываются и сбрасываются индивидуально.\nВ противном случае значения записываются индивидуально и сброс происходит отдельно.\nВозвращаемые значения.\nПРИМЕЧАНИЕ.\nЕсли ошибка возникает во время кодирования элемента в формате JSON, возможно, ответ был записан в и уже зафиксирован, и в этот момент невозможно отобразить правильный ответ об ошибке.\nВ некоторых случаях приложения могут пожертвовать эффективностью использования памяти ради лучшей обработки таких ошибок. буферизация элементов и кодирование их всех одновременно.\nЗатем контроллеры могут вернуть `Flux<List<B>>`; Reactor предоставляет для этого специальный оператор Flux#collectList().\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `@ResponseBody` | Возвращаемое значение кодируется с помощью экземпляров HttpMessageWriter и записывается в ответ."}
{"id": 935, "text": "См. ссылку:web/webflux/controller/ann-methods/responsebody.adoc[`@ResponseBody`].\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `HttpEntity<B>`, `ResponseEntity<B>` | Возвращаемое значение указывает полный ответ, включая заголовки HTTP, а тело закодировано. через экземпляры HttpMessageWriter и записывается в ответ.\nСм. ссылку:web/webflux/controller/ann-methods/responseentity.adoc[`ResponseEntity`].\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `HttpHeaders` | Для возврата ответа с заголовками и без тела.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `ErrorResponse`, `ProblemDetail` | Чтобы отобразить ответ об ошибке RFC 9457 с подробными сведениями в теле, см. ссылку:web/webflux/ann-rest-Exceptions.adoc [Ответы об ошибках]"}
{"id": 936, "text": "[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `Строка` | Имя представления, которое будет разрешено с помощью экземпляров ViewResolver и использовано вместе с неявным модель — определяется с помощью командных объектов и методов @ModelAttribute.\nОбработчик метод также может программно обогатить модель, объявив аргумент Model. (описано ранее).\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `Просмотр` | Экземпляр View, используемый для рендеринга вместе с неявной моделью, определяется через командные объекты и методы @ModelAttribute.\nМетод обработчика также может программно обогатить модель, объявив аргумент Model (описано ранее).\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `java.util.Map`, `org.springframework.ui.Model` | Атрибуты, добавляемые в неявную модель, с неявно определенным именем представления. на основе пути запроса.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `@ModelAttribute` | Атрибут, добавляемый в модель, с именем представления, неявно определяемым на основе по пути запроса."}
{"id": 937, "text": "[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание.\nОбратите внимание, что `@ModelAttribute` не является обязательным.\nСм. раздел «Любое другое возвращаемое значение» ниже. этот стол.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `Рендеринг` | API для сценариев рендеринга моделей и представлений.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `FragmentsRendering`, `Flux<Fragment>`, `Collection<Fragment>` | Для рендеринга одного или нескольких фрагментов, каждый со своим видом и моделью.\nДополнительную информацию см. в HTML Fragments.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `пустота` | Метод с `void`, возможно, асинхронный (например, `Mono<Void>`), тип возвращаемого значения (или возвращаемый `null` value) считается полностью обработавшим ответ, если он также имеет `ServerHttpResponse`, аргумент ServerWebExchange или аннотацию @ResponseStatus."}
{"id": 938, "text": "То же самое верно если контроллер выполнил положительную проверку ETag или временной метки «lastModified».\nПодробности см. в Контроллеры.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание.\nЕсли ничего из вышеперечисленного не соответствует действительности, тип возвращаемого значения `void` также может указывать на отсутствие тела ответа для Контроллеры REST или выбор имени представления по умолчанию для контроллеров HTML.\n[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | `Flux<ServerSentEvent>`, `Observable<ServerSentEvent>` или другой реактивный тип | Генерация событий, отправленных сервером.\nОболочку `ServerSentEvent` можно опустить, если нужны только данные. быть записан (однако `text/event-stream` должен быть запрошен или объявлен в отображении через атрибут «производит»)."}
{"id": 939, "text": "[cols=\"1,2\", options=\"header\"] |=== | Возвращаемое значение метода контроллера | Описание. | Другие возвращаемые значения | Если возвращаемое значение остается неразрешенным каким-либо другим способом, оно рассматривается как модель. атрибут, если только он не является простым типом, как определено {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty], в этом случае он остается нерешенным. |==="}
{"id": 940, "text": "Откат декларативной транзакции.\nВ предыдущем разделе были описаны основы определения параметров транзакций для классы, обычно классы уровня обслуживания, декларативно в вашем приложении.\nЭтот раздел описывает, как можно управлять откатом транзакций простым декларативным способом. мода в конфигурации XML.\nПодробные сведения о декларативном управлении семантикой отката см. с аннотацией `@Transactional`, см.\nОткат декларативной транзакции.\nРекомендуемый способ указания инфраструктуры транзакций Spring Framework что работа транзакции должна быть отменена, означает выдачу «Исключения» из кода, который в данный момент выполняется в контексте транзакции.\nSpring Framework код инфраструктуры транзакций перехватывает любое необработанное «исключение», когда оно всплывает стек вызовов и принимает решение, помечать ли транзакцию для отката.\nОткат декларативной транзакции.\nВ конфигурации по умолчанию код инфраструктуры транзакций Spring Framework помечает транзакцию для отката только в случае непроверенных исключений во время выполнения.\nТо есть, когда выброшенное исключение является экземпляром или подклассом RuntimeException. (Экземпляры `Error` также по умолчанию приводят к откату).\nОткат декларативной транзакции.\nКонфигурация по умолчанию также обеспечивает поддержку метода Try для запуска Vavr. транзакция откатывается, когда возвращает «Сбой».\nЭто позволяет вам обрабатывать ошибки функционального стиля, используя Try and have theтранзакцию. автоматически откатывается назад в случае сбоя.\nДля получения дополнительной информации о «Попытке Вавра» см. обратитесь к {vavr-docs}/#_try[официальной документации Vavr].\nВот пример использования Try Vavr с транзакционным методом:\nJava\n	@Transactional"}
{"id": 941, "text": "public Try<String> myTransactionalMethod() {\n		// Если myDataAccessOperation выдает исключение, оно будет перехвачено\n		// Экземпляр Try, созданный с помощью Try.of() и заключенный в класс Fail.\n		// что можно проверить с помощью метода isFailure() в экземпляре Try.\n		return Try.of(delegate::myDataAccessOperation);\nОткат декларативной транзакции.\nНачиная с Spring Framework 6.1, существует специальная обработка CompletableFuture. (и общие возвращаемые значения `Future`), запуская откат для такого дескриптора, если он был исключительно завершен на момент возврата из исходного метода.\nЭто предназначено для методов `@Async`, где фактическая реализация метода может необходимо соответствовать сигнатуре CompletableFuture (автоматически адаптируемой к фактическому асинхронный дескриптор вызова прокси-сервера посредством обработки `@Async` во время выполнения), предпочитая раскрытие в возвращаемом дескрипторе, а не повторно выдавая исключение:\nJava\n	@Transactional @Async\n	public CompletableFuture<String> myTransactionalMethod() {\n		try {\n			return CompletableFuture.completedFuture(delegate.myDataAccessOperation());\n		catch (DataAccessException ex) {\n			return CompletableFuture.failedFuture(ex);\nОткат декларативной транзакции.\nПроверенные исключения, возникающие из транзакционного метода, не приводят к откату. в конфигурации по умолчанию.\nВы можете точно настроить, какие типы исключений отмечают транзакция для отката, включая проверяемые исключения путем указания _правил отката_."}
{"id": 942, "text": "Откат декларативной транзакции. .Правила отката [ПРИМЕЧАНИЕ] = Правила отката определяют, следует ли откатить транзакцию при возникновении данного исключения. выбрасывается, а правила основаны на типах исключений или шаблонах исключений.\nОткат декларативной транзакции.\nПравила отката можно настроить в XML с помощью параметров «rollback-for» и «no-rollback-for». атрибуты, которые позволяют определять правила как шаблоны.\nПри использовании Правила отката можно настроить с помощью `rollbackFor`/`noRollbackFor` и АтрибутыrollbackForClassName/noRollbackForClassName, которые позволяют определяются на основе типов или шаблонов исключений соответственно.\nОткат декларативной транзакции.\nКогда правило отката определено с типом исключения – например, через `rollbackFor` – этот тип будет использоваться для сопоставления с типом выброшенного исключения.\nВ частности, при заданном типе исключения «C» будет рассматриваться выброшенное исключение типа «T». совпадение с `C`, если `T` равен `C` или подклассу `C`.\nЭто обеспечивает тип безопасности и позволяет избежать непреднамеренных совпадений, которые могут возникнуть при использовании шаблона.\nДля Например, значение `jakarta.servlet.ServletException.class` будет соответствовать только выброшенному исключения типа jakarta.servlet.ServletException и его подклассов.\nОткат декларативной транзакции."}
{"id": 943, "text": "Если правило отката определено с помощью шаблона исключения, этот шаблон может быть полностью квалифицированное имя класса или подстрока полного имени класса для типа исключения (который должен быть подклассом Throwable), без поддержки подстановочных знаков в настоящее время.\nДля например, значение `\"jakarta.servlet.ServletException\"` или `\"ServletException\"` будет сопоставьте `jakarta.servlet.ServletException` и его подклассы.\nОткат декларативной транзакции. [ВНИМАНИЕ] = Вы должны тщательно продумать, насколько специфичен шаблон и следует ли включать пакет информация (которая не является обязательной).\nНапример, `\"Exception\"` будет соответствовать почти что угодно и, вероятно, скроет другие правила. `\"java.lang.Exception\"` было бы правильно, если бы «Исключение» предназначалось для определения правила для всех проверенных исключений.\nС более уникальными имена исключений, такие как «BaseBusinessException», скорее всего, нет необходимости использовать полное имя класса для шаблона исключения.\nОткат декларативной транзакции.\nКроме того, правила отката на основе шаблонов могут привести к непреднамеренному совпадению одноименные исключения и вложенные классы.\nЭто связано с тем, что брошенный исключение считается соответствующим данному правилу отката на основе шаблона, если имя выброшенного исключения содержит шаблон исключения, настроенный для правила отката."}
{"id": 944, "text": "Например, если правило настроено для сопоставления с com.example.CustomException, то правило будет соответствовать исключению с именем `com.example.CustomExceptionV2` (исключение в том же пакете, что и CustomException, но с дополнительным суффиксом) или исключение с именем `com.example.CustomException$AnotherException` (исключение, объявленное как вложенное класс в `CustomException`).\nОткат декларативной транзакции.\nВ следующем фрагменте XML показано, как настроить откат для проверенного, тип `Exception` для конкретного приложения, предоставляя _шаблон исключения_ через метод Атрибут `rollback-for`:\n	<tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n		<tx:attributes>\n			<tx:method name=\"get*\" read-only=\"true\" rollback-for=\"NoProductInStockException\"/>\n			<tx:method name=\"*\"/>\n		</tx:attributes>\n	</tx:advice>\nОткат декларативной транзакции.\nЕсли вы не хотите, чтобы транзакция откатывалась при возникновении исключения, вы также можете укажите правила «без отката».\nВ следующем примере показано, как Spring Framework транзакционная инфраструктура для совершения сопутствующей транзакции даже в условиях необработанное `InstrumentNotFoundException`:\n	<tx:advice id=\"txAdvice\">\n		<tx:attributes>\n			<tx:method name=\"updateStock\" no-rollback-for=\"InstrumentNotFoundException\"/>"}
{"id": 945, "text": "<tx:method name=\"*\"/>\n		</tx:attributes>\n	</tx:advice>\nОткат декларативной транзакции.\nКогда инфраструктура транзакций Spring Framework улавливает исключение и обращается к нему настроенные правила отката, чтобы определить, следует ли помечать транзакцию для отката, the strongest matching rule wins.\nИтак, в случае следующей конфигурации любой исключение, отличное от «InstrumentNotFoundException», приводит к откату сопутствующая транзакция:\n	<tx:advice id=\"txAdvice\">\n		<tx:attributes>\n			<tx:method name=\"*\" rollback-for=\"Throwable\" no-rollback-for=\"InstrumentNotFoundException\"/>\n		</tx:attributes>\n	</tx:advice>\nОткат декларативной транзакции.\nВы также можете указать необходимый откат программно.\nНесмотря на простоту, этот процесс довольно агрессивен и тесно связывает ваш код с транзакцией Spring Framework. инфраструктура.\nВ следующем примере показано, как программно указать требуемый откат:\nJava\n	public void resolvePosition() {\n		try {\n			// немного бизнес-логики...\n		} catch (NoProductInStockException ex) {\n			// запускать откат программно\n			TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\nОткат декларативной транзакции.\nВам настоятельно рекомендуется использовать декларативный подход к откату, если он вообще используется. возможно.\nПрограммный откат доступен, если он вам абсолютно необходим, но его использование противоречит достижению чистой архитектуры на основе POJO."}
{"id": 946, "text": "1. Введение. `scheduler` предоставляет планировщик фоновых задач с cron/interval триггерами, ограничением конкуренции и управлением повторными попытками.\n- автоматизирует регулярные процессы;\n- снижает риск ручных операций;\n- позволяет управлять SLA для batch/jobs.\n```xml\n```java\n    @LilipupCron(\"0 */15 * * * *\")\n    @DisallowParallel\n    public void cleanupExpiredDrafts() {\n        // Выполняется каждые 15 минут.\n        System.out.println(\"Cleaning up expired invoice drafts\");\n```java\n    @LilipupEvery(\"30s\")\n    @RetryableJob(maxAttempts = 3, backoffMs = 2000)\n    public void syncRemoteCatalog() {\n        // Внешний вызов должен быть timeout-ограничен.\n        System.out.println(\"Sync remote catalog\");\n```yaml\n    enabled: true\n    timezone: UTC\n    worker-pool-size: 8\n    max-concurrent-jobs: 16\n    misfire-policy: fire-now\n    default-timeout-ms: 30000\n- Не используйте scheduler-методы без `@LilipupCron` или `@LilipupEvery`.\n- Всегда ограничивайте параллелизм для неидемпотентных задач (`@DisallowParallel`).\n- Проверяйте timeout и circuit breaker на внешних вызовах внутри job.\n- Не запускайте критичные задачи без retry-политики или DLQ-аналогичного механизма.\n- Проверяйте timezone: cron в local timezone часто приводит к инцидентам."}
{"id": 947, "text": "- `ScheduleParseException`: некорректное cron/interval выражение.\n- `JobExecutionTimeoutException`: задача превысила лимит выполнения.\n- `JobConcurrencyViolationException`: нарушено правило параллелизма.\n```java\n    public void run(JobContext ctx) {\n        try {\n            doWork();\n            ctx.markSuccess();\n        } catch (Exception ex) {\n            ctx.markFailure(ex.getMessage());\n            throw ex;\n    private void doWork() {\n        // Business logic\n- Делайте задачи идемпотентными и re-entrant.\n- Храните checkpoint/offset для долгих jobs.\n- Разделяйте CPU-bound и IO-bound jobs по разным пулам.\n- Добавляйте jitter для периодических задач во избежание thundering herd.\n- Тестируйте переход на летнее/зимнее время для cron-задач."}
{"id": 948, "text": "Поддержка АОП на основе схемы.\nЕсли вы предпочитаете формат на основе XML, Spring также предлагает поддержку определения аспектов. используя теги пространства имен `aop`.\nТе же самые выражения и виды советов. как и при использовании стиля @AspectJ.\nПоэтому в этом разделе мы сосредоточимся на этот синтаксис и отправьте читателя к обсуждению в предыдущем разделе. (@AspectJ support) для понимания написания выражений pointcut и привязки параметров рекомендаций.\nПоддержка АОП на основе схемы.\nЧтобы использовать теги пространства имен aop, описанные в этом разделе, вам необходимо импортировать Схема `spring-aop`, как описано в конфигурация на основе XML-схемы.\nСм. схема АОП. о том, как импортировать теги в пространство имен `aop`.\nПоддержка АОП на основе схемы.\nВ ваших конфигурациях Spring все элементы аспектов и советников должны быть размещены внутри элемент `<aop:config>` (вы можете иметь более одного элемента `<aop:config>` в конфигурация контекста приложения).\nЭлемент `<aop:config>` может содержать pointcut, советник и элементы аспекта (обратите внимание, что они должны быть объявлены именно в этом порядке).\nПоддержка АОП на основе схемы.\nВНИМАНИЕ: стиль конфигурации `<aop:config>` интенсивно использует возможности Spring. не вплетается), если вы уже используете явное автоматическое проксирование с помощью `BeanNameAutoProxyCreator` или что-то подобное."}
{"id": 949, "text": "Рекомендуемая схема использования: используйте либо только стиль `<aop:config>`, либо только стиль `AutoProxyCreator` и никогда не смешивайте их.\nОбъявление аспекта.\nКогда вы используете поддержку схемы, аспект представляет собой обычный объект Java, определенный как компонент в контекст вашего приложения Spring.\nСостояние и поведение фиксируются в полях и методы объекта, а информация о точках и советах фиксируется в XML.\nОбъявление аспекта.\nВы можете объявить аспект, используя элемент `<aop:aspect>` и ссылаясь на поддерживающий компонент. используя атрибут `ref`, как показано в следующем примере:\n	<aop:config>\n		<aop:aspect id=\"myAspect\" ref=\"aBean\">\n		</aop:aspect>\n	</aop:config>\n	<bean id=\"aBean\" class=\"...\">\n	</bean>\nОбъявление аспекта.\nКомпонент, поддерживающий аспект (в данном случае aBean), конечно, можно настроить и Зависимость внедряется так же, как и любой другой компонент Spring.\nОбъявление Pointcut.\nВы можете объявить pointcut с именем _named внутри элемента `<aop:config>`, позволяя pointcut Определение может быть общим для нескольких аспектов и советников.\nОбъявление Pointcut.\nPointcut, представляющий выполнение любого бизнес-сервиса на уровне сервиса, может быть определены следующим образом:\n	<aop:config>\n		<aop:pointcut id=\"businessService\""}
{"id": 950, "text": "expression=\"execution(* com.xyz.service.*.*(..))\" />\n	</aop:config>\nОбъявление Pointcut.\nОбратите внимание, что само выражение pointcut использует то же выражение pointcut AspectJ. язык, как описано в @AspectJ support.\nЕсли вы используете объявление на основе схемы вы также можете обратиться к _именованным точечным вырезам_, определенным в типах `@Aspect` внутри выражение точечного выреза.\nТаким образом, другой способ определения вышеуказанной точки будет следующим:\n	<aop:config>\n		<aop:pointcut id=\"businessService\"\n			expression=\"com.xyz.CommonPointcuts.businessService()\" /> <1>\n	</aop:config>\nОбъявление Pointcut. <1> Ссылается на именованный pointcut `businessService`, определенный в Совместное использование именованных определений Pointcut.\nОбъявление Pointcut.\nОбъявление pointcut _внутри_ аспекта очень похоже на объявление pointcut верхнего уровня. как показано в следующем примере:\n	<aop:config>\n		<aop:aspect id=\"myAspect\" ref=\"aBean\">\n			<aop:pointcut id=\"businessService\"\n				expression=\"execution(* com.xyz.service.*.*(..))\"/>\n		</aop:aspect>\n	</aop:config>\nОбъявление Pointcut."}
{"id": 951, "text": "Во многом аналогично аспекту @AspectJ, точечные вырезы, объявленные с использованием схемы на основе стиль определения может собирать контекст точки соединения.\nНапример, следующий pointcut собирает объект `this` как контекст точки соединения и передает его в совет:\n	<aop:config>\n		<aop:aspect id=\"myAspect\" ref=\"aBean\">\n			<aop:pointcut id=\"businessService\"\n				expression=\"execution(* com.xyz.service.*.*(..)) &amp;&amp; this(service)\"/>\n			<aop:before pointcut-ref=\"businessService\" method=\"monitor\"/>\n		</aop:aspect>\n	</aop:config>\nОбъявление Pointcut.\nСовет должен быть объявлен для получения собранного контекста точки соединения, включая параметры совпадающих имен, а именно:\nJava\n	public void monitor(Object service) {\nОбъявление Pointcut.\nПри объединении подвыражений pointcut `+&&+` неудобно использовать в XML. документ, поэтому вы можете использовать ключевые слова `and`, `or` и `not` вместо `+&&+`, `||` и `!` соответственно.\nНапример, предыдущий срез точки лучше записать как следует:\n	<aop:config>\n		<aop:aspect id=\"myAspect\" ref=\"aBean\">\n			<aop:pointcut id=\"businessService\""}
{"id": 952, "text": "expression=\"execution(* com.xyz.service.*.*(..)) and this(service)\"/>\n			<aop:before pointcut-ref=\"businessService\" method=\"monitor\"/>\n		</aop:aspect>\n	</aop:config>\nОбъявление Pointcut.\nОбратите внимание, что на точечные вырезы, определенные таким образом, ссылаются по их XML-идентификаторам, и их нельзя используются как именованные точечные разрезы для формирования составных точечных разрезов.\nИменованная поддержка pointcut в Таким образом, стиль определения на основе схемы более ограничен, чем стиль @AspectJ.\nОбъявление совета.\nПоддержка АОП на основе схемы использует те же пять видов рекомендаций, что и стиль @AspectJ, и они имеют точно такая же семантика.\nПеред советом.\nСовет Before выполняется перед выполнением соответствующего метода.\nОн объявлен внутри `<aop:aspect>` с помощью элемента `<aop:before>`, как показано в следующем примере:\n	<aop:aspect id=\"beforeExample\" ref=\"aBean\">\n		<aop:before\n			pointcut-ref=\"dataAccessOperation\"\n			method=\"doAccessCheck\"/>\n	</aop:aspect>\nПеред советом.\nВ приведенном выше примере `dataAccessOperation` — это `id` _named pointcut_, определенного в верхний уровень (`<aop:config>`) (см.\nОбъявление Pointcut)."}
{"id": 953, "text": "Перед советом.\nПРИМЕЧАНИЕ.\nКак мы отмечали при обсуждении стиля @AspectJ, использование _named pointcuts_ может значительно улучшить читаемость вашего кода.\nСм. совместное использование именованных определений Pointcut. детали.\nПеред советом.\nВместо этого, чтобы определить встроенный pointcut, замените атрибут `pointcut-ref` на атрибут pointcut, например:\n	<aop:aspect id=\"beforeExample\" ref=\"aBean\">\n		<aop:before\n			pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n			method=\"doAccessCheck\"/>\n	</aop:aspect>\nПеред советом.\nАтрибут `method` идентифицирует метод (`doAccessCheck`), который предоставляет тело совет.\nЭтот метод должен быть определен для компонента, на который ссылается элемент аспекта. который содержит советы.\nПрежде чем будет выполнена операция доступа к данным (выполнение метода точка соединения, соответствующая выражению pointcut), метод doAccessCheck для аспекта вызывается компонент.\nПосле возвращения совета.\nПосле возврата совет запускается, когда выполнение соответствующего метода завершается нормально.\nЭто объявлен внутри `<aop:aspect>` так же, как и предыдущий совет.\nСледующий пример показывает, как это объявить:\n	<aop:aspect id=\"afterReturningExample\" ref=\"aBean\">\n		<aop:after-returning\n			pointcut=\"execution(* com.xyz.dao.*.*(..))\""}
{"id": 954, "text": "method=\"doAccessCheck\"/>\n	</aop:aspect>\nПосле возвращения совета.\nКак и в стиле @AspectJ, вы можете получить возвращаемое значение в теле совета.\nДля этого используйте атрибут return, чтобы указать имя параметра, которому должно быть передано возвращаемое значение, как показано в следующем примере:\n	<aop:aspect id=\"afterReturningExample\" ref=\"aBean\">\n		<aop:after-returning\n			pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n			returning=\"retVal\"\n			method=\"doAccessCheck\"/>\n	</aop:aspect>\nПосле возвращения совета.\nМетод doAccessCheck должен объявить параметр с именем retVal.\nТип этого Параметр ограничивает соответствие таким же образом, как описано для `@AfterReturning`.\nДля Например, вы можете объявить сигнатуру метода следующим образом:\nJava\n	public void doAccessCheck(Object retVal) {...\nПосле того, как бросил совет.\nСовет после выдачи запускается, когда выполнение соответствующего метода завершается путем выдачи исключение.\nОн объявляется внутри `<aop:aspect>` с помощью элемента `after-throwing`, как показано в следующем примере:\n	<aop:aspect id=\"afterThrowingExample\" ref=\"aBean\">\n		<aop:after-throwing\n			pointcut=\"execution(* com.xyz.dao.*.*(..))\""}
{"id": 955, "text": "method=\"doRecoveryActions\"/>\n	</aop:aspect>\nПосле того, как бросил совет.\nКак и в стиле @AspectJ, вы можете получить выброшенное исключение в теле совета.\nДля этого используйте атрибут `throwing`, чтобы указать имя параметра для которому должно быть передано исключение, как показано в следующем примере:\n	<aop:aspect id=\"afterThrowingExample\" ref=\"aBean\">\n		<aop:after-throwing\n			pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n			throwing=\"dataAccessEx\"\n			method=\"doRecoveryActions\"/>\n	</aop:aspect>\nПосле того, как бросил совет.\nМетод doRecoveryActions должен объявить параметр с именем dataAccessEx.\nТип этого параметра ограничивает соответствие таким же образом, как описано для `@AfterThrowing`.\nНапример, сигнатуру метода можно объявить следующим образом:\nJava\n	public void doRecoveryActions(DataAccessException dataAccessEx) {...\nПосле (наконец) совета.\nAfter (наконец) совет выполняется независимо от того, как завершается выполнение соответствующего метода.\nВы можете объявить его, используя элемент after, как показано в следующем примере:\n	<aop:aspect id=\"afterFinallyExample\" ref=\"aBean\">\n		<aop:after\n			pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n			method=\"doReleaseLock\"/>"}
{"id": 956, "text": "</aop:aspect>\nВокруг советов.\nПоследний вид советов — это «вокруговые» советы.\nВокруг совета бегает «вокруг» совпадающего выполнение метода.\nИмеет возможность выполнять работу как до, так и после метода. запускается и определить, когда, как и даже будет ли метод вообще запускаться.\nВокруг совета часто используется, если вам нужно поделиться состоянием до и после метода. выполнение потокобезопасным способом — например, запуск и остановка таймера.\nВокруг советов. [СОВЕТ] = Всегда используйте наименее действенную форму совета, отвечающую вашим требованиям.\nВокруг советов.\nНапример, не используйте совет _around_, если совет _before_ достаточен для ваших нужд.\nВокруг советов.\nВы можете объявить совет, используя элемент aop:around.\nМетод консультирования должен объявите `Object` в качестве возвращаемого типа, а первый параметр метода должен иметь значение введите «ProceedingJoinPoint».\nВ теле метода консультации вы должны вызвать `proceed()` для `ProceedingJoinPoint` для запуска базового метода.\nВызов proceed() без аргументов приведет к исходным аргументам вызывающей стороны. передается базовому методу при его вызове.\nДля продвинутых случаев использования есть это перегруженный вариант метода proceed(), который принимает массив аргументов (`Объект[]`).\nЗначения в массиве будут использоваться в качестве аргументов базового метод при его вызове.\nСм.\nAround Advice для получения примечаний по вызову. `продолжить` с `Object[]`."}
{"id": 957, "text": "<aop:aspect id=\"aroundExample\" ref=\"aBean\">\n		<aop:around\n			pointcut=\"execution(* com.xyz.service.*.*(..))\"\n			method=\"doBasicProfiling\"/>\n	</aop:aspect>\nВ следующем примере показано, как объявить рекомендации в XML:.\nРеализация совета `doBasicProfiling` может быть точно такой же, как и в Пример @AspectJ (конечно, без аннотации), как показано в следующем примере:\nJava\n	public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\n		// запустить секундомер\n		Object retVal = pjp.proceed();\n		// остановить секундомер\n		return retVal;\nПараметры рекомендаций.\nСтиль объявления на основе схемы поддерживает полностью типизированные рекомендации так же, как и описано для поддержки @AspectJ - путем сопоставления параметров pointcut по имени с Параметры метода рекомендации.\nСм.\nЕсли вы хотите явно указать имена аргументов для методов рекомендаций (не полагаясь на стратегии обнаружения, описанные ранее), вы можете сделать это, используя `arg-names` атрибут элемента консультации, который обрабатывается так же, как и `argNames` атрибут в аннотации к рекомендации (как описано в В следующем примере показано, как указать имя аргумента в XML:\n	<aop:before\n		pointcut=\"com.xyz.Pointcuts.publicMethod() and @annotation(auditable)\" <1>\n		method=\"audit\""}
{"id": 958, "text": "arg-names=\"auditable\" />\n<1> Ссылается на `publicMethod` с именем pointcut, определенный в.\nАтрибут `arg-names` принимает список имен параметров, разделенных запятыми.\n<1> Ссылается на `publicMethod` с именем pointcut, определенный в.\nСледующий немного более сложный пример подхода на основе XSD показывает некоторые советы, используемые в сочетании с рядом строго типизированных параметров:\nJava\n	package com.xyz.service;\n	public interface PersonService {\n		Person getPerson(String personName, int age);\n	public class DefaultPersonService implements PersonService {\n		public Person getPerson(String name, int age) {\n			return new Person(name, age);\n	package com.xyz.service\n	interface PersonService {\n	class DefaultPersonService : PersonService {\n<1> Ссылается на `publicMethod` с именем pointcut, определенный в.\nДалее — аспект.\nОбратите внимание на тот факт, что метод `profile(..)` принимает несколько строго типизированные параметры, первый из которых является точкой соединения, используемой для продолжите вызов метода.\nНаличие этого параметра указывает на то, что `profile(..)` следует использовать как совет `around`, как показано в следующем примере:\nJava\n	package com.xyz;\n	import org.aspectj.lang.ProceedingJoinPoint;\n	import org.springframework.util.StopWatch;\n	public class SimpleProfiler {"}
{"id": 959, "text": "public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {\n			StopWatch clock = new StopWatch(\"Profiling for '\" + name + \"' and '\" + age + \"'\");\n			try {\n				clock.start(call.toShortString());\n				return call.proceed();\n			} finally {\n				clock.stop();\n				System.out.println(clock.prettyPrint());\n	package com.xyz\n	class SimpleProfiler {\n<1> Ссылается на `publicMethod` с именем pointcut, определенный в.\nНаконец, следующий пример конфигурации XML влияет на выполнение предыдущий совет для конкретной точки соединения:\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/aop\n			https://www.springframework.org/schema/aop/spring-aop.xsd\">"}
{"id": 960, "text": "<!-- this is the object that will be proxied by Spring's AOP infrastructure -->\n		<bean id=\"personService\" class=\"com.xyz.service.DefaultPersonService\"/>\n		<!-- this is the actual advice itself -->\n		<bean id=\"profiler\" class=\"com.xyz.SimpleProfiler\"/>\n		<aop:config>\n			<aop:aspect ref=\"profiler\">\n				<aop:pointcut id=\"theExecutionOfSomePersonServiceMethod\"\n					expression=\"execution(* com.xyz.service.PersonService.getPerson(String,int))\n					and args(name, age)\"/>\n				<aop:around pointcut-ref=\"theExecutionOfSomePersonServiceMethod\"\n					method=\"profile\"/>\n			</aop:aspect>\n		</aop:config>\n	</beans>\nJava\n	public class Boot {\n		public static void main(String[] args) {\n			ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n			PersonService person = ctx.getBean(PersonService.class);\n			person.getPerson(\"Pengo\", 12);\nРассмотрим следующий сценарий драйвера:.\nС таким классом Boot мы получим вывод, аналогичный следующему, в стандартном выводе:\n[литерал,subs=\"дословно\"]."}
{"id": 961, "text": "StopWatch 'Profiling for 'Pengo' and '12': running time (millis) = 0 ----------------------------------------- ms % Task name ----------------------------------------- 00000? execution(getFoo)\nКонсультации Заказ.\nКогда несколько советов необходимо выполнить в одной и той же точке соединения (метод выполнения) правила заказа такие же, как описано в приоритет между аспектами определяется атрибутом order в атрибуте <aop:aspect>. или добавив аннотацию @Order к компоненту, который поддерживает аспект или заставив компонент реализовать интерфейс Ordered.\nКонсультации Заказ. [ПРИМЕЧАНИЕ] = В отличие от правил приоритета для методов советов, определенных в том же `@Aspect` класс, когда два совета, определенные в одном и том же элементе `<aop:aspect>`, оба должны выполняются в одной и той же точке соединения, приоритет определяется порядком, в котором советы элементы объявляются внутри включающего элемента `<aop:aspect>`, от самого высокого до самого низкого. приоритет.\nКонсультации Заказ."}
{"id": 962, "text": "Например, при наличии совета «вокруг» и совета «до», определенных в одном и том же документе. элемент `<aop:aspect>`, который применяется к одной и той же точке соединения, чтобы гарантировать, что `around` совет имеет более высокий приоритет, чем совет `before`, элемент `<aop:around>` должен быть объявлен перед элементом `<aop:before>`.\nКонсультации Заказ.\nКак правило, если вы обнаружите, что у вас определено несколько советов, в том же элементе `<aop:aspect>`, который применяется к одной и той же точке соединения, рассмотрите возможность свертывания такие методы рекомендаций в один метод рекомендаций для каждой точки соединения в каждом элементе `<aop:aspect>` или реорганизуйте советы в отдельные элементы `<aop:aspect>`, которые вы можете заказать на уровне аспекта.\nВведение.\nВведения (известные как объявления между типами в AspectJ) позволяют аспекту объявлять что рекомендуемые объекты реализуют заданный интерфейс и обеспечивают реализацию этот интерфейс от имени этих объектов.\nВведение.\nВы можете представиться, используя элемент aop:declare-parents внутри aop:aspect.\nВы можете использовать элемент aop:declare-parents, чтобы объявить, что соответствующие типы имеют нового родителя (отсюда и название)."}
{"id": 963, "text": "Например, если у вас есть интерфейс с именем UsageTracked и реализация этого интерфейса с именем `DefaultUsageTracked`, следующий аспект заявляет, что все разработчики службы интерфейсы также реализуют интерфейс UsageTracked. (Чтобы выставить статистику через JMX, например.)\n	<aop:aspect id=\"usageTrackerAspect\" ref=\"usageTracking\">\n		<aop:declare-parents\n			types-matching=\"com.xyz.service.*+\"\n			implement-interface=\"com.xyz.service.tracking.UsageTracked\"\n			default-impl=\"com.xyz.service.tracking.DefaultUsageTracked\"/>\n		<aop:before\n			pointcut=\"execution(* com.xyz..service.*.*(..))\n				and this(usageTracked)\"\n				method=\"recordUsage\"/>\n	</aop:aspect>\nJava\n	public void recordUsage(UsageTracked usageTracked) {\n		usageTracked.incrementUseCount();\nКласс, поддерживающий компонент `usageTracking`, тогда будет содержать следующий метод:.\nРеализуемый интерфейс определяется атрибутомimplement-interface. значение атрибута «types-matching» представляет собой шаблон типа AspectJ.\nЛюбой боб тип соответствия реализует интерфейс UsageTracked.\nОбратите внимание, что в предыдущем Согласно предыдущему примеру, сервисные компоненты могут использоваться непосредственно как реализации интерфейс UsageTracked.\nЧтобы получить программный доступ к компоненту, вы можете написать следующее:\nJava"}
{"id": 964, "text": "UsageTracked usageTracked = context.getBean(\"myService\", UsageTracked.class);\nМодели реализации аспектов.\nЕдинственная поддерживаемая модель создания экземпляров для аспектов, определяемых схемой, — это синглтон. модель.\nДругие модели создания экземпляров могут поддерживаться в будущих выпусках.\nСоветники.\nКонцепция «советников» исходит из поддержки АОП, определенной в Spring. и не имеет прямого эквивалента в AspectJ.\nСоветник подобен маленькому самодостаточный аспект, содержащий единственный совет.\nСам совет такой представлен компонентом и должен реализовать один из интерфейсов рекомендаций, описанных в Советники могут использовать преимущества выражений pointcut AspectJ.\nСоветники.\nSpring поддерживает концепцию советника с помощью элемента `<aop:advisor>`.\nТы самый обычно его используют в сочетании с транзакционными рекомендациями, которые также имеют свои собственные поддержка пространства имен в Spring.\nВ следующем примере показан советник:\n	<aop:config>\n		<aop:pointcut id=\"businessService\"\n			expression=\"execution(* com.xyz.service.*.*(..))\"/>\n		<aop:advisor\n			pointcut-ref=\"businessService\"\n			advice-ref=\"tx-advice\" />\n	</aop:config>\n	<tx:advice id=\"tx-advice\">\n		<tx:attributes>\n			<tx:method name=\"*\" propagation=\"REQUIRED\"/>\n		</tx:attributes>\n	</tx:advice>\nСоветники."}
{"id": 965, "text": "Помимо атрибута pointcut-ref, использованного в предыдущем примере, вы также можете использовать Атрибут pointcut для определения встроенного выражения pointcut.\nСоветники.\nЧтобы определить приоритет советника, чтобы совет мог участвовать в заказе, используйте атрибут Order, чтобы определить значение советника Ordered.\nВ этом разделе показано, как пример повторной попытки одновременной блокировки.\nВыполнение бизнес-сервисов иногда может завершаться сбоем из-за проблем параллелизма (например, например, проигравший в тупике).\nЕсли операцию повторить, она, скорее всего, завершится успешно. при следующей попытке.\nДля бизнес-услуг, где уместно повторить попытку в таком условия (идемпотентные операции, которым не нужно возвращаться к пользователю в случае конфликта разрешение), мы хотим прозрачно повторить операцию, чтобы клиент не увидел `PessimisticLockingFailureException`.\nЭто требование, которое явно затрагивает несколько сервисов на уровне сервисов и, следовательно, идеально подходит для реализации через аспект.\nВ этом разделе показано, как пример повторной попытки одновременной блокировки.\nПоскольку мы хотим повторить операцию, нам нужно воспользоваться советом, чтобы мы могли вызовите `proceed` несколько раз.\nВ следующем листинге показана реализация основного аспекта. (это обычный класс Java, использующий поддержку схемы):\nJava\n	public class ConcurrentOperationExecutor implements Ordered {\n		private static final int DEFAULT_MAX_RETRIES = 2;\n		private int maxRetries = DEFAULT_MAX_RETRIES;\n		private int order = 1;\n		public void setMaxRetries(int maxRetries) {\n			this.maxRetries = maxRetries;"}
{"id": 966, "text": "public int getOrder() {\n			return this.order;\n		public void setOrder(int order) {\n			this.order = order;\n		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\n			int numAttempts = 0;\n			PessimisticLockingFailureException lockFailureException;\n			do {\n				numAttempts++;\n				try {\n					return pjp.proceed();\n				catch(PessimisticLockingFailureException ex) {\n					lockFailureException = ex;\n			} while(numAttempts <= this.maxRetries);\n			throw lockFailureException;\n	class ConcurrentOperationExecutor : Ordered {\n			} while (numAttempts <= this.maxRetries)\n			throw lockFailureException\nВ этом разделе показано, как пример повторной попытки одновременной блокировки.\nОбратите внимание, что этот аспект реализует интерфейс Ordered, поэтому мы можем установить приоритет аспект выше, чем совет по транзакции (мы хотим новую транзакцию каждый раз, когда мы повторите попытку).\nСвойства maxRetries и order настраиваются Spring.\nОсновное действие происходит в методе doConcurrentOperation вокруг совета.\nМы стараемся продолжайте.\nЕсли мы потерпим неудачу с PessimisticLockingFailureException, мы попробуем еще раз, если мы не исчерпали все наши повторные попытки.\nВ этом разделе показано, как пример повторной попытки одновременной блокировки.\nПРИМЕЧАНИЕ.\nЭтот класс идентичен тому, который использовался в примере @AspectJ, но с аннотации удалены.\n	<aop:config>\n		<aop:aspect id=\"concurrentOperationRetry\" ref=\"concurrentOperationExecutor\">\n			<aop:pointcut id=\"idempotentOperation\""}
{"id": 967, "text": "expression=\"execution(* com.xyz.service.*.*(..))\"/>\n			<aop:around\n				pointcut-ref=\"idempotentOperation\"\n				method=\"doConcurrentOperation\"/>\n		</aop:aspect>\n	</aop:config>\n	<bean id=\"concurrentOperationExecutor\"\n		class=\"com.xyz.service.impl.ConcurrentOperationExecutor\">\n			<property name=\"maxRetries\" value=\"3\"/>\n			<property name=\"order\" value=\"100\"/>\n	</bean>\nСоответствующая конфигурация Spring выглядит следующим образом:.\nОбратите внимание: на данный момент мы предполагаем, что все бизнес-сервисы идемпотентны.\nЕсли это не так, мы можем уточнить этот аспект, чтобы он повторял только искренние попытки. идемпотентные операции, вводя аннотацию «Идемпотент» и используя аннотацию для аннотирования реализации сервисных операций, как показано в следующем примере:\nJava\n	@Retention(RetentionPolicy.RUNTIME)\n	// аннотация маркера\n	public @interface Idempotent {\n	@Retention(AnnotationRetention.RUNTIME)\n	// аннотация маркера\n	annotation class Idempotent\nСоответствующая конфигурация Spring выглядит следующим образом:. изменение аспекта, позволяющего повторять только идемпотентные операции, требует уточнения выражение pointcut, чтобы совпадали только операции `@Idempotent`, как показано ниже:\n	<aop:pointcut id=\"idempotentOperation\""}
{"id": 968, "text": "expression=\"execution(* com.xyz.service.*.*(..)) and\n			@annotation(com.xyz.service.Idempotent)\"/>"}
{"id": 969, "text": "1. Введение. `security` реализует аутентификацию, авторизацию, шифрование и политики доступа на уровне endpoint, сервиса и данных.\n- предотвращает несанкционированный доступ;\n- унифицирует security-конфигурацию;\n- обеспечивает аудит безопасности и соответствие требованиям.\n```xml\n```java\n    @RequiresRole(\"PAYROLL_ADMIN\")\n    public void recalculatePayroll() {\n        // Доступ только для роли PAYROLL_ADMIN.\n    @RequiresPermission(\"employee:read\")\n    public String getEmployee(String id) {\n        return \"employee:\" + id;\n```java\n    private final CryptoService cryptoService;\n    public SecretTokenStore(CryptoService cryptoService) {\n        this.cryptoService = cryptoService;\n    public String encryptToken(String rawToken) {\n        return cryptoService.encrypt(rawToken);\n    public String decryptToken(String encryptedToken) {\n        return cryptoService.decrypt(encryptedToken);\n```yaml\n    auth:\n      provider: jwt\n      jwt:\n        issuer: lilipup-auth\n        audience: internal-services\n        public-key-path: classpath:keys/public.pem\n        clock-skew-sec: 30\n    authorization:\n      default-policy: deny\n      cache-ttl-sec: 60\n    crypto:\n      algorithm: AES_GCM\n      key-source: env\n      key-env-name: LILIPUP_MASTER_KEY\n    audit:\n      enabled: true\n      include-request-body: false\n- Всегда используйте `default-policy: deny` как безопасный baseline."}
{"id": 970, "text": "- Проверяйте срок действия JWT и `issuer/audience` при каждом запросе.\n- Никогда не храните master key в plaintext-конфиге.\n- Проверяйте, что аудит включен для критичных операций.\n- Не используйте симметричное шифрование без ротации ключей.\n- `AuthenticationException`: невалидный токен или отсутствует credential.\n- `AccessDeniedException`: недостаточно ролей/permission.\n- `CryptoOperationException`: ошибка шифрования/дешифрования.\n```java\n    public int mapToHttpStatus(Exception ex) {\n        if (ex instanceof AuthenticationException) {\n            return 401;\n        if (ex instanceof AccessDeniedException) {\n            return 403;\n        return 500;\n- Применяйте principle of least privilege для ролей и permission.\n- Разделяйте machine-to-machine и user-токены.\n- Включайте key rotation и проверяйте обратную совместимость ключей.\n- Маскируйте PII и секреты в логах.\n- Проводите security regression tests для каждого релиза."}
{"id": 971, "text": "API веб-сокетов.\nSpring Framework предоставляет API WebSocket, который можно использовать для написания клиентских и серверные приложения, обрабатывающие сообщения WebSocket.\n`WebSocketHandler`.\nСоздать сервер WebSocket так же просто, как реализовать WebSocketHandler или что-то еще. вероятно, расширяя либо TextWebSocketHandler, либо BinaryWebSocketHandler.\nСледующие в примере используется TextWebSocketHandler: См. пример кода в исходном документе.\n`WebSocketHandler`.\nСуществует специальная программная конфигурация WebSocket и поддержка пространства имен XML для сопоставления предыдущих WebSocket к определенному URL-адресу, как показано в следующем примере: См. пример кода в исходном документе.\n`WebSocketHandler`.\nПредыдущий пример предназначен для использования в приложениях Spring MVC и его следует включить. в конфигурации файла `DispatcherServlet`.\nОднако весна Поддержка WebSocket не зависит от Spring MVC.\nОтносительно просто интегрировать WebSocketHandler в другие среды HTTP-обслуживания с помощью {spring-framework-api}/web/socket/server/support/WebSocketHttpRequestHandler.html[`WebSocketHttpRequestHandler`].\n`WebSocketHandler`.\nПри использовании API WebSocketHandler напрямую или косвенно, например, через поскольку базовый стандартный сеанс WebSocket (JSR-356) не допускает одновременного отправка.\nОдин из вариантов — обернуть WebSocketSession с помощью {spring-framework-api}/web/socket/handler/ConcurrentWebSocketSessionDecorator.html[`ConcurrentWebSocketSessionDecorator`].\nВебсокетное рукопожатие."}
{"id": 972, "text": "Самый простой способ настроить первоначальный запрос на рукопожатие HTTP WebSocket — через HandshakeInterceptor, который предоставляет методы «до» и «после» рукопожатия.\nВы можете использовать такой перехватчик, чтобы предотвратить рукопожатие или сделать какие-либо атрибуты доступен для `WebSocketSession`.\nВ следующем примере используется встроенный перехватчик. для передачи атрибутов сеанса HTTP в сеанс WebSocket: См. пример кода в исходном документе.\nВебсокетное рукопожатие.\nБолее продвинутый вариант — расширить DefaultHandshakeHandler, который выполняет этапы установления связи WebSocket, включая проверку происхождения клиента, согласование подпротокола и другие детали.\nПриложению также может потребоваться использовать это вариант, если ему необходимо настроить специальную `RequestUpgradeStrategy` для адаптироваться к движку сервера WebSocket и его версии, которая еще не поддерживается (подробнее по этому вопросу см.\nDeployment).\nИ конфигурация Java, и пространство имен XML позволяют настроить собственный `HandshakeHandler`.\nВебсокетное рукопожатие.\nСОВЕТ: Spring предоставляет базовый класс WebSocketHandlerDecorator, который можно использовать для украшения WebSocketHandler с дополнительным поведением.\nЛогирование и обработка исключений реализации предоставляются и добавляются по умолчанию при использовании конфигурации Java WebSocket. или пространство имен XML. `ExceptionWebSocketHandlerDecorator` перехватывает все неперехваченные исключения, возникающие из любого метода `WebSocketHandler` и закрывающие WebSocket сеанс со статусом «1011», что указывает на ошибку сервера.\nРазвертывание.\nAPI Spring WebSocket легко интегрировать в приложение Spring MVC, где DispatcherServlet обслуживает как рукопожатие HTTP WebSocket, так и другие HTTP-запросы."}
{"id": 973, "text": "Его также легко интегрировать в другие сценарии обработки HTTP. вызвав `WebSocketHttpRequestHandler`.\nЭто удобно и легко понимаю.\nОднако в отношении среды выполнения JSR-356 применяются особые соображения.\nРазвертывание.\nAPI Jakarta WebSocket (JSR-356) предоставляет два механизма развертывания.\nПервый включает сканирование пути к классам контейнера сервлетов (функция сервлета 3) при запуске.\nДругой — это API регистрации, который можно использовать при инициализации контейнера сервлетов.\nНи один из этих механизмов не позволяет использовать один «фронт-контроллер». для всей обработки HTTP, включая рукопожатие WebSocket и все другие HTTP-обработки. запросы, такие как DispatcherServlet Spring MVC.\nРазвертывание.\nЭто существенное ограничение JSR-356, которое поддерживает Spring WebSocket. стандартная реализация RequestUpgradeStrategy при работе в среде выполнения WebSocket API 2.1+.\nРазвертывание.\nВторым соображением является то, что ожидаются контейнеры сервлетов с поддержкой JSR-356. для выполнения сканирования `ServletContainerInitializer` (SCI), которое может замедлить работу приложения запуск - в некоторых случаях, резко.\nЕсли значительное воздействие наблюдается после обновиться до версии контейнера сервлетов с поддержкой JSR-356, это должно возможность выборочного включения или отключения веб-фрагментов (и сканирования SCI) с помощью элемента `<absolute-ordering />` в `web.xml`, как показано в следующем примере:"}
{"id": 974, "text": "<web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xsi:schemaLocation=\"\n			https://jakarta.ee/xml/ns/jakartaee\n			https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\"\n		version=\"5.0\">\n		<absolute-ordering/>\n	</web-app>\nРазвертывание.\nЗатем вы можете выборочно включать веб-фрагменты по имени, например собственный Spring.\nSpringServletContainerInitializer, обеспечивающий поддержку сервлета 3.\nAPI инициализации Java.\nВ следующем примере показано, как это сделать:\n	<web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xsi:schemaLocation=\"\n			https://jakarta.ee/xml/ns/jakartaee\n			https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\"\n		version=\"5.0\">\n		<absolute-ordering>\n			<name>spring_web</name>\n		</absolute-ordering>\n	</web-app>\nНастройка сервера."}
{"id": 975, "text": "Вы можете настроить базовый сервер WebSocket, например размер буфера входных сообщений, тайм-аут простоя и многое другое.\nНастройка сервера.\nДля серверов Jakarta WebSocket вы можете добавить ServletServerContainerFactoryBean в свой конфигурация.\nНапример: См. пример кода в исходном документе.\nНастройка сервера.\nПРИМЕЧАНИЕ.\nДля конфигурации клиента Jakarta WebSocket используйте ContainerProvider.getWebSocketContainer() в программной конфигурации или `WebSocketContainerFactoryBean` в XML.\nНастройка сервера.\nДля Jetty вы можете предоставить обратный вызов для настройки сервера WebSocket: См. пример кода в исходном документе.\nНастройка сервера.\nСОВЕТ: При использовании STOMP через WebSocket вам также необходимо настроить свойства.\nРазрешенные источники.\nНачиная с Spring Framework 4.1.5, поведение по умолчанию для WebSocket и SockJS — принимать только запросы одного происхождения.\nТакже возможно разрешить все или указанный список источников.\nЭта проверка в основном предназначена для браузерных клиентов.\nНичто не мешает другим типам клиентов от изменения значения заголовка Origin (см. {rfc-site}/rfc6454 [RFC 6454: Концепция веб-происхождения] для более подробной информации).\n * Разрешить только запросы того же происхождения (по умолчанию). В этом режиме, когда SockJS включен,\nТри возможных варианта поведения:.\nЗаголовок ответа HTTP Iframe `X-Frame-Options` установлен в `SAMEORIGIN`, а JSONP транспорт отключен, так как не позволяет проверить происхождение запроса."}
{"id": 976, "text": "Как следствие, IE6 и IE7 не поддерживаются, когда этот режим включен.\n * Разрешить указанный список источников: каждый разрешенный источник должен начинаться с `http://`\nТри возможных варианта поведения:. или `https://`.\nВ этом режиме, когда SockJS включен, транспорт IFrame отключен.\nКак следствие, IE6–IE9 не поддерживаются, когда это режим включен.\n * Разрешить все источники: чтобы включить этот режим, вы должны указать `{asterisk}` в качестве разрешенного источника.\nТри возможных варианта поведения:. ценность.\nВ этом режиме доступны все транспорты.\nТри возможных варианта поведения:.\nВы можете настроить разрешенные источники WebSocket и SockJS, как показано в следующем примере: См. пример кода в исходном документе."}
{"id": 977, "text": "`@SessionAttribute`.\nЕсли вам нужен доступ к уже существующим атрибутам сеанса, которые управляются глобально (то есть вне контроллера, например, с помощью фильтра) и может присутствовать или отсутствовать, вы можете использовать аннотацию @SessionAttribute для параметра метода, как показано в следующем примере:\nJava\n	@GetMapping(\"/\")\n	public String handle(@SessionAttribute User user) { // <1>\n`@SessionAttribute`. <1> Использование `@SessionAttribute`.\n`@SessionAttribute`.\nВ случаях использования, требующих добавления или удаления атрибутов сеанса, рассмотрите возможность внедрения `WebSession` в метод контроллера.\n`@SessionAttribute`.\nДля временного хранения атрибутов модели в сеансе в составе контроллера рабочего процесса, рассмотрите возможность использования SessionAttributes, как описано в"}
{"id": 978, "text": "`@SessionAttributes` используется для хранения атрибутов модели в `WebSession` между запросы.\nЭто аннотация уровня типа, которая объявляет атрибуты сеанса, используемые конкретный контроллер.\nОбычно здесь перечислены имена атрибутов модели или типов атрибуты модели, которые должны прозрачно храниться в сеансе для последующего запросы на доступ.\nJava\n	@Controller\n	@SessionAttributes(\"pet\") <1>\n	public class EditPetForm {\nРассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`.\n	@Controller\n	@SessionAttributes(\"pet\") // <1>\n	class EditPetForm {\nРассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`.\nРассмотрим следующий пример:.\nПри первом запросе, когда в модель добавляется атрибут модели с именем «pet», он автоматически повышается и сохраняется в `WebSession`.\nОно остается там до тех пор, пока другой метод контроллера использует аргумент метода SessionStatus для очистки хранилища, как показано в следующем примере:\nJava\n	@Controller\n	@SessionAttributes(\"pet\") // <1>\n	public class EditPetForm {\n		@PostMapping(\"/pets/{id}\")\n		public String handle(Pet pet, BindingResult errors, SessionStatus status) { // <2>\n			if (errors.hasErrors()) {\n				status.setComplete();\nРассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`. <2> Использование переменной SessionStatus."}
{"id": 979, "text": "@Controller\n	@SessionAttributes(\"pet\") // <1>\n	class EditPetForm {\nРассмотрим следующий пример:. <1> Использование аннотации `@SessionAttributes`. <2> Использование переменной SessionStatus."}
{"id": 980, "text": "Упрощение операций JDBC с помощью классов SimpleJdbc.\nКлассы SimpleJdbcInsert и SimpleJdbcCall предоставляют упрощенную конфигурацию. используя метаданные базы данных, которые можно получить с помощью драйвера JDBC.\nЭто означает, что вам придется меньше настраивать заранее, хотя вы можете переопределить или отключить обработку метаданных, если вы предпочитаете предоставить все детали в своем коде.\nВставка данных с помощью SimpleJdbcInsert.\nНачнем с рассмотрения класса SimpleJdbcInsert с минимальным количеством варианты конфигурации.\nВы должны создать экземпляр SimpleJdbcInsert при доступе к данным. метод инициализации слоя.\nВ этом примере метод инициализации — это метод `setDataSource`.\nВам не нужно создавать подкласс класса SimpleJdbcInsert.\nВместо этого, вы можете создать новый экземпляр и установить имя таблицы, используя метод withTableName.\nМетоды конфигурации для этого класса следуют «свободному» стилю, который возвращает экземпляр. из SimpleJdbcInsert, который позволяет объединить все методы конфигурации.\nСледующие В примере используется только один метод конфигурации (позже мы покажем примеры нескольких методов):\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcInsert insertActor;\n		public void setDataSource(DataSource dataSource) {\n			this.insertActor = new SimpleJdbcInsert(dataSource).withTableName(\"t_actor\");\n		public void add(Actor actor) {\n			Map<String, Object> parameters = new HashMap<>(3);\n			parameters.put(\"id\", actor.getId());\n			parameters.put(\"first_name\", actor.getFirstName());"}
{"id": 981, "text": "parameters.put(\"last_name\", actor.getLastName());\n			insertActor.execute(parameters);\n		// ... дополнительные методы\nВставка данных с помощью SimpleJdbcInsert.\nИспользуемый здесь метод `execute` принимает простой `java.util.Map` в качестве единственного параметра.\nЗдесь важно отметить, что ключи, используемые для «Карты», должны соответствовать столбцу имена таблиц, определенные в базе данных.\nЭто потому, что мы читаем метаданные для создания фактического оператора вставки.\nПолучение автоматически сгенерированных ключей с помощью SimpleJdbcInsert.\nВ следующем примере используется та же вставка, что и в предыдущем примере, но вместо передачи `id` извлекает автоматически сгенерированный ключ и устанавливает его в новом объекте «Актер».\nКогда он создает `SimpleJdbcInsert`, помимо указания имени таблицы, указывает имя сгенерированного ключевого столбца с помощью метода usingGeneratedKeyColumns.\nСледующие листинг показывает, как это работает:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcInsert insertActor;\n		public void setDataSource(DataSource dataSource) {\n			this.insertActor = new SimpleJdbcInsert(dataSource)\n					.withTableName(\"t_actor\")\n					.usingGeneratedKeyColumns(\"id\");\n		public void add(Actor actor) {\n			Map<String, Object> parameters = new HashMap<>(2);\n			parameters.put(\"first_name\", actor.getFirstName());"}
{"id": 982, "text": "parameters.put(\"last_name\", actor.getLastName());\n			Number newId = insertActor.executeAndReturnKey(parameters);\n			actor.setId(newId.longValue());\n		// ... дополнительные методы\nПолучение автоматически сгенерированных ключей с помощью SimpleJdbcInsert.\nОсновное отличие при запуске вставки с использованием второго подхода заключается в том, что вы не добавьте «id» в «Map» и вызовите метод «executeAndReturnKey».\nЭто возвращает объект `java.lang.Number`, с помощью которого вы можете создать экземпляр числового типа, который используется в вашем доменном классе.\nВы не можете полагаться на то, что все базы данных вернут конкретную Java. класс здесь. `java.lang.Number` — это базовый класс, на который вы можете положиться.\nЕсли у вас есть несколько автоматически созданных столбцов или сгенерированные значения нечисловые, вы можете используйте KeyHolder, возвращаемый методомexecuteAndReturnKeyHolder.\nУказание столбцов для SimpleJdbcInsert.\nВы можете ограничить количество столбцов для вставки, указав список имен столбцов с помощью `usingColumns`, как показано в следующем примере:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcInsert insertActor;\n		public void setDataSource(DataSource dataSource) {\n			this.insertActor = new SimpleJdbcInsert(dataSource)\n					.withTableName(\"t_actor\")\n					.usingColumns(\"first_name\", \"last_name\")\n					.usingGeneratedKeyColumns(\"id\");\n		public void add(Actor actor) {"}
{"id": 983, "text": "Map<String, Object> parameters = new HashMap<>(2);\n			parameters.put(\"first_name\", actor.getFirstName());\n			parameters.put(\"last_name\", actor.getLastName());\n			Number newId = insertActor.executeAndReturnKey(parameters);\n			actor.setId(newId.longValue());\n		// ... дополнительные методы\nУказание столбцов для SimpleJdbcInsert.\nВыполнение вставки такое же, как если бы вы полагались на метаданные для определения какие столбцы использовать.\nИспользование SqlParameterSource для предоставления значений параметров.\nИспользование Map для предоставления значений параметров работает нормально, но это не самый удобный вариант. класс для использования.\nSpring предоставляет несколько реализаций SqlParameterSource. интерфейс, который вы можете использовать вместо этого.\nПервый — «BeanPropertySqlParameterSource», это очень удобный класс, если у вас есть класс, совместимый с JavaBean, который содержит ваши ценности.\nОн использует соответствующий метод получения для извлечения параметра ценности.\nВ следующем примере показано, как использовать BeanPropertySqlParameterSource:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcInsert insertActor;\n		public void setDataSource(DataSource dataSource) {\n			this.insertActor = new SimpleJdbcInsert(dataSource)\n					.withTableName(\"t_actor\")\n					.usingGeneratedKeyColumns(\"id\");\n		public void add(Actor actor) {\n			SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);\n			Number newId = insertActor.executeAndReturnKey(parameters);"}
{"id": 984, "text": "actor.setId(newId.longValue());\n		// ... дополнительные методы\nИспользование SqlParameterSource для предоставления значений параметров.\nДругой вариант — MapSqlParameterSource, который похож на Map, но предоставляет больше возможностей. удобный метод addValue, который можно объединить в цепочку.\nВ следующем примере показано, как его использовать:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcInsert insertActor;\n		public void setDataSource(DataSource dataSource) {\n			this.insertActor = new SimpleJdbcInsert(dataSource)\n					.withTableName(\"t_actor\")\n					.usingGeneratedKeyColumns(\"id\");\n		public void add(Actor actor) {\n			SqlParameterSource parameters = new MapSqlParameterSource()\n					.addValue(\"first_name\", actor.getFirstName())\n					.addValue(\"last_name\", actor.getLastName());\n			Number newId = insertActor.executeAndReturnKey(parameters);\n			actor.setId(newId.longValue());\n		// ... дополнительные методы\nИспользование SqlParameterSource для предоставления значений параметров.\nКак видите, конфигурация та же.\nТолько исполняемый код должен измениться на используйте эти альтернативные классы ввода.\nВызов хранимой процедуры с помощью SimpleJdbcCall.\nКласс SimpleJdbcCall использует метаданные в базе данных для поиска имен in. и параметры `out`, чтобы вам не приходилось их явно объявлять.\nВы можете объявляйте параметры, если вы предпочитаете это делать, или если у вас есть параметры, которые не иметь автоматическое сопоставление с классом Java."}
{"id": 985, "text": "В первом примере показана простая процедура. который возвращает только скалярные значения в формате VARCHAR и DATE из базы данных MySQL.\nПример процедуры считывает указанную запись актера и возвращает `first_name`, Столбцы «last_name» и «birth_date» в виде параметров «out».\nСледующие в листинге показан первый пример:\n	СОЗДАТЬ ПРОЦЕДУРУ read_actor (\n		IN in_id INTEGER,\n		OUT out_first_name VARCHAR(100),\n		OUT out_last_name VARCHAR(100),\n		OUT out_birth_date DATE)\n	BEGIN\n		ВЫБЕРИТЕ имя, фамилию, дату рождения\n		INTO out_first_name, out_last_name, out_birth_date\n		FROM t_actor where id = in_id;\n	END;\nВызов хранимой процедуры с помощью SimpleJdbcCall.\nПараметр in_id содержит идентификатор актера, которого вы ищете. «Выход» параметры возвращают данные, считанные из таблицы.\nВызов хранимой процедуры с помощью SimpleJdbcCall.\nВы можете объявить SimpleJdbcCall аналогично объявлению SimpleJdbcInsert. ты должен создать экземпляр и настроить класс в методе инициализации вашего доступа к данным слой.\nВ отличие от класса StoredProcedure вам не нужно создавать подкласс. и вам не нужно объявлять параметры, которые можно найти в метаданных базы данных.\nВ следующем примере конфигурации SimpleJdbcCall используется предыдущая хранимая процедура.\nЕдинственным параметром конфигурации (кроме DataSource) является имя сохраненного процедура.\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcCall procReadActor;\n		public void setDataSource(DataSource dataSource) {\n			this.procReadActor = new SimpleJdbcCall(dataSource)\n					.withProcedureName(\"read_actor\");\n		public Actor readActor(Long id) {"}
{"id": 986, "text": "SqlParameterSource in = new MapSqlParameterSource()\n					.addValue(\"in_id\", id);\n			Map out = procReadActor.execute(in);\n			Actor actor = new Actor();\n			actor.setId(id);\n			actor.setFirstName((String) out.get(\"out_first_name\"));\n			actor.setLastName((String) out.get(\"out_last_name\"));\n			actor.setBirthDate((Date) out.get(\"out_birth_date\"));\n			return actor;\n		// ... дополнительные методы\n			// ... дополнительные методы\nВызов хранимой процедуры с помощью SimpleJdbcCall.\nКод, который вы пишете для выполнения вызова, включает в себя создание SqlParameterSource. содержащий параметр IN.\nВы должны соответствовать имени, указанному для входного значения. с именем параметра, объявленным в хранимой процедуре.\nДело не имеет соответствовать, поскольку вы используете метаданные для определения того, как следует ссылаться на объекты базы данных в хранимой процедуре.\nТо, что указано в исходном коде хранимой процедуры, не является обязательно так, как он хранится в базе данных.\nНекоторые базы данных преобразуют имена во все верхний регистр, в то время как другие используют нижний регистр или регистр, как указано.\nВызов хранимой процедуры с помощью SimpleJdbcCall."}
{"id": 987, "text": "Метод `execute` принимает параметры IN и возвращает `Map`, который содержит любые `out` параметры, связанные с именем, указанным в хранимой процедуре.\nВ этом случае они `out_first_name`, `out_last_name` и `out_birth_date`.\nВызов хранимой процедуры с помощью SimpleJdbcCall.\nПоследняя часть метода «execute» создает экземпляр «Actor», который можно использовать для возврата данные получены.\nОпять же, важно использовать имена параметров `out`, поскольку они объявляются в хранимой процедуре.\nТакже дело в названиях `out` параметры, хранящиеся в карте результатов, совпадают с именами параметров `out` в база данных, которая может различаться в зависимости от базы данных.\nЧтобы сделать ваш код более переносимым, вам следует выполните поиск без учета регистра или поручите Spring использовать LinkedCaseInsensusMap.\nЧтобы сделать последнее, вы можете создать свой собственный JdbcTemplate и установить setResultsMapCaseInsensitivity. свойство «истина».\nЗатем вы можете передать этот настроенный экземпляр JdbcTemplate в конструктор вашего SimpleJdbcCall.\nВ следующем примере показана эта конфигурация:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcCall procReadActor;\n		public void setDataSource(DataSource dataSource) {\n			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n			jdbcTemplate.setResultsMapCaseInsensitive(true);\n			this.procReadActor = new SimpleJdbcCall(jdbcTemplate)\n					.withProcedureName(\"read_actor\");\n		// ... дополнительные методы\nВызов хранимой процедуры с помощью SimpleJdbcCall."}
{"id": 988, "text": "Совершая это действие, вы избегаете конфликтов в регистре имен ваших вернул параметры `out`.\nЯвное объявление параметров для использования в SimpleJdbcCall.\nРанее в этой главе мы описали, как параметры извлекаются из метаданных, но вы можете их объявить. явно, если хотите.\nВы можете сделать это, создав и настроив SimpleJdbcCall с помощью метод DeclareParameters, который принимает переменное количество объектов SqlParameter. в качестве ввода.\nПодробную информацию о том, как определить SqlParameter, см. в документе следующий раздел.\nЯвное объявление параметров для использования в SimpleJdbcCall.\nПРИМЕЧАНИЕ.\nЯвные объявления необходимы, если используемая вами база данных не поддерживается Spring. база данных.\nВ настоящее время Spring поддерживает поиск метаданных вызовов хранимых процедур для следующие базы данных: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle и Sybase.\nМы также поддерживаем поиск метаданных хранимых функций для MySQL, Microsoft SQL Server, и Оракул.\nЯвное объявление параметров для использования в SimpleJdbcCall.\nВы можете явно объявить один, некоторые или все параметры.\nПараметр метаданные по-прежнему используются там, где вы явно не объявляете параметры.\nЧтобы обойти все обработка поиска метаданных для потенциальных параметров и использование только объявленных параметров, вы можете вызвать метод `withoutProcedureColumnMetaDataAccess` как часть декларация.\nПредположим, что у вас есть две или более разные сигнатуры вызова, объявленные для функция базы данных."}
{"id": 989, "text": "В этом случае вы вызываете useInParameterNames, чтобы указать список имен параметров IN, которые необходимо включить в данную сигнатуру.\nЯвное объявление параметров для использования в SimpleJdbcCall.\nВ следующем примере показан полностью объявленный вызов процедуры и используется информация из предыдущий пример:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcCall procReadActor;\n		public void setDataSource(DataSource dataSource) {\n			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n			jdbcTemplate.setResultsMapCaseInsensitive(true);\n			this.procReadActor = new SimpleJdbcCall(jdbcTemplate)\n					.withProcedureName(\"read_actor\")\n					.withoutProcedureColumnMetaDataAccess()\n					.useInParameterNames(\"in_id\")\n					.declareParameters(\n							new SqlParameter(\"in_id\", Types.NUMERIC),\n							new SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n							new SqlOutParameter(\"out_last_name\", Types.VARCHAR),\n							new SqlOutParameter(\"out_birth_date\", Types.DATE)\n		// ... дополнительные методы\n			// ... дополнительные методы\nЯвное объявление параметров для использования в SimpleJdbcCall.\nВыполнение и конечные результаты двух примеров одинаковы.\nВо втором примере указаны все детали явно, а не полагаться на метаданные.\nКак определить `SqlParameters`.\nЧтобы определить параметр для классов SimpleJdbc, а также для операций RDBMS. классов (описанных в Моделирование операций JDBC как объектов Java), вы можете использовать SqlParameter или один из его подклассов.\nДля этого вы обычно указываете имя параметра и тип SQL в конструкторе."}
{"id": 990, "text": "Тип SQL указывается с помощью констант java.sql.Types.\nРанее в этой главе мы видели объявления похоже на следующее:\nJava\n	new SqlParameter(\"in_id\", Types.NUMERIC),\n	new SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n	SqlParameter(\"in_id\", Types.NUMERIC),\n	SqlOutParameter(\"out_first_name\", Types.VARCHAR),\nКак определить `SqlParameters`.\nПервая строка с `SqlParameter` объявляет параметр IN.\nВы можете использовать параметры IN как для вызовов хранимых процедур, так и для запросов с использованием `SqlQuery` и его подклассы (описаны в документе Понимание `SqlQuery`).\nКак определить `SqlParameters`.\nВторая строка (с `SqlOutParameter`) объявляет параметр `out`, который будет использоваться в вызов хранимой процедуры.\nСуществует также SqlInOutParameter для параметров InOut. (параметры, которые предоставляют процедуре значение IN и которые также возвращают значение).\nКак определить `SqlParameters`.\nПРИМЕЧАНИЕ.\nДля предоставить входные значения.\nЭто отличается от класса StoredProcedure, который (для по соображениям обратной совместимости) позволяет предоставлять входные значения для параметров объявлен как SqlOutParameter.\nКак определить `SqlParameters`.\nДля параметров IN помимо имени и типа SQL можно указать масштаб числовые данные или имя типа для пользовательских типов баз данных.\nДля параметров `out` вы можете предоставьте RowMapper для обработки сопоставления строк, возвращаемых курсором REF."}
{"id": 991, "text": "Другой вариант — указать `SqlReturnType`, который дает возможность определить индивидуальная обработка возвращаемых значений.\nВызов хранимой функции с помощью SimpleJdbcCall.\nВы можете вызвать хранимую функцию почти так же, как и хранимую процедуру, за исключением что вы указываете имя функции, а не имя процедуры.\nВы используете `withFunctionName` как часть конфигурации, чтобы указать, что вы хотите сделать вызов функции, и генерируется соответствующая строка для вызова функции.\nА специализированный вызов (`executeFunction`) используется для запуска функции, и он возвращает возвращаемое значение функции как объект указанного типа, что означает, что вы делаете не нужно получать возвращаемое значение из карты результатов.\nПодобный удобный метод (с именем «executeObject») также доступен для хранимых процедур, имеющих только один «выход». параметр.\nСледующий пример (для MySQL) основан на хранимой функции с именем get_actor_name. который возвращает полное имя актера:\n	СОЗДАТЬ ФУНКЦИЮ get_actor_name (in_id INTEGER)\n	ВОЗВРАЩАЕТ VARCHAR(200) ЧИТАЕТ ДАННЫЕ SQL\n	BEGIN\n		DECLARE out_name VARCHAR(200);\n		SELECT concat(first_name, ' ', Last_name)\n			INTO out_name\n			FROM t_actor where id = in_id;\n		RETURN out_name;\n	END;\nВызов хранимой функции с помощью SimpleJdbcCall.\nЧтобы вызвать эту функцию, мы снова создаем SimpleJdbcCall в методе инициализации: как показано в следующем примере:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcCall funcGetActorName;\n		public void setDataSource(DataSource dataSource) {"}
{"id": 992, "text": "JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n			jdbcTemplate.setResultsMapCaseInsensitive(true);\n			this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)\n					.withFunctionName(\"get_actor_name\");\n		public String getActorName(Long id) {\n			SqlParameterSource in = new MapSqlParameterSource()\n					.addValue(\"in_id\", id);\n			String name = funcGetActorName.executeFunction(String.class, in);\n			return name;\n		// ... дополнительные методы\nВызов хранимой функции с помощью SimpleJdbcCall.\nИспользуемый метод `executeFunction` возвращает `String`, содержащую возвращаемое значение из вызов функции.\nВозврат курсора ResultSet или REF из SimpleJdbcCall.\nВызов хранимой процедуры или функции, возвращающей набор результатов, немного сложнее.\nНекоторые базы данных возвращают наборы результатов во время обработки результатов JDBC, в то время как другие требуют явно зарегистрированный параметр `out` определенного типа.\nОба подхода требуют дополнительная обработка для перебора результирующего набора и обработки возвращенных строк.\nС SimpleJdbcCall, вы можете использовать метод returnResultSet и объявить RowMapper. реализация, которая будет использоваться для определенного параметра.\nЕсли набор результатов возвращаемые во время обработки результатов, имена не определены, поэтому возвращаемые результаты должны соответствовать порядку, в котором вы объявляете RowMapper. реализации.\nУказанное имя по-прежнему используется для хранения обработанного списка результатов. в карте результатов, возвращаемой оператором выполнения.\nВозврат курсора ResultSet или REF из SimpleJdbcCall."}
{"id": 993, "text": "В следующем примере (для MySQL) используется хранимая процедура, которая не принимает параметров IN и возвращает все строки из таблицы t_actor:\n	CREATE PROCEDURE read_all_actors()\n	BEGIN\n	 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;\n	END;\nВозврат курсора ResultSet или REF из SimpleJdbcCall.\nЧтобы вызвать эту процедуру, вы можете объявить RowMapper.\nПотому что класс, в который ты хочешь чтобы сопоставление соответствовало правилам JavaBean, вы можете использовать BeanPropertyRowMapper, созданный передача требуемого класса для сопоставления в методе newInstance.\nВ следующем примере показано, как это сделать:\nJava\n	public class JdbcActorDao implements ActorDao {\n		private SimpleJdbcCall procReadAllActors;\n		public void setDataSource(DataSource dataSource) {\n			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n			jdbcTemplate.setResultsMapCaseInsensitive(true);\n			this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)\n					.withProcedureName(\"read_all_actors\")\n					.returningResultSet(\"actors\",\n					BeanPropertyRowMapper.newInstance(Actor.class));\n		public List getActorsList() {\n			Map m = procReadAllActors.execute(new HashMap<String, Object>(0));\n			return (List) m.get(\"actors\");\n		// ... дополнительные методы\nВозврат курсора ResultSet или REF из SimpleJdbcCall.\nВызов «execute» передает пустую «Map», поскольку этот вызов не принимает никаких параметров.\nСписок актеров затем извлекается из карты результатов и возвращается вызывающей стороне."}
{"id": 994, "text": "Решения распространенных проблем.\nВ этом разделе описаны решения некоторых распространенных проблем.\nИспользование неправильного менеджера транзакций для определенного «источника данных».\nИспользуйте правильную реализацию PlatformTransactionManager на основе вашего выбора. транзакционные технологии и требования.\nПри правильном использовании Spring Framework просто обеспечивает простую и переносимую абстракцию.\nЕсли вы используете глобальный транзакции, вы должны использовать Класс `org.springframework.transaction.jta.JtaTransactionManager` (или it) для всех ваших транзакционных операций.\nВ противном случае инфраструктура транзакций пытается выполнить локальные транзакции с такими ресурсами, как контейнер DataSource. экземпляры.\nТакие локальные транзакции не имеют смысла, а хороший сервер приложений воспринимает их как ошибки."}
{"id": 995, "text": "Использование стандартных аннотаций JSR-330.\nSpring предлагает поддержку стандартных аннотаций _Dependency Injection_ JSR-330, которые доступен в пакете `jakarta.inject`.\nЭти аннотации могут опционально использоваться как альтернативы аннотациям Spring.\nИспользование стандартных аннотаций JSR-330.\nЧтобы использовать их, вам необходимо иметь соответствующий jar в вашем пути к классам.\nНапример, Артефакт `jakarta.inject` доступен в стандартном репозитории Maven. (`https://repo.maven.apache.org/maven2/jakarta/inject/jakarta.inject-api/2.0.0/`),\nИспользование стандартных аннотаций JSR-330. [ПРИМЕЧАНИЕ] = Если вы используете Maven, вы можете добавить следующую зависимость в файл pom.xml.\n	<dependency>\n		<groupId>jakarta.inject</groupId>\n		<artifactId>jakarta.inject-api</artifactId>\n		<version>2.0.0</version>\n	</dependency>\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nВместо использования `@Autowired` для внедрения зависимостей вы можете при желании использовать `@jakarta.inject.Inject` следующим образом.\nJava\n	import jakarta.inject.Inject;\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Inject\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n		public void listMovies() {"}
{"id": 996, "text": "this.movieFinder.findMovies(...);\n	class SimpleMovieLister {\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nКак и в случае с `@Autowired`, вы можете использовать `@Inject` на уровне поля, уровне метода и уровень аргументов конструктора.\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nБолее того, в качестве альтернативы механизму Spring ObjectProvider вы можете выбрать объявите свою точку инъекции как `jakarta.inject.Provider`, что позволит выполнять ее по требованию. доступ к компонентам более короткой области действия или ленивый доступ к другим компонентам через Вызов Provider.get().\nСледующий пример предлагает вариант предыдущего примера.\nJava\n	import jakarta.inject.Inject;\n	import jakarta.inject.Provider;\n	public class SimpleMovieLister {\n		private Provider<MovieFinder> movieFinder;\n		@Inject\n		public void setMovieFinder(Provider<MovieFinder> movieFinder) {\n			this.movieFinder = movieFinder;\n		public void listMovies() {\n			this.movieFinder.get().findMovies(...);\n	class SimpleMovieLister {\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nЕсли вы хотите использовать полное имя для зависимости, которую следует внедрить, вы может использовать аннотацию `@Named` в качестве альтернативы Spring `@Qualifier` поддержку, как показано в следующем примере.\nJava\n	import jakarta.inject.Inject;"}
{"id": 997, "text": "import jakarta.inject.Named;\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Inject\n		public void setMovieFinder(@Named(\"main\") MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n	class SimpleMovieLister {\n	import jakarta.inject.Inject;\n	import java.util.Optional;\n	public class SimpleMovieLister {\n		@Inject\n		public void setMovieFinder(Optional<MovieFinder> movieFinder) {\nJava\n	import jakarta.inject.Inject;\n	import org.jspecify.annotations.Nullable;\n	public class SimpleMovieLister {\n		@Inject\n		public void setMovieFinder(@Nullable MovieFinder movieFinder) {\n	class SimpleMovieLister {\nВнедрение зависимостей с помощью `@Inject` и `@Named`. `@Named`: стандартный эквивалент аннотации `@Component`.\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nВместо `@Component` или других стереотипных аннотаций Spring вы можете при желании выбрать использовать `@jakarta.inject.Named`, как показано в следующем примере.\nJava\n	import jakarta.inject.Inject;\n	import jakarta.inject.Named;\n	@Named(\"movieListener\")\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Inject\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n	@Named(\"movieListener\")\n	class SimpleMovieLister {\nВнедрение зависимостей с помощью `@Inject` и `@Named`."}
{"id": 998, "text": "Очень часто используется `@Component` или другие аннотации стереотипов Spring без указав явное имя для компонента, а `@Named` можно использовать в аналогичном мода, как показывает следующий пример.\nJava\n	import jakarta.inject.Inject;\n	import jakarta.inject.Named;\n	@Named\n	public class SimpleMovieLister {\n		private MovieFinder movieFinder;\n		@Inject\n		public void setMovieFinder(MovieFinder movieFinder) {\n			this.movieFinder = movieFinder;\n	@Named\n	class SimpleMovieLister {\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nКогда вы используете `@Named`, вы можете использовать сканирование компонентов точно так же, как и при используйте аннотации Spring, как показано в следующем примере.\nJava\n	@Configuration\n	@ComponentScan(basePackages = \"org.example\")\n	public class AppConfig  {\n	@Configuration\n	@ComponentScan(basePackages = [\"org.example\"])\n	class AppConfig  {\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nПРИМЕЧАНИЕ.\nВ отличие от @Component, аннотация JSR-330 @Named не является компонуемой. ты следует использовать стереотипную модель Spring для создания аннотаций пользовательских компонентов."}
{"id": 999, "text": "Внедрение зависимостей с помощью `@Inject` и `@Named`. [СОВЕТ] = Если вы работаете с устаревшими системами, которые все еще используют `@javax.inject.Named` или `@javax.annotation.ManagedBean` для компонентов (обратите внимание на пространство имен пакета `javax`), вы можно явно настроить сканирование компонентов для включения этих типов аннотаций, как показано в следующем примере.\nJava\n	@Configuration\n	@ComponentScan(\n		basePackages = \"org.example\",\n		includeFilters = @Filter({\n			javax.inject.Named.class,\n			javax.annotation.ManagedBean.class\n	public class AppConfig  {\nВнедрение зависимостей с помощью `@Inject` и `@Named`.\nКроме того, если вы хотите, чтобы атрибуты `value` в `@javax.inject.Named` и `@javax.annotation.ManagedBean` для использования в качестве имен компонентов, вам необходимо переопределить `isStereotypeWithNameValue(...)` в `AnnotationBeanNameGenerator` для добавления явного поддержку javax.annotation.ManagedBean и javax.inject.Named и зарегистрируйте свой пользовательский AnnotationBeanNameGenerator через атрибут nameGenerator в `@ComponentScan`.\nОграничения стандартных аннотаций JSR-330.\nКогда вы работаете со стандартными аннотациями JSR-330, вы должны знать, что некоторые важные функции недоступны, как показано в следующей таблице.\nОграничения стандартных аннотаций JSR-330."}
{"id": 1000, "text": "Модель компонента Spring в сравнении с вариантами JSR-330 |=== | Весна | JSR-330 | Ограничения/комментарии JSR-330\nОграничения стандартных аннотаций JSR-330. | `@Autowired` | `@Инжект` | `@Inject` не имеет атрибута `required`.\nВместо этого можно использовать с Java `Optional`.\nОграничения стандартных аннотаций JSR-330. | `@Компонент` | `@Named` | JSR-330 не предоставляет составную модель, а только способ идентифицировать именованные компоненты.\nОграничения стандартных аннотаций JSR-330. | `@Scope(\"одиночка\")` | `@Синглтон` | Область действия по умолчанию JSR-330 похожа на «прототип» Spring.\nОднако, чтобы сохранить его в соответствии с общими настройками Spring по умолчанию, компонент JSR-330, объявленный в Spring контейнер по умолчанию является синглтоном.\nЧтобы использовать область действия, отличную от «singleton», вам следует использовать аннотацию Spring `@Scope`. `jakarta.inject` также предоставляет аннотация `jakarta.inject.Scope`; однако этот предназначен только для использования для создания пользовательских аннотаций.\nОграничения стандартных аннотаций JSR-330. | `@Квалификатор` | `@Qualifier` / `@Named` | `jakarta.inject.Qualifier` — это просто метааннотация для создания пользовательских квалификаторов."}
{"id": 1001, "text": "Могут быть связаны конкретные квалификаторы `String` (например, `@Qualifier` Spring со значением). через `jakarta.inject.Named`.\n| `@Ленивый` | - | нет эквивалента. | `ОбъектФабрика` | `Провайдер` | `jakarta.inject.Provider` является прямой альтернативой Spring `ObjectFactory`, только с более коротким именем метода get().\nЕго также можно использовать в сочетании с Spring `@Autowired` или с неаннотированными конструкторами и методами установки. |==="}
{"id": 1002, "text": "Статические ресурсы.\nЭта опция обеспечивает удобный способ обслуживания статических ресурсов из списка Местоположение на основе {spring-framework-api}/core/io/Resource.html[`Resource`].\nСтатические ресурсы.\nВ следующем примере для запроса, начинающегося с `/resources`, относительный путь будет равен используется для поиска и обслуживания статических ресурсов относительно `/public` в веб-приложении root или в пути к классам в `/static`.\nРесурсы предоставляются с перспективой на один год. истечения срока действия, чтобы обеспечить максимальное использование кэша браузера и сокращение количества HTTP-запросов. сделанный браузером.\nИнформация Last-Modified выводится из Resource#lastModified. так что условные запросы HTTP поддерживаются заголовками Last-Modified.\nСтатические ресурсы.\nВ следующем листинге показано, как это сделать: См. пример кода в исходном документе.\nСм. также.\nОбработчик ресурсов также поддерживает цепочку реализации {spring-framework-api}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`] и реализации {spring-framework-api}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`], который вы можете использовать для создания набора инструментов для работы с оптимизированными ресурсами.\nСм. также.\nВы можете использовать VersionResourceResolver для URL-адресов ресурсов с поддержкой версий на основе хеша MD5. вычисляется на основе контента, фиксированной версии приложения или чего-то еще."}
{"id": 1003, "text": "А `ContentVersionStrategy` (хэш MD5) — хороший выбор, за некоторыми заметными исключениями, такими как Ресурсы JavaScript, используемые с загрузчиком модулей.\nСм. также.\nВ следующем примере показано, как использовать VersionResourceResolver: См. пример кода в исходном документе.\nСм. также.\nЗатем вы можете использовать ResourceUrlProvider, чтобы перезаписать URL-адреса и применить полную цепочку преобразователей и преобразователи — например, для вставки версий.\nКонфигурация MVC предоставляет ResourceUrlProvider. bean, чтобы его можно было внедрить другим.\nВы также можете сделать перезапись прозрачной с помощью `ResourceUrlEncodingFilter` для Thymeleaf, JSP, FreeMarker и других с тегами URL, которые полагайтесь на HttpServletResponse#encodeURL.\nСм. также.\nОбратите внимание, что при использовании обоих EncodedResourceResolver (например, для ресурсы в кодировке brotli) и `VersionResourceResolver`, вы должны зарегистрировать их в этом порядке.\nЭто гарантирует, что версии на основе содержимого всегда надежно вычисляются на основе незакодированного файла.\nСм. также.\nДля https://www.webjars.org/documentation[WebJars] URL-адреса с версиями, например `/webjars/jquery/1.2.0/jquery.min.js` — рекомендуемый и наиболее эффективный способ их использования."}
{"id": 1004, "text": "Местоположение связанного ресурса настраивается «из коробки» с помощью Spring Boot (или может быть настроено вручную через `ResourceHandlerRegistry`) и не требует добавления Зависимость `org.webjars:webjars-locator-lite`.\nСм. также.\nURL-адреса без версий, такие как `/webjars/jquery/jquery.min.js`, поддерживаются через `WebJarsResourceResolver`, который автоматически регистрируется при Библиотека `org.webjars:webjars-locator-lite` присутствует в пути к классам.\nРезолвер может перезаписать URL-адреса, включающие версию jar, а также могут сопоставляться с входящими URL-адресами без версий. -- например, с `/webjars/jquery/jquery.min.js` на `/webjars/jquery/1.2.0/jquery.min.js`.\nСм. также.\nСОВЕТ: Конфигурация Java, основанная на ResourceHandlerRegistry, предоставляет дополнительные возможности. для детального контроля, например, поведения последнего изменения и оптимизированного разрешения ресурсов."}
{"id": 1005, "text": "ТОПАТЬ.\nПротокол WebSocket определяет два типа сообщений (текстовые и двоичные), но их содержание не определено.\nПротокол определяет механизм для клиента и сервера для согласования подпротокол (то есть протокол обмена сообщениями более высокого уровня), который можно использовать поверх WebSocket для определить, какие сообщения каждый может отправлять, каков формат и содержание каждого сообщение и так далее.\nИспользование подпротокола не является обязательным, но в любом случае клиент и серверу необходимо согласовать некоторый протокол, определяющий содержимое сообщения."}
{"id": 1006, "text": "Понимание абстракции транзакций Spring Framework.\nКлючом к абстракции транзакций Spring является понятие стратегии транзакций.\nА стратегия транзакции определяется TransactionManager, в частности Интерфейс `org.springframework.transaction.PlatformTransactionManager` для императива управление транзакциями и Интерфейс `org.springframework.transaction.ReactiveTransactionManager` для реактивного управление транзакциями.\nВ следующем листинге показано определение API «PlatformTransactionManager»:\n	public interface PlatformTransactionManager extends TransactionManager {\n		TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n		void commit(TransactionStatus status) throws TransactionException;\n		void rollback(TransactionStatus status) throws TransactionException;\nПонимание абстракции транзакций Spring Framework.\nВ первую очередь это интерфейс поставщика услуг (SPI), хотя вы можете использовать и его. «PlatformTransactionManager» — это интерфейс, его можно легко имитировать или заглушить как необходимо.\nОн не привязан к стратегии поиска, такой как JNDI.\nРеализации PlatformTransactionManager определяются как любой другой объект (или bean-компонент). в IoC-контейнере Spring Framework.\nУже одно это преимущество делает Spring Framework транзакции — достойная абстракция, даже если вы работаете с JTA.\nВы можете протестировать транзакционный код гораздо проще, чем если бы он напрямую использовал JTA.\nПонимание абстракции транзакций Spring Framework.\nОпять же, в соответствии с философией Spring, исключение TransactionException, которое может быть выброшено любым из методов интерфейса PlatformTransactionManager снят флажок (этот то есть он расширяет класс `java.lang.RuntimeException`).\nТранзакционная инфраструктура неудачи почти всегда фатальны."}
{"id": 1007, "text": "В редких случаях, когда код приложения действительно может восстановиться после сбоя транзакции, разработчик приложения все равно может перехватить и обработать TransactionException.\nВажным моментом является то, что разработчики не _вынужден_ сделать это.\nПонимание абстракции транзакций Spring Framework.\nМетод getTransaction(..) возвращает объект TransactionStatus, в зависимости от Параметр TransactionDefinition.\nВозвращенный `TransactionStatus` может представлять собой новая транзакция или может представлять существующую транзакцию, если соответствующая транзакция существует в текущем стеке вызовов.\nВ последнем случае подразумевается, что, как и в случае с В контексте транзакций Jakarta EE TransactionStatus связан с потоком исполнение.\n	public interface ReactiveTransactionManager extends TransactionManager {\n		Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n		Mono<Void> commit(ReactiveTransaction status) throws TransactionException;\n		Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;\nПонимание абстракции транзакций Spring Framework.\nМенеджер реактивных транзакций — это прежде всего интерфейс поставщика услуг (SPI). хотя вы можете использовать его программно из своего код приложения.\nПоскольку `ReactiveTransactionManager` — это интерфейс, его можно легко высмеивали или затыкали по мере необходимости.\n* Распространение. Обычно весь код в области транзакции выполняется в\nИнтерфейс TransactionDefinition определяет:. эта транзакция.\nОднако вы можете указать поведение, если транзакционный метод запускается, когда контекст транзакции уже существует.\nДля Например, код может продолжать работу в существующей транзакции (обычный случай) или существующую транзакцию можно приостановить и создать новую транзакцию."}
{"id": 1008, "text": "Весна предлагает все варианты распространения транзакций, знакомые по EJB CMT.\nЧитать о семантике распространения транзакций в Spring см.\nРаспространение транзакций.\n* Изоляция: степень, в которой эта транзакция изолирована от работы других\nИнтерфейс TransactionDefinition определяет:. транзакции.\nНапример, может ли эта транзакция видеть незафиксированные записи от других транзакции?\n* Тайм-аут: как долго выполняется эта транзакция до истечения времени ожидания и автоматического отката.\nИнтерфейс TransactionDefinition определяет:. базовой инфраструктурой транзакций.\n* Статус «только для чтения». Вы можете использовать транзакцию только для чтения, если ваш код читается, но\nИнтерфейс TransactionDefinition определяет:. не изменяет данные.\nТранзакции только для чтения могут быть полезной оптимизацией в некоторых случаях. случаях, например, когда вы используете Hibernate.\nИнтерфейс TransactionDefinition определяет:.\nЭти настройки отражают стандартные концепции транзакций.\nПри необходимости обратитесь к ресурсам в которых обсуждаются уровни изоляции транзакций и другие основные концепции транзакций.\nПонимание этих концепций необходимо для использования Spring Framework или любого другого решение для управления транзакциями.\nИнтерфейс TransactionDefinition определяет:.\nИнтерфейс TransactionStatus предоставляет простой способ транзакционному коду контролировать выполнение транзакции и запрашивать статус транзакции.\nКонцепции должны быть знакомы, поскольку они являются общими для всех API транзакций.\nВ следующем листинге показаны Интерфейс `TransactionStatus`:\n	public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {\n		@Override\n		boolean isNewTransaction();\n		boolean hasSavepoint();\n		@Override\n		void setRollbackOnly();\n		@Override\n		boolean isRollbackOnly();"}
{"id": 1009, "text": "void flush();\n		@Override\n		boolean isCompleted();\nИнтерфейс TransactionDefinition определяет:.\nНезависимо от того, выбираете ли вы декларативное или программное управление транзакциями в Spring, определение правильной реализации TransactionManager абсолютно необходимо.\nОбычно вы определяете эту реализацию посредством внедрения зависимостей.\nИнтерфейс TransactionDefinition определяет:.\nРеализации TransactionManager обычно требуют знания среды в на которых они работают: JDBC, JTA, Hibernate и так далее.\nСледующие примеры показывают, как вы можете определить локальную реализацию PlatformTransactionManager (в данном случае с помощью простого JDBC.)\n	<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n		<property name=\"driverClassName\" value=\"${jdbc.driverClassName}\" />\n		<property name=\"url\" value=\"${jdbc.url}\" />\n		<property name=\"username\" value=\"${jdbc.username}\" />\n		<property name=\"password\" value=\"${jdbc.password}\" />\n	</bean>\nВы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.\nСоответствующее определение bean-компонента PlatformTransactionManager затем содержит ссылку на Определение `Источника данных`.\nЭто должно напоминать следующий пример:"}
{"id": 1010, "text": "<bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"/>\n	</bean>\nВы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.\nЕсли вы используете JTA в контейнере Jakarta EE, вы используете контейнер DataSource, полученный через JNDI в сочетании с Spring JtaTransactionManager.\nСледующий пример показывает, как будет выглядеть версия поиска JTA и JNDI:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:jee=\"http://www.springframework.org/schema/jee\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/jee\n			https://www.springframework.org/schema/jee/spring-jee.xsd\">"}
{"id": 1011, "text": "<jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/jpetstore\"/>\n		<bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\" />\n		<!-- other <bean/> definitions here -->\n	</beans>\nВы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:. `JtaTransactionManager` не обязательно должен знать об `DataSource` (или любом другом определенные ресурсы), поскольку он использует глобальное управление транзакциями контейнера. инфраструктура.\nВы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.\nПРИМЕЧАНИЕ.\nВ предыдущем определении bean-компонента `dataSource` используется тег `<jndi-lookup/>`. из пространства имен `jee`.\nДля получения дополнительной информации см.\nВы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:.\nПРИМЕЧАНИЕ.\nЕсли вы используете JTA, определение вашего менеджера транзакций должно выглядеть одинаково, независимо от какую технологию доступа к данным вы используете, будь то JDBC, Hibernate JPA или любая другая поддерживаемая технология.\nЭто связано с тем, что транзакции JTA являются глобальными транзакциями, которые может подключить любой транзакционный ресурс.\nВы можете определить JDBC `DataSource`, создав bean-компонент, подобный следующему:."}
{"id": 1012, "text": "Во всех настройках транзакций Spring код приложения изменять не нужно.\nВы можете изменить как транзакции управляются простым изменением конфигурации, даже если это изменение означает переход от локальных транзакций к глобальным и наоборот.\nНастройка транзакции в спящем режиме.\nВы также можете легко использовать локальные транзакции Hibernate, как показано в следующих примерах.\nВ этом случае вам необходимо определить Hibernate `LocalSessionFactoryBean`, который будет код приложения можно использовать для получения экземпляров сеанса Hibernate.\nНастройка транзакции в спящем режиме.\nОпределение bean-компонента DataSource похоже на локальный пример JDBC, показанный ранее. и, таким образом, не показано в следующем примере.\nНастройка транзакции в спящем режиме.\nПРИМЕЧАНИЕ.\nЕсли `DataSource` (используемый любым менеджером транзакций, отличным от JTA) просматривается через JNDI и управляемый контейнером Jakarta EE, он должен быть нетранзакционным, поскольку Spring Framework (а не контейнер Jakarta EE) управляет транзакциями.\nНастройка транзакции в спящем режиме.\nКомпонент `txManager` в этом случае имеет тип `HibernateTransactionManager`.\nВ так же, как DataSourceTransactionManager нуждается в ссылке на DataSource, HibernateTransactionManager нуждается в ссылке на SessionFactory.\nСледующие пример объявляет bean-компоненты `sessionFactory` и `txManager`:\n	<bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n		<property name=\"dataSource\" ref=\"dataSource\"/>\n		<property name=\"mappingResources\">\n			<list>"}
{"id": 1013, "text": "<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>\n			</list>\n		</property>\n		<property name=\"hibernateProperties\">\n			<value>\n				hibernate.dialect=${hibernate.dialect}\n			</value>\n		</property>\n	</bean>\n	<bean id=\"txManager\" class=\"org.springframework.orm.jpa.hibernate.HibernateTransactionManager\">\n		<property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n	</bean>\nНастройка транзакции в спящем режиме.\nЕсли вы используете транзакции JTA, управляемые контейнером Hibernate и Jakarta EE, вам следует использовать тот же `JtaTransactionManager`, что и в предыдущем примере JTA для JDBC, а именно: пример показывает.\nКроме того, рекомендуется информировать Hibernate о JTA через его координатор транзакций и, возможно, также конфигурация режима освобождения соединения:\n	<bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n		<property name=\"dataSource\" ref=\"dataSource\"/>\n		<property name=\"mappingResources\">\n			<list>\n				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>\n			</list>\n		</property>\n		<property name=\"hibernateProperties\">\n			<value>"}
{"id": 1014, "text": "hibernate.dialect=${hibernate.dialect}\n				hibernate.transaction.coordinator_class=jta\n				hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT\n			</value>\n		</property>\n	</bean>\n	<bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/>\nНастройка транзакции в спящем режиме.\nИли, альтернативно, вы можете передать JtaTransactionManager в свой LocalSessionFactoryBean. для обеспечения соблюдения тех же значений по умолчанию:\n	<bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n		<property name=\"dataSource\" ref=\"dataSource\"/>\n		<property name=\"mappingResources\">\n			<list>\n				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>\n			</list>\n		</property>\n		<property name=\"hibernateProperties\">\n			<value>\n				hibernate.dialect=${hibernate.dialect}\n			</value>\n		</property>\n		<property name=\"jtaTransactionManager\" ref=\"txManager\"/>\n	</bean>\n	<bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/>"}
{"id": 1015, "text": "Использование реализаций TargetSource.\nSpring предлагает концепцию TargetSource, выраженную в Интерфейс `org.springframework.aop.TargetSource`.\nЭтот интерфейс отвечает за возвращение «целевого объекта», реализующего точку соединения. «Целевой источник» реализация запрашивает целевой экземпляр каждый раз, когда прокси-сервер AOP обрабатывает метод призыв.\nИспользование реализаций TargetSource.\nРазработчикам, использующим Spring AOP, обычно не требуется работать напрямую с реализациями TargetSource, но это обеспечивает мощные средства поддержки пула, горячей замены и других сложные цели.\nНапример, объединение TargetSource может возвращать другую цель. экземпляр для каждого вызова, используя пул для управления экземплярами.\nИспользование реализаций TargetSource.\nЕсли вы не укажете TargetSource, для переноса будет использоваться реализация по умолчанию. локальный объект.\nОдна и та же цель возвращается для каждого вызова (как и следовало ожидать).\nИспользование реализаций TargetSource.\nОставшаяся часть этого раздела описывает стандартные целевые источники, поставляемые с Spring, и способы их использования.\nИспользование реализаций TargetSource.\nСОВЕТ: При использовании пользовательского целевого источника вашей целью обычно должен быть прототип. а не определение одноэлементного компонента.\nЭто позволяет Spring создать новую цель экземпляр, когда это необходимо.\nЦелевые источники с возможностью горячей замены. `org.springframework.aop.target.HotSwappableTargetSource` существует, чтобы позволить цели прокси-сервера AOP, позволяя вызывающим абонентам сохранять свои ссылки на него.\nЦелевые источники с возможностью горячей замены.\nИзменение цели целевого источника вступает в силу немедленно."}
{"id": 1016, "text": "HotSwappableTargetSource является потокобезопасным.\nЦелевые источники с возможностью горячей замены.\nВы можете изменить цель, используя метод swap() в HotSwappableTargetSource, как показано в следующем примере:\nJava\n	HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(\"swapper\");\n	Object oldTarget = swapper.swap(newTarget);\n	<bean id=\"initialTarget\" class=\"mycompany.OldTarget\"/>\n	<bean id=\"swapper\" class=\"org.springframework.aop.target.HotSwappableTargetSource\">\n		<constructor-arg ref=\"initialTarget\"/>\n	</bean>\n	<bean id=\"swappable\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n		<property name=\"targetSource\" ref=\"swapper\"/>\n	</bean>\nВ следующем примере показаны необходимые определения XML:.\nПредыдущий вызов swap() изменяет цель заменяемого компонента.\nКлиенты, имеющие ссылка на этот компонент не знает об изменении, но сразу же начинает нажимать новая цель.\nВ следующем примере показаны необходимые определения XML:.\nХотя этот пример не добавляет никаких советов (нет необходимости добавлять советы к используйте TargetSource), любой TargetSource можно использовать в сочетании с произвольный совет.\nОбъединение целевых источников.\nИспользование целевого источника пула обеспечивает модель программирования, аналогичную сеансу без сохранения состояния.\nEJB, в которых поддерживается пул идентичных экземпляров с вызовами методов. собираюсь освободить объекты в бассейне."}
{"id": 1017, "text": "Объединение целевых источников.\nПринципиальное различие между пулом Spring и пулом SLSB заключается в том, что пул Spring может применяться к любому POJO.\nКак и в случае со Spring в целом, этот сервис можно применять в неинвазивный способ.\nОбъединение целевых источников.\nSpring обеспечивает поддержку Commons Pool 2, который обеспечивает довольно эффективная реализация пула.\nВам понадобится Jar `commons-pool` на вашем путь к классам приложения, чтобы использовать эту функцию.\nВы также можете создать подкласс `org.springframework.aop.target.AbstractPoolingTargetSource` для поддержки любых других пул API.\n	<bean id=\"businessObjectTarget\" class=\"com.mycompany.MyBusinessObject\"\n			scope=\"prototype\">\n		... properties omitted\n	</bean>\n	<bean id=\"poolTargetSource\" class=\"org.springframework.aop.target.CommonsPool2TargetSource\">\n		<property name=\"targetBeanName\" value=\"businessObjectTarget\"/>\n		<property name=\"maxSize\" value=\"25\"/>\n	</bean>\n	<bean id=\"businessObject\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n		<property name=\"targetSource\" ref=\"poolTargetSource\"/>\n		<property name=\"interceptorNames\" value=\"myInterceptor\"/>\n	</bean>\nВ следующем листинге показан пример конфигурации:."}
{"id": 1018, "text": "Обратите внимание, что целевой объект (businessObjectTarget в предыдущем примере) должен быть прототип.\nЭто позволяет реализации PoolingTargetSource создавать новые экземпляры. цели для увеличения пула по мере необходимости.\nСм. {spring-framework-api}/aop/target/AbstractPoolingTargetSource.html[javadoc of `AbstractPoolingTargetSource`] и конкретный подкласс, который вы хотите использовать для информации. о его свойствах. `maxSize` является самым простым и всегда гарантированно присутствует.\nВ следующем листинге показан пример конфигурации:.\nВ данном случае `myInterceptor` — это имя перехватчика, который необходимо определены в том же контексте IoC.\nОднако вам не нужно указывать перехватчики для использовать пул.\nЕсли вам нужно только объединение и никаких других советов, не устанавливайте `interceptorNames` вообще.\nВ следующем листинге показан пример конфигурации:.\nВы можете настроить Spring так, чтобы он мог приводить любой объект из пула к Интерфейс `org.springframework.aop.target.PoolingConfig`, который предоставляет информацию о конфигурации и текущем размере пула во введении. ты необходимо определить советника, подобного следующему:\n	<bean id=\"poolConfigAdvisor\" class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\">\n		<property name=\"targetObject\" ref=\"poolTargetSource\"/>\n		<property name=\"targetMethod\" value=\"getPoolingConfigMixin\"/>\n	</bean>\nВ следующем листинге показан пример конфигурации:."}
{"id": 1019, "text": "Этот советник получается вызовом удобного метода на Класс AbstractPoolingTargetSource, отсюда и использование MethodInvokingFactoryBean.\nЭто имя советника (здесь `poolConfigAdvisor`) должно быть в списке имен перехватчиков в `ProxyFactoryBean`, который предоставляет объединенный объект.\nJava\n	PoolingConfig conf = (PoolingConfig) beanFactory.getBean(\"businessObject\");\n	System.out.println(\"Max pool size is \" + conf.getMaxSize());\nАктерский состав определен следующим образом:.\nПРИМЕЧАНИЕ.\nОбъединение объектов службы без сохранения состояния в пул обычно не требуется.\nМы не считаем, что это должно быть выбором по умолчанию, поскольку большинство объектов без состояния, естественно, потокобезопасны, и экземпляр объединение в пул проблематично, если ресурсы кэшируются.\nАктерский состав определен следующим образом:.\nБолее простой пул доступен при использовании автоматического проксирования.\nВы можете установить реализации TargetSource. используется любым создателем автоматических прокси.\nЦелевые источники прототипов.\nНастройка целевого источника «прототипа» аналогична настройке пула «TargetSource».\nВ этом В этом случае новый экземпляр цели создается при каждом вызове метода.\nХотя стоимость создания нового объекта в современной JVM невелика, стоимость подключения новый объект (удовлетворяющий его зависимости IoC) может оказаться дороже.\nТаким образом, вам не следует используйте этот подход без очень веской причины.\nЦелевые источники прототипов.\nДля этого вы можете изменить определение `poolTargetSource`, показанное ранее, следующим образом: (мы также изменили название, для ясности):"}
{"id": 1020, "text": "<bean id=\"prototypeTargetSource\" class=\"org.springframework.aop.target.PrototypeTargetSource\">\n		<property name=\"targetBeanName\" ref=\"businessObjectTarget\"/>\n	</bean>\nЦелевые источники прототипов.\nЕдинственное свойство — это имя целевого компонента.\nНаследование используется в Реализации TargetSource для обеспечения согласованного именования.\nКак и в случае с целью объединения исходный код, целевой компонент должен быть определением прототипа компонента.\nЦелевые источники `ThreadLocal` полезны, если вам нужно создать объект для каждого входящий запрос (то есть для каждого потока).\nКонцепция ThreadLocal обеспечивает общедоступный JDK возможность прозрачного хранения ресурса рядом с потоком.\nНастройка `ThreadLocalTargetSource` практически такой же, как объяснялось для других типов. целевого источника, как показано в следующем примере:\n	<bean id=\"threadlocalTargetSource\" class=\"org.springframework.aop.target.ThreadLocalTargetSource\">\n		<property name=\"targetBeanName\" value=\"businessObjectTarget\"/>\n	</bean>\nЦелевые источники `ThreadLocal`.\nПРИМЕЧАНИЕ.\nЭкземпляры `ThreadLocal` вызывают серьезные проблемы (потенциально приводящие к утечкам памяти), когда неправильное использование их в многопоточных средах и средах с несколькими загрузчиками классов. ты всегда следует рассматривать возможность переноса ThreadLocal в какой-либо другой класс и никогда не использовать напрямую сам `ThreadLocal` (кроме класса-оболочки)."}
{"id": 1021, "text": "Кроме того, вам следует всегда не забывайте правильно устанавливать и снимать с охраны (если последнее предполагает вызов `ThreadLocal.remove()`) — локальный ресурс потока.\nСнятие с охраны должно производиться в в любом случае, поскольку если не отключить настройку, это может привести к проблемному поведению.\nВесна Поддержка `ThreadLocal` сделает это за вас, и ее всегда следует рассматривать в пользу использования Экземпляры `ThreadLocal` без другого надлежащего кода обработки."}
{"id": 1022, "text": "Шаблоны выражений позволяют смешивать буквальный текст с одним или несколькими блоками оценки.\nКаждый блок оценки ограничен префиксными и суффиксными символами, которые вы можете определить.\nРаспространенным выбором является использование `+#{ }+` в качестве разделителей, как показано в следующем примере. показывает:\nJava\n	String randomPhrase = parser.parseExpression(\n			\"random number is #{T(java.lang.Math).random()}\",\n			new TemplateParserContext()).getValue(String.class);\n	// оценивается как «случайное число 0,7038186818312008»\nШаблоны выражений.\nСтрока оценивается путем объединения буквального текста `'случайное число'` с результат вычисления выражения внутри разделителей `+#{ }+` (в данном случае результат вызова этого метода `random()`).\nВторой аргумент функции parseExpression(). метод имеет тип ParserContext.\nИнтерфейс ParserContext используется для влияния как выражение анализируется для поддержки функций шаблонов выражений. `TemplateParserContext`, использованный в предыдущем примере, находится в `org.springframework.expression.common` и является реализацией `ParserContext`, который по умолчанию настраивает префикс и суффикс на `#{` и `}`, соответственно."}
{"id": 1023, "text": "Управление транзакциями.\nКомплексная поддержка транзакций — одна из наиболее веских причин использовать Spring.\nРамки.\nSpring Framework обеспечивает последовательную абстракцию для транзакций. управление, которое обеспечивает следующие преимущества:\n* Согласованная модель программирования для различных API транзакций, таких как Java.\nУправление транзакциями.\nAPI транзакций (JTA), JDBC, Hibernate и API сохранения Java (JPA).\n* Поддержка декларативного управления транзакциями.\n* Более простой API для управления транзакциями.\nУправление транзакциями. чем сложные API транзакций, такие как JTA.\n* Отличная интеграция с абстракциями доступа к данным Spring.\n* Преимущества модели поддержки транзакций Spring Framework\nВ следующих разделах описываются функции и технологии транзакций Spring Framework:. описывает, почему вам следует использовать абстракцию транзакций Spring Framework вместо EJB.\nТранзакции, управляемые контейнером (CMT), или выбор управления транзакциями через собственный API.\n* Понимание абстракции транзакций Spring Framework\nВ следующих разделах описываются функции и технологии транзакций Spring Framework:. описывает основные классы и описывает, как настроить и получить экземпляры DataSource. из самых разных источников.\n* Синхронизация ресурсов с транзакциями\nВ следующих разделах описываются функции и технологии транзакций Spring Framework:. описывает, как код приложения обеспечивает правильное создание, повторное использование и очистку ресурсов.\n* Декларативное управление транзакциями описывает поддержку\nВ следующих разделах описываются функции и технологии транзакций Spring Framework:. декларативное управление транзакциями.\n* Программное управление транзакциями охватывает поддержку"}
{"id": 1024, "text": "В следующих разделах описываются функции и технологии транзакций Spring Framework:. программное (то есть явно закодированное) управление транзакциями.\n* событие, связанное с транзакцией описывает, как вы можете использовать приложение.\nВ следующих разделах описываются функции и технологии транзакций Spring Framework:. события внутри транзакции.\nВ следующих разделах описываются функции и технологии транзакций Spring Framework:.\nГлава также включает обсуждение передового опыта, и решения распространенных проблем."}
{"id": 1025, "text": "Понимание реализации декларативных транзакций Spring Framework.\nНедостаточно просто сказать вам аннотировать ваши классы с помощью аннотацию `@Transactional`, добавьте `@EnableTransactionManagement` в вашу конфигурацию, и ожидаю, что вы поймете, как все это работает.\nЧтобы обеспечить более глубокое понимание, это В разделе объясняется внутренняя работа декларативной транзакции Spring Framework. инфраструктуры в контексте вопросов, связанных с транзакциями.\nПонимание реализации декларативных транзакций Spring Framework.\nНаиболее важные концепции, которые необходимо усвоить в отношении декларативной структуры Spring Framework. поддержка транзакций заключается в том, что эта поддержка включена рекомендации основаны на метаданных (в настоящее время основанных на XML или аннотациях).\nКомбинация АОП с транзакционными метаданными дает прокси-сервер AOP, который использует TransactionInterceptor в сочетании с соответствующей реализацией TransactionManager для управления транзакциями вокруг вызовов методов.\nПонимание реализации декларативных транзакций Spring Framework.\nПРИМЕЧАНИЕ.\nSpring AOP описан в раздел AOP.\nПонимание реализации декларативных транзакций Spring Framework.\nВарианты управления транзакциями влияют на то, какой менеджер транзакций требуется.\nИмператив для транзакций требуется PlatformTransactionManager, а для реактивных транзакций используется Реализации ReactiveTransactionManager.\nПонимание реализации декларативных транзакций Spring Framework. [ПРИМЕЧАНИЕ] = `@Transactional` обычно работает с транзакциями, связанными с потоками, управляемыми `PlatformTransactionManager`, предоставляющий транзакцию всем операциям доступа к данным внутри текущий поток выполнения.\nПримечание.\nЭто _не_ распространяется на вновь запущенные потоки. внутри метода.\nПонимание реализации декларативных транзакций Spring Framework."}
{"id": 1026, "text": "Реактивная транзакция, управляемая ReactiveTransactionManager, использует контекст Reactor. вместо локальных атрибутов потока.\nКак следствие, доступ к данным всех участников операции должны выполняться в одном и том же контексте Reactor в одном реактивном конвейере.\nПонимание реализации декларативных транзакций Spring Framework.\nПри настройке с помощью ReactiveTransactionManager все методы, разграниченные по транзакциям, Ожидается, что они вернут реактивный трубопровод.\nНеобходимо использовать методы Void или обычные возвращаемые типы. быть связан с обычным «PlatformTransactionManager», например, через Атрибут transactionManager соответствующих объявлений @Transactional.\nПонимание реализации декларативных транзакций Spring Framework.\nНа следующем изображении показано концептуальное представление вызова метода на транзакционном прокси-сервере:"}
{"id": 1027, "text": "Выбор между программным и декларативным управлением транзакциями.\nПрограммное управление транзакциями обычно является хорошей идеей, только если у вас небольшой количество транзакционных операций.\nНапример, если у вас есть веб-приложение, которое требует транзакций только для определенных операций обновления, возможно, вы не захотите настраивать транзакционные прокси с использованием Spring или любой другой технологии.\nВ этом случае с помощью `TransactionTemplate` может быть хорошим подходом.\nВозможность установить имя транзакции явно — это тоже то, что можно сделать только с помощью программного подхода. к управлению транзакциями.\nВыбор между программным и декларативным управлением транзакциями.\nС другой стороны, если ваше приложение содержит множество транзакционных операций, декларативное управление транзакциями обычно имеет смысл.\nОн сохраняет транзакцию управление вне бизнес-логики и его несложно настроить.\nПри использовании Spring Framework, а не EJB CMT, стоимость настройки декларативной транзакции управление значительно сокращается."}
{"id": 1028, "text": "Распространение транзакций.\nВ этом разделе описывается некоторая семантика распространения транзакций в Spring.\nПримечание что этот раздел не является надлежащим введением в распространение транзакций.\nСкорее, это подробно описывает некоторые семантики, касающиеся распространения транзакций в Spring.\nРаспространение транзакций.\nВ транзакциях, управляемых Spring, помните о разнице между физическими и логические транзакции и то, как настройки распространения применяются к этой разнице.\nизображение::tx_prop_required.png[].\nPROPAGATION_REQUIRED обеспечивает физическую транзакцию либо локально для текущей область действия, если транзакция еще не существует или участвует в существующей «внешней» транзакции определены для более широкой области применения.\nЭто прекрасное значение по умолчанию в общих схемах стека вызовов. внутри одного потока (например, фасад службы, который делегирует несколько методов репозитория где все базовые ресурсы должны участвовать в транзакции уровня обслуживания).\nизображение::tx_prop_required.png[].\nПРИМЕЧАНИЕ.\nПо умолчанию участвующая транзакция объединяет характеристики внешней области, молча игнорируя локальный уровень изоляции, значение тайм-аута или флаг только для чтения (если таковой имеется).\nРассмотрите возможность переключения флага validateExistingTransactions на true в вашей транзакции. менеджер, если вы хотите, чтобы объявления уровня изоляции отклонялись при участии в существующая транзакция с другим уровнем изоляции.\nЭтот немягкий режим также отклоняет несоответствия, доступные только для чтения (то есть внутреннюю транзакцию чтения-записи, которая пытается участвовать во внешней области, доступной только для чтения).\nизображение::tx_prop_required.png[]."}
{"id": 1029, "text": "Если параметр распространения равен PROPAGATION_REQUIRED, область логической транзакции создается для каждого метода, к которому применяется этот параметр.\nКаждое такое логичное Область транзакции может определять статус только отката индивидуально, с помощью внешнего область транзакции логически независима от внутренней области транзакции.\nВ случае стандартного поведения PROPAGATION_REQUIRED все эти области сопоставлены с одной и той же физической транзакцией.\nТаким образом, маркер только для отката, установленный во внутреннем Область транзакции влияет на вероятность фактической фиксации внешней транзакции.\nизображение::tx_prop_required.png[].\nОднако в случае, когда внутренняя область транзакции устанавливает маркер только отката, внешняя транзакция сама не приняла решение об откате, поэтому откат (тихо вызвано внутренней областью транзакции) является неожиданным.\nСоответствующий В этот момент выдается `UnexpectedRollbackException`.\nЭто ожидаемое поведение, поэтому что вызывающая транзакция никогда не может быть введена в заблуждение, предполагая, что фиксация была выступал, когда его на самом деле не было.\nИтак, если внутренняя транзакция (в которой внешний вызывающий абонент не знает) молча помечает транзакцию как доступную только для отката, внешний вызывающий объект по-прежнему вызовы фиксации.\nВнешний вызывающий объект должен получить UnexpectedRollbackException, чтобы четко указать, что вместо этого был выполнен откат.\nизображение::tx_prop_requires_new.png[].\nPROPAGATION_REQUIRES_NEW, в отличие от PROPAGATION_REQUIRED, всегда использует независимая физическая транзакция для каждой затронутой области транзакции, никогда участие в существующей транзакции для внешней области."}
{"id": 1030, "text": "В таком расположении базовые транзакции ресурсов различны и, следовательно, могут фиксироваться или откатываться независимо, при этом внешняя транзакция не зависит от отката внутренней транзакции статус и блокировки внутренней транзакции, снятые сразу после ее завершения.\nТакая независимая внутренняя транзакция также может объявлять свой собственный уровень изоляции, тайм-аут, и настройки только для чтения и не наследуют характеристики внешней транзакции.\nизображение::tx_prop_requires_new.png[].\nПРИМЕЧАНИЕ.\nРесурсы, прикрепленные к внешней транзакции, останутся привязанными к ней, пока внутренняя транзакция получает свои собственные ресурсы, такие как новое соединение с базой данных.\nЭто может привести к исчерпанию пула соединений и, возможно, к взаимоблокировке, если несколько потоков имеют активную внешнюю транзакцию и ждут нового соединения для их внутренней транзакции, при этом пул не может выдавать такие внутренние транзакции связи больше нет.\nНе используйте PROPAGATION_REQUIRES_NEW, если только ваш пул соединений не имеет соответствующий размер и превышает количество одновременных потоков как минимум на 1.\nПонимание `PROPAGATION_NESTED`.\nPROPAGATION_NESTED использует одну физическую транзакцию с несколькими точками сохранения. к которому он может вернуться.\nТакие частичные откаты позволяют внутренней области транзакции вызвать откат для своей области, при этом внешняя транзакция сможет продолжиться физическая транзакция, несмотря на то, что некоторые операции были отменены.\nЭта настройка обычно сопоставляется с точками сохранения JDBC, поэтому работает только с ресурсом JDBC. транзакции.\nСм."}
{"id": 1031, "text": "Spring's {spring-framework-api}/jdbc/datasource/DataSourceTransactionManager.html[`DataSourceTransactionManager`]."}
{"id": 1032, "text": "Синхронизация ресурсов с транзакциями.\nКак создавать разные менеджеры транзакций и как они связаны со связанными ресурсами которые необходимо синхронизировать с транзакциями (например, DataSourceTransactionManager` в JDBC DataSource, HibernateTransactionManager в Hibernate SessionFactory, и так далее) теперь должно быть ясно.\nВ этом разделе описывается, как код приложения (прямо или косвенно, используя API сохранения, такой как JDBC, Hibernate или JPA) гарантирует, что эти ресурсы создаются, повторно используются и очищаются должным образом.\nРаздел также обсуждается, как синхронизация транзакций (необязательно) инициируется через соответствующий `TransactionManager`.\nВысокоуровневый подход к синхронизации.\nПредпочтительный подход — использовать сохраняемость Spring на основе шаблонов самого высокого уровня.\nAPI-интерфейсы интеграции или использовать собственные API-интерфейсы ORM с фабричными компонентами, учитывающими транзакции, или прокси для управления собственными фабриками ресурсов.\nЭти решения с учетом транзакций внутренняя обработка создания и повторного использования ресурсов, очистка, необязательные транзакции синхронизация ресурсов и отображение исключений.\nТаким образом, код доступа к пользовательским данным не нужно решать эти задачи, а можно сосредоточиться исключительно на нестандартных задачах. логика постоянства.\nКак правило, вы используете собственный ORM API или шаблонный подход. для доступа к JDBC с помощью JdbcTemplate.\nЭти решения подробно описаны в последующих разделы настоящей справочной документации.\nПодход низкоуровневой синхронизации."}
{"id": 1033, "text": "Такие классы, как DataSourceUtils (для JDBC), EntityManagerFactoryUtils (для JPA), `SessionFactoryUtils` (для Hibernate) и т. д. существуют на более низком уровне.\nКогда вы хотите код приложения для прямой работы с типами ресурсов собственных API-интерфейсов персистентности, вы используете эти классы, чтобы гарантировать получение правильных экземпляров, управляемых Spring Framework, транзакции (необязательно) синхронизируются, а исключения, возникающие в процессе, правильно сопоставлен с согласованным API.\nПодход низкоуровневой синхронизации.\nНапример, в случае JDBC вместо традиционного подхода JDBC вызова метод getConnection() в DataSource, вместо этого вы можете использовать метод Spring `org.springframework.jdbc.datasource.DataSourceUtils`, как показано ниже:\n	Connection conn = DataSourceUtils.getConnection(dataSource);\nПодход низкоуровневой синхронизации.\nЕсли существующая транзакция уже имеет синхронизированное (связанное) с ней соединение, это экземпляр возвращается.\nВ противном случае вызов метода инициирует создание нового соединение, которое (опционально) синхронизируется с любой существующей транзакцией и выполняется доступен для последующего повторного использования в той же транзакции.\nКак уже говорилось ранее, любой `SQLException` заключено в Spring Framework `CannotGetJdbcConnectionException`, один иерархии Spring Framework непроверенных типов DataAccessException.\nЭтот подход дает вам больше информации, чем можно легко получить из `SQLException` и обеспечивает переносимость между базами данных и даже между различными технологиями сохранения.\nПодход низкоуровневой синхронизации."}
{"id": 1034, "text": "Этот подход также работает без управления транзакциями Spring (транзакция синхронизация не является обязательной), поэтому вы можете использовать ее независимо от того, используете ли вы Spring для управление транзакциями.\nПодход низкоуровневой синхронизации.\nКонечно, если вы воспользовались поддержкой Spring JDBC, JPA или Hibernate, вы обычно предпочитаете не использовать DataSourceUtils или другие вспомогательные классы, потому что вам гораздо приятнее работать с абстракцией Spring, чем напрямую с соответствующими API.\nНапример, если вы используете Spring `JdbcTemplate` или Пакет `jdbc.object` для упрощения использования JDBC, происходит правильное получение соединения. за кулисами, и вам не нужно писать какой-либо специальный код.\n`TransactionAwareDataSourceProxy`.\nНа самом нижнем уровне существует класс TransactionAwareDataSourceProxy.\nЭто прокси для целевого DataSource, который обертывает целевой DataSource, чтобы добавить осведомленность о Транзакции, управляемые Spring.\nВ этом отношении он похож на транзакционный JNDI. `DataSource`, предоставленный сервером Jakarta EE.\n`TransactionAwareDataSourceProxy`.\nВам почти никогда не понадобится или не захочется использовать этот класс, за исключением тех случаев, когда он уже существует. код должен быть вызван и передан стандартной реализации интерфейса DataSource JDBC.\nВ этом случае вполне возможно, что этот код можно использовать, но он участвует в управляемом Spring транзакции.\nВы можете написать свой новый код, используя более высокий уровень абстракции, упомянутые ранее."}
{"id": 1035, "text": "<tx:advice/> Настройки.\nВ этом разделе суммированы различные настройки транзакций, которые вы можете указать с помощью тег `<tx:advice/>`.\nНастройки `<tx:advice/>` по умолчанию:\n* Параметр настройка распространения является `ОБЯЗАТЕЛЬНЫМ`.\n* Уровень изоляции — «ПО УМОЛЧАНИЮ».\n* Транзакция является чтение-запись.\n* Тайм-аут транзакции по умолчанию равен тайм-ауту по умолчанию базовой транзакции.\n<tx:advice/> Настройки. system или none, если таймауты не поддерживаются.\n* Любое исключение RuntimeException вызывает откат, а любое отмеченное исключение — нет.\n<tx:advice/> Настройки.\nВы можете изменить эти настройки по умолчанию.\nВ следующей таблице приведены различные атрибуты тегов `<tx:method/>`. которые вложены в теги `<tx:advice/>` и `<tx:attributes/>`:\n.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `имя` | Да | | Имена методов, с которыми должны быть связаны атрибуты транзакции."}
{"id": 1036, "text": "Подстановочный знак ({звездочка}) может использоваться для связи одного и того же атрибута транзакции. настройки с помощью нескольких методов (например, `get*`, `handle*`, `on*Event` и т. д. далее).\n.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `распространение` | Нет | `ОБЯЗАТЕЛЬНО` | Поведение распространения транзакций.\n.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `изоляция` | Нет | `ПО УМОЛЧАНИЮ` | Уровень изоляции транзакции.\nПрименимо только к настройкам распространения REQUIRED или REQUIRES_NEW.\n.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `тайм-аут` | Нет | -1 | Таймаут транзакции (секунды).\nПрименимо только к распространению REQUIRED или REQUIRES_NEW.\n.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `только для чтения` | Нет | ложный | Транзакция чтения-записи в сравнении с транзакцией только чтения.\nПрименяется только к `REQUIRED` или `REQUIRES_NEW`."}
{"id": 1037, "text": ".<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `откат-для` | Нет | | Список экземпляров исключений, разделенных запятыми, которые вызывают откат.\nНапример, `com.foo.MyBusinessException,ServletException`.\n.<tx:method/> настройки |=== | Атрибут| Требуется?| По умолчанию| Описание. | `без отката` | Нет | | Список экземпляров исключений, разделенных запятыми, которые не вызывают откат.\nНапример, `com.foo.MyBusinessException,ServletException`. |==="}
{"id": 1038, "text": "Преобразование типа.\nНекоторые аннотированные аргументы метода контроллера, которые представляют входные данные запроса на основе строки (например, `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable` и `@CookieValue`) может потребоваться преобразование типа, если аргумент объявлен как нечто отличное от `String`.\nПреобразование типа.\nВ таких случаях преобразование типов применяется автоматически на основе настроенных преобразователей.\nПо умолчанию поддерживаются простые типы (такие как int, long, Date и другие).\nПреобразование типов можно настроить с помощью WebDataBinder (см. ссылку:web/webflux/controller/ann-initbinder.adoc[`DataBinder`]). или зарегистрировав «Форматтеры» в «FormattingConversionService» (см.\nПреобразование типа.\nПрактической проблемой преобразования типов является обработка пустого исходного значения String.\nТакое значение считается отсутствующим, если оно становится нулевым в результате преобразования типа.\nЭто может относиться к «Long», «UUID» и другим типам целей.\nЕсли вы хотите разрешить `null` для внедрения, либо используйте флаг `required` в аннотации аргумента, либо объявите аргумент как `@Nullable`."}
{"id": 1039, "text": "Типы.\nВы можете использовать специальный оператор `T`, чтобы указать экземпляр `java.lang.Class` (тип).\nСтатические методы также вызываются с использованием этого оператора.\nStandardEvaluationContext использует TypeLocator для поиска типов, а `StandardTypeLocator` (который можно заменить) создан с учетом пакет `java.lang`.\nЭто означает, что `T()` ссылается на типы в `java.lang`. пакет не обязательно должен быть полным, но все остальные ссылки на типы должны быть указаны.\nВ следующем примере показано, как использовать оператор `T`:\nJava\n	Class dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n	Class stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n	boolean trueValue = parser.parseExpression(\n			\"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\")\n			.getValue(Boolean.class);\nТипы. [ПРИМЕЧАНИЕ] = Если ваше приложение или платформа управляет собственным «EvaluationContext», вам может потребоваться вручную настройте StandardTypeLocator с определенным ClassLoader, чтобы гарантировать, что анализатор выражений SpEL способен надежно определять типы пользователей.\nТипы.\nНапример, StandardBeanExpressionResolver в модуле Spring-context. настраивает StandardTypeLocator, используя bean-компонент ClassLoader соответствующего `БинФабрика`."}
{"id": 1040, "text": "URI-ссылки.\nВ этом разделе описаны различные параметры, доступные в Spring Framework для подготовки URI."}
{"id": 1041, "text": "Использование AspectJ с приложениями Spring.\nВсе, что мы рассмотрели до сих пор в этой главе, — это чистый Spring AOP.\nВ этом разделе мы рассмотрим, как можно использовать компилятор AspectJ или Weaver вместо или в дополнение к Spring AOP, если ваши потребности выходят за рамки возможностей Spring AOP. один.\nИспользование AspectJ с приложениями Spring.\nSpring поставляется с небольшой библиотекой аспектов AspectJ, которая доступна отдельно в вашем распространение как `spring-aspect.jar`.\nВам нужно добавить это в свой путь к классам, чтобы использовать аспекты в нем. и Другие аспекты Spring для AspectJ обсудите содержимое этой библиотеки и то, как вы можете ее использовать. обсуждается, как внедрить зависимости в аспекты AspectJ, созданные с помощью компилятора AspectJ.\nНаконец, содержит введение в переплетение во время загрузки для приложений Spring, использующих AspectJ.\nИспользование AspectJ с приложениями Spring.\nИспользование AspectJ для внедрения зависимостей в объекты домена с помощью Spring\nИспользование AspectJ с приложениями Spring.\nКонтейнер Spring создает экземпляры и настраивает bean-компоненты, определенные в вашем приложении. контекст.\nТакже можно попросить фабрику компонентов настроить уже существующую объект, которому присвоено имя определения компонента, содержащего конфигурацию, которую необходимо применить. `spring-aspects.jar` содержит аспект, управляемый аннотациями, который использует это возможность разрешить внедрение зависимостей любого объекта.\nПоддержка предназначена для использоваться для объектов, созданных вне контроля какого-либо контейнера."}
{"id": 1042, "text": "Объекты домена часто попадают в эту категорию, потому что они часто создаются программно с помощью оператором `new` или инструментом ORM в результате запроса к базе данных.\nИспользование AspectJ с приложениями Spring.\nАннотация `@Configurable` отмечает класс как имеющий право на управление Spring. конфигурация.\nВ простейшем случае вы можете использовать его исключительно как аннотацию маркера, поскольку следующий пример показывает:\nJava\n	package com.xyz.domain;\n	import org.springframework.beans.factory.annotation.Configurable;\n	@Configurable\n	public class Account {\n	package com.xyz.domain\n	@Configurable\n	class Account {\nИспользование AspectJ с приложениями Spring.\nПри таком использовании в качестве интерфейса маркера Spring настраивает новые экземпляры аннотированный тип (в данном случае «Account») с использованием определения bean-компонента (обычно в области прототипа) с тем же именем, что и полное имя типа. (`com.xyz.domain.Account`).\nПоскольку именем по умолчанию для bean-компонента, определенного через XML, является полное имя своего типа, удобный способ объявить определение прототипа заключается в том, чтобы опустить атрибут `id`, как показано в следующем примере:\n	<bean class=\"com.xyz.domain.Account\" scope=\"prototype\">\n		<property name=\"fundsTransferService\" ref=\"fundsTransferService\"/>\n	</bean>\nИспользование AspectJ с приложениями Spring."}
{"id": 1043, "text": "Если вы хотите явно указать имя используемого определения прототипа bean-компонента, вы можно сделать это непосредственно в аннотации, как показано в следующем примере:\nJava\n	package com.xyz.domain;\n	import org.springframework.beans.factory.annotation.Configurable;\n	@Configurable(\"account\")\n	public class Account {\n	package com.xyz.domain\n	@Configurable(\"account\")\n	class Account {\nИспользование AspectJ с приложениями Spring.\nSpring теперь ищет определение компонента с именем «account» и использует его в качестве определение для настройки новых экземпляров `Account`.\nИспользование AspectJ с приложениями Spring.\nВы также можете использовать автоматическое связывание, чтобы избежать необходимости указывать определение выделенного компонента в все.\nЧтобы Spring применял автоматическое связывание, используйте свойство autowire в @Configurable. аннотация.\nВы можете указать либо `@Configurable(autowire=Autowire.BY_TYPE)`, либо `@Configurable(autowire=Autowire.BY_NAME)` для автоматического подключения по типу или по имени, соответственно.\nВ качестве альтернативы предпочтительно указать явный, управляемый аннотациями внедрение зависимостей для ваших bean-компонентов `@Configurable` через `@Autowired` или `@Inject` на уровне поля или метода (дополнительную информацию см. в Конфигурация контейнера на основе аннотаций).\nИспользование AspectJ с приложениями Spring."}
{"id": 1044, "text": "Наконец, вы можете включить проверку зависимостей Spring для ссылок на объекты в новом файле. созданный и настроенный объект с помощью атрибута dependencyCheck (например, `@Configurable(autowire=Autowire.BY_NAME,dependentCheck=true)`).\nЕсли этот атрибут установлено значение true, Spring после настройки проверяет, что все свойства (которые не являются примитивами или коллекциями).\nИспользование AspectJ с приложениями Spring.\nОбратите внимание, что использование аннотации само по себе ничего не дает.\nЭто AnnotationBeanConfigurerAspect в Spring-aspects.jar, который действует при наличии аннотация.\nПо сути, аспект говорит: «после возврата из инициализации новый объект типа, помеченного `@Configurable`, настройте вновь созданный объект используя Spring в соответствии со свойствами аннотации».\nВ этом контексте «инициализация» относится к вновь созданным объектам (например, к объектам, созданным с оператором `new`), а также к `Serializable` объектам, которые подвергаются десериализация (например, через {java-api}/java.base/java/io/Serializable.html[readResolve()]).\nИспользование AspectJ с приложениями Spring. [ПРИМЕЧАНИЕ] = Одна из ключевых фраз в приведенном выше абзаце — «по существу».\nВ большинстве случаев точная семантика «после возврата из инициализации нового объекта» хорошо.\nВ этом контексте «после инициализации» означает, что зависимости вводится после того, как объект был построен."}
{"id": 1045, "text": "Это означает, что зависимости недоступны для использования в телах конструкторов класса.\nЕсли вы хотите зависимости, которые необходимо внедрить до запуска тел конструктора и, таким образом, доступен для использования в теле конструкторов, вам необходимо определить это в Объявление `@Configurable`, следующее:\nJava\n	@Configurable(preConstruction = true)\nИспользование AspectJ с приложениями Spring.\nВы можете найти дополнительную информацию о языковой семантике различных Pointcut. типы в AspectJ {aspectj-docs-progguide}/semantics-joinPoints.html[в этом приложении] {aspectj-docs-progguide}/index.html[Руководство по программированию AspectJ].\nИспользование AspectJ с приложениями Spring.\nЧтобы это работало, аннотированные типы должны быть сплетены с помощью AspectJ weaver.\nВы можете либо используйте для этого задачу Ant или Maven во время сборки (см., например, {aspectj-docs-devguide}/antTasks.html[Разработка AspectJ Руководство по среде]) или переплетение во время загрузки (см.\nПереплетение во время загрузки с AspectJ в Spring Framework).\nСам AnnotationBeanConfigurerAspect должен быть настроен Spring (чтобы получить ссылка на фабрику компонентов, которая будет использоваться для настройки новых объектов).\nВы можете определить соответствующая конфигурация выглядит следующим образом: См. пример кода в исходном документе.\nИспользование AspectJ с приложениями Spring."}
{"id": 1046, "text": "Экземпляры объектов @Configurable, созданные до настройки аспекта. в результате в журнал отладки будет выдано сообщение, а настройка конфигурации не будет выполнена. происходит объект.\nПримером может быть bean-компонент в конфигурации Spring, который создает объекты домена, когда он инициализируется Spring.\nВ этом случае вы можете использовать Атрибут bean-компонента `dependents-on`, чтобы вручную указать, что bean-компонент зависит от аспект конфигурации.\nВ следующем примере показано, как использовать атрибут «зависит от»:\n	<bean id=\"myService\"\n			class=\"com.xyz.service.MyService\"\n			depends-on=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\">\n	</bean>\nИспользование AspectJ с приложениями Spring.\nПРИМЕЧАНИЕ.\nНе активируйте обработку @Configurable через конфигуратор компонента, если только вы не на самом деле означает полагаться на его семантику во время выполнения.\nВ частности, убедитесь, что вы делаете не используйте @Configurable для классов компонентов, которые зарегистрированы как обычные компоненты Spring. с контейнером.\nЭто приведет к двойной инициализации, один раз через контейнер и один раз через аспект.\nМодульное тестирование объектов `@Configurable`.\nОдна из целей поддержки @Configurable — обеспечить независимое модульное тестирование. объектов домена без трудностей, связанных с жестко запрограммированным поиском.\nЕсли типы @Configurable не были созданы AspectJ, аннотация не оказывает никакого влияния. во время модульного тестирования."}
{"id": 1047, "text": "Вы можете установить ссылки на свойства макета или заглушки в объекте в разделе протестируйте и действуйте как обычно.\nЕсли типы @Configurable были созданы с помощью AspectJ, вы по-прежнему можете выполнять модульное тестирование вне контейнера, как обычно, но вы увидите предупреждение сообщение каждый раз, когда вы создаете объект `@Configurable`, указывающий, что он имеет не настроен Spring.\nРабота с несколькими контекстами приложения.\nAnnotationBeanConfigurerAspect, используемый для реализации поддержки @Configurable. является одноэлементным аспектом AspectJ.\nОбласть действия синглтонного аспекта такая же, как и область действия. статических членов: для каждого ClassLoader существует один экземпляр аспекта, определяющий тип.\nЭто означает, что если вы определите несколько контекстов приложения в одном ClassLoader иерархии, вам нужно подумать, где определить bean-компонент `@EnableSpringConfigured` и где разместить `spring-aspects.jar` в пути к классам.\nРабота с несколькими контекстами приложения.\nРассмотрим типичную конфигурацию веб-приложения Spring с общим родительским приложением. контекст, определяющий общие бизнес-услуги, все необходимое для поддержки этих услуг, и один контекст дочернего приложения для каждого сервлета (который содержит определения конкретных этому сервлету).\nВсе эти контексты сосуществуют в одной и той же иерархии ClassLoader. и поэтому AnnotationBeanConfigurerAspect может содержать ссылку только на один из них.\nВ этом случае мы рекомендуем определить bean-компонент @EnableSpringConfigured в общем (родительский) контекст приложения."}
{"id": 1048, "text": "Это определяет услуги, которые вы, вероятно, захотите внедрить в объекты домена.\nСледствием этого является то, что вы не можете настраивать объекты домена. со ссылками на bean-компоненты, определенные в дочерних (специфичных для сервлета) контекстах с помощью @Конфигурируемый механизм (который, вероятно, в любом случае вам не нужен).\nРабота с несколькими контекстами приложения.\nПри развертывании нескольких веб-приложений в одном контейнере убедитесь, что каждое веб-приложение загружает типы в Spring-aspects.jar, используя собственный ClassLoader. (например, поместив Spring-aspects.jar в WEB-INF/lib).\nЕсли `spring-aspects.jar` добавляется только в путь к классам всего контейнера (и, следовательно, загружается общим родительским элементом `ClassLoader`), все веб-приложения используют один и тот же экземпляр аспекта (что, вероятно, не то, что вы хотите).\nДругие аспекты Spring для AspectJ.\nВ дополнение к аспекту @Configurable, Spring-aspects.jar содержит AspectJ. аспект, который вы можете использовать для управления транзакциями Spring для типов и методов. помеченный аннотацией `@Transactional`.\nЭто в первую очередь предназначено для пользователей, которые хотите использовать поддержку транзакций Spring Framework за пределами контейнера Spring.\nДругие аспекты Spring для AspectJ.\nАспект, который интерпретирует аннотации `@Transactional`, - это `АннотацияТранзакцияАспект`."}
{"id": 1049, "text": "Когда вы используете этот аспект, вы должны аннотировать класс реализации (или методы внутри этого класса или оба), а не интерфейс (если любой), который реализует класс.\nAspectJ следует правилу Java, согласно которому аннотации на интерфейсы не наследуются.\nДругие аспекты Spring для AspectJ.\nАннотация `@Transactional` в классе определяет семантику транзакции по умолчанию для выполнение любой публичной операции в классе.\nДругие аспекты Spring для AspectJ.\nАннотация `@Transactional` для метода внутри класса переопределяет значение по умолчанию. семантика транзакции, заданная аннотацией класса (если присутствует).\nМетоды любые видимость может быть аннотирована, включая частные методы.\nАннотирование закрытых методов напрямую — единственный способ получить разграничение транзакций для выполнения таких методов.\nДругие аспекты Spring для AspectJ.\nСОВЕТ: Начиная с Spring Framework 4.2, Spring-aspects предоставляет аналогичный аспект, который предлагает точно такие же функции для стандартной аннотации `jakarta.transaction.Transactional`.\nПроверить `JtaAnnotationTransactionAspect` для более подробной информации.\nДругие аспекты Spring для AspectJ.\nДля программистов AspectJ, которые хотят использовать конфигурацию и транзакции Spring. поддержка управления, но вы не хотите (или не можете) использовать аннотации, `spring-aspect.jar` также содержит «абстрактные» аспекты, которые вы можете расширить, чтобы создать свой собственный pointcut. определения.\nСм. исходники для `AbstractBeanConfigurerAspect` и Аспекты «AbstractTransactionAspect» для получения дополнительной информации."}
{"id": 1050, "text": "В качестве примера можно привести следующее отрывок показывает, как можно написать аспект для настройки всех экземпляров объектов. определенные в модели предметной области с использованием определений прототипов bean-компонентов, которые соответствуют полные имена классов:\n	public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {\n		public DomainObjectConfiguration() {\n			setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());\n		// создание нового bean-компонента (любого объекта в модели предметной области)\n		protected pointcut beanCreation(Object beanInstance) :\n			initialization(new(..)) &&\n			CommonPointcuts.inDomainModel() &&\n			this(beanInstance);\nНастройка аспектов AspectJ с помощью Spring IoC.\nКогда вы используете аспекты AspectJ с приложениями Spring, естественно одновременно хотеть и ожидайте, что сможете настроить такие аспекты с помощью Spring.\nСама среда выполнения AspectJ отвечает за создание аспекта и средства настройки созданного AspectJ аспекты через Spring зависят от модели создания экземпляра AspectJ (предложение per-xxx). используется аспектом.\nНастройка аспектов AspectJ с помощью Spring IoC.\nБольшинство аспектов AspectJ являются одноэлементными аспектами.\nКонфигурация этих аспекты — это легко.\nВы можете создать определение компонента, которое ссылается на тип аспекта как нормальный и включите атрибут bean-компонента `factory-method=\"aspectOf\"`.\nЭто гарантирует, что Spring получает экземпляр аспекта, запрашивая его у AspectJ, а не пытаясь создать сам экземпляр.\nВ следующем примере показано, как использовать атрибут Factory-method=\"aspectOf\"`:"}
{"id": 1051, "text": "<bean id=\"profiler\" class=\"com.xyz.profiler.Profiler\"\n			factory-method=\"aspectOf\"> <1>\n		<property name=\"profilingStrategy\" ref=\"jamonProfilingStrategy\"/>\n	</bean>\nНастройка аспектов AspectJ с помощью Spring IoC. <1> Обратите внимание на атрибут `factory-method=\"aspectOf\"`.\nНастройка аспектов AspectJ с помощью Spring IoC.\nАспекты, не являющиеся одноэлементными, сложнее настроить.\nОднако это можно сделать, создание определений прототипов bean-компонентов и использование поддержки @Configurable из `spring-aspects.jar` для настройки экземпляров аспектов после того, как они будут созданы bean-компонентом среда выполнения AspectJ.\nНастройка аспектов AspectJ с помощью Spring IoC.\nЕсли у вас есть некоторые аспекты @AspectJ, которые вы хотите объединить с AspectJ (например, использование переплетения во время загрузки для типов моделей предметной области) и другие аспекты @AspectJ, которые вы хотите для использования с Spring AOP, и все эти аспекты настраиваются в Spring, вы необходимо сообщить поддержке автоматического проксирования Spring AOP @AspectJ, какое именно подмножество Аспекты @AspectJ, определенные в конфигурации, следует использовать для автоматического проксирования.\nВы можете сделайте это, используя один или несколько элементов `<include/>` внутри `<aop:aspectj-autoproxy/>` декларация."}
{"id": 1052, "text": "Каждый элемент `<include/>` определяет шаблон имени, и только компоненты с имена, соответствующие хотя бы одному из шаблонов, используются для автоматического прокси Spring AOP. конфигурация.\nВ следующем примере показано, как использовать элементы `<include/>`:\n	<aop:aspectj-autoproxy>\n		<aop:include name=\"thisBean\"/>\n		<aop:include name=\"thatBean\"/>\n	</aop:aspectj-autoproxy>\nНастройка аспектов AspectJ с помощью Spring IoC.\nПРИМЕЧАНИЕ.\nПусть вас не вводит в заблуждение имя элемента `<aop:aspectj-autoproxy/>`.\nИспользуя его приводит к созданию прокси Spring AOP.\nСтиль аспекта @AspectJ Здесь используется декларация, но среда выполнения AspectJ не задействована.\nПереплетение во время загрузки с помощью AspectJ в Spring Framework.\nПереплетение во время загрузки (LTW) относится к процессу объединения аспектов AspectJ в файлы классов приложения по мере их загрузки в виртуальную машину Java (JVM).\nВ этом разделе основное внимание уделяется настройке и использованию LTW в конкретном контексте Весенний фреймворк.\nЭтот раздел не является общим введением в LTW.\nДля получения полной информации о особенности LTW и настройка LTW только с помощью AspectJ (при этом Spring не используется). вообще участвует), см. {aspectj-docs-devguide}/ltw.html[раздел LTW в AspectJ Руководство по среде разработки]."}
{"id": 1053, "text": "Переплетение во время загрузки с помощью AspectJ в Spring Framework.\nЦенность, которую Spring Framework привносит в AspectJ LTW, заключается в возможности более детальный контроль над процессом плетения. «Ванильный» AspectJ LTW осуществляется с помощью агент Java (5+), который включается указанием аргумента виртуальной машины при запуске JVM.\nТаким образом, это настройка всей JVM, которая может быть удобна в некоторых ситуациях, но часто является немного слишком грубо.\nLTW с поддержкой Spring позволяет включать LTW на для каждого ClassLoader, который является более детальным и позволяет сделать больше смысл в среде «одного JVM-множества приложений» (например, в типичной среду сервера приложений).\nПереплетение во время загрузки с помощью AspectJ в Spring Framework.\nКроме того, эта поддержка позволяет переплетение во время загрузки без внесения каких-либо изменений в запуск сервера приложений скрипт, который необходим для добавления `-javaagent:path/to/aspectjweaver.jar` или (как мы описываем далее в этом разделе) `-javaagent:path/to/spring-instrument.jar`.\nРазработчики настраивают контекст приложения, чтобы включить переплетение во время загрузки вместо того, чтобы полагаться на администраторов которые обычно отвечают за конфигурацию развертывания, например за сценарий запуска.\nПереплетение во время загрузки с помощью AspectJ в Spring Framework.\nТеперь, когда коммерческое предложение закончено, давайте сначала рассмотрим краткий пример AspectJ."}
{"id": 1054, "text": "LTW, использующий Spring, с последующими подробностями об элементах, представленных в пример.\nПолный пример см. {petclinic-github-org}/spring-framework-petclinic [пример приложения Petclinic на основе Spring Framework].\nПервый пример.\nПредположим, вы разработчик приложения, которому поручена диагностика причина некоторых проблем с производительностью системы.\nВместо того, чтобы вырвать инструмент профилирования, мы собираемся включить простой аспект профилирования, который позволит нам быстро получить некоторые показатели производительности.\nЗатем мы можем применить более детальное профилирование. инструмент в эту конкретную область сразу после этого.\nПервый пример.\nПРИМЕЧАНИЕ.\nВ представленном здесь примере используется конфигурация XML.\nВы также можете настроить и используйте @AspectJ с конфигурация Java.\nВ частности, вы можете использовать Аннотация `@EnableLoadTimeWeaving` как альтернатива `<context:load-time-weaver/>` (подробности см. в ниже).\nПервый пример.\nВ следующем примере показан аспект профилирования, который не является чем-то необычным.\nЭто профилировщик, основанный на времени, который использует @AspectJ-стиль объявления аспектов:\nJava\n	package com.xyz;\n	import org.aspectj.lang.ProceedingJoinPoint;\n	import org.aspectj.lang.annotation.Aspect;\n	import org.aspectj.lang.annotation.Around;\n	import org.aspectj.lang.annotation.Pointcut;\n	import org.springframework.util.StopWatch;"}
{"id": 1055, "text": "import org.springframework.core.annotation.Order;\n	@Aspect\n	public class ProfilingAspect {\n		@Around(\"methodsToBeProfiled()\")\n		public Object profile(ProceedingJoinPoint pjp) throws Throwable {\n			StopWatch sw = new StopWatch(getClass().getSimpleName());\n			try {\n				sw.start(pjp.getSignature().getName());\n				return pjp.proceed();\n			} finally {\n				sw.stop();\n				System.out.println(sw.prettyPrint());\n		@Pointcut(\"execution(public * com.xyz..*.*(..))\")\n		public void methodsToBeProfiled(){}\n	package com.xyz\n	@Aspect\n	class ProfilingAspect {\nПервый пример.\nНам также необходимо создать файл META-INF/aop.xml, чтобы сообщить ткачу AspectJ, что мы хотим встроить наш «ProfilingAspect» в наши классы.\nЭто соглашение о файлах, а именно наличие файла (или файлов) в пути к классам Java с именем `META-INF/aop.xml` является стандартный аспектJ.\nВ следующем примере показан файл aop.xml:\n	<!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"https://www.eclipse.org/aspectj/dtd/aspectj.dtd\">\n	<aspectj>\n		<weaver>"}
{"id": 1056, "text": "<!-- only weave classes in our application-specific packages and sub-packages -->\n			<include within=\"com.xyz..*\"/>\n		</weaver>\n		<aspects>\n			<!-- weave in just this aspect -->\n			<aspect name=\"com.xyz.ProfilingAspect\"/>\n		</aspects>\n	</aspectj>\nПервый пример.\nПРИМЕЧАНИЕ.\nРекомендуется объединять только определенные классы (обычно те, которые находятся в пакеты приложений, как показано в примере `aop.xml` выше) в порядке чтобы избежать побочных эффектов, таких как файлы дампа AspectJ и предупреждения.\nЭто также лучшая практика с точки зрения эффективности.\nПервый пример.\nТеперь мы можем перейти к части конфигурации, специфичной для Spring.\nНам нужен для настройки LoadTimeWeaver (объясняется позже).\nЭтот ткач во время загрузки является важный компонент, отвечающий за вплетение конфигурации аспекта в один или больше файлов META-INF/aop.xml в классы вашего приложения.\nХороший дело в том, что он не требует большой настройки (есть еще несколько параметры, которые вы можете указать, но они подробно описаны позже), как видно на следующий пример:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\""}
{"id": 1057, "text": "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans\n			https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context\n			https://www.springframework.org/schema/context/spring-context.xsd\">\n		<!-- a service object; we will be profiling its methods -->\n		<bean id=\"entitlementCalculationService\"\n				class=\"com.xyz.StubEntitlementCalculationService\"/>\n		<!-- this switches on the load-time weaving -->\n		<context:load-time-weaver/>\n	</beans>\nПервый пример.\nТеперь, когда все необходимые артефакты (аспект `META-INF/aop.xml` файл и конфигурация Spring) на месте, мы можем создать следующее класс драйвера с методом `main(..)` для демонстрации LTW в действии:\nJava\n	package com.xyz;\n	// импорт\n	public class Main {\n		public static void main(String[] args) {"}
{"id": 1058, "text": "ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n			EntitlementCalculationService service =\n					ctx.getBean(EntitlementCalculationService.class);\n			// аспект профилирования «вплетен» в выполнение этого метода\n			service.calculateEntitlement();\n	package com.xyz\n	// импорт\n		// аспект профилирования «вплетен» в выполнение этого метода\n		service.calculateEntitlement()\nПервый пример.\nНам осталось сделать последнее дело.\nВо введении к этому разделу говорилось, что можно включайте LTW выборочно для каждого ClassLoader с помощью Spring, и это правда.\nОднако в этом примере мы используем агент Java (поставляемый вместе со Spring) для включения LTW.\nМы используем следующую команду для запуска класса Main, показанного ранее:\njava -javaagent:C:/projects/xyz/lib/spring-instrument.jar com.xyz.Main. `-javaagent` — это флаг для указания и включения {java-api}/java.instrument/java/lang/instrument/package-summary.html[агенты для инструментирования программ, работающих на JVM].\nSpring Framework поставляется с таким агент, InstrumentSavingAgent, который упакован в пакет `spring-instrument.jar`, который был предоставлен как значение аргумента `-javaagent` в предыдущий пример.\njava -javaagent:C:/projects/xyz/lib/spring-instrument.jar com.xyz.Main."}
{"id": 1059, "text": "Результат выполнения программы Main выглядит примерно так, как показано в следующем примере. (Я добавил оператор `Thread.sleep(..)` в `calculateEntitlement()` реализацию, чтобы профилировщик фактически фиксировал что-то отличное от 0 миллисекунды (миллисекунды «01234» не являются накладными расходами, вносимыми АОП).\nВ следующем листинге показаны выходные данные, которые мы получили при запуске нашего профилировщика:\nCalculating entitlement.\nStopWatch 'ProfilingAspect': running time (millis) = 1234 ------ ----- ---------------------------- ms % Task name ------ ----- ---------------------------- 01234 100% calculateEntitlement\nCalculating entitlement.\nПоскольку это LTW осуществляется с помощью полноценного AspectJ, мы не ограничиваемся только советами.\nВесенняя фасоль.\nСледующая небольшая вариация программы Main дает тот же результат: результат:\nJava\n	package com.xyz;\n	// импорт\n	public class Main {\n		public static void main(String[] args) {\n			new ClassPathXmlApplicationContext(\"beans.xml\");\n			EntitlementCalculationService service =\n					new StubEntitlementCalculationService();"}
{"id": 1060, "text": "// аспект профилирования будет «вплетен» в выполнение этого метода\n			service.calculateEntitlement();\n	package com.xyz\n	// импорт\n		// аспект профилирования будет «вплетен» в выполнение этого метода\n		service.calculateEntitlement()\nCalculating entitlement.\nОбратите внимание, как в предыдущей программе мы загружаем контейнер Spring и затем создайте новый экземпляр StubEntitlementCalculationService полностью за пределами контекст весны.\nСоветы по профилированию все еще вплетены.\nCalculating entitlement.\nСогласитесь, пример упрощенный.\nОднако основы поддержки LTW в Spring все они были представлены в предыдущем примере, а остальная часть этого раздела объясняет «Почему» за каждым битом конфигурации и использования в деталях.\nCalculating entitlement.\nПРИМЕЧАНИЕ.\nИспользуемый в этом примере параметр «ProfilingAspect» может быть простым, но он весьма полезен.\nЭто хороший пример аспекта времени разработки, который разработчики могут использовать во время разработки а затем легко исключить из сборок развертываемого приложения в UAT или производство.\nАспекты, которые вы используете в LTW, должны быть аспектами AspectJ.\nВы можете написать их в либо сам язык AspectJ, либо вы можете писать свои аспекты в стиле @AspectJ.\nТогда ваши аспекты являются действительными аспектами AspectJ и Spring AOP.\nБолее того, скомпилированные классы аспектов должны быть доступны в пути к классам.\n`META-INF/aop.xml`."}
{"id": 1061, "text": "Инфраструктура AspectJ LTW настраивается с использованием одного или нескольких `META-INF/aop.xml` файлы, находящиеся в пути к классам Java (либо напрямую, либо, что чаще, в файлах jar).\nНапример:\n	<!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"https://www.eclipse.org/aspectj/dtd/aspectj.dtd\">\n	<aspectj>\n		<weaver>\n			<!-- only weave classes in our application-specific packages and sub-packages -->\n			<include within=\"com.xyz..*\"/>\n		</weaver>\n	</aspectj>\n`META-INF/aop.xml`.\nПРИМЕЧАНИЕ.\nРекомендуется объединять только определенные классы (обычно те, которые находятся в пакеты приложений, как показано в примере `aop.xml` выше) в порядке чтобы избежать побочных эффектов, таких как файлы дампа AspectJ и предупреждения.\nЭто также лучшая практика с точки зрения эффективности.\n`META-INF/aop.xml`.\nСтруктура и содержимое этого файла подробно описаны в разделе LTW. {aspectj-docs-devguide}/ltw-configuration.html[ссылка на AspectJ документация].\nПоскольку файл aop.xml на 100% состоит из AspectJ, мы не описываем его здесь далее.\nНеобходимые библиотеки (JARS)."}
{"id": 1062, "text": "Для использования поддержки Spring Framework вам потребуются как минимум следующие библиотеки: для AspectJ LTW:\n* `spring-aop.jar`\n* `aspectjweaver.jar`\nНеобходимые библиотеки (JARS).\nЕсли вы используете агент, предоставленный Spring для включения инструментов, вам также понадобится:\n* `spring-instrument.jar`\nВесенняя конфигурация.\nКлючевым компонентом поддержки LTW в Spring является интерфейс LoadTimeWeaver (в `org.springframework.instrument.classloading`) и многочисленные реализации из них он поставляется с дистрибутивом Spring.\nLoadTimeWeaver отвечает за добавление одного или нескольких `java.lang.instrument.ClassFileTransformers` к `ClassLoader` в среда выполнения, которая открывает двери для всевозможных интересных приложений, одно из которых оказывается LTW аспектов.\nВесенняя конфигурация.\nСОВЕТ: Если вы не знакомы с идеей преобразования файлов классов во время выполнения, см.\nПрежде чем продолжить, прочтите документацию по API javadoc для пакета `java.lang.instrument`.\nХотя эта документация не является исчерпывающей, по крайней мере, вы можете увидеть ключевые интерфейсы. и классы (для справки при чтении этого раздела).\nВесенняя конфигурация.\nНастроить LoadTimeWeaver для конкретного ApplicationContext может быть так же просто, как добавление одной строки. (Обратите внимание, что вам почти наверняка придется использовать `ApplicationContext` в качестве контейнера Spring.\nОбычно `BeanFactory` не является достаточно, потому что поддержка LTW использует BeanFactoryPostProcessors.)\nВесенняя конфигурация."}
{"id": 1063, "text": "Чтобы включить поддержку LTW Spring Framework, вам необходимо настроить LoadTimeWeaver следующим образом: См. пример кода в исходном документе.\nВесенняя конфигурация.\nПредыдущая конфигурация автоматически определяет и регистрирует ряд специфичных для LTW инфраструктурные компоненты, такие как LoadTimeWeaver и AspectJWeavingEnabler.\nПо умолчанию LoadTimeWeaver — это класс DefaultContextLoadTimeWeaver, который пытается для оформления автоматически обнаруженного `LoadTimeWeaver`.\nТочный тип LoadTimeWeaver. то, что «обнаружено автоматически», зависит от вашей среды выполнения.\nВ следующей таблице приведены различные реализации LoadTimeWeaver:\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | Запуск в https://eclipse-ee4j.github.io/glassfish/[GlassFish] (ограничено развертываниями EAR) | `GlassFishLoadTimeWeaver`\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | Запуск в Red Hat https://www.jboss.org/jbossas/[JBoss AS] или https://www.wildfly.org/[WildFly] | `JBossLoadTimeWeaver`\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | JVM началась с Spring `InstrumentationSavingAgent` (`java -javaagent:path/to/spring-instrument.jar`) | `ИнструментацияLoadTimeWeaver`"}
{"id": 1064, "text": "| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. | Резервный вариант, ожидающий, что базовый ClassLoader будет следовать общим соглашениям. (а именно `addTransformer` и, возможно, метод `getThrowawayClassLoader`) | `ReflectiveLoadTimeWeaver` |===\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`.\nОбратите внимание, что в таблице перечислены только те `LoadTimeWeavers`, которые автоматически определяются при используйте `DefaultContextLoadTimeWeaver`.\nВы можете точно указать, какой именно `LoadTimeWeaver` реализация для использования.\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`.\nЧтобы настроить конкретный `LoadTimeWeaver`, реализуйте Интерфейс LoadTimeWeavingConfigurer и переопределить метод getLoadTimeWeaver(). (или используйте эквивалент XML).\nВ следующем примере указывается ReflectiveLoadTimeWeaver: См. пример кода в исходном документе.\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`. `LoadTimeWeaver`, определенный и зарегистрированный в конфигурации, может быть позже извлекается из контейнера Spring с использованием хорошо известного имени loadTimeWeaver.\nПомните, что LoadTimeWeaver существует только как механизм Spring LTW. инфраструктура для добавления одного или нескольких ClassFileTransformers."}
{"id": 1065, "text": "Фактический ClassFileTransformer, выполняющий LTW, — это ClassPreProcessorAgentAdapter (из пакет `org.aspectj.weaver.loadtime`).\nСм.\nJavadoc уровня класса ClassPreProcessorAgentAdapter для получения более подробной информации, поскольку особенности того, как фактическое плетение выходит за рамки данного документа.\n| Запуск в https://tomcat.apache.org/[Apache Tomcat] | `TomcatLoadTimeWeaver`.\nОстался обсудить еще один последний атрибут конфигурации: aspectjWeaving. атрибут (или «aspectj-weaving», если вы используете XML).\nЭтот атрибут определяет, будет ли LTW включен или нет.\nОн принимает одно из трех возможных значений, значением по умолчанию является `autodetect`, если атрибут отсутствует.\nВ следующей таблице суммированы три возможные значения:\nЗначения атрибутов переплетения.AspectJ |=== | Значение аннотации | XML-значение| Объяснение. | `ВКЛЮЧЕНО` | `вкл` | Переплетение AspectJ включено, и аспекты переплетаются во время загрузки по мере необходимости.\nЗначения атрибутов переплетения.AspectJ |=== | Значение аннотации | XML-значение| Объяснение. | `ОТКЛЮЧЕН` | `выключено` | ЛТВ выключен.\nНи один аспект не переплетается во время загрузки."}
{"id": 1066, "text": "Значения атрибутов переплетения.AspectJ |=== | Значение аннотации | XML-значение| Объяснение. | `АВТООБНАРУЖЕНИЕ` | `автоопределение` | Если инфраструктура Spring LTW может найти хотя бы один файл META-INF/aop.xml, затем включается плетение AspectJ.\nВ противном случае он выключен.\nЭто значение по умолчанию. |===\nКонфигурация, специфичная для окружающей среды.\nЭтот последний раздел содержит любые дополнительные настройки и конфигурации, которые вам нужны. когда вы используете поддержку Spring LTW в таких средах, как серверы приложений и веб-сайты. контейнеры.\nТомкэт, JBoss, WildFly.\nTomcat и JBoss/WildFly предоставляют общее приложение ClassLoader, способное локально приборы.\nСобственный LTW Spring может использовать эти реализации ClassLoader. обеспечить плетение AspectJ.\nВы можете просто включить переплетение во время загрузки, как описано ранее.\nВ частности, вам не нужно изменять сценарий запуска JVM, чтобы добавить `-javaagent:путь/к/spring-instrument.jar`.\nТомкэт, JBoss, WildFly.\nОбратите внимание, что в JBoss вам может потребоваться отключить сканирование сервера приложений, чтобы предотвратить его загрузка классов до фактического запуска приложения.\nБыстрый обходной путь — добавить к вашему артефакту файл с именем WEB-INF/jboss-scanning.xml со следующим содержимым:\n	<scanning xmlns=\"urn:jboss:scanning:1.0\"/>\nОбщие Java-приложения."}
{"id": 1067, "text": "Когда инструментарий класса требуется в средах, которые не поддерживаются В конкретных реализациях LoadTimeWeaver общим решением является агент JVM.\nДля таких случаев Spring предоставляет InstrumentationLoadTimeWeaver, для которого требуется Специальный для Spring (но очень общий) агент JVM, `spring-instrument.jar`, обнаруживается автоматически с помощью общих настроек `@EnableLoadTimeWeaving` и `<context:load-time-weaver/>`.\nОбщие Java-приложения.\nЧтобы использовать его, вы должны запустить виртуальную машину с агентом Spring, указав следующие параметры JVM:\n-javaagent:/path/to/spring-instrument.jar.\nОбратите внимание, что для этого требуется модификация сценария запуска JVM, что может помешать вам от использования этого в средах серверов приложений (в зависимости от вашего сервера и вашего операционная политика).\nТем не менее, для развертываний с одним приложением на JVM, таких как автономные Приложения Spring Boot в любом случае обычно вы контролируете всю настройку JVM."}
{"id": 1068, "text": "1. Введение. `validation` отвечает за декларативную и программную проверку входных данных, доменных объектов и конфигурации.\n- снижает число дефектов на ранних этапах;\n- стандартизирует ошибки валидации;\n- упрощает защиту API и внутренних команд.\n```xml\n```java\n    @NotBlank(message = \"username must not be blank\")\n    private String username;\n    @Email(message = \"email has invalid format\")\n    private String email;\n    @Min(value = 18, message = \"age must be >= 18\")\n    private int age;\n    // getters/setters omitted for brevity\n```java\n    private final Validator validator;\n    public UserService(Validator validator) {\n        this.validator = validator;\n    public void register(RegisterUserRequest request) {\n        ValidationResult result = validator.validate(request);\n        if (!result.isValid()) {\n            // В проде лучше возвращать структурированный список нарушений.\n            throw new IllegalArgumentException(\"Validation failed: \" + result.errors());\n        // Сохраняем пользователя.\n```yaml\n    fail-fast: false\n    max-errors: 50\n    locale: ru-RU\n    sanitize-strings: true\n- Всегда валидируйте входные DTO до начала бизнес-операций.\n- Проверяйте, что `max-errors` ограничен, чтобы исключить избыточную нагрузку.\n- Не доверяйте данным из очередей/внешних API без повторной валидации."}
{"id": 1069, "text": "- Для денежных и идентификационных полей добавляйте доменные кастомные валидаторы.\n- Не маскируйте ошибки валидации generic-исключением без деталей.\n- `ConstraintDefinitionException`: неверно настроен кастомный constraint.\n- `ValidationOverflowException`: превышено `max-errors`.\n- `MessageInterpolationException`: проблема локализации текста ошибок.\n```java\n    @Override\n    public boolean isValid(String value, ConstraintContext context) {\n        if (value == null) {\n            context.addError(\"orderId must not be null\");\n            return false;\n        boolean ok = value.matches(\"ORD-[0-9]{10}\");\n        if (!ok) {\n            context.addError(\"orderId must match pattern ORD-##########\");\n        return ok;\n- Используйте fail-fast только для latency-critical путей.\n- Для публичных API возвращайте machine-readable ошибки (`code`, `field`, `message`).\n- Группируйте правила валидации по use-case (create/update/import).\n- Пишите unit-тесты на каждый кастомный validator.\n- Не смешивайте валидацию и бизнес-логику в одном классе."}
{"id": 1070, "text": "Проверка с использованием интерфейса валидатора Spring.\nSpring имеет интерфейс «Валидатор», который можно использовать для проверки объектов.\nИнтерфейс «Валидатор» работает с использованием объекта «Ошибки», поэтому при проверке валидаторы могут сообщать об ошибках проверки объекту «Errors».\nJava\n	public class Person {\n		private String name;\n		private int age;\n		// обычные геттеры и сеттеры...\nРассмотрим следующий пример небольшого объекта данных:.\nВ следующем примере показано поведение проверки для класса Person путем реализации следующие два метода интерфейса `org.springframework.validation.Validator`:\n* `supports(Class)`: может ли этот `Validator` проверять экземпляры предоставленного `Class`?\n* `validate(Object, org.springframework.validation.Errors)`: проверяет заданный объект.\nРассмотрим следующий пример небольшого объекта данных:. и, в случае ошибок проверки, регистрирует их с помощью данного объекта «Errors».\nРассмотрим следующий пример небольшого объекта данных:.\nРеализация «Валидатора» довольно проста, особенно если вы знаете о Вспомогательный класс ValidationUtils, который также предоставляет Spring Framework.\nСледующие пример реализует `Validator` для экземпляров `Person`:\nJava\n	public class PersonValidator implements Validator {\n		 * Этот валидатор проверяет только экземпляры Person.\n		public boolean supports(Class clazz) {\n			return Person.class.equals(clazz);\n		public void validate(Object obj, Errors e) {"}
{"id": 1071, "text": "ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\");\n			Person p = (Person) obj;\n			if (p.getAge() < 0) {\n				e.rejectValue(\"age\", \"negativevalue\");\n			} else if (p.getAge() > 110) {\n				e.rejectValue(\"age\", \"too.darn.old\");\n	class PersonValidator : Validator {\nРассмотрим следующий пример небольшого объекта данных:.\nСтатический метод `rejectIfEmpty(..)` в классе `ValidationUtils` используется для отклонить свойство name, если оно имеет значение null или пустую строку.\nВзгляните на {spring-framework-api}/validation/ValidationUtils.html[`ValidationUtils`] javadoc чтобы увидеть, какие функции он предоставляет помимо примера, показанного ранее.\nРассмотрим следующий пример небольшого объекта данных:.\nХотя, безусловно, можно реализовать один класс Validator для проверки каждого вложенных объектов в расширенный объект, возможно, лучше инкапсулировать проверку логика для каждого вложенного класса объекта в своей собственной реализации «Валидатора».\nПростой примером «богатого» объекта может быть объект «Клиент», состоящий из двух строк. свойства (имя и второе имя) и сложный объект «Адрес».\nОбъекты `Адрес` может использоваться независимо от объектов Customer, поэтому отдельный объект AddressValidator был реализован."}
{"id": 1072, "text": "Если вы хотите, чтобы ваш CustomerValidator повторно использовал содержащуюся логику внутри класса AddressValidator, не прибегая к копированию и вставке, вы можете внедрить зависимость или создать экземпляр AddressValidator внутри вашего CustomerValidator, как показано в следующем примере:\nJava\n	public class CustomerValidator implements Validator {\n		private final Validator addressValidator;\n		public CustomerValidator(Validator addressValidator) {\n			if (addressValidator == null) {\n				throw new IllegalArgumentException(\"The supplied [Validator] is \" +\n					\"required and must not be null.\");\n			if (!addressValidator.supports(Address.class)) {\n				throw new IllegalArgumentException(\"The supplied [Validator] must \" +\n					\"support the validation of [Address] instances.\");\n			this.addressValidator = addressValidator;\n		 * Этот Валидатор проверяет экземпляры Клиента, а также любые подклассы Клиента.\n		public boolean supports(Class clazz) {\n			return Customer.class.isAssignableFrom(clazz);\n		public void validate(Object target, Errors errors) {\n			ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"field.required\");\n			ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"surname\", \"field.required\");\n			Customer customer = (Customer) target;\n			try {\n				errors.pushNestedPath(\"address\");\n				ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);\n			} finally {\n				errors.popNestedPath();"}
{"id": 1073, "text": "Рассмотрим следующий пример небольшого объекта данных:.\nОб ошибках проверки сообщается объекту «Errors», передаваемому валидатору.\nВ случае Spring Web MVC вы можете использовать тег `<spring:bind/>` для проверки сообщений об ошибках, но вы также можете проверить объект «Ошибки» самостоятельно.\nБолее подробная информация о Предлагаемые им методы можно найти в файле {spring-framework-api}/validation/Errors.html[javadoc].\nРассмотрим следующий пример небольшого объекта данных:.\nВалидаторы также могут вызываться локально для немедленной проверки данного объекта. без обязательного процесса.\nНачиная с версии 6.1, это было упрощено за счет нового Метод `Validator.validateObject(Object)`, который теперь доступен по умолчанию, возвращает простое представление `Errors`, которое можно проверить: обычно вызывая `hasErrors()` или новый методfailOnError для превращения сводного сообщения об ошибке в исключение. (например, `validator.validateObject(myObject).failOnError(IllegalArgumentException::new)`)."}
{"id": 1074, "text": "Java\n	@Component\n	public class MovieRecommender {\n		private final String catalog;\n		public MovieRecommender(@Value(\"${catalog.name}\") String catalog) {\n			this.catalog = catalog;\nJava\n	@Configuration\n	@PropertySource(\"classpath:application.properties\")\n	public class AppConfig { }\n	@Configuration\n	@PropertySource(\"classpath:application.properties\")\n	class AppConfig\n	catalog.name=MovieCatalog\nИ следующий файл application.properties:.\nВ этом случае параметр и поле «catalog» будут равны значению MovieCatalog.\nИ следующий файл application.properties:.\nМягкий встроенный преобразователь значений по умолчанию предоставляется Spring.\nОн попытается решить значение свойства и, если его невозможно разрешить, имя свойства (например, `${catalog.name}`) будет введено как значение.\nЕсли вы хотите сохранить строгий контроль над несуществующим значения, вам следует объявить bean-компонент PropertySourcesPlaceholderConfigurer, как показано ниже. пример показывает:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {\n			return new PropertySourcesPlaceholderConfigurer();\n	@Configuration\n	class AppConfig {\nИ следующий файл application.properties:.\nПРИМЕЧАНИЕ.\nПри настройке PropertySourcesPlaceholderConfigurer с помощью JavaConfig Метод `@Bean` должен быть `статическим`.\nИ следующий файл application.properties:.\nИспользование приведенной выше конфигурации гарантирует сбой инициализации Spring, если есть `${}` заполнитель не может быть разрешен."}
{"id": 1075, "text": "Также можно использовать такие методы, как `setPlaceholderPrefix()`, `setPlaceholderSuffix()`, `setValueSeparator()` или `setEscapeCharacter()` для настройки синтаксиса заполнителя.\nКроме того, по умолчанию escape-символ можно изменить или отключить глобально, установив параметр `spring.placeholder.escapeCharacter.default` через системное свойство JVM (или через механизм SpringProperties[`SpringProperties`]).\nИ следующий файл application.properties:.\nПРИМЕЧАНИЕ.\nSpring Boot по умолчанию настраивает bean-компонент PropertySourcesPlaceholderConfigurer, который получит свойства из файлов application.properties и application.yml.\nИ следующий файл application.properties:.\nВстроенная поддержка конвертеров, предоставляемая Spring, позволяет выполнять простое преобразование типов (в Integer). или, например, `int`) для автоматической обработки.\nМожно указать несколько значений, разделенных запятыми. автоматически преобразуется в массив String без дополнительных усилий.\nJava\n	@Component\n	public class MovieRecommender {\n		private final String catalog;\n		public MovieRecommender(@Value(\"${catalog.name:defaultCatalog}\") String catalog) {\n			this.catalog = catalog;\nМожно указать значение по умолчанию следующим образом:.\nSpring `BeanPostProcessor` использует ConversionService за кулисами для обработки процесс преобразования значения `String` в `@Value` в целевой тип."}
{"id": 1076, "text": "Если вы хотите обеспечить поддержку преобразования для вашего собственного типа, вы можете предоставить свой собственный Экземпляр bean-компонента `ConversionService`, как показано в следующем примере:\nJava\n	@Configuration\n	public class AppConfig {\n		@Bean\n		public ConversionService conversionService() {\n			DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();\n			conversionService.addConverter(new MyCustomConverter());\n			return conversionService;\n	@Configuration\n	class AppConfig {\nМожно указать значение по умолчанию следующим образом:.\nЕсли `@Value` содержит выражение `SpEL`, значение будет динамическим. вычисляется во время выполнения, как показано в следующем примере:\nJava\n	@Component\n	public class MovieRecommender {\n		private final String catalog;\n		public MovieRecommender(@Value(\"#{systemProperties['user.catalog'] + 'Catalog' }\") String catalog) {\n			this.catalog = catalog;\nJava\n	@Component\n	public class MovieRecommender {\n		private final Map<String, Integer> countOfMoviesPerCatalog;\n		public MovieRecommender(\n				@Value(\"#{{'Thriller': 100, 'Comedy': 300}}\") Map<String, Integer> countOfMoviesPerCatalog) {\n			this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;"}
{"id": 1077, "text": "Вызовы Варарга.\nЯзык выражений Spring поддерживает https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html[varargs] вызовы для constructors,\nВызовы Варарга.\nВ следующем примере показано, как вызвать `java.lang.String#formatted(Object...)` _varargs_ внутри выражения, предоставляя список аргументов переменной как отдельный аргументы (`'синий', 1`).\nJava\n	// оценивается как «синий — цвет №1»\n	String expression = \"'%s is color #%d'.formatted('blue', 1)\";\n	String message = parser.parseExpression(expression).getValue(String.class);\nВызовы Варарга.\nСписок переменных аргументов также может быть предоставлен в виде массива, как показано в следующий пример (`new Object[] {'blue', 1}`).\nJava\n	// оценивается как «синий — цвет №1»\n	String expression = \"'%s is color #%d'.formatted(new Object[] {'blue', 1})\";\n	String message = parser.parseExpression(expression).getValue(String.class);\nВызовы Варарга."}
{"id": 1078, "text": "В качестве альтернативы список переменных аргументов может быть предоставлен как `java.util.List` – для например, в виде встроенный список (`{'синий', 1}`).\nВ следующем примере показано, как это сделать.\nJava\n	// оценивается как «синий — цвет №1»\n	String expression = \"'%s is color #%d'.formatted({'blue', 1})\";\n	String message = parser.parseExpression(expression).getValue(String.class);\nПреобразование типов переменных аргументов.\nВ отличие от стандартной поддержки вызовов с переменным числом аргументов в Java, применяется к отдельным аргументам при вызове конструкторов, методов или функции в SpEL.\nПреобразование типов переменных аргументов.\nНапример, если мы зарегистрировали пользовательский под именем #reverseStrings для метода с сигнатурой `StringverseStrings(String... strings)`, мы можем вызвать эту функцию внутри SpEL. выражение с любым аргументом, который можно преобразовать в строку, как показано в следующий пример.\nJava\n	// оценивается как «3.0, 2.0, 1, SpEL»\n	String expression = \"#reverseStrings('SpEL', 1, 10F / 5, 3.0000)\";\n	String message = parser.parseExpression(expression)\n			.getValue(evaluationContext, String.class);\nПреобразование типов переменных аргументов."}
{"id": 1079, "text": "Аналогично, любой массив, тип компонента которого является подтипом требуемого типа varargs, может быть предоставлен в качестве списка переменных аргументов для вызова varargs.\nНапример, Массив `String[]` может быть передан в вызов varargs, который принимает `Object...` список аргументов.\nПреобразование типов переменных аргументов.\nСледующий листинг показывает, что мы можем передать массив `String[]` в `java.lang.String#formatted(Object...)` метод _varargs_.\nТакже подчеркивается, что `1` будет автоматически преобразован в `\"1\"`.\nJava\n	// оценивается как «синий — цвет №1»\n	String expression = \"'%s is color #%s'.formatted(new String[] {'blue', 1})\";\n	String message = parser.parseExpression(expression).getValue(String.class);"}
{"id": 1080, "text": "Переменные.\nВы можете ссылаться на переменные в выражении, используя синтаксис #variableName.\nПеременные устанавливаются с помощью метода setVariable() в реализациях EvaluationContext.\nПеременные. [ПРИМЕЧАНИЕ] = Имена переменных должны начинаться с буквы (как определено ниже), подчеркивания или доллара. знак.\nПеременные.\nИмена переменных должны состоять из одного или нескольких следующих поддерживаемых типов: персонажи.\n* буква: любой символ, для которого `java.lang.Character.isLetter(char)` возвращает `true`\nПеременные. – Сюда входят такие буквы, как от «A» до «Z», от «a» до «z», «ü», «ñ» и «é», а также\n    буквы из других наборов символов, таких как китайский, японский, кириллица и т. д.\n* цифра: от `0` до `9`\n* подчеркивание: `_`\n* знак доллара: `$`\nПеременные. [СОВЕТ] = При установке переменной или объекта корневого контекста в EvaluationContext рекомендуется чтобы тип переменной или объекта корневого контекста был «публичным».\nПеременные.\nВ противном случае некоторые типы выражений SpEL, включающие переменную или объект корневого контекста. с закрытым типом может не выполниться или скомпилироваться.\nПеременные. [ВНИМАНИЕ] = Поскольку переменные имеют общее пространство имен с необходимо следить за тем, чтобы имена переменных и имена функций не перекрывались.\nПеременные."}
{"id": 1081, "text": "В следующем примере показано, как использовать переменные.\nJava\n	Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\n	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n	context.setVariable(\"newName\", \"Mike Tesla\");\n	parser.parseExpression(\"name = #newName\").getValue(context, tesla);\n	System.out.println(tesla.getName());  // \"Mike Tesla\"\n	parser.parseExpression(\"name = #newName\").getValue(context, tesla)\n	println(tesla.name) // «Майк Тесла»\nПеременные `#this` и `#root`.\nПеременная `#this` всегда определена и ссылается на текущий объект оценки. (против которых разрешаются неквалифицированные ссылки).\nПеременная `#root` всегда определен и ссылается на корневой объект контекста.\nХотя `#this` может варьироваться в зависимости от компонентов выражения оцениваются, `#root` всегда относится к корню.\nПеременные `#this` и `#root`.\nВ следующем примере показано, как использовать переменную #this в сочетании с\nJava\n	// Создайте список простых целых чисел.\n	List<Integer> primes = List.of(2, 3, 5, 7, 11, 13, 17);"}
{"id": 1082, "text": "// Создаём парсер и устанавливаем переменные «простые числа» в качестве списка целых чисел.\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n	context.setVariable(\"primes\", primes);\n	// Выберите из списка все простые числа > 10 (используя выделение ?{...}).\n	String expression = \"#primes.?[#this > 10]\";\n	// Возвращает список, содержащий [11, 13, 17].\n	List<Integer> primesGreaterThanTen =\n			parser.parseExpression(expression).getValue(context, List.class);\nПеременные `#this` и `#root`.\nВ следующем примере показано, как использовать переменные `#this` и `#root` вместе в сочетании с\nJava\n	// Создайте контекст синтаксического анализатора и оценки.\n	ExpressionParser parser = new SpelExpressionParser();\n	EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n	// Создание изобретателя для использования в качестве объекта корневого контекста.\n	Inventor tesla = new Inventor(\"Nikola Tesla\");\n	tesla.setInventions(\"Telephone repeater\", \"Tesla coil transformer\");\n	// Перебираем все изобретения Inventor, на которые ссылается #root\n	// объект и генерируем список строк, содержимое которых имеет вид"}
{"id": 1083, "text": "// «<имя изобретателя> изобрел <изобретение>». (с использованием проекции !{...}).\n	String expression = \"#root.inventions.![#root.name + ' invented the ' + #this + '.']\";\n	// Возвращает список, содержащий:\n	// «Никола Тесла изобрел телефонный ретранслятор».\n	// «Никола Тесла изобрел катушечный трансформатор Теслы».\n	List<String> results = parser.parseExpression(expression)\n			.getValue(context, tesla, List.class);"}
{"id": 1084, "text": "Просмотр контроллеров.\nЭто ярлык для определения ParameterizableViewController, который немедленно пересылает к представлению при вызове.\nВы можете использовать его в статических случаях, когда нет Java-контроллера. логика, которая будет запущена до того, как представление сгенерирует ответ.\nПросмотр контроллеров.\nВ следующем примере запрос `/` перенаправляется в представление под названием `home`: См. пример кода в исходном документе.\nПросмотр контроллеров.\nЕсли метод @RequestMapping сопоставлен с URL-адресом любого метода HTTP, то представление контроллер не может использоваться для обработки одного и того же URL-адреса.\nЭто связано с тем, что совпадение по URL-адресу с аннотированный контроллер считается достаточно убедительным признаком владения конечной точкой, поэтому что ответ 405 (METHOD_NOT_ALLOWED), 415 (UNSUPPORTED_MEDIA_TYPE) или аналогичный может быть отправлен клиенту для помощи в отладке.\nПо этой причине рекомендуется избегать разделение обработки URL-адресов между аннотированным контроллером и контроллером представления."}
{"id": 1085, "text": "Посмотреть резольверы.\nКонфигурация MVC упрощает регистрацию преобразователей представлений.\nПосмотреть резольверы.\nВ следующем примере настраивается разрешение представления согласования содержимого с использованием JSP и Jackson в качестве по умолчанию `View` для рендеринга JSON: См. пример кода в исходном документе.\nПосмотреть резольверы.\nОднако обратите внимание, что для FreeMarker, Groovy Markup и шаблонов сценариев также требуется конфигурация базовой технологии просмотра.\nСледующий пример работает с FreeMarker: См. пример кода в исходном документе."}
{"id": 1086, "text": "КОРС.\nSpring WebFlux позволяет обрабатывать CORS (совместное использование ресурсов между источниками).\nЭтот раздел описывает, как это сделать.\nВведение.\nПо соображениям безопасности браузеры запрещают вызовы AJAX к ресурсам за пределами текущего источника.\nНапример, ваш банковский счет может находиться на одной вкладке, а сайт evil.com — на другой.\nСкрипты от evil.com не должен иметь возможности отправлять AJAX-запросы к API вашего банка с помощью вашего учетные данные - например, снятие денег со своего счета!\nВведение.\nСовместное использование ресурсов между источниками (CORS) — это https://www.w3.org/TR/cors/[спецификация W3C] реализовано https://caniuse.com/#feat=cors[большинством браузеров], что позволяет вам указать какие междоменные запросы разрешены, вместо использования менее безопасных и менее мощные обходные пути на основе IFRAME или JSONP.\nОбработка.\nСпецификация CORS различает предполетные, простые и фактические запросы.\nЧтобы узнать, как работает CORS, вы можете прочитать https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[эта статья], среди многие другие или см. спецификацию для получения более подробной информации.\nОбработка.\nРеализации Spring WebFlux HandlerMapping предоставляют встроенную поддержку CORS.\nПосле успешного сопоставление запроса с обработчиком, HandlerMapping проверяет конфигурацию CORS на наличие данный запрос и обработчик и предпринимает дальнейшие действия."}
{"id": 1087, "text": "Предполетные запросы обрабатываются напрямую, в то время как простые и актуальные запросы CORS перехватываются, проверяются и имеют установлен требуемый набор заголовков ответа CORS.\nОбработка.\nЧтобы включить запросы между источниками (то есть заголовок «Origin» присутствует и отличается от хоста запроса), вам необходимо иметь явно объявленный CORS. конфигурация.\nЕсли соответствующая конфигурация CORS не найдена, заголовки CORS не добавляются. ответы на предполетные, простые и актуальные запросы CORS и, следовательно, браузеры отвергнуть их.\nОбработка.\nКаждое HandlerMapping может быть {spring-framework-api}/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations(java.util.Map)[настроено] индивидуально с сопоставлениями CorsConfiguration на основе шаблонов URL.\nВ большинстве случаев приложения используйте конфигурацию Java WebFlux для объявления таких сопоставлений, что приводит к созданию одного глобальная карта передается во все реализации HandlerMapping.\nОбработка.\nВы можете комбинировать глобальную конфигурацию CORS на уровне HandlerMapping с другими детальная конфигурация CORS на уровне обработчика.\nНапример, аннотированные контроллеры могут использовать Аннотации `@CrossOrigin` на уровне класса или метода (другие обработчики могут реализовать `CorsConfigurationSource`).\nОбработка.\nПравила объединения глобальной и локальной конфигурации обычно аддитивны, например: все глобальное и все локальное происхождение.\nДля тех атрибутов, где может быть указано только одно значение принимаются, например, «allowCredentials» и «maxAge», локальное значение переопределяет глобальное значение."}
{"id": 1088, "text": "См. {spring-framework-api}/web/cors/CorsConfiguration.html#combine(org.springframework.web.cors.CorsConfiguration)[`CorsConfiguration#combine(CorsConfiguration)`] для более подробной информации.\nОбработка. [СОВЕТ] = Чтобы узнать больше из источника или выполнить расширенную настройку, см.:\n* `КорсКонфигурация`\n* `CorsProcessor` и `DefaultCorsProcessor`\n* `AbstractHandlerMapping`\nСертифицированные запросы.\nИспользование CORS с запросами с учетными данными требует включения `allowedCredentials`.\nИмейте в виду, что эта опция устанавливает высокий уровень доверия с настроенными доменами, а также увеличивает поверхность атаки веб-приложения путем раскрытия конфиденциальной информации, специфичной для пользователя такие как файлы cookie и токены CSRF.\nСертифицированные запросы.\nВключение учетных данных также влияет на обработку настроенных подстановочных знаков `\"*\"` CORS:\n* Подстановочные знаки не разрешены в `allowOrigins`, но альтернативно\nСертифицированные запросы.\nСвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.\n* Если установлено значение `allowedHeaders` или `allowedMethods`, `Access-Control-Allow-Headers`\nСертифицированные запросы. и заголовки ответов `Access-Control-Allow-Methods` обрабатываются путем копирования связанных заголовки и метод, указанные в предполетном запросе CORS.\n* Если установлено значение `exposeHeaders`, устанавливается заголовок ответа `Access-Control-Expose-Headers`."}
{"id": 1089, "text": "Сертифицированные запросы. либо к настроенному списку заголовков, либо к подстановочному знаку.\nХотя спецификация CORS не разрешает использование подстановочного знака, если для параметра «Access-Control-Allow-Credentials» установлено значение `true`, большинство браузеров поддерживают его, и не все заголовки ответов доступны во время Обработка CORS, поэтому подстановочный знак является значением заголовка, используемым при указывается независимо от значения свойстваallowCredentials.\nСертифицированные запросы.\nВНИМАНИЕ: Хотя такая конфигурация с подстановочными знаками может быть удобной, рекомендуется, если это возможно, настроить вместо этого используется конечный набор значений для обеспечения более высокого уровня безопасности.\n`@CrossOrigin`. {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`] аннотация позволяет выполнять запросы между источниками к аннотированным методам контроллера, поскольку следующий пример показывает:\nJava\n	@RestController\n	@RequestMapping(\"/account\")\n	public class AccountController {\n		@CrossOrigin\n		@GetMapping(\"/{id}\")\n		public Mono<Account> retrieve(@PathVariable Long id) {\n		@DeleteMapping(\"/{id}\")\n		public Mono<Void> remove(@PathVariable Long id) {\n	@RestController\n	@RequestMapping(\"/account\")\n	class AccountController {\n* Все происхождение.\n* Все заголовки.\n* Все методы HTTP, с которыми сопоставлен метод контроллера."}
{"id": 1090, "text": "По умолчанию @CrossOrigin позволяет:. `allowCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.\nКогда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `\"*\"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.\nПо умолчанию @CrossOrigin позволяет:. `maxAge` установлен на 30 минут.\nПо умолчанию @CrossOrigin позволяет:. `@CrossOrigin` также поддерживается на уровне класса и наследуется всеми методами.\nВ следующем примере указывается определенный домен и для параметра maxAge устанавливается значение часа:\nJava\n	@CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600)\n	@RestController\n	@RequestMapping(\"/account\")\n	public class AccountController {\n		@GetMapping(\"/{id}\")\n		public Mono<Account> retrieve(@PathVariable Long id) {\n		@DeleteMapping(\"/{id}\")\n		public Mono<Void> remove(@PathVariable Long id) {\n	@CrossOrigin(\"https://domain2.com\", maxAge = 3600)\n	@RestController\n	@RequestMapping(\"/account\")\n	class AccountController {\nПо умолчанию @CrossOrigin позволяет:."}
{"id": 1091, "text": "Вы можете использовать @CrossOrigin как на уровне класса, так и на уровне метода. как показано в следующем примере:\nJava\n	@CrossOrigin(maxAge = 3600) // <1>\n	@RestController\n	@RequestMapping(\"/account\")\n	public class AccountController {\n		@CrossOrigin(\"https://domain2.com\") // <2>\n		@GetMapping(\"/{id}\")\n		public Mono<Account> retrieve(@PathVariable Long id) {\n		@DeleteMapping(\"/{id}\")\n		public Mono<Void> remove(@PathVariable Long id) {\nПо умолчанию @CrossOrigin позволяет:. <1> Использование `@CrossOrigin` на уровне класса. <2> Использование `@CrossOrigin` на уровне метода.\n	@CrossOrigin(maxAge = 3600) // <1>\n	@RestController\n	@RequestMapping(\"/account\")\n	class AccountController {\nПо умолчанию @CrossOrigin позволяет:. <1> Использование `@CrossOrigin` на уровне класса. <2> Использование `@CrossOrigin` на уровне метода.\nГлобальная конфигурация.\nВ дополнение к детальной настройке на уровне методов контроллера вы, вероятно, захотите также определите некоторую глобальную конфигурацию CORS.\nВы можете установить CorsConfiguration на основе URL-адреса. сопоставления индивидуально для любого HandlerMapping.\nОднако большинство приложений используют Конфигурация Java WebFlux для этого.\n* Все происхождение.\n* Все заголовки."}
{"id": 1092, "text": "* Методы GET, HEAD и POST.\nПо умолчанию глобальная конфигурация позволяет следующее:. `allowedCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.\nКогда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `\"*\"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.\nПо умолчанию глобальная конфигурация позволяет следующее:. `maxAge` установлен на 30 минут.\nПо умолчанию глобальная конфигурация позволяет следующее:.\nЧтобы включить CORS в конфигурации Java WebFlux, вы можете использовать обратный вызов CorsRegistry: как показано в следующем примере:\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Override\n		public void addCorsMappings(CorsRegistry registry) {\n			registry.addMapping(\"/api/**\")\n				.allowedOrigins(\"https://domain2.com\")\n				.allowedMethods(\"PUT\", \"DELETE\")\n				.allowedHeaders(\"header1\", \"header2\", \"header3\")\n				.exposedHeaders(\"header1\", \"header2\")\n				.allowCredentials(true).maxAge(3600);\n			// Добавить больше сопоставлений...\n	@Configuration\n	class WebConfig : WebFluxConfigurer {"}
{"id": 1093, "text": "registry.addMapping(\"/api/**\")\n					.allowedOrigins(\"https://domain2.com\")\n					.allowedMethods(\"PUT\", \"DELETE\")\n					.allowedHeaders(\"header1\", \"header2\", \"header3\")\n					.exposedHeaders(\"header1\", \"header2\")\n					.allowCredentials(true).maxAge(3600)\n			// Добавить больше сопоставлений...\nCORS `WebFilter`.\nВы можете применить поддержку CORS через встроенный {spring-framework-api}/web/cors/reactive/CorsWebFilter.html[`CorsWebFilter`], который представляет собой хорошо подходит для функциональные конечные точки.\nCORS `WebFilter`.\nПРИМЕЧАНИЕ.\nЕсли вы попытаетесь использовать CorsFilter с Spring Security, имейте в виду, что Spring Безопасность имеет {docs-spring-security}/servlet/integrations/cors.html[встроенную поддержку] для КОРС.\nCORS `WebFilter`.\nЧтобы настроить фильтр, вы можете объявить bean-компонент CorsWebFilter и передать `CorsConfigurationSource` в свой конструктор, как показано в следующем примере:\nJava\n	@Bean\n	CorsWebFilter corsFilter() {\n		CorsConfiguration config = new CorsConfiguration();\n		// Возможно...\n		// config.applyPermitDefaultValues()\n		config.setAllowCredentials(true);\n		config.addAllowedOrigin(\"https://domain1.com\");"}
{"id": 1094, "text": "config.addAllowedHeader(\"*\");\n		config.addAllowedMethod(\"*\");\n		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n		source.registerCorsConfiguration(\"/**\", config);\n		return new CorsWebFilter(source);\n		// Возможно...\n		// config.applyPermitDefaultValues()\n		config.allowCredentials = true\n		config.addAllowedOrigin(\"https://domain1.com\")\n		config.addAllowedHeader(\"*\")\n		config.addAllowedMethod(\"*\")"}
{"id": 1095, "text": "Функциональные конечные точки.\nSpring WebFlux включает WebFlux.fn, облегченную модель функционального программирования, в которой функции используются для маршрутизации и обработки запросов, а контракты разработаны с учетом неизменяемости.\nЭто альтернатива модели программирования на основе аннотаций, но в остальном она работает на тот же фундамент [Reactive Core].\nОбзор.\nВ WebFlux.fn HTTP-запрос обрабатывается с помощью HandlerFunction: функции, которая принимает `ServerRequest` и возвращает задержанный `ServerResponse` (т. е. `Mono<ServerResponse>`).\nИ объект запроса, и объект ответа имеют неизменяемые контракты, которые обеспечивают совместимость с JDK 8. доступ к HTTP-запросу и ответу.\nHandlerFunction — это эквивалент тела метода @RequestMapping в модель программирования на основе аннотаций.\nОбзор.\nВходящие запросы направляются в функцию-обработчик с помощью RouterFunction: функции, которая принимает `ServerRequest` и возвращает задержанную `HandlerFunction` (т. е. `Mono<HandlerFunction>`).\nКогда функция маршрутизатора совпадает, возвращается функция-обработчик; в противном случае пустой Mono.\nRouterFunction — это эквивалент аннотации @RequestMapping, но с основным Разница в том, что функции маршрутизатора предоставляют не только данные, но и поведение.\nОбзор. `RouterFunctions.route()` предоставляет конструктор маршрутизаторов, который упрощает создание маршрутизаторов. как показано в следующем примере:\nJava\n	import static org.springframework.http.MediaType.APPLICATION_JSON;"}
{"id": 1096, "text": "import static org.springframework.web.reactive.function.server.RequestPredicates.*;\n	import static org.springframework.web.reactive.function.server.RouterFunctions.route;\n	PersonRepository repository = ...\n	PersonHandler handler = new PersonHandler(repository);\n	RouterFunction<ServerResponse> route = route() <1>\n		.GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n		.GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople)\n		.POST(\"/person\", handler::createPerson)\n		.build();\n	public class PersonHandler {\n		public Mono<ServerResponse> listPeople(ServerRequest request) {\n		public Mono<ServerResponse> createPerson(ServerRequest request) {\n		public Mono<ServerResponse> getPerson(ServerRequest request) {\nОбзор. <1> Создайте маршрутизатор с помощью `route()`.\nОбзор. <1> Создайте маршрутизатор с помощью маршрутизатора Coroutines DSL; Реактивная альтернатива также доступна через `router { }`.\nОбзор.\nОдин из способов запустить RouterFunction — превратить его в HttpHandler и установить. через один из встроенных адаптеры сервера:\n* `RouterFunctions.toHttpHandler(RouterFunction)`\n* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`\nОбзор.\nБольшинство приложений могут работать через конфигурацию Java WebFlux, см.\nЗапуск сервера."}
{"id": 1097, "text": "ОбработчикФункция. `ServerRequest` и `ServerResponse` — это неизменяемые интерфейсы, совместимые с JDK 8. доступ к HTTP-запросу и ответу.\nИ запрос, и ответ оказывают обратное давление на {reactive-streams-site}[Reactive Streams]. против потоков тела.\nТело запроса представлено Reactor Flux или Mono.\nТело ответа представлено любым издателем Reactive Streams, включая Flux и Mono.\nПодробнее об этом см.\nРеактивные библиотеки.\nСерверный запрос. `ServerRequest` обеспечивает доступ к методу HTTP, URI, заголовкам и параметрам запроса. в то время как доступ к телу предоставляется через методы body.\nJava\nFlux<Person> people = request.bodyToFlux(Person.class);.\nПредыдущие примеры представляют собой ярлыки, использующие более общий вариант ServerRequest.body(BodyExtractor). который принимает интерфейс функциональной стратегии BodyExtractor.\nКласс полезности BodyExtractors предоставляет доступ к ряду экземпляров.\nНапример, предыдущие примеры могут также записать так:\nJava\nFlux<Person> people = request.bodyToFlux(Person.class);.\nMono<String> string = request.body(BodyExtractors.toMono(String.class)); Flux<Person> people = request.body(BodyExtractors.toFlux(Person.class));\nJava\nMono<MultiValueMap<String, String>> map = request.formData();."}
{"id": 1098, "text": "В следующем примере показано, как получить доступ к составным данным в виде карты:\nJava\nMono<MultiValueMap<String, Part>> map = request.multipartData();.\nВ следующем примере показано, как получить доступ к составным данным по одному в потоковом режиме: См. пример кода в исходном документе.\nMono<MultiValueMap<String, Part>> map = request.multipartData();.\nПРИМЕЧАНИЕ.\nСодержимое тела объектов PartEvent должно быть полностью использовано, передано или освобождено во избежание утечек памяти.\nMono<MultiValueMap<String, Part>> map = request.multipartData();.\nНиже показано, как связать параметры запроса, переменные URI или заголовки с помощью DataBinder. а также показывает, как настроить DataBinder: См. пример кода в исходном документе.\nОтвет сервера. `ServerResponse` обеспечивает доступ к HTTP-ответу, и, поскольку он неизменяем, вы можете использовать метод `build` для его создания.\nВы можете использовать конструктор, чтобы установить статус ответа, добавить ответ заголовки или предоставить тело.\nВ следующем примере создается ответ 200 (ОК) с JSON. содержание: См. пример кода в исходном документе.\nОтвет сервера.\nВ следующем примере показано, как создать ответ 201 (CREATED) с заголовком Location и без тела:\nJava\nURI location =... return ServerResponse.created(location).build();."}
{"id": 1099, "text": "В зависимости от используемого кодека можно передавать параметры подсказки, чтобы настроить способ тело сериализуется или десериализуется.\nНапример, чтобы указать {baeldung-blog}/jackson-json-view-annotation[представление JSON Джексона]:\nJava\nКлассы обработчиков.\nМы можем написать функцию-обработчик в виде лямбды, как показано в следующем примере:\nJava\nКлассы обработчиков.\nHandlerFunction<ServerResponse> helloWorld = request -> ServerResponse.ok().bodyValue(\"Hello World\");\nКлассы обработчиков.\nЭто удобно, но в приложении нам нужно несколько функций и несколько встроенных лямбда может запутаться.\nПоэтому полезно сгруппировать связанные функции-обработчики в класс обработчиков, который имеет ту же роль, что и `@Controller` в приложении на основе аннотаций.\nНапример, следующий класс предоставляет реактивный репозиторий Person: См. пример кода в исходном документе.\nВалидация.\nФункциональная конечная точка может использовать Spring средства проверки для применить проверку к телу запроса.\nНапример, учитывая пользовательский Spring См. пример кода в исходном документе.\nВалидация.\nОбработчики также могут использовать стандартный API проверки компонентов (JSR-303), создавая и внедряя глобальный экземпляр Validator, основанный на LocalValidatorFactoryBean.\nСм.\nSpring Validation.\n`RouterFunction`.\nФункции маршрутизатора используются для маршрутизации запросов к соответствующей функции HandlerFunction."}
{"id": 1100, "text": "Обычно вы не пишете функции маршрутизатора самостоятельно, а используете метод на Утилита RouterFunctions для его создания. `RouterFunctions.route()` (без параметров) предоставляет вам удобный конструктор для создания маршрутизатора. функция, тогда как RouterFunctions.route(RequestPredicate, HandlerFunction) предлагает прямой путь создать роутер.\n`RouterFunction`.\nКак правило, рекомендуется использовать построитель `route()`, поскольку он обеспечивает удобные ярлыки для типичных сценариев картографии, не требующие сложного обнаружения статический импорт.\nНапример, построитель функций маршрутизатора предлагает метод GET(String, HandlerFunction) создать сопоставление для GET-запросов; и POST(String, HandlerFunction) для POST.\n`RouterFunction`.\nПомимо сопоставления на основе HTTP-метода, построитель маршрутов предлагает способ введения дополнительных предикаты при сопоставлении с запросами.\nДля каждого метода HTTP существует перегруженный вариант, который принимает RequestPredicate в качестве параметр, через который могут быть выражены дополнительные ограничения.\nПредикаты.\nВы можете написать свой собственный RequestPredicate, но служебный класс RequestPredicates предлагает встроенные возможности для общих нужд сопоставления на основе метода HTTP, запроса путь, заголовки, версия API и многое другое.\nПредикаты.\nВ следующем примере используется заголовок Accept, предикат запроса: См. пример кода в исходном документе.\n* `RequestPredicate.and(RequestPredicate)` -- оба должны совпадать.\n* `RequestPredicate.or(RequestPredicate)` — любой из них может совпадать."}
{"id": 1101, "text": "Вы можете составить несколько предикатов запроса вместе, используя:.\nМногие предикаты из RequestPredicates являются составными.\nНапример, RequestPredicates.GET(String)` состоит из RequestPredicates.method(HttpMethod)` и `RequestPredicates.path(String)`.\nВ приведенном выше примере также используются два предиката запроса, поскольку построитель использует `RequestPredicates.GET` внутренне и объединяет его с предикатом `accept`.\nМаршруты.\nФункции маршрутизатора оцениваются по порядку: если первый маршрут не совпадает, то оценивается второй и так далее.\nПоэтому имеет смысл объявлять более конкретные маршруты перед общими.\nЭто также важно при регистрации функций маршрутизатора в качестве bean-компонентов Spring. быть описаны позже.\nОбратите внимание, что это поведение отличается от модели программирования на основе аннотаций, где «Наиболее конкретный» метод контроллера выбирается автоматически.\nМаршруты.\nПри использовании конструктора функций маршрутизатора все определенные маршруты объединяются в один. `RouterFunction`, возвращаемая из `build()`.\nСуществуют и другие способы объединения нескольких функций маршрутизатора:\n* `add(RouterFunction)` в конструкторе `RouterFunctions.route()`\n* `RouterFunction.and(RouterFunction)`\n* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` -- ярлык для\nМаршруты. `RouterFunction.and()` с вложенным `RouterFunctions.route()`.\nМаршруты.\nВ следующем примере показан состав четырех маршрутов: См. пример кода в исходном документе."}
{"id": 1102, "text": "Вложенные маршруты.\nОбычно группа функций маршрутизатора имеет общий предикат, например общий путь.\nВ приведенном выше примере общий предикат будет предикатом пути, который соответствует `/person`, используемому тремя маршрутами.\nПри использовании аннотаций вы должны удалить это дублирование с помощью аннотации @RequestMapping на уровне типа, которая сопоставляется с `/человек`.\nВ WebFlux.fn предикаты пути могут быть разделены с помощью метода path на построитель функций маршрутизатора.\nНапример, последние несколько строк приведенного выше примера могут быть улучшено следующим образом за счет использования вложенных маршрутов:\nJava\n	.path(\"/person\", builder -> builder // <1>\n		.GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n		.GET(accept(APPLICATION_JSON), handler::listPeople)\n		.POST(handler::createPerson))\n	.build();\nRouterFunction<ServerResponse> route = route(). <1> Обратите внимание, что второй параметр `path` — это потребитель, который принимает сборщик маршрутизатора.\nRouterFunction<ServerResponse> route = route(). <1> Создайте маршрутизатор с помощью маршрутизатора Coroutines DSL; Реактивная альтернатива также доступна через `router { }`.\nRouterFunction<ServerResponse> route = route().\nХотя вложение на основе пути является наиболее распространенным, вы можете вложить любой тип предиката, используя метод `nest` в конструкторе."}
{"id": 1103, "text": "Вышеупомянутое все еще содержит некоторое дублирование в виде общего предиката заголовка Accept.\nМы можем улучшить ситуацию, используя метод «nest» вместе с «accept»:\nJava\n	RouterFunction<ServerResponse> route = route()\n		.path(\"/person\", b1 -> b1\n			.nest(accept(APPLICATION_JSON), b2 -> b2\n				.GET(\"/{id}\", handler::getPerson)\n				.GET(handler::listPeople))\n			.POST(handler::createPerson))\n		.build();\nВерсия API.\nФункции маршрутизатора поддерживают сопоставление по версии API.\nВерсия API.\nСначала включите управление версиями API в используйте `version` predicate следующим образом:\nJava\n	RouterFunction<ServerResponse> route = RouterFunctions.route()\n		.GET(\"/hello-world\", version(\"1.2\"),\n			request -> ServerResponse.ok().bodyValue(\"Hello World\")).build();\n- Фиксированная версия (\"1.2\") — соответствует только данной версии.\n- Базовая версия (\"1.2+\") — соответствует данной версии и выше, вплоть до самой высокой.\nПредикат `version` может быть:.\nСм.\nВерсии API для получения более подробной информации об основных инфраструктура и поддержка управления версиями API.\nОбслуживание ресурсов.\nWebFlux.fn предоставляет встроенную поддержку обслуживания ресурсов."}
{"id": 1104, "text": "Обслуживание ресурсов.\nПРИМЕЧАНИЕ.\nВ дополнение к возможностям, описанным ниже, можно реализовать еще более гибкое управление ресурсами благодаря {spring-framework-api}++/web/reactive/function/server/RouterFunctions.html#resources(java.util.function.Function)++[`RouterFunctions#resource(java.util.function.Function)`].\nПеренаправление на ресурс.\nМожно перенаправить запросы, соответствующие указанному предикату, на ресурс.\nЭто может быть полезно, например, для обработки перенаправлений в одностраничных приложениях.\nJava\n	ClassPathResource index = new ClassPathResource(\"static/index.html\");\n	RequestPredicate spaPredicate = path(\"/api/**\").or(path(\"/error\")).negate();\n	RouterFunction<ServerResponse> redirectToIndex = route()\n		.resource(spaPredicate, index)\n		.build();\nОбслуживание ресурсов из корневого расположения.\nТакже возможно маршрутизировать запросы, соответствующие заданному шаблону, к ресурсам относительно заданного корневого местоположения.\nJava\n    Resource location = new FileUrlResource(\"public-resources/\");\n    RouterFunction<ServerResponse> resources = RouterFunctions.resources(\"/resources/**\", location);\nЗапуск сервера.\nКак запустить функцию маршрутизатора на HTTP-сервере?\nПростой вариант — переделать роутер функцию для `HttpHandler`, используя одно из следующих действий:"}
{"id": 1105, "text": "* `RouterFunctions.toHttpHandler(RouterFunction)`\n* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`\nЗапуск сервера.\nЗатем вы можете использовать возвращенный HttpHandler с рядом серверных адаптеров, выполнив следующие действия:\nЗапуск сервера.\nБолее типичный вариант, также используемый Spring Boot, — запуск с помощью компоненты, необходимые для обработки запросов.\nКонфигурация Java WebFlux объявляет следующее: компоненты инфраструктуры для поддержки функциональных конечных точек:\n* `RouterFunctionMapping`: обнаруживает один или несколько bean-компонентов `RouterFunction<?>` в Spring.\nЗапуск сервера. конфигурация, упорядочивает их, объединяет их посредством RouterFunction.andOther и направляет запросы в результирующую функцию RouterFunction.\n* HandlerFunctionAdapter: простой адаптер, позволяющий вызывать DispatcherHandler.\nЗапуск сервера.\nHandlerFunction, сопоставленный с запросом.\n* `ServerResponseResultHandler`: обрабатывает результат вызова\nЗапуск сервера.\nHandlerFunction, вызвав метод writeTo для ServerResponse.\nЗапуск сервера.\nПредыдущие компоненты позволяют функциональным конечным точкам соответствовать запросу DispatcherHandler. жизненный цикл обработки, а также (потенциально) запускаться параллельно с аннотированными контроллерами, если любые объявлены.\nИменно так функциональные конечные точки включаются с помощью Spring Boot WebFlux. стартер.\nЗапуск сервера.\nВ следующем примере показана конфигурация Java WebFlux (см.\nJava\n	@Configuration\n	public class WebConfig implements WebFluxConfigurer {\n		@Bean\n		public RouterFunction<?> routerFunctionA() {\n		@Bean\n		public RouterFunction<?> routerFunctionB() {\n		@Override\n		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {"}
{"id": 1106, "text": "// настроить преобразование сообщений...\n		@Override\n		public void addCorsMappings(CorsRegistry registry) {\n			// настроить CORS...\n		@Override\n		public void configureViewResolvers(ViewResolverRegistry registry) {\n			// настраиваемое разрешение просмотра для рендеринга HTML...\n	@Configuration\n	class WebConfig : WebFluxConfigurer {\nФильтрация функций-обработчиков.\nВы можете фильтровать функции обработчика, используя методы «before», «after» или «filter» в маршрутизации. конструктор функций.\nС помощью аннотаций вы можете добиться аналогичной функциональности, используя @ControllerAdvice, ServletFilter или оба.\nФильтр будет применяться ко всем маршрутам, построенным строителем.\nЭто означает, что фильтры, определенные во вложенных маршрутах, не применяются к маршрутам «верхнего уровня».\nНапример, рассмотрим следующий пример:\nJava\n	RouterFunction<ServerResponse> route = route()\n		.path(\"/person\", b1 -> b1\n			.nest(accept(APPLICATION_JSON), b2 -> b2\n				.GET(\"/{id}\", handler::getPerson)\n				.GET(handler::listPeople)\n				.before(request -> ServerRequest.from(request) // <1>\n					.header(\"X-RequestHeader\", \"Value\")\n					.build()))\n			.POST(handler::createPerson))\n		.after((request, response) -> logResponse(response)) // <2>"}
{"id": 1107, "text": ".build();\nФильтрация функций-обработчиков. <1> Фильтр «before», который добавляет пользовательский заголовок запроса, применяется только к двум маршрутам GET. <2> Фильтр «after», регистрирующий ответ, применяется ко всем маршрутам, включая вложенные.\nФильтрация функций-обработчиков.\nМетод filter в конструкторе маршрутизатора принимает HandlerFilterFunction: функция, которая принимает ServerRequest и HandlerFunction и возвращает ServerResponse.\nПараметр функции-обработчика представляет следующий элемент в цепочке.\nОбычно это обработчик, на который перенаправляется, но это также может быть другой фильтровать, если применено несколько.\nФильтрация функций-обработчиков.\nТеперь мы можем добавить к нашему маршруту простой фильтр безопасности, предполагая, что у нас есть SecurityManager, который может определить, разрешен ли конкретный путь.\nВ следующем примере показано, как это сделать: См. пример кода в исходном документе.\nФильтрация функций-обработчиков.\nПредыдущий пример демонстрирует, что вызов next.handle(ServerRequest) не является обязательным.\nМы разрешаем запуск функции-обработчика только тогда, когда доступ разрешен.\nФильтрация функций-обработчиков.\nПомимо использования метода фильтра в конструкторе функций маршрутизатора, можно применить отфильтровать существующую функцию маршрутизатора через `RouterFunction.filter(HandlerFilterFunction)`."}
{"id": 1108, "text": "HTTP-клиент службы.\nSpring Frameworks позволяет определить службу HTTP как интерфейс Java с HTTP. методы обмена.\nЗатем вы можете создать прокси, реализующий этот интерфейс, и осуществляет обмены.\nЭто помогает упростить удаленный доступ по HTTP и предоставляет дополнительные возможности. гибкость в выборе стиля API, например синхронного или реактивного.\nHTTP-клиент службы.\nПодробности см. в Клиенты службы HTTP."}
{"id": 1109, "text": "Реактивные библиотеки. `spring-webflux` зависит от `reactor-core` и использует его внутри себя для создания асинхронных логику и обеспечить поддержку Reactive Streams.\nОбычно API WebFlux возвращают Flux или `Mono` (поскольку они используются внутри) и снисходительно принимать любые реактивные потоки.\nРеализация `Publisher` в качестве входных данных.\nЕсли указан «Издатель», его можно рассматривать только как поток с неизвестной семантикой (0..N).\nОднако, если семантика известна, вместо этого вам следует обернуть ее с помощью Flux или Mono.from(Publisher). передачи необработанного `Publisher`.\nИспользование «Flux» вместо «Mono» важно, потому что оно помогает выразить кардинальность. например, ожидается ли одно или несколько асинхронных значений, и это может быть важно для принятия решений (например, при кодировании или декодировании HTTP-сообщений)."}
{"id": 1110, "text": "Тестирование.\nМодуль Spring-test предоставляет макет реализации ServerHttpRequest, «ServerHttpResponse» и «ServerWebExchange».\nСм.\nSpring Web Reactive для обсуждение макетов объектов.\nТестирование. объекты ответа для обеспечения поддержки тестирования приложений WebFlux без HTTP сервер.\nВы также можете использовать WebTestClient для комплексных интеграционных тестов."}
{"id": 1111, "text": "Управление версиями API.\nSpring WebFlux поддерживает управление версиями API.\nВ этом разделе представлен обзор поддержки и лежащие в основе стратегии.\n- Настройте ссылку:web/webflux/config.adoc#webflux-config-api-version[версии API]\n- Запросы карты\n- Запросы маршрутизации\nк функциональным конечным точкам с версией API.\nПоддержка клиента для управления версиями API доступна также в RestClient, WebClient и для тестирования в `WebTestClient`.\nApiVersionStrategy.\nЭто центральная стратегия управления версиями API, которая сохраняет все настроенные предпочтения. связанные с управлением версиями.\nОн делает следующее:\n- Разрешает версии из запросов через ApiVersionResolver\n- Анализирует необработанные значения версии в `Comparable<?>` с помощью ApiVersionParser\n- Проверяет версии запроса\nApiVersionStrategy помогает сопоставлять запросы с методами контроллера @RequestMapping. и инициализируется конфигурацией WebFlux.\nОбычно приложения не взаимодействуют непосредственно с ним.\nАпиверсионрезольвер.\nЭта стратегия определяет версию API из запроса.\nКонфигурация WebFlux предоставляет встроенный параметры для разрешения из заголовка, параметра запроса, параметра типа носителя, или из URL-пути.\nВы также можете использовать собственный ApiVersionResolver.\nАпиверсионрезольвер.\nПРИМЕЧАНИЕ.\nСопоставитель пути всегда разрешает версию из указанного сегмента пути или в противном случае вызывает InvalidApiVersionException, и поэтому он не может уступить место другим резольверы.\nApiVersionParser.\nЭта стратегия помогает анализировать необработанные значения версий в `Comparable<?>`, что помогает сравнивайте, сортируйте и выбирайте версии."}
{"id": 1112, "text": "По умолчанию встроенный SemanticApiVersionParser. анализирует версию на целочисленные значения `major`, `minor` и `patWebFluxch`.\nМинор и патч значения устанавливаются на 0, если они отсутствуют.\nВалидация.\nЕсли версия запроса не поддерживается, возникает исключение InvalidApiVersionException. в ответе 400.\nПо умолчанию список поддерживаемых версий инициализируется из объявленного версии в аннотированных сопоставлениях контроллеров, но вы можете отключить это с помощью флага в WebFlux и используйте только версии, явно настроенные в конфигурации.\nВалидация.\nПо умолчанию версия требуется, если включено управление версиями API.\nВызывается MissingApiVersionException, что приводит к ответу 400, если его нет.\nВы можете сделать его необязательным, и в этом случае будет использоваться самая последняя версия.\nВы также можете указать версию по умолчанию для использования.\nApiVersionDeprecationHandler.\nЭту стратегию можно настроить на отправку подсказок и информации об устаревших версиях клиентов через заголовки ответов.\nВстроенный `StandardApiVersionDeprecationHandler` можно установить заголовки «Устаревание», «Закат» и «Ссылка», как определено в https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].\nВы также можете настроить индивидуальный обработчик для разных заголовков.\nЗапросить сопоставление. `ApiVersionStrategy` поддерживает сопоставление запросов с аннотированными методами контроллера."}
{"id": 1113, "text": "См. ссылку:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-version[Версии API] для более подробной информации."}
{"id": 1114, "text": "Посмотреть технологии.\nРендеринг представлений в Spring WebFlux является подключаемым.\nЕсли вы решите использование Thymeleaf, FreeMarker или какой-либо другой технологии просмотра — это, прежде всего, вопрос изменение конфигурации.\nВ этой главе рассматриваются технологии представления, интегрированные со Spring.\nВебФлюкс.\nПосмотреть технологии.\nДополнительную информацию о рендеринге представления см. в Разрешение просмотра.\nПосмотреть технологии.\nВНИМАНИЕ: представления приложения Spring WebFlux находятся внутри внутренних границ доверия. приложения.\nПредставления имеют доступ к компонентам в контексте приложения, и, поскольку поэтому мы не рекомендуем использовать поддержку шаблонов Spring WebFlux в приложениях, где шаблоны доступны для редактирования из внешних источников, поскольку это может иметь последствия для безопасности.\nТимелиф.\nThymeleaf — это современный серверный механизм шаблонов Java, который подчеркивает естественный HTML. шаблоны, которые можно просмотреть в браузере двойным щелчком мыши, что очень удобно. полезно для самостоятельной работы над шаблонами пользовательского интерфейса (например, дизайнером) без необходимости работающий сервер.\nThymeleaf предлагает обширный набор функций и активно развивается. и поддерживается.\nБолее полное введение см. https://www.thymeleaf.org/Домашняя страница проекта [Thymeleaf].\nТимелиф.\nИнтеграция Thymeleaf с Spring WebFlux управляется проектом Thymeleaf. конфигурация включает в себя несколько объявлений bean-компонентов, таких как SpringResourceTemplateResolver, SpringWebFluxTemplateEngine и `ThymeleafReactiveViewResolver`."}
{"id": 1115, "text": "Более подробную информацию см. https://www.thymeleaf.org/documentation.html[Thymeleaf+Spring] и интеграция WebFlux https://web.archive.org/web/20210623051330/http%3A//forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html[объявление].\nFreeMarker. https://freemarker.apache.org/[Apache FreeMarker] — это шаблонизатор для создания любых вид вывода текста из HTML на электронную почту и другие.\nSpring Framework имеет встроенный интеграция для использования Spring WebFlux с шаблонами FreeMarker.\nПросмотр конфигурации.\nВ следующем примере показано, как настроить FreeMarker в качестве технологии просмотра:\nJava\n	@Configuration\n	public class WebConfiguration implements WebFluxConfigurer {\n		@Override\n		public void configureViewResolvers(ViewResolverRegistry registry) {\n			registry.freeMarker();\n		// Настроить FreeMarker...\n		@Bean\n		public FreeMarkerConfigurer freeMarkerConfigurer() {\n			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n			configurer.setTemplateLoaderPath(\"classpath:/templates/freemarker\");\n			return configurer;\n	@Configuration\n	class WebConfiguration : WebFluxConfigurer {\n		// Настроить FreeMarker...\nПросмотр конфигурации.\nВаши шаблоны должны храниться в каталоге, указанном в `FreeMarkerConfigurer`. показано в предыдущем примере."}
{"id": 1116, "text": "Учитывая предыдущую конфигурацию, если ваш контроллер возвращает имя представления, `добро пожаловать`, преобразователь ищет `classpath:/templates/freemarker/welcome.ftl` шаблон.\nКонфигурация FreeMarker.\nВы можете передать «Настройки» и «SharedVariables» FreeMarker непосредственно во FreeMarker.\nОбъект `Configuration` (который управляется Spring), установив соответствующий bean-компонент свойства bean-компонента FreeMarkerConfigurer.\nДля свойства freemarkerSettings требуется объект `java.util.Properties`, а свойство `freemarkerVariables` требует `java.util.Map`.\nВ следующем примере показано, как использовать FreeMarkerConfigurer:\nJava\n	@Configuration\n	public class WebConfiguration implements WebFluxConfigurer {\n		@Bean\n		public FreeMarkerConfigurer freeMarkerConfigurer() {\n			Map<String, Object> variables = new HashMap<>();\n			variables.put(\"xml_escape\", new XmlEscape());\n			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n			configurer.setTemplateLoaderPath(\"classpath:/templates\");\n			configurer.setFreemarkerVariables(variables);\n			return configurer;\n	@Configuration\n	class WebConfiguration : WebFluxConfigurer {\nКонфигурация FreeMarker.\nПодробную информацию о настройках и переменных см. в документации FreeMarker. объект «Конфигурация».\nОбработка формы.\nSpring предоставляет библиотеку тегов для использования в JSP, которая содержит, среди прочего, Элемент `<spring:bind/>`."}
{"id": 1117, "text": "Этот элемент в первую очередь позволяет формам отображать значения из объекты поддержки формы и отображать результаты неудачных проверок со стороны «Валидатора» в веб- или бизнес-уровень.\nSpring также поддерживает ту же функциональность в FreeMarker. с дополнительными удобными макросами для генерации самих элементов ввода формы.\nМакросы привязки.\nСтандартный набор макросов поддерживается в файле Spring-webflux.jar для FreeMarker, поэтому они всегда доступны для соответствующим образом настроенного приложения.\nМакросы привязки.\nНекоторые макросы, определенные в библиотеках шаблонов Spring, считаются внутренними. (частный), но в определениях макросов такой области действия не существует, что делает все макросы видимыми. к вызывающему коду и пользовательским шаблонам.\nСледующие разделы посвящены только макросам. вам нужно напрямую позвонить из ваших шаблонов.\nЕсли вы хотите просмотреть код макроса напрямую, файл называется `spring.ftl` и находится в папке Пакет `org.springframework.web.reactive.result.view.freemarker`.\nМакросы привязки.\nДополнительные сведения о поддержке привязки см. в статье Simple Binding. для Spring MVC.\nФормировать макросы.\nПодробную информацию о поддержке макросов форм Spring для шаблонов FreeMarker см. по следующему адресу. разделы документации Spring MVC.\n* Входные макросы\n* Поля ввода\n* Поля выбора\n* Эскейпирование HTML\nПредставления сценариев.\nSpring Framework имеет встроенную интеграцию для использования Spring WebFlux с любыми библиотека шаблонов, которая может работать поверх {JSR}223[JSR-223] Механизм сценариев Java."}
{"id": 1118, "text": "В следующей таблице показаны библиотеки шаблонов, которые мы тестировали на различных механизмах сценариев:\nПредставления сценариев. [%заголовок] |=== |Библиотека сценариев |Скриптовый механизм |https://docs.ruby-lang.org/en/master/ERB.html[ERB] |https://www.jruby.org[JRuby] |https://docs.python.org/2/library/string.html#template-strings[Шаблоны строк] |https://www.jython.org/[Jython] |===\nПредставления сценариев.\nСОВЕТ: Основное правило интеграции любого другого механизма сценариев заключается в том, что он должен реализовать Интерфейсы `ScriptEngine` и `Invocable`.\nТребования.\nВам необходимо иметь механизм сценариев в вашем пути к классам, детали которого зависят от механизма сценариев:\n* https://www.jruby.org[JRuby] следует добавить в качестве зависимости для поддержки Ruby.\n* https://www.jython.org[Jython] следует добавить в качестве зависимости для поддержки Python.\nШаблоны сценариев.\nВы можете объявить bean-компонент `ScriptTemplateConfigurer`, чтобы указать используемый механизм сценариев: файлы сценариев для загрузки, какую функцию вызывать для рендеринга шаблонов и т. д.\nВ следующем примере используется движок Jython Python:\nJava\n	@Configuration\n	public class WebConfiguration implements WebFluxConfigurer {\n		@Override"}
{"id": 1119, "text": "public void configureViewResolvers(ViewResolverRegistry registry) {\n			registry.scriptTemplate();\n		@Bean\n		public ScriptTemplateConfigurer configurer() {\n			ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n			configurer.setEngineName(\"jython\");\n			configurer.setScripts(\"render.py\");\n			configurer.setRenderFunction(\"render\");\n			return configurer;\n	@Configuration\n	class WebConfiguration : WebFluxConfigurer {\n* `Шаблон строки`: содержимое шаблона.\n* `Модель карты`: модель представления.\n* `RenderingContext renderingContext`:\nФункция рендеринга вызывается со следующими параметрами:. {spring-framework-api}/web/servlet/view/script/RenderingContext.html[`RenderingContext`] который предоставляет доступ к контексту приложения, локали, загрузчику шаблонов и URL-адрес\nФункция рендеринга вызывается со следующими параметрами:.\nОзнакомьтесь с модульными тестами Spring Framework, {spring-framework-code}/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script[Java] и {spring-framework-code}/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script[resources], дополнительные примеры конфигурации."}
{"id": 1120, "text": "HTML-фрагмент. https://htmx.org/[HTMX] и https://turbo.hotwired.dev/[Hotwire Turbo] подчеркивают Подход «HTML по сети», при котором клиенты получают обновления сервера в формате HTML, а не в формате JSON.\nЭто позволяет использовать преимущества SPA (одностраничного приложения) без необходимости писать много или даже любой JavaScript.\nДля получения хорошего обзора и получения дополнительной информации посетите соответствующие веб-сайты.\nHTML-фрагмент.\nВ Spring WebFlux рендеринг представления обычно включает указание одного представления и одной модели.\nОднако в HTML-по-проводной связи общей возможностью является отправка нескольких фрагментов HTML, которые браузер может использовать для обновления различных частей страницы.\nДля этого методы контроллера может вернуть `Collection<Fragment>`.\nНапример:\nJava\n	@GetMapping\n	List<Fragment> handle() {\n		return List.of(Fragment.create(\"posts\"), Fragment.create(\"comments\"));\nJava\n	@GetMapping\n	FragmentsRendering handle() {\n		return FragmentsRendering.fragment(\"posts\").fragment(\"comments\").build();\nТо же самое можно сделать, вернув выделенный тип FragmentsRendering:.\nКаждый фрагмент может иметь независимую модель, и эта модель наследует атрибуты от общая модель для запроса.\nТо же самое можно сделать, вернув выделенный тип FragmentsRendering:."}
{"id": 1121, "text": "HTMX и Hotwire Turbo поддерживают потоковую передачу обновлений через SSE (события, отправляемые сервером).\nКонтроллер может создать FragmentsRendering с помощью Flux<Fragment> или любого другого реактивный производитель, адаптируемый к «Издателю» Reactive Streams через «ReactiveAdapterRegistry».\nТакже возможно вернуть Flux<Fragment> напрямую без FragmentsRendering. обертка.\nJSON и XML.\nДля ссылки:web/webflux/dispatcher-handler.adoc#webflux-multiple-representations[Согласование контента] Для целей полезно иметь возможность чередовать рендеринг модели с помощью HTML-шаблона. или в других форматах (например, JSON или XML), в зависимости от типа контента, запрошенного клиентом.\nДля поддержки этого Spring WebFlux предоставляет HttpMessageWriterView, который вы можете использовать для подключите любой из доступных Codecs из «spring-web», например «JacksonJsonEncoder», «JacksonSmileEncoder» или «Jaxb2XmlEncoder».\nJSON и XML.\nВ отличие от других технологий просмотра, HttpMessageWriterView не требует ViewResolver, но вместо этого в качестве представления по умолчанию используется настроено.\nВы можете настроить одно или несколько таких представлений по умолчанию, обернув разные экземпляры HttpMessageWriter. или экземпляры `Encoder`.\nТот, который соответствует запрошенному типу контента, используется во время выполнения.\nJSON и XML.\nВ большинстве случаев модель содержит несколько атрибутов.\nЧтобы определить, какой из них сериализовать, вы можете настроить HttpMessageWriterView с именем атрибута модели, который будет использоваться для рендеринг."}
{"id": 1122, "text": "Если модель содержит только один атрибут, используется именно он."}
{"id": 1123, "text": "Веб-клиент.\nSpring WebFlux включает клиент для выполнения HTTP-запросов. `WebClient` имеет функциональный, свободный API на основе Reactor (см.\nReactive Libraries) что позволяет декларативную композицию асинхронной логики без необходимости иметь дело с потоки или параллелизм.\nОн полностью неблокирующий, поддерживает потоковую передачу и опирается на те же ссылки:web/webflux/reactive-spring.adoc#webflux-codecs[кодеки], которые также используются для кодирования и декодировать содержимое запроса и ответа на стороне сервера.\nВеб-клиент. `WebClient` нуждается в клиентской библиотеке HTTP для выполнения запросов.\nЕсть встроенный поддержка следующего:\n* {reactor-github-org}/reactor-netty[Reactor Netty]\n* {java-api}/java.net.http/java/net/http/HttpClient.html[JDK HttpClient]\n* Jetty Reactive HttpClient: https://github.com/jetty-project/jetty-reactive-httpclient\n* https://hc.apache.org/index.html[Apache HttpComponents]\n* Остальные можно подключить через ClientHttpConnector."}
{"id": 1124, "text": "Вебсокеты.\nВ этой части справочной документации рассматривается поддержка WebSocket с реактивным стеком. обмен сообщениями.\nAPI веб-сокетов.\nSpring Framework предоставляет API WebSocket, который можно использовать для написания клиентских и серверные приложения, обрабатывающие сообщения WebSocket.\nСервер.\nЧтобы создать сервер WebSocket, вы можете сначала создать WebSocketHandler.\nВ следующем примере показано, как это сделать:\nJava\n	import org.springframework.web.reactive.socket.WebSocketHandler;\n	import org.springframework.web.reactive.socket.WebSocketSession;\n	public class MyWebSocketHandler implements WebSocketHandler {\n		@Override\n		public Mono<Void> handle(WebSocketSession session) {\n	class MyWebSocketHandler : WebSocketHandler {\nJava\n	@Configuration\n	class WebConfig {\n		@Bean\n		public HandlerMapping handlerMapping() {\n			Map<String, WebSocketHandler> map = new HashMap<>();\n			map.put(\"/path\", new MyWebSocketHandler());\n			int order = -1; // before annotated controllers\n			return new SimpleUrlHandlerMapping(map, order);\n	@Configuration\n	class WebConfig {\n			return SimpleUrlHandlerMapping(map, order)\nЗатем вы можете сопоставить его с URL-адресом:.\nПри использовании WebFlux Config ничего не происходит. что делать дальше, или иначе, если вы не используете конфигурацию WebFlux, вам нужно будет объявить `WebSocketHandlerAdapter`, как показано ниже:\nJava\n	@Configuration\n	class WebConfig {\n		@Bean\n		public WebSocketHandlerAdapter handlerAdapter() {\n			return new WebSocketHandlerAdapter();\n	@Configuration"}
{"id": 1125, "text": "class WebConfig {\n`WebSocketHandler`.\nМетод handle объекта WebSocketHandler принимает WebSocketSession и возвращает Mono<Void>. чтобы указать, когда обработка сеанса приложением завершена.\nСессия обрабатывается через два потока: один для входящих и один для исходящих сообщений.\nСледующая таблица описывает два метода, которые обрабатывают потоки:\n[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание. | `Flux<WebSocketMessage> get()` | Предоставляет доступ к потоку входящих сообщений и завершается при закрытии соединения.\n[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание. | `Mono<Void> send(Publisher<WebSocketMessage>)` | Берет источник исходящих сообщений, записывает сообщения и возвращает `Mono<Void>`, который завершается, когда исходный код завершается и запись завершается.\n[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание. `WebSocketHandler` должен объединить входящие и исходящие потоки в единый поток и верните `Mono<Void>`, который отражает завершение этого потока.\nВ зависимости от применения требований, единый поток завершается, когда:\n* Завершается либо входящий, либо исходящий поток сообщений.\n* Входящий поток завершается (то есть соединение закрывается), а исходящий поток бесконечен.\n* В выбранной точке с помощью метода close метода WebSocketSession."}
{"id": 1126, "text": "[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание.\nКогда потоки входящих и исходящих сообщений объединены вместе, нет необходимости проверьте, открыто ли соединение, поскольку Reactive Streams сигнализирует о завершении активности.\nВходящий поток получает сигнал завершения или ошибки, а исходящий поток получает сигнал отмены.\n[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание.\nСамая базовая реализация обработчика — это та, которая обрабатывает входящий поток. следующий пример показывает такую реализацию:\nJava\n	class ExampleHandler implements WebSocketHandler {\n		@Override\n		public Mono<Void> handle(WebSocketSession session) {\n			return session.receive()			// <1>\n					.doOnNext(message -> {\n						// ...					// <2>\n					.concatMap(message -> {\n						// ...					// <3>\n					.then();					// <4>\n[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание. <1> Доступ к потоку входящих сообщений. <2> Сделайте что-нибудь с каждым сообщением. <3> Выполнять вложенные асинхронные операции, использующие содержимое сообщения. <4> Возвращает `Mono<Void>`, который завершается после завершения приема.\n	class ExampleHandler : WebSocketHandler {"}
{"id": 1127, "text": "[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание. <1> Доступ к потоку входящих сообщений. <2> Сделайте что-нибудь с каждым сообщением. <3> Выполнять вложенные асинхронные операции, использующие содержимое сообщения. <4> Возвращает `Mono<Void>`, который завершается после завершения приема.\n[options=\"заголовок\"] |=== | Метод `WebSocketSession` | Описание.\nСОВЕТ: Для вложенных асинхронных операций вам может потребоваться вызвать `message.retain()` на базовом уровне. серверы, использующие объединенные буферы данных (например, Netty).\nВ противном случае буфер данных может быть выпущен до того, как вы успели прочитать данные.\nДополнительную информацию см.\nJava\n	class ExampleHandler implements WebSocketHandler {\n		@Override\n		public Mono<Void> handle(WebSocketSession session) {\n			Flux<WebSocketMessage> output = session.receive()				// <1>\n					.doOnNext(message -> {\n					.concatMap(message -> {\n					.map(value -> session.textMessage(\"Echo \" + value));	// <2>\n			return session.send(output);									// <3>"}
{"id": 1128, "text": "Следующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Создайте исходящее сообщение, создав комбинированный поток. <3> Возвращает `Mono<Void>`, который не завершается, пока мы продолжаем получать.\n	class ExampleHandler : WebSocketHandler {\n			return session.send(output)							// <3>\nСледующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Создайте исходящее сообщение, создав комбинированный поток. <3> Возвращает `Mono<Void>`, который не завершается, пока мы продолжаем получать.\nСледующая реализация объединяет входящие и исходящие потоки:.\nВходящие и исходящие потоки могут быть независимыми и объединяться только для завершения. как показано в следующем примере:\nJava\n	class ExampleHandler implements WebSocketHandler {\n		@Override\n		public Mono<Void> handle(WebSocketSession session) {\n			Mono<Void> input = session.receive()								<1>\n					.doOnNext(message -> {\n					.concatMap(message -> {\n					.then();\n			Flux<String> source = ... ;\n			Mono<Void> output = session.send(source.map(session::textMessage));	<2>\n			return input.and(output);											<3>"}
{"id": 1129, "text": "Следующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Отправка исходящих сообщений. <3> Объедините потоки и верните `Mono<Void>`, который завершится, когда любой из потоков закончится.\n	class ExampleHandler : WebSocketHandler {\n			return input.and(output)										// <3>\nСледующая реализация объединяет входящие и исходящие потоки:. <1> Обработка потока входящих сообщений. <2> Отправка исходящих сообщений. <3> Объедините потоки и верните `Mono<Void>`, который завершится, когда любой из потоков закончится.\n`Буфер данных`. `DataBuffer` — это представление байтового буфера в WebFlux.\nЧасть Spring Core в ссылке есть дополнительная информация об этом в разделе, посвященном на таких серверах, как Netty, байтовые буферы объединяются в пул, подсчитываются ссылки и должны быть освобождены. при потреблении, чтобы избежать утечек памяти.\n`Буфер данных`.\nПри работе на Netty приложения должны использовать DataBufferUtils.retain(dataBuffer), если они хотите сохранить буферы входных данных, чтобы гарантировать, что они не будут освобождены, и впоследствии используйте `DataBufferUtils.release(dataBuffer)`, когда буферы будут использованы.\nРукопожатие. `WebSocketHandlerAdapter` делегирует `WebSocketService`.\nПо умолчанию это экземпляр HandshakeWebSocketService, который выполняет базовые проверки запроса WebSocket и затем использует RequestUpgradeStrategy для используемого сервера."}
{"id": 1130, "text": "На данный момент имеется встроенный поддержка Reactor Netty, Tomcat и Jetty.\nРукопожатие.\nHandshakeWebSocketService предоставляет свойство sessionAttributePredicate, которое позволяет установка `Predicate<String>` для извлечения атрибутов из `WebSession` и вставки их в атрибуты WebSocketSession.\nКонфигурация сервера. `RequestUpgradeStrategy` для каждого сервера предоставляет конфигурацию, специфичную для базовый механизм сервера WebSocket.\nПри использовании конфигурации Java WebFlux вы можете настроить такие свойства, как показано в соответствующем разделе не используя конфигурацию WebFlux, используйте следующее:\nJava\n	@Configuration\n	class WebConfig {\n		@Bean\n		public WebSocketHandlerAdapter handlerAdapter() {\n			return new WebSocketHandlerAdapter(webSocketService());\n		@Bean\n		public WebSocketService webSocketService() {\n			TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();\n			strategy.setMaxSessionIdleTimeout(0L);\n			return new HandshakeWebSocketService(strategy);\n	@Configuration\n	class WebConfig {\nКонфигурация сервера.\nПроверьте стратегию обновления вашего сервера, чтобы узнать, какие варианты доступны.\nВ настоящее время только Tomcat и Jetty предоставляют такие возможности.\nКОРС.\nСамый простой способ настроить CORS и ограничить доступ к конечной точке WebSocket — это пусть ваш WebSocketHandler реализует CorsConfigurationSource и возвращает `CorsConfiguration` с разрешенными источниками, заголовками и другими деталями.\nЕсли вы не можете сделать то вы также можете установить для свойства corsConfigurations в SimpleUrlHandler значение укажите настройки CORS по шаблону URL.\nЕсли указаны оба, они объединяются с помощью метод объединения в CorsConfiguration.\nКлиент."}
{"id": 1131, "text": "Spring WebFlux предоставляет абстракцию WebSocketClient с реализациями для Reactor Netty, Tomcat, Jetty и стандартная Java (то есть JSR-356).\nКлиент.\nПРИМЕЧАНИЕ.\nКлиент Tomcat по сути является расширением стандартного Java-клиента с некоторыми дополнительными возможностями. функциональность в обработке `WebSocketSession`, чтобы воспользоваться преимуществами специфичной для Tomcat API для приостановки получения сообщений из-за противодавления.\nКлиент.\nЧтобы запустить сеанс WebSocket, вы можете создать экземпляр клиента и использовать его команду «execute». методы:\nJava\n	WebSocketClient client = new ReactorNettyWebSocketClient();\n	URI url = new URI(\"ws://localhost:8080/path\");\n	client.execute(url, session ->\n			session.receive()\n					.doOnNext(System.out::println)\n					.then());\nКлиент.\nНекоторые клиенты, такие как Jetty, реализуют «жизненный цикл», и их необходимо останавливать и запускать. прежде чем вы сможете их использовать.\nУ всех клиентов есть параметры конструктора, связанные с конфигурацией. базового клиента WebSocket."}
{"id": 1132, "text": "Весенний WebFlux.\nИсходная веб-платформа, включенная в Spring Framework, Spring Web MVC, была специально созданный для API сервлетов и контейнеров сервлетов.\nВеб-фреймворк реактивного стека, Spring WebFlux был добавлен позже в версии 5.0.\nОн полностью неблокирующий, поддерживает {reactive-streams-site}/[Reactive Streams] обратное давление и работает на таких серверах, как Контейнеры Netty и Servlet.\nВесенний WebFlux.\nОбе веб-платформы отражают имена своих исходных модулей. ({spring-framework-code}/spring-webmvc[spring-webmvc] и {spring-framework-code}/spring-webflux[spring-webflux]) и сосуществовать бок о бок в Весенний фреймворк.\nКаждый модуль является дополнительным.\nПриложения могут использовать тот или иной модуль или, в некоторых случаях и то, и другое — например, контроллеры Spring MVC с реактивным WebClient."}
{"id": 1133, "text": "REST-клиенты.\nВ этом разделе описаны параметры клиентского доступа к конечным точкам REST.\n`РестКлиент`.\nRestClient — это синхронный HTTP-клиент, предоставляющий современный гибкий API.\n`РестКлиент`.\nДополнительную информацию см. в `RestClient`.\n`Вебклиент`. «WebClient» — это реактивный клиент для выполнения HTTP-запросов с помощью гибкого API.\n`Вебклиент`.\nДополнительную информацию см. в `WebClient`.\n`RestTemplate`.\nRestTemplate — это синхронный клиент для выполнения HTTP-запросов.\nЭто оригинал Spring REST-клиент и предоставляет простой API-интерфейс шаблонного метода поверх базового HTTP-клиента. библиотеки.\n`RestTemplate`.\nПодробности см. в `RestTemplate`.\nHTTP-клиент службы.\nSpring Framework позволяет определить службу HTTP как интерфейс Java с HTTP. методы обмена.\nЗатем вы можете создать прокси, реализующий этот интерфейс, и осуществляет обмены.\nЭто помогает упростить удаленный доступ по HTTP и предоставляет дополнительные возможности. гибкость выбора стиля API, например синхронного или реактивного.\nHTTP-клиент службы.\nПодробности см. в клиент службы HTTP."}
{"id": 1134, "text": "КОРС.\nSpring MVC позволяет обрабатывать CORS (совместное использование ресурсов между источниками).\nЭтот раздел описывает, как это сделать.\nВведение.\nПо соображениям безопасности браузеры запрещают вызовы AJAX к ресурсам за пределами текущего источника.\nНапример, ваш банковский счет может находиться на одной вкладке, а сайт evil.com — на другой.\nСкрипты от evil.com не должен иметь возможности отправлять AJAX-запросы к API вашего банка с помощью вашего учетные данные — например, снятие денег со своего счета!\nВведение.\nСовместное использование ресурсов между источниками (CORS) — это https://www.w3.org/TR/cors/[спецификация W3C] реализовано https://caniuse.com/#feat=cors[большинством браузеров], что позволяет вам указать какие междоменные запросы разрешены, вместо использования менее безопасных и менее мощные обходные пути на основе IFRAME или JSONP.\nСертифицированные запросы.\nИспользование CORS с запросами с учетными данными требует включения `allowedCredentials`.\nИмейте в виду, что эта опция устанавливает высокий уровень доверия с настроенными доменами, а также увеличивает поверхность атаки веб-приложения путем раскрытия конфиденциальной информации, специфичной для пользователя такие как файлы cookie и токены CSRF.\nСертифицированные запросы.\nВключение учетных данных также влияет на обработку настроенных подстановочных знаков `\"*\"` CORS:\n* Подстановочные знаки не разрешены в `allowOrigins`, но альтернативно\nСертифицированные запросы."}
{"id": 1135, "text": "СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.\n* Если установлено значение `allowedHeaders` или `allowedMethods`, `Access-Control-Allow-Headers`\nСертифицированные запросы. и заголовки ответов `Access-Control-Allow-Methods` обрабатываются путем копирования связанных заголовки и метод, указанные в предполетном запросе CORS.\n* Если установлено значение `exposeHeaders`, устанавливается заголовок ответа `Access-Control-Expose-Headers`.\nСертифицированные запросы. либо к настроенному списку заголовков, либо к подстановочному знаку.\nХотя спецификация CORS не разрешает использование подстановочного знака, если для параметра «Access-Control-Allow-Credentials» установлено значение `true`, большинство браузеров поддерживают его, и не все заголовки ответов доступны во время Обработка CORS, поэтому подстановочный знак является значением заголовка, используемым при указывается независимо от значения свойстваallowCredentials.\nСертифицированные запросы.\nВНИМАНИЕ: Хотя такая конфигурация с подстановочными знаками может быть удобной, рекомендуется, если это возможно, настроить вместо этого используется конечный набор значений для обеспечения более высокого уровня безопасности.\nОбработка.\nСпецификация CORS различает предполетные, простые и фактические запросы.\nЧтобы узнать, как работает CORS, вы можете прочитать https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[эта статья], среди многие другие или см. спецификацию для получения более подробной информации.\nОбработка.\nРеализации Spring MVC HandlerMapping предоставляют встроенную поддержку CORS."}
{"id": 1136, "text": "После успешного сопоставление запроса с обработчиком, реализации HandlerMapping проверяют конфигурацию CORS на наличие данный запрос и обработчик и предпринять дальнейшие действия.\nПредполетные запросы обрабатываются напрямую, в то время как простые и актуальные запросы CORS перехватываются, проверяются и обрабатываются. установлен требуемый набор заголовков ответа CORS.\nОбработка.\nЧтобы включить запросы между источниками (то есть заголовок «Origin» присутствует и отличается от хоста запроса), вам необходимо иметь явно объявленный CORS. конфигурация.\nЕсли соответствующая конфигурация CORS не найдена, заголовки CORS не добавляются. ответы на предполетные, простые и актуальные запросы CORS и, следовательно, браузеры отвергнуть их.\nОбработка.\nКаждое HandlerMapping может быть {spring-framework-api}/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations(java.util.Map)[настроено] индивидуально с сопоставлениями CorsConfiguration на основе шаблонов URL.\nВ большинстве случаев приложения используйте конфигурацию MVC Java или пространство имен XML для объявления таких сопоставлений, что приводит к в одной глобальной карте, передаваемой всем экземплярам HandlerMapping.\nОбработка.\nВы можете комбинировать глобальную конфигурацию CORS на уровне HandlerMapping с другими детальная конфигурация CORS на уровне обработчика.\nНапример, аннотированные контроллеры могут использовать Аннотации `@CrossOrigin` на уровне класса или метода (другие обработчики могут реализовать `CorsConfigurationSource`).\nОбработка.\nПравила объединения глобальной и локальной конфигурации обычно аддитивны, например: все глобальное и все локальное происхождение."}
{"id": 1137, "text": "Для тех атрибутов, где может быть указано только одно значение принимаются, например, `allowCredentials` и `maxAge`, локальное значение переопределяет глобальное значение.\nСм. {spring-framework-api}/web/cors/CorsConfiguration.html#combine(org.springframework.web.cors.CorsConfiguration)[`CorsConfiguration#combine(CorsConfiguration)`] для более подробной информации.\nОбработка. [СОВЕТ] = Чтобы узнать больше из исходного кода или выполнить расширенные настройки, проверьте код:\n* `КорсКонфигурация`\n* `CorsProcessor`, `DefaultCorsProcessor`\n* `AbstractHandlerMapping`\n`@CrossOrigin`. {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`] аннотация позволяет выполнять запросы между источниками к аннотированным методам контроллера, как показано в следующем примере:\nJava\n	@RestController\n	@RequestMapping(\"/account\")\n	public class AccountController {\n		@CrossOrigin\n		@GetMapping(\"/{id}\")\n		public Account retrieve(@PathVariable Long id) {\n		@DeleteMapping(\"/{id}\")\n		public void remove(@PathVariable Long id) {\n	@RestController\n	@RequestMapping(\"/account\")\n	class AccountController {\n* Все происхождение.\n* Все заголовки.\n* Все методы HTTP, с которыми сопоставлен метод контроллера."}
{"id": 1138, "text": "По умолчанию @CrossOrigin позволяет:. `allowCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно.\nКогда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `\"*\"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.\nПо умолчанию @CrossOrigin позволяет:. `maxAge` установлен на 30 минут.\nПо умолчанию @CrossOrigin позволяет:. `@CrossOrigin` также поддерживается на уровне класса и наследуется всеми методами. как показано в следующем примере:\nJava\nПо умолчанию @CrossOrigin позволяет:. @CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600) @RestController @RequestMapping(\"/account\") public class AccountController {\n	@GetMapping(\"/{id}\")\n	public Account retrieve(@PathVariable Long id) {\n	@DeleteMapping(\"/{id}\")\n	public void remove(@PathVariable Long id) {\n	@CrossOrigin(origins = [\"https://domain2.com\"], maxAge = 3600)\n	@RestController\n	@RequestMapping(\"/account\")\n	class AccountController {\nПо умолчанию @CrossOrigin позволяет:."}
{"id": 1139, "text": "Вы можете использовать @CrossOrigin как на уровне класса, так и на уровне метода. как показано в следующем примере:\nJava\n	@CrossOrigin(maxAge = 3600)\n	@RestController\n	@RequestMapping(\"/account\")\n	public class AccountController {\n		@CrossOrigin(\"https://domain2.com\")\n		@GetMapping(\"/{id}\")\n		public Account retrieve(@PathVariable Long id) {\n		@DeleteMapping(\"/{id}\")\n		public void remove(@PathVariable Long id) {\n	@CrossOrigin(maxAge = 3600)\n	@RestController\n	@RequestMapping(\"/account\")\n	class AccountController {\nГлобальная конфигурация.\nВ дополнение к детальной настройке уровня метода контроллера вы, вероятно, захотите также определите некоторую глобальную конфигурацию CORS.\nВы можете установить CorsConfiguration на основе URL-адреса. сопоставления индивидуально для любого HandlerMapping.\nОднако большинство приложений используют Конфигурация MVC Java или пространство имен MVC XML для этого.\n* Все происхождение.\n* Все заголовки.\n* Методы GET, HEAD и POST.\nПо умолчанию глобальная конфигурация позволяет следующее:. `allowCredentials` не включен по умолчанию, поскольку он устанавливает уровень доверия. который раскрывает конфиденциальную информацию, специфичную для пользователя (например, файлы cookie и токены CSRF) и следует использовать только там, где это уместно."}
{"id": 1140, "text": "Когда он включен, либо `allowOrigins` должен быть установлен для одного или нескольких конкретных доменов (но не специального значения `\"*\"`) или альтернативно СвойствоallowOriginPatterns можно использовать для сопоставления с динамическим набором источников.\nПо умолчанию глобальная конфигурация позволяет следующее:. `maxAge` установлен на 30 минут.\nПо умолчанию глобальная конфигурация позволяет следующее:.\nВы можете включить CORS в конфигурации Spring MVC, как показано в следующем примере: См. пример кода в исходном документе.\nКОРС-фильтр.\nВы можете применить поддержку CORS через встроенный {spring-framework-api}/web/filter/CorsFilter.html[`CorsFilter`].\nКОРС-фильтр.\nПРИМЕЧАНИЕ.\nЕсли вы попытаетесь использовать CorsFilter с Spring Security, имейте в виду, что Spring Безопасность имеет {docs-spring-security}/servlet/integrations/cors.html[встроенную поддержку] для КОРС.\nКОРС-фильтр.\nЧтобы настроить фильтр, передайте CorsConfigurationSource его конструктору, поскольку следующий пример показывает:\nJava\n	CorsConfiguration config = new CorsConfiguration();\n	// Возможно...\n	// config.applyPermitDefaultValues()\n	config.setAllowCredentials(true);\n	config.addAllowedOrigin(\"https://domain1.com\");\n	config.addAllowedHeader(\"*\");\n	config.addAllowedMethod(\"*\");\n	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();"}
{"id": 1141, "text": "source.registerCorsConfiguration(\"/**\", config);\n	CorsFilter filter = new CorsFilter(source);\n	// Возможно...\n	// config.applyPermitDefaultValues()\n	config.allowCredentials = true\n	config.addAllowedOrigin(\"https://domain1.com\")\n	config.addAllowedHeader(\"*\")\n	config.addAllowedMethod(\"*\")"}
{"id": 1142, "text": "Функциональные конечные точки.\nSpring Web MVC включает WebMvc.fn, облегченную модель функционального программирования, в которой функции используются для маршрутизации и обработки запросов, а контракты разработаны с учетом неизменяемости.\nЭто альтернатива модели программирования на основе аннотаций, но в остальном она работает на тот же DispatcherServlet.\nОбзор.\nВ WebMvc.fn HTTP-запрос обрабатывается с помощью HandlerFunction: функции, которая принимает `ServerRequest` и возвращает `ServerResponse`.\nИ объект запроса, и объект ответа имеют неизменяемые контракты, которые обеспечивают совместимость с JDK 8. доступ к HTTP-запросу и ответу.\nHandlerFunction — это эквивалент тела метода @RequestMapping в модель программирования на основе аннотаций.\nОбзор.\nВходящие запросы направляются в функцию-обработчик с помощью RouterFunction: функции, которая принимает `ServerRequest` и возвращает необязательную `HandlerFunction` (т. е. `Optional<HandlerFunction>`).\nКогда функция маршрутизатора совпадает, возвращается функция-обработчик; в противном случае пустой Необязательный.\nRouterFunction — это эквивалент аннотации @RequestMapping, но с основным Разница в том, что функции маршрутизатора предоставляют не только данные, но и поведение.\nОбзор. `RouterFunctions.route()` предоставляет конструктор маршрутизаторов, который упрощает создание маршрутизаторов. как показано в следующем примере:\nJava\n	import static org.springframework.http.MediaType.APPLICATION_JSON;\n	import static org.springframework.web.servlet.function.RequestPredicates.*;"}
{"id": 1143, "text": "import static org.springframework.web.servlet.function.RouterFunctions.route;\n	PersonRepository repository = ...\n	PersonHandler handler = new PersonHandler(repository);\n	RouterFunction<ServerResponse> route = route() // <1>\n		.GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n		.GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople)\n		.POST(\"/person\", handler::createPerson)\n		.build();\n	public class PersonHandler {\n		public ServerResponse listPeople(ServerRequest request) {\n		public ServerResponse createPerson(ServerRequest request) {\n		public ServerResponse getPerson(ServerRequest request) {\nОбзор. <1> Создайте маршрутизатор с помощью `route()`.\nОбзор. <1> Создайте маршрутизатор, используя DSL маршрутизатора.\nОбзор.\nЕсли вы зарегистрируете RouterFunction как компонент, например, выставив его в `@Configuration`, он будет автоматически обнаружен сервлетом, как описано в разделе\nОбработчикФункция. `ServerRequest` и `ServerResponse` — это неизменяемые интерфейсы, совместимые с JDK 8. доступ к HTTP-запросу и ответу, включая заголовки, тело, метод и код состояния.\nСерверный запрос. `ServerRequest` обеспечивает доступ к методу HTTP, URI, заголовкам и параметрам запроса. в то время как доступ к телу предоставляется через методы body.\nJava"}
{"id": 1144, "text": "String string = request.body(String.class);.\nВ следующем примере тело извлекается в `List<Person>`, где объекты Person декодируются из сериализованной формы, например JSON или XML:\nJava\nMultiValueMap<String, String> params = request.params();.\nНиже показано, как связать параметры запроса, переменные URI или заголовки с помощью DataBinder. а также показывает, как настроить DataBinder:\nJava\nОтвет сервера. `ServerResponse` обеспечивает доступ к HTTP-ответу, и, поскольку он неизменяем, вы можете использовать метод `build` для его создания.\nВы можете использовать конструктор, чтобы установить статус ответа, добавить ответ заголовки или предоставить тело.\nВ следующем примере создается ответ 200 (ОК) с JSON. содержание:\nJava\nPerson person =...\nServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);.\nВ следующем примере показано, как создать ответ 201 (CREATED) с заголовком Location и без тела:\nJava\nURI location =...\nServerResponse.created(location).build();.\nВы также можете использовать асинхронный результат в качестве тела в форме CompletableFuture. `Publisher` или любой другой тип, поддерживаемый `ReactiveAdapterRegistry`.\nНапример:\nJava\nURI location =...\nServerResponse.created(location).build();."}
{"id": 1145, "text": "Mono<Person> person = webClient.get().retrieve().bodyToMono(Person.class); ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);\nURI location =...\nServerResponse.created(location).build();.\nЕсли не только тело, но и статус или заголовки основаны на асинхронном типе, вы можете использовать статический метод async для ServerResponse, который принимает `CompletableFuture<ServerResponse>`, `Publisher<ServerResponse>` или любой другой асинхронный тип, поддерживаемый ReactiveAdapterRegistry.\nНапример:\nJava\nURI location =...\nServerResponse.created(location).build();.\nMono<ServerResponse> asyncResponse = webClient.get().retrieve().bodyToMono(Person.class).map(p -> ServerResponse.ok().header(\"Name\", p.name()).body(p)); ServerResponse.async(asyncResponse);\nURI location =...\nServerResponse.created(location).build();. https://html.spec.whatwg.org/multipage/server-sent-events.html[Отправленные сервером события] можно предоставить через статический метод sse для ServerResponse.\nСтроитель, предоставленный этим методом позволяет отправлять строки или другие объекты в формате JSON.\nНапример:\nJava"}
{"id": 1146, "text": "public RouterFunction<ServerResponse> sse() {\n		return route(GET(\"/sse\"), request -> ServerResponse.sse(sseBuilder -> {\n					// Сохраняем где-нибудь объект sseBuilder..\n	// В каком-то другом потоке отправка строки\n	sseBuilder.send(\"Hello world\");\n	// Или объект, который будет преобразован в JSON\n	Person person = ...\n	sseBuilder.send(person);\n	// Настраиваем событие, используя другие методы\n	sseBuilder.id(\"42\")\n			.event(\"sse event\")\n			.data(person);\n	// и сделано в какой-то момент\n	sseBuilder.complete();\n	// В каком-то другом потоке отправка строки\n	sseBuilder.send(\"Hello world\")\n	// Настраиваем событие, используя другие методы\n	sseBuilder.id(\"42\")\n			.event(\"sse event\")\n			.data(person)\n	// и сделано в какой-то момент\n	sseBuilder.complete()\nКлассы обработчиков.\nМы можем написать функцию-обработчик в виде лямбды, как показано в следующем примере:\nJava\nHandlerFunction<ServerResponse> helloWorld = request -> ServerResponse.ok().body(\"Hello World\");.\nЭто удобно, но в приложении нам нужно несколько функций и несколько встроенных лямбда может запутаться."}
{"id": 1147, "text": "Поэтому полезно сгруппировать связанные функции-обработчики в класс обработчиков, который имеет ту же роль, что и `@Controller` в приложении на основе аннотаций.\nНапример, следующий класс предоставляет реактивный репозиторий Person:\nJava\nHandlerFunction<ServerResponse> helloWorld = request -> ServerResponse.ok().body(\"Hello World\");. import static org.springframework.http.MediaType.APPLICATION_JSON; import static org.springframework.web.reactive.function.server.ServerResponse.ok;\n	private final PersonRepository repository;\n	public PersonHandler(PersonRepository repository) {\n		this.repository = repository;\n	public ServerResponse listPeople(ServerRequest request) { // <1>\n		List<Person> people = repository.allPeople();\n		return ok().contentType(APPLICATION_JSON).body(people);\n	public ServerResponse createPerson(ServerRequest request) throws Exception { // <2>\n		Person person = request.body(Person.class);\n		repository.savePerson(person);\n		return ok().build();\n	public ServerResponse getPerson(ServerRequest request) { // <3>\n		int personId = Integer.parseInt(request.pathVariable(\"id\"));\n		Person person = repository.getPerson(personId);\n		if (person != null) {\n			return ok().contentType(APPLICATION_JSON).body(person);\n		else {"}
{"id": 1148, "text": "return ServerResponse.notFound().build();\npublic class PersonHandler {. <1> `listPeople` — это функция-обработчик, которая возвращает все объекты `Person`, найденные в репозитории, в виде JSON. <2> `createPerson` — это функция-обработчик, которая сохраняет новое `Person`, содержащееся в теле запроса. <3> `getPerson` — это функция-обработчик, которая возвращает одного человека, идентифицируемого по пути `id`. переменная.\nМы извлекаем этого «Человека» из репозитория и создаем ответ JSON, если он есть. нашел.\nЕсли он не найден, мы возвращаем ответ 404 Not Found.\nВалидация.\nФункциональная конечная точка может использовать Spring средства проверки для применить проверку к телу запроса.\nНапример, учитывая пользовательский Spring\nJava\n	public class PersonHandler {\n		private final Validator validator = new PersonValidator(); // <1>\n		public ServerResponse createPerson(ServerRequest request) {\n			Person person = request.body(Person.class);\n			validate(person); // <2>\n			repository.savePerson(person);\n			return ok().build();\n		private void validate(Person person) {\n			Errors errors = new BeanPropertyBindingResult(person, \"person\");\n			validator.validate(person, errors);\n			if (errors.hasErrors()) {"}
{"id": 1149, "text": "throw new ServerWebInputException(errors.toString()); // <3>\nВалидация. <1> Создать экземпляр «Валидатора». <2> Применить проверку. <3> Вызов исключения для ответа 400.\nВалидация.\nОбработчики также могут использовать стандартный API проверки компонентов (JSR-303), создавая и внедряя глобальный экземпляр Validator, основанный на LocalValidatorFactoryBean.\nСм.\nSpring Validation.\n`RouterFunction`.\nФункции маршрутизатора используются для маршрутизации запросов к соответствующей функции HandlerFunction.\nОбычно вы не пишете функции маршрутизатора самостоятельно, а используете метод на Утилита RouterFunctions для его создания. `RouterFunctions.route()` (без параметров) предоставляет вам удобный конструктор для создания маршрутизатора. функция, тогда как RouterFunctions.route(RequestPredicate, HandlerFunction) предлагает прямой путь создать роутер.\n`RouterFunction`.\nКак правило, рекомендуется использовать построитель `route()`, поскольку он обеспечивает удобные ярлыки для типичных сценариев картографии, не требующие сложного обнаружения статический импорт.\nНапример, построитель функций маршрутизатора предлагает метод GET(String, HandlerFunction) создать сопоставление для GET-запросов; и POST(String, HandlerFunction) для POST.\n`RouterFunction`.\nПомимо сопоставления на основе HTTP-метода, построитель маршрутов предлагает способ введения дополнительных предикаты при сопоставлении с запросами.\nДля каждого метода HTTP существует перегруженный вариант, который принимает RequestPredicate в качестве параметр, посредством которого могут быть выражены дополнительные ограничения.\nПредикаты."}
{"id": 1150, "text": "Вы можете написать свой собственный RequestPredicate, но служебный класс RequestPredicates предлагает встроенные возможности для общих нужд сопоставления на основе метода HTTP, запроса путь, заголовки, версия API и многое другое.\nJava\n	RouterFunction<ServerResponse> route = RouterFunctions.route()\n		.GET(\"/hello-world\", accept(MediaType.TEXT_PLAIN),\n			request -> ServerResponse.ok().body(\"Hello World\")).build();\n* `RequestPredicate.and(RequestPredicate)` -- оба должны совпадать.\n* `RequestPredicate.or(RequestPredicate)` — любой из них может совпадать.\nВы можете составить несколько предикатов запроса вместе, используя:.\nМногие предикаты из RequestPredicates являются составными.\nНапример, RequestPredicates.GET(String)` состоит из RequestPredicates.method(HttpMethod)` и `RequestPredicates.path(String)`.\nВ приведенном выше примере также используются два предиката запроса, поскольку построитель использует `RequestPredicates.GET` внутренне и объединяет его с предикатом `accept`.\nМаршруты.\nФункции маршрутизатора оцениваются по порядку: если первый маршрут не совпадает, то оценивается второй и так далее.\nПоэтому имеет смысл объявлять более конкретные маршруты перед общими.\nЭто также важно при регистрации функций маршрутизатора в качестве bean-компонентов Spring. быть описаны позже."}
{"id": 1151, "text": "Обратите внимание, что это поведение отличается от модели программирования на основе аннотаций, где «Наиболее конкретный» метод контроллера выбирается автоматически.\nМаршруты.\nПри использовании конструктора функций маршрутизатора все определенные маршруты объединяются в один. `RouterFunction`, возвращаемая из `build()`.\nСуществуют и другие способы объединения нескольких функций маршрутизатора:\n* `add(RouterFunction)` в конструкторе `RouterFunctions.route()`\n* `RouterFunction.and(RouterFunction)`\n* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` -- ярлык для\nМаршруты. `RouterFunction.and()` с вложенным `RouterFunctions.route()`.\nJava\n	import static org.springframework.http.MediaType.APPLICATION_JSON;\n	import static org.springframework.web.servlet.function.RequestPredicates.*;\n	PersonRepository repository = ...\n	PersonHandler handler = new PersonHandler(repository);\n	RouterFunction<ServerResponse> otherRoute = ...\n	RouterFunction<ServerResponse> route = route()\n		.GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) // <1>\n		.GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) // <2>\n		.POST(\"/person\", handler::createPerson) // <3>\n		.add(otherRoute) // <4>"}
{"id": 1152, "text": ".build();\nВ следующем примере показан состав четырех маршрутов:. <1> pass:q[`GET /person/{id}`] с заголовком `Accept`, который соответствует JSON, направляется на `PersonHandler.getPerson` <2> `GET /person` с заголовком `Accept`, соответствующим JSON, перенаправляется на `PersonHandler.listPeople` <3> `POST /person` без дополнительных предикатов сопоставляется с `PersonHandler.createPerson` и <4> `otherRoute` — это функция маршрутизатора, которая создается где-то еще и добавляется к построенному маршруту.\nВложенные маршруты.\nОбычно группа функций маршрутизатора имеет общий предикат, например общий путь.\nВ приведенном выше примере общий предикат будет предикатом пути, соответствующим `/person`, используется тремя маршрутами.\nПри использовании аннотаций вы должны удалить это дублирование, используя @RequestMapping на уровне типа. аннотация, которая отображается в `/person`.\nВ WebMvc.fn предикаты пути могут использоваться совместно с помощью метода path в конструкторе функций маршрутизатора.\nНапример, последние несколько строк приведенного выше примера можно улучшить следующим образом, используя вложенные маршруты:\nJava\n	.path(\"/person\", builder -> builder // <1>\n		.GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson)"}
{"id": 1153, "text": ".GET(accept(APPLICATION_JSON), handler::listPeople)\n		.POST(handler::createPerson))\n	.build();\nRouterFunction<ServerResponse> route = route(). <1> Обратите внимание, что второй параметр `path` — это потребитель, который принимает сборщик маршрутизатора.\nRouterFunction<ServerResponse> route = route(). <1> Использование `nest` DSL.\nRouterFunction<ServerResponse> route = route().\nХотя вложение на основе пути является наиболее распространенным, вы можете вложить любой тип предиката, используя метод `nest` в конструкторе.\nВышеупомянутое все еще содержит некоторое дублирование в виде общего предиката заголовка Accept.\nМы можем улучшить ситуацию, используя метод «nest» вместе с «accept»:\nJava\n	RouterFunction<ServerResponse> route = route()\n		.path(\"/person\", b1 -> b1\n			.nest(accept(APPLICATION_JSON), b2 -> b2\n				.GET(\"/{id}\", handler::getPerson)\n				.GET(handler::listPeople))\n			.POST(handler::createPerson))\n		.build();\nВерсия API.\nФункции маршрутизатора поддерживают сопоставление по версии API.\nJava\n	RouterFunction<ServerResponse> route = RouterFunctions.route()\n		.GET(\"/hello-world\", version(\"1.2\"),"}
{"id": 1154, "text": "request -> ServerResponse.ok().body(\"Hello World\")).build();\n- Фиксированная версия (\"1.2\") — соответствует только данной версии.\n- Базовая версия (\"1.2+\") — соответствует данной версии и выше, вплоть до самой высокой.\nПредикат `version` может быть:.\nСм.\nВерсии API для получения более подробной информации об основных инфраструктура и поддержка управления версиями API.\nОбслуживание ресурсов.\nWebMvc.fn предоставляет встроенную поддержку обслуживания ресурсов.\nОбслуживание ресурсов.\nПРИМЕЧАНИЕ.\nВ дополнение к возможностям, описанным ниже, можно реализовать еще более гибкое управление ресурсами благодаря {spring-framework-api}++/web/servlet/function/RouterFunctions.html#resources(java.util.function.Function)++[`RouterFunctions#resource(java.util.function.Function)`].\nПеренаправление на ресурс.\nМожно перенаправить запросы, соответствующие указанному предикату, на ресурс.\nЭто может быть полезно, например, для обработки перенаправлений в одностраничных приложениях.\nJava\n	ClassPathResource index = new ClassPathResource(\"static/index.html\");\n	List<String> extensions = List.of(\"js\", \"css\", \"ico\", \"png\", \"jpg\", \"gif\");"}
{"id": 1155, "text": "RequestPredicate spaPredicate = path(\"/api/**\").or(path(\"/error\")).negate();\n	RouterFunction<ServerResponse> redirectToIndex = route()\n		.resource(spaPredicate, index)\n		.build();\nОбслуживание ресурсов из корневого расположения.\nТакже возможно маршрутизировать запросы, соответствующие заданному шаблону, к ресурсам относительно заданного корневого местоположения.\nJava\n	Resource location = new FileUrlResource(\"public-resources/\");\n	RouterFunction<ServerResponse> resources = RouterFunctions.resources(\"/resources/**\", location);\nЗапуск сервера.\nОбычно вы запускаете функции маршрутизатора в настройке на основе `DispatcherHandler` через компоненты, необходимые для обработки запросов.\nКонфигурация MVC Java объявляет следующее компоненты инфраструктуры для поддержки функциональных конечных точек:\n* `RouterFunctionMapping`: обнаруживает один или несколько bean-компонентов `RouterFunction<?>` в Spring.\nЗапуск сервера. конфигурация, упорядочивает их, объединяет их посредством RouterFunction.andOther и направляет запросы в результирующую функцию RouterFunction.\n* HandlerFunctionAdapter: простой адаптер, позволяющий вызывать DispatcherHandler.\nЗапуск сервера.\nHandlerFunction, сопоставленный с запросом.\nЗапуск сервера.\nПредыдущие компоненты позволяют функциональным конечным точкам соответствовать запросу DispatcherServlet. жизненный цикл обработки, а также (потенциально) запускаться параллельно с аннотированными контроллерами, если любые объявлены.\nИменно так функциональные конечные точки активируются с помощью Spring Boot Web. стартер.\nЗапуск сервера."}
{"id": 1156, "text": "В следующем примере показана связанная конфигурация Spring MVC: См. пример кода в исходном документе.\nФильтрация функций-обработчиков.\nВы можете фильтровать функции обработчика, используя методы «before», «after» или «filter» в маршрутизации. конструктор функций.\nС помощью аннотаций вы можете добиться аналогичной функциональности, используя @ControllerAdvice, ServletFilter или оба.\nФильтр будет применяться ко всем маршрутам, построенным строителем.\nЭто означает, что фильтры, определенные во вложенных маршрутах, не применяются к маршрутам «верхнего уровня».\nНапример, рассмотрим следующий пример:\nJava\n	RouterFunction<ServerResponse> route = route()\n		.path(\"/person\", b1 -> b1\n			.nest(accept(APPLICATION_JSON), b2 -> b2\n				.GET(\"/{id}\", handler::getPerson)\n				.GET(handler::listPeople)\n				.before(request -> ServerRequest.from(request) // <1>\n					.header(\"X-RequestHeader\", \"Value\")\n					.build()))\n			.POST(handler::createPerson))\n		.after((request, response) -> logResponse(response)) // <2>\n		.build();"}
{"id": 1157, "text": "Фильтрация функций-обработчиков. <1> Фильтр «before», который добавляет пользовательский заголовок запроса, применяется только к двум маршрутам GET. <2> Фильтр «after», регистрирующий ответ, применяется ко всем маршрутам, включая вложенные.\nФильтрация функций-обработчиков.\nМетод filter в конструкторе маршрутизатора принимает HandlerFilterFunction: функция, которая принимает ServerRequest и HandlerFunction и возвращает ServerResponse.\nПараметр функции-обработчика представляет следующий элемент в цепочке.\nОбычно это обработчик, на который перенаправляется, но это также может быть другой фильтровать, если применено несколько.\nФильтрация функций-обработчиков.\nТеперь мы можем добавить к нашему маршруту простой фильтр безопасности, предполагая, что у нас есть SecurityManager, который может определить, разрешен ли конкретный путь.\nВ следующем примере показано, как это сделать:\nJava\n	SecurityManager securityManager = ...\n	RouterFunction<ServerResponse> route = route()\n		.path(\"/person\", b1 -> b1\n			.nest(accept(APPLICATION_JSON), b2 -> b2\n				.GET(\"/{id}\", handler::getPerson)\n				.GET(handler::listPeople))\n			.POST(handler::createPerson))\n		.filter((request, next) -> {\n			if (securityManager.allowAccessTo(request.path())) {\n				return next.handle(request);\n			else {"}
{"id": 1158, "text": "return ServerResponse.status(UNAUTHORIZED).build();\n		.build();\nФильтрация функций-обработчиков.\nПредыдущий пример демонстрирует, что вызов next.handle(ServerRequest) не является обязательным.\nМы разрешаем запуск функции-обработчика только тогда, когда доступ разрешен.\nФильтрация функций-обработчиков.\nПомимо использования метода фильтра в конструкторе функций маршрутизатора, можно применить отфильтровать существующую функцию маршрутизатора через `RouterFunction.filter(HandlerFilterFunction)`."}
{"id": 1159, "text": "Тестирование.\nВ этом разделе суммированы параметры, доступные в Spring-test для приложений Spring MVC.\n* Моки API сервлетов: макеты реализации контрактов API сервлетов для контроллеров модульного тестирования,\nТестирование. фильтры и другие веб-компоненты.\nСм. ссылку:testing/unit.adoc#mock-objects-servlet[API сервлетов]. макетируйте объекты для получения более подробной информации.\n* TestContext Framework: поддержка загрузки конфигурации Spring в тестах JUnit и TestNG,\nТестирование. включая эффективное кэширование загруженной конфигурации в различных методах тестирования и поддержку загрузка WebApplicationContext с помощью MockServletContext.\nДополнительную информацию см. в TestContext Framework.\n* Spring MVC Test: платформа, также известная как MockMvc, для тестирования аннотированных контроллеров.\nТестирование. через DispatcherServlet (то есть поддерживающий аннотации), в комплекте с Инфраструктура Spring MVC, но без HTTP-сервера.\nДополнительную информацию см. в Spring MVC Test.\n* REST на стороне клиента: Spring-test предоставляет MockRestServiceServer, который вы можете использовать в качестве\nТестирование. макетный сервер для тестирования клиентского кода, который внутри использует RestTemplate.\nДополнительную информацию см. в Клиентские тесты REST.\n* `WebTestClient`: создан для тестирования приложений WebFlux, но его также можно использовать для\nТестирование. сквозное интеграционное тестирование на любом сервере через HTTP-соединение.\nЭто неблокирующий, реактивный клиент и хорошо подходит для тестирования асинхронных и потоковых сервисов. сценарии.\nДополнительную информацию см. в `WebTestClient`."}
{"id": 1160, "text": "Управление версиями API.\nSpring MVC поддерживает управление версиями API.\nВ этом разделе представлен обзор поддержки и лежащие в основе стратегии.\n- Настройте версии API в конфигурации MVC.\n- запросы карты\n- Запросы маршрутизации\nк функциональным конечным точкам с версией API.\nПоддержка клиента для управления версиями API доступна также в RestClient, WebClient и для тестирования в MockMvc и WebTestClient.\nApiVersionStrategy.\nЭто центральная стратегия управления версиями API, которая сохраняет все настроенные предпочтения. связанные с управлением версиями.\nОн делает следующее:\n- Анализирует необработанные значения версии в `Comparable<?>` с помощью ApiVersionParser\n- Проверяет версии запроса\n- Отправляет подсказки об устаревании в ответах.\n— Разрешает версии из запросов через ApiVersionResolver.\nApiVersionStrategy помогает сопоставлять запросы с методами контроллера @RequestMapping. и инициализируется конфигурацией MVC.\nОбычно приложения не взаимодействуют непосредственно с ним.\nАпиверсионрезольвер.\nЭта стратегия определяет версию API из запроса.\nКонфигурация MVC предоставляет встроенные параметры для разрешения из заголовка, параметра запроса, параметра типа носителя, или из URL-пути.\nВы также можете использовать собственный ApiVersionResolver.\nАпиверсионрезольвер.\nПРИМЕЧАНИЕ.\nСопоставитель пути всегда разрешает версию из указанного сегмента пути или в противном случае вызывает InvalidApiVersionException, и поэтому он не может уступить место другим резольверы.\nApiVersionParser.\nЭта стратегия помогает анализировать необработанные значения версий в `Comparable<?>`, что помогает сравнивайте, сортируйте и выбирайте версии."}
{"id": 1161, "text": "По умолчанию встроенный SemanticApiVersionParser. анализирует версию на целочисленные значения `major`, `minor` и `patch`.\nМинор и патч значения устанавливаются на 0, если они отсутствуют.\nВалидация.\nЕсли версия запроса не поддерживается, возникает исключение InvalidApiVersionException. в ответе 400.\nПо умолчанию список поддерживаемых версий инициализируется из объявленного версии в аннотированных сопоставлениях контроллеров, но вы можете отключить это с помощью флага в MVC и используйте только версии, явно настроенные в конфигурации.\nВалидация.\nПо умолчанию версия требуется, если включено управление версиями API.\nВызывается MissingApiVersionException, что приводит к ответу 400, если его нет.\nВы можете сделать его необязательным, и в этом случае будет использоваться самая последняя версия.\nВы также можете указать версию по умолчанию для использования.\nApiVersionDeprecationHandler.\nЭту стратегию можно настроить на отправку подсказок и информации об устаревших версиях клиентов через заголовки ответов.\nВстроенный `StandardApiVersionDeprecationHandler` можно установить заголовки «Устаревание», «Закат» и «Ссылка», как определено в https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] и https://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].\nВы также можете настроить индивидуальный обработчик для разных заголовков.\nЗапросить сопоставление. `ApiVersionStrategy` поддерживает сопоставление запросов с аннотированными методами контроллера."}
{"id": 1162, "text": "См. ссылку:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-version [Версия API] для более подробной информации."}
{"id": 1163, "text": "Посмотреть технологии.\nРендеринг представлений в Spring MVC является подключаемым.\nЕсли вы решите использовать Thymeleaf, шаблоны разметки Groovy, JSP или другие технологии — это прежде всего вопрос изменение конфигурации.\nВ этой главе рассматриваются технологии представления, интегрированные с Spring MVC.\nПосмотреть технологии.\nДополнительную информацию о рендеринге представления см. в документе Разрешение представления.\nПосмотреть технологии.\nВНИМАНИЕ: представления приложения Spring MVC находятся в пределах внутренних границ доверия. этого приложения.\nПредставления имеют доступ ко всем компонентам контекста вашего приложения.\nКак например, не рекомендуется использовать поддержку шаблонов Spring MVC в приложениях, где шаблоны доступны для редактирования из внешних источников, поскольку это может иметь последствия для безопасности."}
{"id": 1164, "text": "Весенний веб-MVC.\nSpring Web MVC — это оригинальная веб-платформа, построенная на API сервлетов и включенная в нее. в Spring Framework с самого начала.\nОфициальное название «Spring Web MVC». происходит от имени исходного модуля ({spring-framework-code}/spring-webmvc[`spring-webmvc`]), но он более известен как «Spring MVC».\nВесенний веб-MVC.\nПараллельно Spring Web MVC в Spring Framework 5.0 был представлен веб-фреймворк с реактивным стеком. чье имя «Spring WebFlux» также основано на его исходном модуле. ({spring-framework-code}/spring-webflux[`spring-webflux`]).\nВ этой главе рассматривается Spring Web MVC.\nИнформацию о веб-приложениях с реактивным стеком см.\nВесенний веб-MVC.\nБазовая информация и совместимость с контейнером сервлетов и версией Jakarta EE. диапазоны, см.\nSpring Framework {spring-framework-wiki}/Spring-Framework-Versions[Вики]."}
{"id": 1165, "text": "Вебсокеты.\nВ этой части справочной документации рассматривается поддержка стека сервлетов, WebSocket. обмен сообщениями, включающий необработанные взаимодействия WebSocket, эмуляцию WebSocket через SockJS и Обмен сообщениями публикации-подписки через STOMP в качестве подпротокола через WebSocket."}
{"id": 1166, "text": "Создание XML-схемы.\nНачиная с версии 2.0, в Spring реализован механизм добавления расширений на основе схемы в базовый формат Spring XML для определения и настройки bean-компонентов.\nЭтот раздел охватывает как написать свои собственные синтаксические анализаторы определений XML-компонентов и интегрируйте такие парсеры в контейнер Spring IoC.\nСоздание XML-схемы.\nЧтобы облегчить создание файлов конфигурации, использующих XML-редактор с поддержкой схемы, Расширяемый механизм конфигурации XML Spring основан на схеме XML.\nЕсли вы не знакомы с текущими расширениями конфигурации XML Spring, которые поставляются со стандартом Spring, вам следует сначала прочитать предыдущий раздел XML Schemas.\nЧтобы создать новые расширения конфигурации XML:. .\nАвтор XML-схема для описания ваших пользовательских элементов..\nКод — пользовательская реализация NamespaceHandler..\nCode одна или несколько реализаций BeanDefinitionParser (здесь и делается настоящая работа)..\nЗарегистрируйте свои новые артефакты с помощью Spring.\nЧтобы создать новые расширения конфигурации XML:.\nДля унифицированного примера мы создаем Расширение XML (пользовательский элемент XML), позволяющее нам настраивать объекты типа SimpleDateFormat (из пакета java.text).\nКогда мы закончим, мы сможем определить определения bean-компонентов типа SimpleDateFormat следующим образом:\n	<myns:dateformat id=\"dateFormat\"\n		pattern=\"yyyy-MM-dd HH:mm\"\n		lenient=\"true\"/>"}
{"id": 1167, "text": "Чтобы создать новые расширения конфигурации XML:. (Мы включаем гораздо более подробную примеры приведены далее в этом приложении.\nЦель этого первого простого примера — показать вам через основные этапы создания собственного расширения.)\nСоздание схемы.\nСоздание расширения конфигурации XML для использования с контейнером IoC Spring начинается с создание XML-схемы для описания расширения.\nДля нашего примера мы используем следующую схему для настройки объектов SimpleDateFormat:\n	<!-- myns.xsd (inside package org/springframework/samples/xml) -->\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<xsd:schema xmlns=\"http://www.mycompany.example/schema/myns\"\n			xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n			xmlns:beans=\"http://www.springframework.org/schema/beans\"\n			targetNamespace=\"http://www.mycompany.example/schema/myns\"\n			elementFormDefault=\"qualified\"\n			attributeFormDefault=\"unqualified\">\n		<xsd:import namespace=\"http://www.springframework.org/schema/beans\"/>\n		<xsd:element name=\"dateformat\">\n			<xsd:complexType>\n				<xsd:complexContent>\n					<xsd:extension base=\"beans:identifiedType\"> <1>"}
{"id": 1168, "text": "<xsd:attribute name=\"lenient\" type=\"xsd:boolean\"/>\n						<xsd:attribute name=\"pattern\" type=\"xsd:string\" use=\"required\"/>\n					</xsd:extension>\n				</xsd:complexContent>\n			</xsd:complexType>\n		</xsd:element>\n	</xsd:schema>\nСоздание схемы. <1> Указанная строка содержит базу расширения для всех идентифицируемых тегов. (это означает, что у них есть атрибут `id`, который мы можем использовать в качестве идентификатора компонента в контейнер).\nМы можем использовать этот атрибут, поскольку мы импортировали предоставленный Spring пространство имен `beans`.\nСоздание схемы.\nПредыдущая схема позволяет нам настраивать объекты SimpleDateFormat непосредственно в XML-файл контекста приложения с помощью элемента `<myns:dateformat/>`, как показано ниже. пример показывает:\n	<myns:dateformat id=\"dateFormat\"\n		pattern=\"yyyy-MM-dd HH:mm\"\n		lenient=\"true\"/>\nСоздание схемы.\nОбратите внимание, что после того, как мы создали классы инфраструктуры, предыдущий фрагмент XML имеет вид по сути то же самое, что и следующий фрагмент XML:\n	<bean id=\"dateFormat\" class=\"java.text.SimpleDateFormat\">"}
{"id": 1169, "text": "<constructor-arg value=\"yyyy-MM-dd HH:mm\"/>\n		<property name=\"lenient\" value=\"true\"/>\n	</bean>\nСоздание схемы.\nВторой из двух предыдущих фрагментов создает bean-компонент в контейнере (идентифицируемый именем dateFormat типа `SimpleDateFormat`) с несколькими установленными свойствами.\nСоздание схемы.\nПРИМЕЧАНИЕ.\nПодход к созданию формата конфигурации на основе схемы обеспечивает тесную интеграцию. с IDE, которая имеет XML-редактор с поддержкой схемы.\nИспользуя правильно разработанную схему, вы может использовать автозаполнение, чтобы позволить пользователю выбирать между несколькими вариантами конфигурации определенные в перечислении.\nКодирование NamespaceHandler.\nВ дополнение к схеме нам нужен NamespaceHandler для анализа всех элементов это конкретное пространство имен, с которым Spring сталкивается при анализе файлов конфигурации.\nДля этого примера NamespaceHandler должен позаботиться о синтаксическом анализе myns:dateformat. элемент.\n* `init()`: позволяет инициализировать `NamespaceHandler` и вызывается\nИнтерфейс NamespaceHandler имеет три метода:.\nSpring перед использованием обработчика.\n* `BeanDefinition parse(Element, ParserContext)`: вызывается, когда Spring обнаруживает\nИнтерфейс NamespaceHandler имеет три метода:. элемент верхнего уровня (не вложенный в определение компонента или другое пространство имен).\nЭтот метод сам может регистрировать определения bean-компонентов, возвращать определение bean-компонента или и то, и другое.\n* `BeanDefinitionHolder украсить(Node, BeanDefinitionHolder, ParserContext)`: Вызывается"}
{"id": 1170, "text": "Интерфейс NamespaceHandler имеет три метода:. когда Spring встречает атрибут или вложенный элемент другого пространства имен.\nУкрашение одного или нескольких определений компонента используется (например) с помощью Начнем с выделения простого примера, без использования декораций, после чего мы показываем украшение на несколько более продвинутом примере.\nИнтерфейс NamespaceHandler имеет три метода:.\nХотя вы можете написать свой собственный NamespaceHandler для всего пространство имен (и, следовательно, предоставить код, который анализирует каждый элемент в пространстве имен), часто бывает, что каждый элемент XML верхнего уровня в файле конфигурации Spring XML приводит к одному определению bean-компонента (как в нашем случае, где один `<myns:dateformat/>` приводит к одному определению bean-компонента SimpleDateFormat).\nВесна отличается количество удобных классов, поддерживающих этот сценарий.\nВ следующем примере мы используйте класс NamespaceHandlerSupport:\nJava\n	package org.springframework.samples.xml;\n	import org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n	public class MyNamespaceHandler extends NamespaceHandlerSupport {\n		public void init() {\n			registerBeanDefinitionParser(\"dateformat\", new SimpleDateFormatBeanDefinitionParser());\n	package org.springframework.samples.xml\n	class MyNamespaceHandler : NamespaceHandlerSupport {\nИнтерфейс NamespaceHandler имеет три метода:.\nВы можете заметить, что на самом деле логики синтаксического анализа не так много. в этом классе.\nДействительно, класс NamespaceHandlerSupport имеет встроенное понятие делегация."}
{"id": 1171, "text": "Он поддерживает регистрацию любого количества BeanDefinitionParser. экземпляры, которым он делегирует свои полномочия, когда ему необходимо проанализировать элемент в своем пространство имен.\nТакое чистое разделение задач позволяет NamespaceHandler обрабатывать оркестровка анализа всех пользовательских элементов в своем пространстве имен, в то время как делегирование BeanDefinitionParsers выполнения тяжелой работы по анализу XML.\nЭто означает, что каждый BeanDefinitionParser содержит только логику для анализа одного пользовательский элемент, как мы увидим на следующем шаге.\nИспользование BeanDefinitionParser. `BeanDefinitionParser` используется, если `NamespaceHandler` встречает XML-код. элемент типа, который был сопоставлен с конкретным анализатором определения компонента (в данном случае «dateformat»).\nДругими словами, BeanDefinitionParser отвечает за анализ одного отдельного XML-элемента верхнего уровня, определенного в схеме.\nВ синтаксического анализатора, у нас есть доступ к элементу XML (и, следовательно, к его подэлементам), так что мы можем проанализировать наш собственный XML-контент, как вы можете видеть в следующем примере:\nJava\n	package org.springframework.samples.xml;\n	import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n	import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;\n	import org.springframework.util.StringUtils;\n	import org.w3c.dom.Element;\n	import java.text.SimpleDateFormat;\n	public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { // <1>\n		protected Class getBeanClass(Element element) {"}
{"id": 1172, "text": "return SimpleDateFormat.class; // <2>\n		protected void doParse(Element element, BeanDefinitionBuilder bean) {\n			// это значение никогда не будет нулевым, поскольку схема явно требует указания значения\n			String pattern = element.getAttribute(\"pattern\");\n			bean.addConstructorArgValue(pattern);\n			// однако это необязательное свойство\n			String lenient = element.getAttribute(\"lenient\");\n			if (StringUtils.hasText(lenient)) {\n				bean.addPropertyValue(\"lenient\", Boolean.valueOf(lenient));\nИспользование BeanDefinitionParser. <1> Мы используем предоставленный Spring `AbstractSingleBeanDefinitionParser` для обработки большого количества основная тяжелая работа по созданию одного BeanDefinition. <2> Мы предоставляем суперклассу `AbstractSingleBeanDefinitionParser` тип, который соответствует нашему представляет собой одиночный `BeanDefinition`.\n	package org.springframework.samples.xml\n	class SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { // <1>\nИспользование BeanDefinitionParser. <1> Мы используем предоставленный Spring `AbstractSingleBeanDefinitionParser` для обработки большого количества основная тяжелая работа по созданию одного BeanDefinition. <2> Мы предоставляем суперклассу `AbstractSingleBeanDefinitionParser` тип, который соответствует нашему представляет собой одиночный `BeanDefinition`.\nИспользование BeanDefinitionParser.\nВ этом простом случае это все, что нам нужно сделать.\nСоздание нашего сингла `BeanDefinition` обрабатывается суперклассом `AbstractSingleBeanDefinitionParser`, как — это извлечение и установка уникального идентификатора определения компонента.\nРегистрация обработчика и схемы.\nКодирование закончено."}
{"id": 1173, "text": "Все, что осталось сделать, это сделать Spring XML инфраструктура синтаксического анализа знает наш пользовательский элемент.\nМы делаем это, регистрируя наш собственный `namespaceHandler` и пользовательский файл XSD в двух файлах свойств специального назначения.\nЭти файлы свойств размещаются в каталоге `META-INF` вашего приложения и может, например, распространяться вместе с вашими двоичными классами в файле JAR.\nВесна Инфраструктура синтаксического анализа XML автоматически подхватывает ваше новое расширение, потребляя эти файлы специальных свойств, форматы которых подробно описаны в следующих двух разделах.\nНаписание `META-INF/spring.handlers`.\nФайл свойств под названием «spring.handlers» содержит сопоставление URI XML-схемы с классы обработчиков пространства имен.\nДля нашего примера нам нужно написать следующее:\nhttp\\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler. (Символ `:` является допустимым разделителем в формате свойств Java, поэтому Символ `:` в URI необходимо экранировать обратной косой чертой.)\nhttp\\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler.\nПервая часть (ключ) пары «ключ-значение» — это URI, связанный с вашим пользовательским расширение пространства имен и должно точно совпадать со значением targetNamespace. атрибут, как указано в вашей пользовательской схеме XSD."}
{"id": 1174, "text": "Написание «META-INF/spring.schemas».\nФайл свойств под названием «spring.schemas» содержит сопоставление местоположений XML-схемы. (упоминается вместе с объявлением схемы в файлах XML, которые используют схему как часть атрибута `xsi:schemaLocation`) к ресурсам пути к классам.\nЭтот файл необходим чтобы предотвратить необходимость использования Spring EntityResolver по умолчанию, который требует Доступ в Интернет для получения файла схемы.\nЕсли вы укажете сопоставление в этом файл свойств, Spring ищет схему (в данном случае myns.xsd в пакете org.springframework.samples.xml) в пути к классам.\nВ следующем фрагменте показана строка, которую нам нужно добавить для нашей пользовательской схемы:\n(Помните, что символ `:` должен быть экранирован.).\nВам рекомендуется развернуть файл (или файлы) XSD рядом с классы NamespaceHandler и BeanDefinitionParser в пути к классам.\nИспользование специального расширения в конфигурации Spring XML.\nИспользование собственного расширения, которое вы сами реализовали, ничем не отличается от использования одно из «пользовательских» расширений, предоставляемых Spring.\nСледующие в примере используется пользовательский элемент `<dateformat/>`, разработанный на предыдущих шагах. в файле конфигурации Spring XML:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\""}
{"id": 1175, "text": "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:myns=\"http://www.mycompany.example/schema/myns\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd\">\n		<!-- as a top-level bean -->\n		<myns:dateformat id=\"defaultDateFormat\" pattern=\"yyyy-MM-dd HH:mm\" lenient=\"true\"/> <1>\n		<bean id=\"jobDetailTemplate\" abstract=\"true\">\n			<property name=\"dateFormat\">\n				<!-- as an inner bean -->\n				<myns:dateformat pattern=\"HH:mm MM-dd-yyyy\"/>\n			</property>\n		</bean>\n	</beans>\nИспользование специального расширения в конфигурации Spring XML. <1> Наш собственный компонент.\nБолее подробные примеры.\nВ этом разделе представлены некоторые более подробные примеры пользовательских расширений XML.\nВложение пользовательских элементов в пользовательские элементы."}
{"id": 1176, "text": "Пример, представленный в этом разделе, показывает, как писать различные необходимые артефакты. для удовлетворения цели следующей конфигурации:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:foo=\"http://www.foo.example/schema/component\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd\">\n		<foo:component id=\"bionic-family\" name=\"Bionic-1\">\n			<foo:component name=\"Mother-1\">\n				<foo:component name=\"Karate-1\"/>\n				<foo:component name=\"Sport-1\"/>\n			</foo:component>\n			<foo:component name=\"Rock-1\"/>\n		</foo:component>\n	</beans>"}
{"id": 1177, "text": "Вложение пользовательских элементов в пользовательские элементы.\nПредыдущая конфигурация вкладывает пользовательские расширения друг в друга.\nКласс который на самом деле настраивается элементом `<foo:comComponent/>`, является `Component` класс (показан в следующем примере).\nОбратите внимание, что класс `Component` не предоставляет метод установки для свойства `comments`.\nЭто затрудняет (или, скорее, делает невозможным) чтобы настроить определение компонента для класса Component с помощью внедрения установщика.\nВ следующем листинге показан класс Component:\nJava\n	package com.foo;\n	import java.util.ArrayList;\n	import java.util.List;\n	public class Component {\n		private String name;\n		private List<Component> components = new ArrayList<Component> ();\n		// для «компонентов» не существует метода установки\n		public void addComponent(Component component) {\n			this.components.add(component);\n		public List<Component> getComponents() {\n			return components;\n		public String getName() {\n			return name;\n		public void setName(String name) {\n			this.name = name;\n	package com.foo\n	class Component {\nВложение пользовательских элементов в пользовательские элементы.\nТипичным решением этой проблемы является создание собственного FactoryBean, который предоставляет Свойство установки для свойства `comments`.\nВ следующем листинге показан такой обычай `ФабрикаБин`:\nJava\n	package com.foo;\n	import org.springframework.beans.factory.FactoryBean;"}
{"id": 1178, "text": "import java.util.List;\n	public class ComponentFactoryBean implements FactoryBean<Component> {\n		private Component parent;\n		private List<Component> children;\n		public void setParent(Component parent) {\n			this.parent = parent;\n		public void setChildren(List<Component> children) {\n			this.children = children;\n		public Component getObject() throws Exception {\n			if (this.children != null && this.children.size() > 0) {\n				for (Component child : children) {\n					this.parent.addComponent(child);\n			return this.parent;\n		public Class<Component> getObjectType() {\n			return Component.class;\n		public boolean isSingleton() {\n			return true;\n	package com.foo\n	class ComponentFactoryBean : FactoryBean<Component> {\nВложение пользовательских элементов в пользовательские элементы.\nЭто работает хорошо, но конечному пользователю открывается большая часть возможностей Spring.\nЧто мы собираюсь написать собственное расширение, которое скроет всю эту сантехнику Spring.\nЕсли мы будем придерживаться шаги, описанные ранее, мы начнем создав схему XSD для определения структуры нашего пользовательского тега, как показано ниже. листинг показывает:\n	<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n	<xsd:schema xmlns=\"http://www.foo.example/schema/component\""}
{"id": 1179, "text": "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n			targetNamespace=\"http://www.foo.example/schema/component\"\n			elementFormDefault=\"qualified\"\n			attributeFormDefault=\"unqualified\">\n		<xsd:element name=\"component\">\n			<xsd:complexType>\n				<xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n					<xsd:element ref=\"component\"/>\n				</xsd:choice>\n				<xsd:attribute name=\"id\" type=\"xsd:ID\"/>\n				<xsd:attribute name=\"name\" use=\"required\" type=\"xsd:string\"/>\n			</xsd:complexType>\n		</xsd:element>\n	</xsd:schema>\nJava\n	package com.foo;\n	import org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n	public class ComponentNamespaceHandler extends NamespaceHandlerSupport {\n		public void init() {\n			registerBeanDefinitionParser(\"component\", new ComponentBeanDefinitionParser());\n	package com.foo\n	class ComponentNamespaceHandler : NamespaceHandlerSupport() {\nСнова следуя процесс, описанный ранее, затем мы создаем собственный NamespaceHandler:.\nДалее идет пользовательский BeanDefinitionParser.\nПомните, что мы создаем `BeanDefinition`, который описывает `ComponentFactoryBean`.\nСледующие В листинге показана наша собственная реализация BeanDefinitionParser:\nJava\n	package com.foo;"}
{"id": 1180, "text": "import org.springframework.beans.factory.config.BeanDefinition;\n	import org.springframework.beans.factory.support.AbstractBeanDefinition;\n	import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n	import org.springframework.beans.factory.support.ManagedList;\n	import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;\n	import org.springframework.beans.factory.xml.ParserContext;\n	import org.springframework.util.xml.DomUtils;\n	import org.w3c.dom.Element;\n	import java.util.List;\n	public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {\n		protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {\n			return parseComponentElement(element);\n		private static AbstractBeanDefinition parseComponentElement(Element element) {\n			BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);\n			factory.addPropertyValue(\"parent\", parseComponent(element));\n			List<Element> childElements = DomUtils.getChildElementsByTagName(element, \"component\");\n			if (childElements != null && childElements.size() > 0) {\n				parseChildComponents(childElements, factory);\n			return factory.getBeanDefinition();\n		private static BeanDefinition parseComponent(Element element) {\n			BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);\n			component.addPropertyValue(\"name\", element.getAttribute(\"name\"));\n			return component.getBeanDefinition();"}
{"id": 1181, "text": "private static void parseChildComponents(List<Element> childElements, BeanDefinitionBuilder factory) {\n			ManagedList<BeanDefinition> children = new ManagedList<>(childElements.size());\n			for (Element element : childElements) {\n				children.add(parseComponentElement(element));\n			factory.addPropertyValue(\"children\", children);\n	package com.foo\n	class ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() {\n			return factory.getBeanDefinition()\nСнова следуя процесс, описанный ранее, затем мы создаем собственный NamespaceHandler:.\nНаконец, различные артефакты необходимо зарегистрировать в инфраструктуре Spring XML. изменив файлы META-INF/spring.handlers и META-INF/spring.schemas следующим образом:\nПользовательские атрибуты для «обычных» элементов.\nНаписать собственный синтаксический анализатор и связанные с ним артефакты несложно.\nОднако, иногда это неправильно.\nРассмотрим сценарий, в котором вам необходимо добавить метаданные к уже существующим определениям компонентов.\nВ этом случае вы наверняка не хотите писать свое собственное расширение.\nСкорее, вы просто хотите добавить дополнительный атрибут к существующему элементу определения компонента.\nПользовательские атрибуты для «обычных» элементов.\nВ качестве другого примера предположим, что вы определяете определение компонента для объект службы, который (неизвестно ему) обращается к кластерному {JSR}107[JCache], и вы хотите убедиться, что именованный экземпляр JCache быстро запускается в окружающем кластере.\nВ следующем листинге показано такое определение:"}
{"id": 1182, "text": "<bean id=\"checkingAccountService\" class=\"com.foo.DefaultCheckingAccountService\"\n			jcache:cache-name=\"checking.account\">\n		<!-- other dependencies here... -->\n	</bean>\nПользовательские атрибуты для «обычных» элементов.\nЗатем мы можем создать еще одно BeanDefinition, когда Атрибут `'jcache:cache-name'` анализируется.\nЗатем этот `BeanDefinition` инициализирует для нас именованный JCache.\nМы также можем изменить существующее `BeanDefinition` для `'checkingAccountService'`, чтобы он зависел от этого нового JCache-инициализация `BeanDefinition`.\nВ следующем листинге показан наш JCacheInitializer:\nJava\n	package com.foo;\n	public class JCacheInitializer {\n		private final String name;\n		public JCacheInitializer(String name) {\n			this.name = name;\n		public void initialize() {\n			// множество вызовов API JCache для создания именного кеша...\n	package com.foo\nПользовательские атрибуты для «обычных» элементов.\nТеперь мы можем перейти к пользовательскому расширению.\nВо-первых, нам нужно написать схема XSD, описывающая настраиваемый атрибут, следующим образом:\n	<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n	<xsd:schema xmlns=\"http://www.foo.example/schema/jcache\""}
{"id": 1183, "text": "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n			targetNamespace=\"http://www.foo.example/schema/jcache\"\n			elementFormDefault=\"qualified\">\n		<xsd:attribute name=\"cache-name\" type=\"xsd:string\"/>\n	</xsd:schema>\nJava\n	package com.foo;\n	import org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n	public class JCacheNamespaceHandler extends NamespaceHandlerSupport {\n		public void init() {\n			super.registerBeanDefinitionDecoratorForAttribute(\"cache-name\",\n				new JCacheInitializingBeanDefinitionDecorator());\n	package com.foo\n	class JCacheNamespaceHandler : NamespaceHandlerSupport() {\nДалее нам нужно создать связанный NamespaceHandler следующим образом:.\nДалее нам нужно создать парсер.\nОбратите внимание, что в данном случае, поскольку мы собираемся анализировать атрибут XML, мы пишем BeanDefinitionDecorator, а не BeanDefinitionParser.\nВ следующем листинге показана реализация BeanDefinitionDecorator:\nJava\n	package com.foo;\n	import org.springframework.beans.factory.config.BeanDefinitionHolder;\n	import org.springframework.beans.factory.support.AbstractBeanDefinition;\n	import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n	import org.springframework.beans.factory.xml.BeanDefinitionDecorator;\n	import org.springframework.beans.factory.xml.ParserContext;\n	import org.w3c.dom.Attr;"}
{"id": 1184, "text": "import org.w3c.dom.Node;\n	import java.util.ArrayList;\n	import java.util.Arrays;\n	import java.util.List;\n	public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {\n		private static final String[] EMPTY_STRING_ARRAY = new String[0];\n		public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,\n				ParserContext ctx) {\n			String initializerBeanName = registerJCacheInitializer(source, ctx);\n			createDependencyOnJCacheInitializer(holder, initializerBeanName);\n			return holder;\n		private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,\n				String initializerBeanName) {\n			AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());\n			String[] dependsOn = definition.getDependsOn();\n			if (dependsOn == null) {\n				dependsOn = new String[]{initializerBeanName};\n			} else {\n				List dependencies = new ArrayList(Arrays.asList(dependsOn));\n				dependencies.add(initializerBeanName);\n				dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);\n			definition.setDependsOn(dependsOn);\n		private String registerJCacheInitializer(Node source, ParserContext ctx) {\n			String cacheName = ((Attr) source).getValue();\n			String beanName = cacheName + \"-initializer\";\n			if (!ctx.getRegistry().containsBeanDefinition(beanName)) {\n				BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);\n				initializer.addConstructorArg(cacheName);"}
{"id": 1185, "text": "ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());\n			return beanName;\n	package com.foo\n	class JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator {\nДалее нам нужно создать связанный NamespaceHandler следующим образом:.\nНаконец, нам нужно зарегистрировать различные артефакты в инфраструктуре Spring XML. изменив файлы META-INF/spring.handlers и META-INF/spring.schemas следующим образом:"}
{"id": 1186, "text": "XML-схемы.\nВ этой части приложения перечислены XML-схемы, относящиеся к основному контейнеру.\nСхема `util`.\nКак следует из названия, теги `util` имеют дело с общей конфигурацией утилит. такие вопросы, как настройка коллекций, ссылки на константы и т. д.\nЧтобы использовать теги в схеме `util`, вам необходимо иметь следующую преамбулу вверху: вашего файла конфигурации Spring XML (текст во фрагменте ссылается на исправить схему, чтобы теги в пространстве имен `util` были вам доступны):\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:util=\"http://www.springframework.org/schema/util\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd\">\n			<!-- bean definitions here -->\n	</beans>"}
{"id": 1187, "text": "<bean id=\"...\" class=\"...\">\n		<property name=\"isolation\">\n			<bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"\n					class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\" />\n		</property>\n	</bean>\nРассмотрим следующее определение компонента:.\nВ предыдущей конфигурации используется реализация Spring FactoryBean (компонент `FieldRetrivingFactoryBean`), чтобы установить значение свойства `isolation` для bean-компонента. значению константы `java.sql.Connection.TRANSACTION_SERIALIZABLE`.\nЭто все это хорошо, но это многословно и (без необходимости) раскрывает внутреннюю структуру Spring. водопровод до конечного потребителя.\nРассмотрим следующее определение компонента:.\nСледующая версия на основе XML-схемы является более краткой и четко выражает намерение разработчика («ввести это постоянное значение»), и это читается лучше:\n	<bean id=\"...\" class=\"...\">\n		<property name=\"isolation\">\n			<util:constant static-field=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"/>\n		</property>\n	</bean>"}
{"id": 1188, "text": "Установка свойства компонента или аргумента конструктора на основе значения поля. {spring-framework-api}/beans/factory/config/FieldRetrivingFactoryBean.html[`FieldRetrivingFactoryBean`] представляет собой FactoryBean, который извлекает статическое или нестатическое значение поля.\nОбычно это используется для получения `public` `static` `final` констант, которые затем можно использовать для установки значение свойства или аргумент конструктора для другого компонента.\nУстановка свойства компонента или аргумента конструктора на основе значения поля.\nВ следующем примере показано, как отображается статическое поле с помощью метода {spring-framework-api}/beans/factory/config/FieldRetrivingFactoryBean.html#setStaticField(java.lang.String)[`staticField`] имущество:\n	<bean id=\"myField\"\n			class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\">\n		<property name=\"staticField\" value=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"/>\n	</bean>\nУстановка свойства компонента или аргумента конструктора на основе значения поля.\nСуществует также удобная форма использования, в которой поле static указывается как bean-компонент. имя, как показано в следующем примере:\n	<bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"\n			class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\"/>\nУстановка свойства компонента или аргумента конструктора на основе значения поля."}
{"id": 1189, "text": "Это означает, что больше нет никакого выбора в отношении идентификатора компонента (поэтому любой другой компонент, который ссылается на него, также должен использовать это более длинное имя), но эта форма очень лаконично определить и очень удобно использовать в качестве внутреннего компонента, поскольку `id` не имеет необходимо указать для ссылки на компонент, как показано в следующем примере:\n	<bean id=\"...\" class=\"...\">\n		<property name=\"isolation\">\n			<bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"\n					class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\" />\n		</property>\n	</bean>\nУстановка свойства компонента или аргумента конструктора на основе значения поля.\nВы также можете получить доступ к нестатическому полю (экземпляра) другого компонента, например описано в документации API для {spring-framework-api}/beans/factory/config/FieldRetrivingFactoryBean.html[`FieldRetrivingFactoryBean`] класс.\nУстановка свойства компонента или аргумента конструктора на основе значения поля.\nВнедрение значений перечисления в bean-компоненты в качестве аргументов свойства или конструктора легко сделать Spring.\nНа самом деле вам не нужно ничего делать или знать что-либо о внутреннее устройство Spring (или даже о таких классах, как FieldRetrivingFactoryBean).\nСледующий пример перечисления показывает, насколько легко ввести значение перечисления:\nJava\n	package jakarta.persistence;"}
{"id": 1190, "text": "public enum PersistenceContextType {\n		TRANSACTION,\n		EXTENDED\n	package jakarta.persistence\n	enum class PersistenceContextType {\n		TRANSACTION,\n		EXTENDED\nУстановка свойства компонента или аргумента конструктора на основе значения поля.\nТеперь рассмотрим следующий установщик типа PersistenceContextType и соответствующее определение bean-компонента:\nJava\n	package example;\n	public class Client {\n		private PersistenceContextType persistenceContextType;\n		public void setPersistenceContextType(PersistenceContextType type) {\n			this.persistenceContextType = type;\n	package example\n	class Client {\n	<bean class=\"example.Client\">\n		<property name=\"persistenceContextType\" value=\"TRANSACTION\"/>\n	</bean>\n	<!-- target bean to be referenced by name -->\n	<bean id=\"testBean\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\">\n		<property name=\"age\" value=\"10\"/>\n		<property name=\"spouse\">\n			<bean class=\"org.springframework.beans.TestBean\">\n				<property name=\"age\" value=\"11\"/>\n			</bean>\n		</property>\n	</bean>\n	<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->\n	<bean id=\"testBean.age\" class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/>\nРассмотрим следующий пример:."}
{"id": 1191, "text": "В предыдущей конфигурации используется реализация Spring FactoryBean (компонент `PropertyPathFactoryBean`) для создания bean-компонента (типа `int`) с именем `testBean.age`, который имеет значение, равное свойству age компонента testBean.\n	<!-- target bean to be referenced by name -->\n	<bean id=\"testBean\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\">\n		<property name=\"age\" value=\"10\"/>\n		<property name=\"spouse\">\n			<bean class=\"org.springframework.beans.TestBean\">\n				<property name=\"age\" value=\"11\"/>\n			</bean>\n		</property>\n	</bean>\n	<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->\n	<util:property-path id=\"name\" path=\"testBean.age\"/>\nТеперь рассмотрим следующий пример, в котором добавляется элемент `<util:property-path/>`:.\nЗначение атрибута `path` элемента `<property-path/>` имеет форму `beanName.beanProperty`.\nВ этом случае он берет свойство age компонента с именем `testBean`.\nЗначение этого свойства age равно 10."}
{"id": 1192, "text": "Использование `<util:property-path/>` для установки свойства компонента или аргумента конструктора. `PropertyPathFactoryBean` — это `FactoryBean`, который оценивает путь к свойству по заданному целевой объект.\nЦелевой объект можно указать напрямую или по имени компонента.\nЗатем вы можете использовать это значение в другом определении bean-компонента как значение свойства или конструктор аргумент.\nИспользование `<util:property-path/>` для установки свойства компонента или аргумента конструктора.\nВ следующем примере показан путь, используемый для другого компонента по имени:\n	<!-- target bean to be referenced by name -->\n	<bean id=\"person\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\">\n		<property name=\"age\" value=\"10\"/>\n		<property name=\"spouse\">\n			<bean class=\"org.springframework.beans.TestBean\">\n				<property name=\"age\" value=\"11\"/>\n			</bean>\n		</property>\n	</bean>\n	<!-- results in 11, which is the value of property 'spouse.age' of bean 'person' -->\n	<bean id=\"theAge\"\n			class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\">"}
{"id": 1193, "text": "<property name=\"targetBeanName\" value=\"person\"/>\n		<property name=\"propertyPath\" value=\"spouse.age\"/>\n	</bean>\n	<!-- results in 12, which is the value of property 'age' of the inner bean -->\n	<bean id=\"theAge\"\n			class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\">\n		<property name=\"targetObject\">\n			<bean class=\"org.springframework.beans.TestBean\">\n				<property name=\"age\" value=\"12\"/>\n			</bean>\n		</property>\n		<property name=\"propertyPath\" value=\"age\"/>\n	</bean>\nВ следующем примере путь оценивается по внутреннему компоненту:.\nСуществует также сокращенная форма, в которой имя компонента является путем к свойству.\nВ следующем примере показана форма быстрого доступа:\n	<!-- results in 10, which is the value of property 'age' of bean 'person' -->\n	<bean id=\"person.age\"\n			class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/>\nВ следующем примере путь оценивается по внутреннему компоненту:.\nЭта форма означает, что нет выбора имени компонента."}
{"id": 1194, "text": "Любая ссылка на него также должен использовать тот же идентификатор, который является путем.\nЕсли используется в качестве внутреннего bean, вообще нет необходимости ссылаться на него, как показывает следующий пример:\n	<bean id=\"...\" class=\"...\">\n		<property name=\"age\">\n			<bean id=\"person.age\"\n					class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/>\n		</property>\n	</bean>\nВ следующем примере путь оценивается по внутреннему компоненту:.\nВы можете специально установить тип результата в фактическом определении.\nЭто не обязательно для большинства случаев использования, но иногда это может быть полезно.\nДополнительную информацию см. в javadoc. эта функция.\n	<!-- creates a java.util.Properties instance with values loaded from the supplied location -->\n	<bean id=\"jdbcConfiguration\" class=\"org.springframework.beans.factory.config.PropertiesFactoryBean\">\n		<property name=\"location\" value=\"classpath:com/foo/jdbc-production.properties\"/>\n	</bean>\nРассмотрим следующий пример:.\nВ предыдущей конфигурации используется реализация Spring FactoryBean (компонент `PropertiesFactoryBean`) для создания экземпляра `java.util.Properties` со значениями загружается из предоставленного местоположения (`Resource`)."}
{"id": 1195, "text": "<!-- creates a java.util.Properties instance with values loaded from the supplied location -->\n	<util:properties id=\"jdbcConfiguration\" location=\"classpath:com/foo/jdbc-production.properties\"/>\n	<!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' -->\n	<bean id=\"emails\" class=\"org.springframework.beans.factory.config.ListFactoryBean\">\n		<property name=\"sourceList\">\n			<list>\n				<value>pechorin@hero.org</value>\n				<value>raskolnikov@slums.org</value>\n				<value>stavrogin@gov.org</value>\n				<value>porfiry@gov.org</value>\n			</list>\n		</property>\n	</bean>\nРассмотрим следующий пример:.\nВ предыдущей конфигурации используется реализация Spring FactoryBean (компонент `ListFactoryBean`), чтобы создать экземпляр `java.util.List` и инициализировать его взятыми значениями. из предоставленного `sourceList`.\n	<!-- creates a java.util.List instance with the supplied values -->\n	<util:list id=\"emails\">\n		<value>pechorin@hero.org</value>\n		<value>raskolnikov@slums.org</value>"}
{"id": 1196, "text": "<value>stavrogin@gov.org</value>\n		<value>porfiry@gov.org</value>\n	</util:list>\nВ следующем примере используется элемент `<util:list/>` для более краткого представления:.\nВы также можете явно контролировать точный тип списка, который создается и заполняется с помощью атрибута list-class в элементе <util:list/>.\nДля Например, если нам действительно нужно создать экземпляр `java.util.LinkedList`, мы могли бы использовать следующая конфигурация:\n	<util:list id=\"emails\" list-class=\"java.util.LinkedList\">\n		<value>jackshaftoe@vagabond.org</value>\n		<value>eliza@thinkingmanscrumpet.org</value>\n		<value>vanhoek@pirate.org</value>\n		<value>d'Arcachon@nemesis.org</value>\n	</util:list>\nВ следующем примере используется элемент `<util:list/>` для более краткого представления:.\nЕсли атрибут list-class не указан, контейнер выбирает реализацию List.\n	<!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' -->\n	<bean id=\"emails\" class=\"org.springframework.beans.factory.config.MapFactoryBean\">"}
{"id": 1197, "text": "<property name=\"sourceMap\">\n			<map>\n				<entry key=\"pechorin\" value=\"pechorin@hero.org\"/>\n				<entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/>\n				<entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/>\n				<entry key=\"porfiry\" value=\"porfiry@gov.org\"/>\n			</map>\n		</property>\n	</bean>\nРассмотрим следующий пример:.\nВ предыдущей конфигурации используется реализация Spring FactoryBean (компонент `MapFactoryBean`) для создания экземпляра `java.util.Map`, инициализированного парами ключ-значение. взято из предоставленного `'sourceMap'`.\n	<!-- creates a java.util.Map instance with the supplied key-value pairs -->\n	<util:map id=\"emails\">\n		<entry key=\"pechorin\" value=\"pechorin@hero.org\"/>\n		<entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/>\n		<entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/>\n		<entry key=\"porfiry\" value=\"porfiry@gov.org\"/>\n	</util:map>"}
{"id": 1198, "text": "В следующем примере используется элемент `<util:map/>` для более краткого представления:.\nВы также можете явно контролировать точный тип `Map`, который создается и заполняется с помощью атрибута Map-class элемента <util:map/>.\nДля Например, если нам действительно нужно создать экземпляр `java.util.TreeMap`, мы могли бы использовать следующая конфигурация:\n	<util:map id=\"emails\" map-class=\"java.util.TreeMap\">\n		<entry key=\"pechorin\" value=\"pechorin@hero.org\"/>\n		<entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/>\n		<entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/>\n		<entry key=\"porfiry\" value=\"porfiry@gov.org\"/>\n	</util:map>\nВ следующем примере используется элемент `<util:map/>` для более краткого представления:.\nЕсли атрибут Map-class не указан, контейнер выбирает реализацию Map.\n	<!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' -->\n	<bean id=\"emails\" class=\"org.springframework.beans.factory.config.SetFactoryBean\">\n		<property name=\"sourceSet\">"}
{"id": 1199, "text": "<set>\n				<value>pechorin@hero.org</value>\n				<value>raskolnikov@slums.org</value>\n				<value>stavrogin@gov.org</value>\n				<value>porfiry@gov.org</value>\n			</set>\n		</property>\n	</bean>\nРассмотрим следующий пример:.\nВ предыдущей конфигурации используется реализация Spring FactoryBean (компонент `SetFactoryBean`) для создания экземпляра `java.util.Set`, инициализированного взятыми значениями. из предоставленного `sourceSet`.\n	<!-- creates a java.util.Set instance with the supplied values -->\n	<util:set id=\"emails\">\n		<value>pechorin@hero.org</value>\n		<value>raskolnikov@slums.org</value>\n		<value>stavrogin@gov.org</value>\n		<value>porfiry@gov.org</value>\n	</util:set>\nВ следующем примере используется элемент `<util:set/>` для более краткого представления:.\nВы также можете явно контролировать точный тип `Set`, который создается и заполняется с помощью атрибута `set-class` в элементе `<util:set/>`."}
{"id": 1200, "text": "Для Например, если нам действительно нужно создать экземпляр `java.util.TreeSet`, мы могли бы использовать следующая конфигурация:\n	<util:set id=\"emails\" set-class=\"java.util.TreeSet\">\n		<value>pechorin@hero.org</value>\n		<value>raskolnikov@slums.org</value>\n		<value>stavrogin@gov.org</value>\n		<value>porfiry@gov.org</value>\n	</util:set>\nВ следующем примере используется элемент `<util:set/>` для более краткого представления:.\nЕсли атрибут set-class не указан, контейнер выбирает реализацию Set.\nСхема «аоп».\nТеги `aop` предназначены для настройки всех элементов AOP в Spring, включая Spring. собственная платформа АОП на основе прокси и интеграция Spring со структурой АОП AspectJ.\nЭти теги подробно описаны в главе под названием Аспектно-ориентированное программирование с помощью Spring..\nСхема «аоп».\nВ целях полноты, чтобы использовать теги в схеме `aop`, вам необходимо иметь следующую преамбулу в верхней части файла конфигурации Spring XML (текст в фрагмент ссылается на правильную схему, поэтому теги в пространстве имен `aop` доступны вам):\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>"}
{"id": 1201, "text": "<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:aop=\"http://www.springframework.org/schema/aop\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n		<!-- bean definitions here -->\n	</beans>\nСхема «контекста».\nТеги `context` имеют дело с конфигурацией `ApplicationContext`, которая относится к сантехнике.\n- то есть обычно не компоненты, которые важны для конечного пользователя, а скорее компоненты, которые\nСхема «контекста». в Spring много «ворчащих» работ, таких как BeanfactoryPostProcessors.\nСледующие фрагмент ссылается на правильную схему, так что элементы в пространстве имен `context` вам доступны:\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\""}
{"id": 1202, "text": "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n			http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n		<!-- bean definitions here -->\n	</beans>\nИспользование `<property-placeholder/>`.\nЭтот элемент активирует замену заполнителей `${...}`, которые разрешаются относительно указанный файл свойств (как файл расположение ресурса Spring).\nЭтот элемент — это удобный механизм, настраивающий файл PropertySourcesPlaceholderConfigurer. для тебя.\nЕсли вам нужен больший контроль над конкретным При настройке PropertySourcesPlaceholderConfigurer вы можете самостоятельно явно определить его как bean-компонент.\nИспользование `<property-placeholder/>`. [ВНИМАНИЕ] = Для данного приложения должен быть определен только один такой элемент со свойствами что это нужно.\nМожно настроить несколько заполнителей свойств, если они имеют отдельные синтаксис заполнителя (`${...}`)."}
{"id": 1203, "text": "Использование `<property-placeholder/>`.\nЕсли вам необходимо модулировать источник свойств, используемых для замены, вам следует не создавать несколько заполнителей свойств.\nСкорее, каждый модуль должен внести свой вклад «PropertySource» в «Среду».\nАльтернативно, вы можете создать свой собственный Компонент `PropertySourcesPlaceholderConfigurer`, который собирает используемые свойства.\nИспользование `<annotation-config/>`.\nЭтот элемент активирует инфраструктуру Spring для обнаружения аннотаций в классах компонентов:\n* Модель Spring:core/beans/basics.adoc#beans-factory-metadata[`@Configuration`]\n* `@Autowired`/`@Inject`, `@Value` и `@Lookup`\n* JSR-250 `@Resource`, `@PostConstruct` и `@PreDestroy` (если доступно)\n* `@WebServiceRef` в JAX-WS и `@EJB` в EJB 3 (если доступно).\n* JPA `@PersistenceContext` и `@PersistenceUnit` (если доступны)\n* внешняя ссылка Spring:core/beans/context-introduction.adoc#context-functionality-events-annotation[`@EventListener`]\nИспользование `<annotation-config/>`.\nАльтернативно, вы можете явно активировать отдельные `BeanPostProcessors` для этих аннотаций.\nИспользование `<annotation-config/>`.\nПРИМЕЧАНИЕ."}
{"id": 1204, "text": "Этот элемент не активирует обработку Spring. вы можете использовать <<data-access.adoc#tx-decl-explained, `<tx:annotation-driven/>`>> элемент для этой цели.\nАналогично, Весна\nИспользование `<Component-scan/>`.\nЭтот элемент подробно описан в разделе конфигурация контейнера на основе аннотаций.\nИспользование `<load-time-weaver/>`.\nЭтот элемент подробно описан в разделе переплетение во время загрузки с AspectJ в Spring Framework.\nИспользование `<spring-configured/>`.\nЭтот элемент подробно описан в разделе использование AspectJ для внедрения зависимостей в объекты домена с помощью Spring.\nИспользование `<mbean-export/>`.\nЭтот элемент подробно описан в разделе настройка экспорта MBean на основе аннотаций.\nСхема бинов.\nИ последнее, но не менее важное: у нас есть элементы в схеме beans.\nЭти элементы были Spring с самого зарождения фреймворка.\nПримеры различных элементов в схеме beans здесь не показаны, поскольку они достаточно подробно описаны. в подробное описание зависимостей и конфигурации (и, действительно, во всем этом документе).\nСхема бинов.\nОбратите внимание, что вы можете добавить ноль или более пар ключ-значение в определения XML `<bean/>`."}
{"id": 1205, "text": "Что будет сделано с этими дополнительными метаданными, полностью зависит от ваших предпочтений. логика (и поэтому обычно используется только в том случае, если вы пишете свои собственные элементы, как описано в приложении под названием Разработка XML-схемы).\nСхема бинов.\nВ следующем примере показан элемент `<meta/>` в контексте окружающего `<bean/>`. (обратите внимание, что без какой-либо логики для их интерпретации метаданные фактически бесполезны. в нынешнем виде).\n	<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n	<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xsi:schemaLocation=\"\n			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\n		<bean id=\"foo\" class=\"x.y.Foo\">\n			<meta key=\"cacheName\" value=\"foo\"/> <1>\n			<property name=\"name\" value=\"Rick\"/>\n		</bean>\n	</beans>\nСхема бинов. <1> Это пример элемента `meta`.\nСхема бинов."}
{"id": 1206, "text": "В случае предыдущего примера вы могли бы предположить, что существует некоторая логика, которая потребляет определение компонента и настраивает некоторую инфраструктуру кэширования, которая использует предоставленные метаданные."}
